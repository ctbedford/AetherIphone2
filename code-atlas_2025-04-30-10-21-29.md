# Aether Code Atlas  
_generated 2025-04-30-10-21-29_

## Contents
- [Definitions Table](#definitions-table)
- [Dependency Graph](#dependency-graph)
- [Buckets](#buckets)

## Definitions Table
| File | Exports |
|---|---|
| __tests__/server/test-helpers.ts | createInnerTRPCContext, createTestContext, MockablePostgrestResponse, MockableQueryBuilder, MockableSupabaseClient, MockableTableOperations, mockDeep, mockSupabaseAdmin, resetSupabaseMocks, TableName |
| __tests__/test-utils.tsx | render |
| app/(auth)/_layout.tsx | default |
| app/(auth)/forgot-password.tsx | default |
| app/(auth)/login.tsx | default |
| app/(auth)/register.tsx | default |
| app/(tabs)/_layout.tsx | default |
| app/(tabs)/compass/index.tsx | default |
| app/(tabs)/home/index.tsx | default |
| app/(tabs)/planner/_layout.tsx | default |
| app/(tabs)/planner/add-goal.tsx | default |
| app/(tabs)/planner/add-habit.tsx | default |
| app/(tabs)/planner/add-task.tsx | default |
| app/(tabs)/planner/goal/[id].tsx | default |
| app/(tabs)/planner/habit/[id].tsx | default |
| app/(tabs)/planner/index.tsx | default |
| app/(tabs)/rewards/index.tsx | default |
| app/(tabs)/settings/_layout.tsx | default |
| app/(tabs)/settings/about.tsx | default |
| app/(tabs)/settings/help.tsx | default |
| app/(tabs)/settings/index.tsx | default |
| app/(tabs)/settings/notifications.tsx | default |
| app/(tabs)/settings/privacy.tsx | default |
| app/(tabs)/settings/profile.tsx | default |
| app/(tabs)/settings/security.tsx | default |
| app/_layout.tsx | default |
| app/components/SectionCard.tsx | SectionCard |
| app/components/SwipeableRow.tsx | SwipeableRow |
| app/components/TaskRow.tsx | TaskRow |
| app/compose.tsx | default |
| app/index.tsx | default |
| app/lib/useDashboardQuery.ts | DashboardData, useDashboardQuery |
| app/lib/useToggleTaskStatus.ts | useToggleTaskStatus |
| app/planner/add-habit.tsx | default |
| app/planner/index.tsx | default |
| app/settings/index.tsx | default |
| app/states/[id].tsx | default |
| app/utils/api-types.ts | RouterInputs, RouterOutputs |
| app/values/[id].tsx | default |
| components/EmptyOrSkeleton.tsx | default, EmptyOrSkeletonProps, EmptyStateProps |
| components/aether/ProgressRing.tsx | default |
| components/auth/FloatingInput.tsx | default, FloatingInputProps |
| components/compass/PrincipleCard.tsx | PrincipleCard |
| components/compass/PrinciplesTab.tsx | default |
| components/compass/StateDefinitionCard.tsx | StateDefinitionCard |
| components/dashboard/DailyProgressBanner.tsx | default |
| components/dashboard/DashboardSection.tsx | default |
| components/dashboard/GoalSummaryCard.tsx | default |
| components/dashboard/HabitCheckItem.tsx | default |
| components/dashboard/StateIndicator.tsx | default |
| components/dashboard/TaskItem.tsx | default |
| components/lists/GoalList.tsx | GoalCard, GoalList |
| components/lists/HabitList.tsx | HabitCard, HabitList |
| components/lists/TaskList.tsx | TaskCard, TaskList |
| components/lists/index.ts | GoalCard, GoalList, HabitCard, HabitList, TaskCard, TaskList |
| components/planner/GoalsList.tsx | default, Goal, GoalsListProps |
| components/planner/HabitTracker.tsx | HabitTracker |
| components/planner/HabitsList.tsx | default, Habit, HabitsListProps |
| components/planner/StreakCalendar.tsx | default, StreakCalendarProps |
| components/rewards/ConfettiBurst.tsx | default |
| components/settings/NotificationRow.tsx | default, NotificationRowProps |
| components/settings/ThemePreview.tsx | default, ThemePreviewProps |
| components/ui/Container.tsx | Container, default |
| components/ui/EmptyOrSkeleton.tsx | EmptyOrSkeleton, EmptyOrSkeletonProps |
| components/ui/ErrorBanner.tsx | ErrorBanner, SectionError |
| components/ui/InteractiveCard.tsx | default |
| components/ui/Section.tsx | default |
| components/ui/Skeleton.tsx | Skeleton, SkeletonAvatar, SkeletonCard, SkeletonCircle, SkeletonProfile, SkeletonRow |
| components/ui/SwipeableRow.tsx | default |
| components/ui/primitives/AetherCard.tsx | AetherCard |
| components/ui/primitives/AetherListItem.tsx | AetherListItem, AetherListItemProps |
| components/ui/primitives/SectionHeader.tsx | SectionHeader, SectionHeaderProps |
| components/ui/primitives/index.ts | AetherCard, AetherListItem, AetherListItemProps, SectionHeader, SectionHeaderProps |
| constants/Colors.ts | Colors |
| constants/motion.ts | componentAnimations, durations, easings, presets |
| debug/toast-test.tsx | default |
| design-system/Animations.ts | fadeInUp, korokReveal, sheikahGlow, slideOutLeft, taskComplete |
| design-system/Primitives.tsx | Button, Center, gs, HStack, Pressable, ScrollView, Stack, Text, useColorMode, useColorModeValue, useToast, VStack |
| design-system/theme.glue.ts | glueTheme |
| design-system/tokens.ts | colors, default, fonts, radii, sizes, space |
| hooks/useColorScheme.ts | useColorScheme |
| hooks/useColorScheme.web.ts | useColorScheme |
| hooks/useOfflineSync.ts | useOfflineSync |
| hooks/useSkeleton.ts | SkeletonOptions, useSkeleton |
| hooks/useThemeColor.ts | useThemeColor |
| modals/compose.tsx | default |
| providers/AppProvider.tsx | AppProvider |
| providers/ConfettiProvider.tsx | ConfettiProvider, useConfetti |
| providers/SupabaseProvider.tsx | SupabaseContext, SupabaseProvider, useSupabase |
| providers/TRPCProvider.tsx | trpc, TRPCProvider |
| server/src/context.ts | Context, createContext, supabaseAdmin |
| server/src/router.ts | appRouter, AppRouter, protectedProcedure, publicProcedure, router |
| server/src/routers/dashboardRouter.ts | dashboardRouter |
| server/src/routers/goalProgressNoteRouter.ts | goalProgressNoteRouter |
| server/src/routers/goalRouter.ts | goalRouter |
| server/src/routers/habitRouter.ts | habitRouter |
| server/src/routers/principleRouter.ts | principleRouter |
| server/src/routers/reminderRouter.ts | reminderRouter |
| server/src/routers/rewardsRouter.ts | rewardsRouter |
| server/src/routers/taskRouter.ts | taskRouter |
| server/src/routers/trackedStateRouter.ts | trackedStateRouter |
| server/src/routers/userRouter.ts | userRouter |
| server/src/routers/valueRouter.ts | valueRouter |
| server/src/types/index.ts | Badge, BadgeId, Goal, GoalId, Habit, HabitId, KeyResult, Principle, Task, TaskId, TrackedStateDef, Value, ValueId |
| server/src/types/trpc-types.ts | awardBadgeInput, BadgeDefinition, BadgeDefinition, claimLootInput, createGoalInput, createGoalProgressNoteInput, createHabitEntryInput, createHabitInput, createPrincipleInput, createReminderInput, CreateStateEntryInput, createTaskInput, createTrackedStateDefInput, createValueInput, DeleteGoalProgressNoteInput, DeleteReminderInput, DeleteStateEntryInput, DeleteTrackedStateDefInput, GetGoalProgressNotesInput, GetRemindersForEntityInput, GetStateEntriesInput, GetTrackedStateDefByIdInput, Goal, Goal, GoalProgressNote, GoalProgressNote, greetingInput, greetingOutput, Habit, Habit, HabitEntry, HabitEntry, HabitFrequencyPeriodEnum, HabitTypeEnum, NotificationPrefs, PointTransaction, PointTransaction, Principle, Principle, Reminder, Reminder, Reward, Reward, RewardTypeEnum, RouterInputs, RouterOutputs, StateEntry, StateEntry, Task, Task, TaskPriorityEnum, TaskStatusEnum, TrackedStateDef, TrackedStateDef, UiPrefs, updateGoalInput, updateGoalProgressNoteInput, updateHabitEntryInput, updateHabitInput, updatePrincipleInput, updateProfileInput, updateReminderInput, updateSettingsInput, updateStateEntryInput, updateTaskInput, updateTaskStatusInput, updateTrackedStateDefInput, updateValueInput, UserBadge, UserBadge, UserProfile, UserProfile, UserReward, UserReward, UserSettings, UserSettings, Value, Value |
| stores/uiStore.ts | useUiStore |
| tamagui.config.ts | default |
| types/database.types.ts | CompositeTypes, Constants, Database, Enums, Json, Tables, TablesInsert, TablesUpdate |
| utils/api-types.ts | RouterInputs, RouterOutputs |
| utils/auth.ts | getUserProfile, logout |
| utils/colors.ts | palette, semanticTokens, useColors, withOpacity |
| utils/generated-hooks.ts | useDashboard, useGoal, useGoalProgressNote, useHabit, usePrinciple, useReminder, useRewards, useState, useTask, useUser, useValue |
| utils/haptics.ts | haptics |
| utils/mock-api.ts | appRouter, AppRouter |
| utils/nats-client.ts | addSubjectHandler, closeNatsConnection, getNatsConnection, initNatsClient, subscribeWithCache |
| utils/offline-mutations.ts | asyncStoragePersister, configureQueryClientForOffline, getPendingMutations, markItemAsOffline, markItemAsSynced, reactQueryPersistOptions, useResumeNetworkMutations |
| utils/offline-sync.ts | getPendingItems, PendingItem, saveOfflineMutation, setupBackgroundSync, syncOfflineMutations |
| utils/query-client.ts | queryClient |
| utils/settings.ts | APP_SETTINGS_KEY, AppSettings, getAppVersion, getPlatformInfo, getSettings, saveSettings, updateSetting |
| utils/supabase.ts | getCurrentUser, isAuthenticated, supabase |
| utils/trpc.ts | RouterInputs, RouterOutputs, trpc |

## Dependency Graph

*Note: This graph shows dependencies between local files only.*
```mermaid
graph TD;
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
```

## Buckets

### .

- **.env**
  *(No explicit exports found)*

- **.env.example**
  *(No explicit exports found)*

- **.eslintrc.js**
  *(No explicit exports found)*

- **.gitignore**
  *(No explicit exports found)*

- **.windsurfrules**
  *(No explicit exports found)*

- **AETHER_TODO.md**
  *(No explicit exports found)*

- **HAHA.js**
  *(No explicit exports found)*

- **README.md**
  *(No explicit exports found)*

- **REFACTORING_PLAN_V2.yaml**
  *(No explicit exports found)*

- **SUPABASE_INTEGRATION.md**
  *(No explicit exports found)*

- **aetherOUT.md**
  *(No explicit exports found)*

- **aether_migration_context.md**
  *(No explicit exports found)*

- **aether_migration_context_full.md**
  *(No explicit exports found)*

- **aether_migration_context_full_20250430_041229.md**
  *(No explicit exports found)*

- **aether_migration_context_full_20250430_041247.md**
  *(No explicit exports found)*

- **aether_migration_context_full_20250430_041307.md**
  *(No explicit exports found)*

- **aether_migration_context_full_20250430_041337.md**
  *(No explicit exports found)*

- **aether_migration_context_full_20250430_041425.md**
  *(No explicit exports found)*

- **aether_migration_context_full_20250430_041425.md.tmp**
  *(No explicit exports found)*

- **aether_styling_context.txt**
  *(No explicit exports found)*

- **app.json**
  *(No explicit exports found)*

- **babel-tap.js**
  *(No explicit exports found)*

- **babel.config.js**
  *(No explicit exports found)*

- **code_atlas.js**
  *(No explicit exports found)*

- **debug_context.txt**
  *(No explicit exports found)*

- **eas.json**
  *(No explicit exports found)*

- **file_hierarchy.txt**
  *(No explicit exports found)*

- **gather_complete_context.sh**
  *(No explicit exports found)*

- **gather_complete_context_fixed.sh**
  *(No explicit exports found)*

- **gather_complete_context_full.sh**
  *(No explicit exports found)*

- **gather_complete_context_improved.sh**
  *(No explicit exports found)*

- **gather_complete_context_v3.sh**
  *(No explicit exports found)*

- **gather_debug_info.js**
  *(No explicit exports found)*

- **gather_implementation_details.sh**
  *(No explicit exports found)*

- **gather_integrated_context.sh**
  *(No explicit exports found)*

- **gather_project_context.sh**
  *(No explicit exports found)*

- **gather_tamagui_styles.sh**
  *(No explicit exports found)*

- **global.css**
  *(No explicit exports found)*

- **implementation_details.txt**
  *(No explicit exports found)*

- **index.js**
  *(No explicit exports found)*

- **jest.config.server.js**
  *(No explicit exports found)*

- **jest.config.ui.js**
  *(No explicit exports found)*

- **jest.server.config.js**
  *(No explicit exports found)*

- **jest.server.setup.js**
  *(No explicit exports found)*

- **jest.setup.js**
  *(No explicit exports found)*

- **metro.config.js**
  *(No explicit exports found)*

- **o3.txt**
  *(No explicit exports found)*

- **package.json**
  *(No explicit exports found)*

- **postcss.config.js**
  *(No explicit exports found)*

- **project.txt**
  *(No explicit exports found)*

- **project_structure.txt**
  *(No explicit exports found)*

- **refactor_checklist.md**
  *(No explicit exports found)*

- **refactoring_plan.md**
  *(No explicit exports found)*

- **styling_report.txt**
  *(No explicit exports found)*

- **tailwind.config.js**
  *(No explicit exports found)*

- **tamagui.config.ts**

  *Exports: `default`*
  ```ts
export default config;
  ```

- **testing_strategy.md**
  *(No explicit exports found)*

- **tsconfig.json**
  *(No explicit exports found)*

- **why.txt**
  *(No explicit exports found)*

### __tests__

- **__tests__/components/dashboard/HabitCheckItem.test.tsx**
  *(No explicit exports found)*

- **__tests__/components/lists/GoalList.test.tsx**
  *(No explicit exports found)*

- **__tests__/components/lists/HabitList.test.tsx**
  *(No explicit exports found)*

- **__tests__/components/lists/TaskList.test.tsx**
  *(No explicit exports found)*

- **__tests__/components/ui/primitives/AetherCard.test.tsx**
  *(No explicit exports found)*

- **__tests__/components/ui/primitives/AetherListItem.test.tsx**
  *(No explicit exports found)*

- **__tests__/server/routers/dashboardRouter.getWeeklyProgress.test.ts**
  *(No explicit exports found)*

- **__tests__/server/routers/dashboardRouter.test.ts**
  *(No explicit exports found)*

- **__tests__/server/routers/habitRouter.test.ts**
  *(No explicit exports found)*

- **__tests__/server/routers/taskRouter.toggleTask.test.ts**
  *(No explicit exports found)*

- **__tests__/server/test-helpers.ts**

  *Exports: `createInnerTRPCContext`*
  ```ts
export function createInnerTRPCContext(opts: {
  userId: string | null;
  supabase?: any; // Keep as any for simplicity
}): Context {
  if (!opts.userId) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
      message: 'User must be authenticated to access this resource',
    });
  }

  return {
    userId: opts.userId,
    supabaseAdmin: opts.supabase || mockSupabaseAdmin,
  };
}
  ```

  *Exports: `createTestContext`*
  ```ts
export function createTestContext(userId: string | null = 'test-user-id', supabase?: any) {
  return createInnerTRPCContext({
    userId,
    supabase,
  });
}
  ```

  *Exports: `MockablePostgrestResponse`*
  ```ts
export type MockablePostgrestResponse<T> = Promise<{
  data: T | null;
  error: any;
  count?: number | null; 
  status?: number;
  statusText?: string;
}>;
  ```

  *Exports: `MockableQueryBuilder`*
  ```ts
export interface MockableQueryBuilder {
  select: (query?: string, options?: { head?: boolean; count?: 'exact' | 'planned' | 'estimated' }) => MockableQueryBuilder;
  eq: (column: string, value: any) => MockableQueryBuilder;
  neq: (column: string, value: any) => MockableQueryBuilder;
  gt: (column: string, value: any) => MockableQueryBuilder;
  gte: (column: string, value: any) => MockableQueryBuilder;
  lt: (column: string, value: any) => MockableQueryBuilder;
  lte: (column: string, value: any) => MockableQueryBuilder;
  like: (column: string, pattern: string) => MockableQueryBuilder;
  ilike: (column: string, pattern: string) => MockableQueryBuilder;
  is: (column: string, value: boolean | null) => MockableQueryBuilder;
  in: (column: string, values: any[]) => MockableQueryBuilder;
  contains: (column: string, value: any) => MockableQueryBuilder;
  containedBy: (column: string, value: any) => MockableQueryBuilder;
  rangeGt: (column: string, range: string) => MockableQueryBuilder;
  rangeGte: (column: string, range: string) => MockableQueryBuilder;
  rangeLt: (column: string, range: string) => MockableQueryBuilder;
  rangeLte: (column: string, range: string) => MockableQueryBuilder;
  rangeAdjacent: (column: string, range: string) => MockableQueryBuilder;
  overlaps: (column: string, value: any) => MockableQueryBuilder;
  textSearch: (column: string, query: string, options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }) => MockableQueryBuilder;
  match: (query: Record<string, unknown>) => MockableQueryBuilder;
  not: (column: string, operator: string, value: any) => MockableQueryBuilder;
  or: (filters: string, options?: { referencedTable?: string }) => MockableQueryBuilder;
  filter: (column: string, operator: string, value: any) => MockableQueryBuilder;
  limit: (count: number, options?: { referencedTable?: string }) => MockableQueryBuilder;
  range: (from: number, to: number, options?: { referencedTable?: string }) => MockableQueryBuilder;
  order: (column: string, options?: { ascending?: boolean; nullsFirst?: boolean; referencedTable?: string }) => MockableQueryBuilder;
}
  ```

  *Exports: `MockableSupabaseClient`*
  ```ts
export interface MockableSupabaseClient {
  // `from` now returns the object with both chainable and terminal methods
  from: (relation: string) => MockableTableOperations;

  // Top-level client methods
  auth: {
    getUser: (
      jwt?: string
    ) => Promise<{ data: { user: User | null }; error: AuthError | null }>;
    // Add other auth methods here if needed by tests (e.g., signUp, signInWithPassword)
  };
  rpc: <T = any>(fn: string, params?: object, options?: { head?: boolean; count?: 'exact' | 'planned' | 'estimated' }) => MockablePostgrestResponse<T>;
  // Add storage interface here if needed by tests
  // storage: { ... };
}
  ```

  *Exports: `MockableTableOperations`*
  ```ts
export interface MockableTableOperations extends MockableQueryBuilder {
  // Terminal methods (return Promises)
  single: <T = any>() => MockablePostgrestResponse<T>;
  maybeSingle: <T = any>() => MockablePostgrestResponse<T>;
  // Note: Insert/Update/Upsert often return arrays in Supabase v2, but the *methods* return the builder
  insert: <T = any>(values: any | any[], options?: any) => MockableTableOperations; 
  upsert: <T = any>(values: any | any[], options?: any) => MockableTableOperations; 
  update: <T = any>(values: any, options?: any) => MockableTableOperations; 
  delete: (options?: any) => MockableTableOperations; 
}
  ```

  *Exports: `mockDeep`*
  ```ts
export { mockDeep };
  ```

  *Exports: `mockSupabaseAdmin`*
  ```ts
const mockSupabaseAdmin = mockDeep<MockableSupabaseClient>();
  ```

  *Exports: `resetSupabaseMocks`*
  ```ts
export function resetSupabaseMocks() {
  // Use mockReset for better compatibility with jest-mock-extended
  mockReset(mockSupabaseAdmin);

  // --- Re-apply default implementations after reset --- 

  // Default: Successful authentication
  mockSupabaseAdmin.auth.getUser.mockResolvedValue({
    data: { user: { id: 'test-user-id', /* other user props */ } as User },
    error: null,
  });

  // Default: Successful RPC call returning null data
  mockSupabaseAdmin.rpc.mockResolvedValue({ 
      data: null, 
      error: null, 
      count: 0, 
      status: 200, 
      statusText: 'OK' 
  });

  // Helper type to create Promise-like chain-terminating objects
  type AsyncResult<T> = Promise<{ data: T | null; error: any; count?: number; status?: number; statusText?: string; }>;

  // Helper function to create a proper mock that handles both chaining AND awaiting
  function createMockWithPromiseCapability<T>(defaultData: T | null = null): any {
    const mockObj = mockDeep<MockableTableOperations>();
    
    // Add an implicit then handler that allows awaiting the mock directly
    // This is what Supabase's actual Query Builder does
    const defaultResponse = { 
      data: defaultData, 
      error: null, 
      count: defaultData && Array.isArray(defaultData) ? defaultData.length : 0,
      status: 200, 
      statusText: 'OK' 
    };
    
    // Allow the mock to be awaited directly
    (mockObj as any).then = jest.fn((onFulfill, onReject) => {
      return Promise.resolve(defaultResponse).then(onFulfill, onReject);
    });
    
    return mockObj;
  }

  // Default behavior for 'from': Return a mock that handles chaining and terminal methods
  mockSupabaseAdmin.from.mockImplementation((relation: string) => {
    // This inner mock needs to satisfy MockableTableOperations
    // AND be awaitable like a promise for terminal operations
    const innerMock = createMockWithPromiseCapability<any[]>([]);

    // --- Configure Default CHAINABLE Methods (Return Self) --- 
    innerMock.select.mockReturnValue(innerMock);
    innerMock.eq.mockReturnValue(innerMock);
    innerMock.neq.mockReturnValue(innerMock);
    innerMock.gt.mockReturnValue(innerMock);
    innerMock.gte.mockReturnValue(innerMock);
    innerMock.lt.mockReturnValue(innerMock);
    innerMock.lte.mockReturnValue(innerMock);
    innerMock.like.mockReturnValue(innerMock);
    innerMock.ilike.mockReturnValue(innerMock);
    innerMock.is.mockReturnValue(innerMock);
    innerMock.in.mockReturnValue(innerMock);
    innerMock.contains.mockReturnValue(innerMock);
    innerMock.containedBy.mockReturnValue(innerMock);
    innerMock.rangeGt.mockReturnValue(innerMock);
    innerMock.rangeGte.mockReturnValue(innerMock);
    innerMock.rangeLt.mockReturnValue(innerMock);
    innerMock.rangeLte.mockReturnValue(innerMock);
    innerMock.rangeAdjacent.mockReturnValue(innerMock);
    innerMock.overlaps.mockReturnValue(innerMock);
    innerMock.textSearch.mockReturnValue(innerMock);
    innerMock.match.mockReturnValue(innerMock);
    innerMock.not.mockReturnValue(innerMock);
    innerMock.or.mockReturnValue(innerMock);
    innerMock.filter.mockReturnValue(innerMock);
    innerMock.limit.mockReturnValue(innerMock);
    innerMock.range.mockReturnValue(innerMock);
    innerMock.order.mockReturnValue(innerMock);

    // --- Configure Default TERMINAL Methods --- 
    // For single-returning methods, default to null
    const singleResponse = { 
      data: null, 
      error: null, 
      status: 200, 
      statusText: 'OK' 
    };
    
    innerMock.single.mockResolvedValue(singleResponse);
    innerMock.maybeSingle.mockResolvedValue(singleResponse);
    
    // For insert/update/upsert operations, return the builder that can be chained further or awaited
    innerMock.insert.mockImplementation(() => {
      const insertMock = createMockWithPromiseCapability();
      insertMock.select.mockReturnValue(insertMock);
      return insertMock;
    });
    
    innerMock.upsert.mockImplementation(() => {
      const upsertMock = createMockWithPromiseCapability();
      upsertMock.select.mockReturnValue(upsertMock);
      return upsertMock;
    });
    
    innerMock.update.mockImplementation(() => {
      const updateMock = createMockWithPromiseCapability();
      updateMock.select.mockReturnValue(updateMock);
      return updateMock;
    });
    
    innerMock.delete.mockImplementation(() => {
      const deleteMock = createMockWithPromiseCapability();
      deleteMock.select.mockReturnValue(deleteMock);
      return deleteMock;
    });

    return innerMock;
  });
}
  ```

  *Exports: `TableName`*
  ```ts
export type TableName = 
| 'users' 
| 'user_profiles' 
| 'user_settings'
| 'values'
| 'principles'
| 'goals' 
| 'tasks'
| 'habits'
| 'habit_entries'
| 'tracked_state_defs' 
| 'state_entries'     
| 'reminders'         
| 'goal_progress_notes'
| 'rewards'           
| 'user_badges';
  ```

- **__tests__/test-utils.tsx**

  *Exports: `render`*
  ```tsx
export { customRender as render };
  ```

### .github

- **.github/workflows/ci.yml**
  *(No explicit exports found)*

### app

- **app/(auth)/_layout.tsx**

  *Exports: `default`*
  ```tsx
export default function AuthLayout() {
  return (
    <Stack>
      <Stack.Screen 
        name="login" 
        options={{ 
          title: 'Sign In',
          headerShown: false
        }} 
      />
      <Stack.Screen 
        name="register" 
        options={{ 
          title: 'Create Account',
          headerShown: false
        }} 
      />
      <Stack.Screen 
        name="forgot-password" 
        options={{ 
          title: 'Reset Password',
          headerShown: false
        }} 
      />
    </Stack>
  );
}
  ```

- **app/(auth)/forgot-password.tsx**

  *Exports: `default`*
  ```tsx
export default function ForgotPasswordScreen() {
  const [email, setEmail] = useState('');
  const [loading, setLoading] = useState(false);
  const [success, setSuccess] = useState(false);
  const toast = useToastController();

  // Send password reset email via Supabase
  const handleResetPassword = async () => {
    if (!email) {
      toast.show('Please enter your email', { type: 'error' });
      return;
    }

    setLoading(true);

    try {
      const { error } = await supabase.auth.resetPasswordForEmail(email, {
        redirectTo: window?.location?.origin ? `${window.location.origin}/update-password` : undefined,
      });

      if (error) throw error;

      setSuccess(true);
      toast.show('Password reset email sent!', { type: 'success' });
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to send reset email';
      toast.show(errorMessage, { type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <YStack flex={1} padding="$4" justifyContent="center" space="$4" backgroundColor="$background">
      <YStack alignItems="center" marginBottom="$6">
        {/* Replace with your app logo */}
        <Image 
          source={require('@/assets/images/icon.png')} 
          width={100} 
          height={100} 
          marginBottom="$6" 
          resizeMode="contain"
        />
        <H1>Reset Password</H1>
        <Text color="$gray10" textAlign="center">
          {success 
            ? 'Check your email for reset instructions' 
            : 'Enter your email to receive reset instructions'}
        </Text>
      </YStack>

      {!success ? (
        <>
          <Input
            placeholder="Email"
            value={email}
            onChangeText={setEmail}
            autoCapitalize="none"
            keyboardType="email-address"
          />

          <Button
            onPress={handleResetPassword}
            disabled={loading}
            backgroundColor="$blue10"
            color="white"
            size="$5"
          >
            {loading ? <Spinner color="white" /> : 'Send Reset Link'}
          </Button>
        </>
      ) : null}

      <YStack paddingTop="$6" alignItems="center">
        <Link href="/(auth)/login">
          <Text color="$blue10">Back to Sign In</Text>
        </Link>
      </YStack>
    </YStack>
  );
}
  ```

- **app/(auth)/login.tsx**

  *Exports: `default`*
  ```tsx
export default function LoginScreen() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const toast = useToastController();

  // Sign in with Supabase authentication
  const handleLogin = async () => {
    if (!email || !password) {
      toast.show('Please enter both email and password', { type: 'error' });
      return;
    }

    setLoading(true);

    try {
      const { error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (error) throw error;

      // Navigate to home screen on successful login
      router.replace('/(tabs)/home');
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Login failed';
      toast.show(errorMessage, { type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <YStack flex={1} padding="$4" justifyContent="center" space="$4" backgroundColor="$background">
      <YStack alignItems="center" marginBottom="$6">
        {/* Replace with your app logo */}
        <Image 
          source={require('@/assets/images/icon.png')} 
          width={100} 
          height={100} 
          marginBottom="$6" 
          resizeMode="contain"
        />
        <H1>Welcome to Aether</H1>
        <Text color="$gray10">Sign in to your account</Text>
      </YStack>

      <Input
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        autoCapitalize="none"
        keyboardType="email-address"
      />

      <Input
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <Button
        onPress={handleLogin}
        disabled={loading}
        backgroundColor="$blue10"
        color="white"
        size="$5"
      >
        {loading ? <Spinner color="white" /> : 'Sign In'}
      </Button>

      <XStack justifyContent="space-between" paddingTop="$2">
        <Link href="/(auth)/forgot-password">
          <Text color="$blue10">Forgot Password?</Text>
        </Link>

        <Link href="/(auth)/register">
          <Text color="$blue10">Create Account</Text>
        </Link>
      </XStack>
    </YStack>
  );
}
  ```

- **app/(auth)/register.tsx**

  *Exports: `default`*
  ```tsx
export default function RegisterScreen() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const toast = useToastController();

  // Create new account with Supabase authentication
  const handleRegister = async () => {
    if (!email || !password) {
      toast.show('Please enter both email and password', { type: 'error' });
      return;
    }

    if (password !== confirmPassword) {
      toast.show('Passwords do not match', { type: 'error' });
      return;
    }

    setLoading(true);

    try {
      const { error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          emailRedirectTo: window?.location?.origin || undefined,
        }
      });

      if (error) throw error;

      // Navigate to home screen on successful registration
      toast.show('Account created successfully!', { type: 'success' });
      router.replace('/(tabs)/home');
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Registration failed';
      toast.show(errorMessage, { type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <YStack flex={1} padding="$4" justifyContent="center" space="$4" backgroundColor="$background">
      <YStack alignItems="center" marginBottom="$6">
        {/* Replace with your app logo */}
        <Image 
          source={require('@/assets/images/icon.png')} 
          width={100} 
          height={100} 
          marginBottom="$6" 
          resizeMode="contain"
        />
        <H1>Create Account</H1>
        <Text color="$gray10">Sign up to get started</Text>
      </YStack>

      <Input
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        autoCapitalize="none"
        keyboardType="email-address"
      />

      <Input
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />
      
      <Input
        placeholder="Confirm Password"
        value={confirmPassword}
        onChangeText={setConfirmPassword}
        secureTextEntry
      />

      <Button
        onPress={handleRegister}
        disabled={loading}
        backgroundColor="$blue10"
        color="white"
        size="$5"
      >
        {loading ? <Spinner color="white" /> : 'Create Account'}
      </Button>

      <XStack justifyContent="center" paddingTop="$2">
        <Text color="$gray10">Already have an account? </Text>
        <Link href="/(auth)/login">
          <Text color="$blue10">Sign In</Text>
        </Link>
      </XStack>
    </YStack>
  );
}
  ```

- **app/(tabs)/_layout.tsx**

  *Exports: `default`*
  ```tsx
export default function TabsLayout() {
  const active = useColorModeValue('#86A5A9', '#64FFDA');
  const inactive = useColorModeValue('#8e8e93', '#626262');
  const bg = useColorModeValue('#FDFFE0', '#1A2E3A');
  const border = useColorModeValue('#E5E5EA', '#2C2C2E');

  return (
    <Tabs
      screenOptions={{
        headerShown: false,
        tabBarActiveTintColor: active,
        tabBarInactiveTintColor: inactive,
        tabBarStyle: { backgroundColor: bg, borderTopColor: border, height: 60 },
      }}
    >
      <Tabs.Screen
        name="home"
        options={{
          title: 'Home',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="home-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="planner"
        options={{
          title: 'Planner',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="calendar-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="compass"
        options={{
          title: 'Compass',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="stats-chart-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="rewards"
        options={{
          title: 'Rewards',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="sparkles-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="settings"
        options={{
          title: 'Settings',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="settings-outline" size={size} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}
  ```

- **app/(tabs)/compass/index.tsx**

  *Exports: `default`*
  ```tsx
export default function CompassScreen() {
  const [activeTab, setActiveTab] = useState<string>('principles');
  const colorScheme = useColorScheme();

  const handleAddPress = () => {
    const route = `/compose?type=${activeTab === 'principles' ? 'value' : 'state'}` as Href;
    router.push(route);
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Compass</Text>
          <Button
            size="$3"
            circular
            onPress={handleAddPress} 
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>

        {/* Tabs */}
        <Tabs
          defaultValue="principles"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {React.cloneElement(tab.icon as React.ReactElement, { color: activeTab === tab.key ? '$colorFocus' : '$color' })}
                  <Text color={activeTab === tab.key ? '$colorFocus' : '$color'}>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>

          {/* Tab Content */}
          <Tabs.Content value="principles" flex={1} key="principles-content">
            <ScrollView>
              <PrinciplesTab />
            </ScrollView>
          </Tabs.Content>

          <Tabs.Content value="states" flex={1} key="states-content">
            <ScrollView>
              <StatesTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/home/index.tsx**

  *Exports: `default`*
  ```tsx
export default function HomeScreen() {
  const router = useRouter();
  const { data, isLoading, isRefetching, refetch } = useDashboardQuery();
  const toggleTask = useToggleTaskStatus();

  const parchment = useColorModeValue('#FDFFE0', '#1A2E3A');

  return (
    <ScrollView
      className="flex-1 px-4"
      style={{ backgroundColor: parchment }}
      refreshControl={<RefreshControl refreshing={isRefetching} onRefresh={refetch} />}
    >
      <Text className="text-2xl font-heading text-darkText mt-6 mb-4">
        Good morning, Link!
      </Text>

      {/* Tasks Section */}
      <SectionCard
        title="Tasks for today"
        action={
          <Button
            className="flex-row items-center"
            onPress={() => router.push('/(tabs)/planner/add-task')}
          >
            <Ionicons name="add" size={18} color="#86A5A9" />
            <Text className="ml-1 text-sheikahCyan">New</Text>
          </Button>
        }
      >
        {isLoading && <Text>Loading…</Text>}
        {!isLoading && (!data?.tasks?.length ? (
          <Text className="text-ios-gray-3">No tasks 🎉</Text>
        ) : (
          data.tasks.map((task) => (
            <SwipeableRow
              key={task.id}
              onComplete={() =>
                toggleTask.mutate({ taskId: task.id, completed: task.status !== 'done' })
              }
            >
              <TaskRow task={task} />
            </SwipeableRow>
          ))
        ))}
      </SectionCard>

      {/* You can add Habits / Goals sections here following the same pattern */}
    </ScrollView>
  );
}
  ```

- **app/(tabs)/planner/_layout.tsx**

  *Exports: `default`*
  ```tsx
export default function PlannerLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      {/* The index screen is the default for the planner tab */}
      <Stack.Screen name="index" />
      {/* Add screens for the sub-pages */}
      <Stack.Screen name="add-task" options={{ presentation: 'modal', title: 'Add Task' }} />
      <Stack.Screen name="add-habit" options={{ presentation: 'modal', title: 'Add Habit' }} />
      <Stack.Screen name="add-goal" options={{ presentation: 'modal', title: 'Add Goal' }} />
      <Stack.Screen name="goal/[id]" options={{ title: 'Goal Details' }} />
      <Stack.Screen name="habit/[id]" options={{ title: 'Habit Details' }} />
    </Stack>
  );
}
  ```

- **app/(tabs)/planner/add-goal.tsx**

  *Exports: `default`*
  ```tsx
export default function AddGoalScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Add New Goal</H1>
        <Text>Goal details form will go here.</Text>
        <Button onPress={() => router.back()}>Cancel</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/planner/add-habit.tsx**

  *Exports: `default`*
  ```tsx
export default function AddHabitScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Add New Habit</H1>
        <Text>Habit details form will go here.</Text>
        <Button onPress={() => router.back()}>Cancel</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/planner/add-task.tsx**

  *Exports: `default`*
  ```tsx
export default function AddTaskScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Add New Task</H1>
        <Text>Task details form will go here.</Text>
        <Button onPress={() => router.back()}>Cancel</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/planner/goal/[id].tsx**

  *Exports: `default`*
  ```tsx
export default function GoalDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const colorScheme = useColorScheme();

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Goal Detail: {id}</H1>
        <Text>Details for goal {id} will be displayed here.</Text>
        {/* Add tRPC query to fetch goal data based on id */}
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/planner/habit/[id].tsx**

  *Exports: `default`*
  ```tsx
export default function HabitDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const colorScheme = useColorScheme();

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Habit Detail: {id}</H1>
        <Text>Details for habit {id} will be displayed here.</Text>
        {/* Add tRPC query to fetch habit data based on id */}
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/planner/index.tsx**

  *Exports: `default`*
  ```tsx
export default function PlannerScreen() {
  const [activeTab, setActiveTab] = useState<string>('goals');
  const colorScheme = useColorScheme();
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Planner</Text>
          <Button
            size="$3"
            circular
            onPress={() => {/* Handle new item */}}
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>
        
        {/* Tabs */}
        <Tabs
          defaultValue="goals"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List 
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {tab.icon}
                  <Text>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>
          
          {/* Tab Content */}
          <Tabs.Content value="goals" flex={1}>
            <ScrollView>
              <GoalsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="habits" flex={1}>
            <ScrollView>
              <HabitsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="calendar" flex={1}>
            <ScrollView>
              <CalendarTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/rewards/index.tsx**

  *Exports: `default`*
  ```tsx
export default function RewardsScreen() {
  const [viewMode, setViewMode] = useState<ViewMode>(ViewMode.Grid);
  const colorScheme = useColorScheme();
  const theme = useTheme();

  // Define fallback colors
  const blue2 = theme?.blue2?.val ?? '#eff6ff';
  const blue5 = theme?.blue5?.val ?? '#60a5fa';
  const blue10 = theme?.blue10?.val ?? '#1e40af';
  const blue11 = theme?.blue11?.val ?? '#1e3a8a';
  const green9 = theme?.green9?.val ?? '#16a34a';

  // Fetch available rewards from tRPC
  const { 
    data: rewards, 
    isLoading, 
    error, 
    refetch 
  } = trpc.rewards.getAvailableRewards.useQuery();

  // Mutation for claiming rewards
  const claimMutation = trpc.rewards.earnReward.useMutation({
    onSuccess: (data) => {
      console.log('Reward claimed successfully:', data);
      // Maybe show confetti?
      Alert.alert('Reward Claimed!', `You spent ${data.reward.points_spent} points. Remaining: ${data.remainingPoints}`);
      refetch(); // Refetch the list of available rewards
    },
    onError: (err) => {
      console.error('Failed to claim reward:', err);
      Alert.alert('Claim Failed', err.message || 'Could not claim reward.');
    }
  });
  
  const handleClaimReward = useCallback((rewardId: string) => {
    if (claimMutation.isPending) return; // Prevent double-clicks
    
    Alert.alert(
      'Confirm Claim',
      'Are you sure you want to spend points on this reward?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Claim', 
          onPress: () => {
            claimMutation.mutate({ rewardId });
          },
          style: 'default'
        }
      ]
    );
  }, [claimMutation]);
  
  const renderItem = ({ item }: { item: RewardItem }) => { // Use inferred type
    // Assuming backend field is image_url, map to imagePath
    const imagePath = item.image_url; 
    // All items from getAvailableRewards are considered claimable (not yet claimed)
    const claimed = false; 
    // Map required_points to pointCost
    const pointCost = item.required_points;

    if (viewMode === ViewMode.Grid) {
      return (
        <Card
          size="$4"
          bordered
          width={160}
          height={200}
          margin="$2"
          overflow="hidden"
          elevation="$2"
          opacity={claimed ? 0.7 : 1}
        >
          <ImageBackground
            source={{ uri: imagePath }}
            style={{ width: '100%', height: 100 }}
          >
            <View style={{ 
              position: 'absolute', 
              top: 5, 
              right: 5, 
              backgroundColor: blue5,
              borderRadius: 10,
              padding: 4
            }}>
              <Text color="white" fontSize="$2" fontWeight="bold">
                {pointCost} pts
              </Text>
            </View>
          </ImageBackground>
          
          <YStack padding="$2" flex={1} justifyContent="space-between">
            <Text fontSize="$4" fontWeight="bold" numberOfLines={1}>
              {item.name}
            </Text>
            
            <Button
              size="$2"
              themeInverse={claimed}
              backgroundColor={claimed ? undefined : blue10}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </YStack>
        </Card>
      );
    } else {
      return (
        <Card
          bordered
          margin="$2"
          padding="$3"
          opacity={claimed ? 0.7 : 1}
        >
          <XStack space="$3" alignItems="center">
            {imagePath && (
              <View style={{ 
                width: 60, 
                height: 60, 
                borderRadius: 8, 
                overflow: 'hidden',
                backgroundColor: theme.gray3.val
              }}>
                <ImageBackground
                  source={{ uri: imagePath }}
                  style={{ width: '100%', height: '100%' }}
                />
              </View>
            )}
            
            <YStack flex={1} space="$1">
              <Text fontSize="$5" fontWeight="bold">{item.name}</Text>
              <Text fontSize="$3" color="$gray11" numberOfLines={2}>{item.description}</Text>
              <Text fontSize="$3" color={blue10} fontWeight="500">{pointCost} points</Text>
            </YStack>
            
            <Button
              size="$3"
              backgroundColor={claimed ? undefined : blue10}
              themeInverse={claimed}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </XStack>
        </Card>
      );
    }
  };
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        <YStack space="$4">
          {/* Header */}
          <XStack justifyContent="space-between" alignItems="center">
            <H1>Rewards</H1>
            
            <XStack space="$2">
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.Grid ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.Grid)}
              >
                <Ionicons 
                  name="grid-outline" 
                  size={22} 
                  color={viewMode === ViewMode.Grid ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
              
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.List ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.List)}
              >
                <Ionicons 
                  name="list-outline" 
                  size={22} 
                  color={viewMode === ViewMode.List ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
            </XStack>
          </XStack>
          
          {/* Stats */}
          <Card padding="$3" backgroundColor={blue2}>
            <XStack justifyContent="space-between" alignItems="center">
              <Text fontSize="$5" fontWeight="bold" color={blue11}>Your Points</Text>
              <Text fontSize="$6" fontWeight="bold" color={blue10}>275</Text>
            </XStack>
          </Card>
        </YStack>
        
        {/* Content Area */} 
        <EmptyOrSkeleton 
          isLoading={isLoading}
          isEmpty={!isLoading && !error && (!rewards || rewards.length === 0)}
          isError={!!error}
          text={error ? error.message : 'No rewards available yet.'} // Use text for error OR empty msg
          onRetry={refetch}
          type={viewMode === ViewMode.Grid ? 'card' : 'row'}
          count={viewMode === ViewMode.Grid ? 6 : 3}
        >
          <FlatList
            key={viewMode} // Change key based on viewMode to force re-render
            data={rewards}
            renderItem={renderItem}
            keyExtractor={(item, index) =>
              `${item?.id ?? `tmp-${index}`}-${viewMode}`   // fall back to index if ID is missing
            }
            
            // Optional: Log corrupt data in development
            onLayout={() => {
              if (__DEV__) {
                const missing = (rewards ?? []).filter(r => !r?.id);
                if (missing.length) console.warn('Rewards missing id:', missing);
              }
            }}
            numColumns={viewMode === ViewMode.Grid ? 2 : 1}
            contentContainerStyle={{ paddingBottom: 50 }} // Add padding at the bottom
            // Optional Optimizations (Patch #6)
            initialNumToRender={8}
            removeClippedSubviews={true} // Note: Can have visual glitches on iOS sometimes
          />
        </EmptyOrSkeleton>

      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/_layout.tsx**

  *Exports: `default`*
  ```tsx
export default function SettingsLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      {/* The index screen is the default for the settings tab */}
      <Stack.Screen name="index" />
      {/* Add screens for the sub-pages */}
      <Stack.Screen name="profile" options={{ title: 'Edit Profile' }} />
      <Stack.Screen name="security" options={{ title: 'Security' }} />
      <Stack.Screen name="privacy" options={{ title: 'Data & Privacy' }} />
      <Stack.Screen name="notifications" options={{ title: 'Notifications' }} />
      <Stack.Screen name="help" options={{ title: 'Help & Support' }} />
      <Stack.Screen name="about" options={{ title: 'About Aether' }} />
    </Stack>
  );
}
  ```

- **app/(tabs)/settings/about.tsx**

  *Exports: `default`*
  ```tsx
export default function AboutScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>About Aether</H1>
        <Text>App version, terms of service, credits, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/help.tsx**

  *Exports: `default`*
  ```tsx
export default function HelpScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Help & Support</H1>
        <Text>FAQ, contact support link, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/index.tsx**

  *Exports: `default`*
  ```tsx
export default function SettingsScreen() {
  const colorScheme = useColorScheme();
  const [notificationsEnabled, setNotificationsEnabled] = useState(true);
  const [trackingEnabled, setTrackingEnabled] = useState(true);
  const { setAccent } = useAccent(); // Get the function to update accent color
  const [selectedAccent, setSelectedAccent] = useState('blue'); // Placeholder state for selected accent

  const handleLogout = async () => {
    Alert.alert(
      'Log Out',
      'Are you sure you want to log out?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Log Out', 
          style: 'destructive',
          onPress: async () => {
            await supabase.auth.signOut();
            router.replace('/(auth)/login');
          }
        }
      ]
    );
  };

  const AccentSelector = ({ currentAccent, onSelect }: { currentAccent: string, onSelect: (accent: string) => void }) => {
    const accents = ['blue', 'green', 'orange', 'red']; // Example accents corresponding to theme names
    return (
      <XStack space="$2">
        {accents.map((accent) => (
          <Button 
            key={accent} 
            onPress={() => {
              onSelect(accent);
              setAccent(accent); // Call setAccent with the selected accent
            }} 
            theme={accent as any} // Preview the theme (cast needed for demo)
            backgroundColor={accent === currentAccent ? '$backgroundStrong' : '$background'}
          >
            {accent.charAt(0).toUpperCase() + accent.slice(1)}
          </Button>
        ))}
      </XStack>
    );
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <ScrollView>
        <YStack flex={1} padding="$4">
          <H1 marginBottom="$4">Settings</H1>
          
          {/* Account Section */}
          <SettingsSection
            title="Account"
            icon={<Ionicons name="person-circle-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Edit Profile"
                icon={<Ionicons name="person-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/profile' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Security"
                icon={<Ionicons name="lock-closed-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/security' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Data & Privacy"
                icon={<Ionicons name="shield-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/privacy' as any)}
              />
            </YStack>
          </SettingsSection>
          
          {/* Appearance Section */}
          <SettingsSection
            title="Appearance"
            icon={<Ionicons name="color-palette-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Theme"
                icon={<Ionicons name="moon-outline" size={20} color="#A0A0A0" />}
                rightElement={<Text color="$gray10">{colorScheme === 'dark' ? 'Dark (System)' : 'Light (System)'}</Text>}
              />
              <SettingsRow
                label="Accent Color"
                icon={<Ionicons name="color-palette-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <AccentSelector 
                    currentAccent={selectedAccent} 
                    onSelect={(accent) => setSelectedAccent(accent)} 
                  />
                }
              />
            </YStack>
          </SettingsSection>
          
          {/* Notifications Section */}
          <SettingsSection
            title="Notifications"
            icon={<Ionicons name="notifications-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Push Notifications"
                icon={<Ionicons name="push-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={notificationsEnabled}
                    onCheckedChange={setNotificationsEnabled}
                  />
                }
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Notification Settings"
                icon={<Ionicons name="options-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/notifications' as any)}
              />
            </YStack>
          </SettingsSection>
          
          {/* Privacy Section */}
          <SettingsSection
            title="Privacy & Data"
            icon={<Ionicons name="analytics-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Analytics Tracking"
                icon={<Ionicons name="trending-up-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={trackingEnabled}
                    onCheckedChange={setTrackingEnabled}
                  />
                }
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Export Data"
                icon={<Ionicons name="download-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => {
                  Alert.alert(
                    'Export Data',
                    'Your data will be prepared for export and sent to your email address.',
                    [
                      { text: 'Cancel', style: 'cancel' },
                      { text: 'Export', onPress: () => {
                        // Would call an API endpoint to initiate export
                        Alert.alert('Export Initiated', 'Check your email for the export file.');
                      }}
                    ]
                  );
                }}
              />
            </YStack>
          </SettingsSection>
          
          {/* Support Section */}
          <SettingsSection
            title="Support & About"
            icon={<Ionicons name="help-circle-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Help Center"
                icon={<Ionicons name="help-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/help' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="About Aether"
                icon={<Ionicons name="information-circle-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/about' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="App Version"
                icon={<Ionicons name="code-outline" size={20} color="#A0A0A0" />}
                rightElement={<Text color="$gray10">1.0.0</Text>}
              />
            </YStack>
          </SettingsSection>
          
          {/* Logout Button */}
          <Button
            marginTop="$6"
            marginBottom="$8"
            size="$4"
            themeInverse
            onPress={handleLogout}
          >
            Log Out
          </Button>
        </YStack>
      </ScrollView>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/notifications.tsx**

  *Exports: `default`*
  ```tsx
export default function NotificationSettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Notification Settings</H1>
        <Text>Granular controls for different notification types.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/privacy.tsx**

  *Exports: `default`*
  ```tsx
export default function PrivacySettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Data & Privacy</H1>
        <Text>Data management options, privacy policy link, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/profile.tsx**

  *Exports: `default`*
  ```tsx
export default function ProfileSettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Edit Profile</H1>
        <Text>Profile editing form will go here.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/security.tsx**

  *Exports: `default`*
  ```tsx
export default function SecuritySettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Security Settings</H1>
        <Text>Password change, 2FA options, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/_layout.tsx**

  *Exports: `default`*
  ```tsx
export default function RootLayout() {
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        <GluestackUIProvider config={glueTheme}>
          <SupabaseProvider>
            <TRPCProvider>
              <Stack screenOptions={{ headerShown: false }} />
            </TRPCProvider>
          </SupabaseProvider>
        </GluestackUIProvider>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}
  ```

- **app/components/SectionCard.tsx**

  *Exports: `SectionCard`*
  ```tsx
const SectionCard: React.FC<SectionCardProps> = ({ title, children }) => {
  return (
    <Stack className="mb-6 overflow-hidden rounded-2xl">
      <BlurView intensity={30} tint="light" className="overflow-hidden rounded-2xl">
        <Stack className="p-4 bg-parchment/50 dark:bg-sheikahCyan/10">
          <Text className="font-heading text-lg mb-2 text-darkText dark:text-parchment">{title}</Text>
          {children}
        </Stack>
      </BlurView>
    </Stack>
  );
};
  ```

- **app/components/SwipeableRow.tsx**

  *Exports: `SwipeableRow`*
  ```tsx
const SwipeableRow = ({ children, onComplete, onDelete }: SwipeableRowProps) => {
  // Render left-swipe (complete) action
  const renderLeftActions = () => {
    if (!onComplete) return null;
    return (
      <View className="flex-row">
        <Button 
          className="w-20 h-full justify-center items-center bg-korokGreen" 
          onPress={onComplete}
          aria-label="Complete task"
        >
          <Ionicons name="checkmark-outline" size={20} color="#FDFFE0" /* parchment */ />
        </Button>
      </View>
    );
  };

  // Render right-swipe (delete) action
  const renderRightActions = () => {
    if (!onDelete) return null;
    return (
      <View className="flex-row justify-end">
        <Button 
          className="w-20 h-full justify-center items-center bg-guardianOrange" 
          onPress={onDelete}
          aria-label="Delete task"
        >
          <Ionicons name="trash-outline" size={20} color="#FDFFE0" /* parchment */ />
        </Button>
      </View>
    );
  };

  return (
    <Swipeable
      renderLeftActions={renderLeftActions}
      renderRightActions={renderRightActions}
      overshootFriction={8}
      containerStyle={{ backgroundColor: 'transparent' }}
    >
      {children}
    </Swipeable>
  );
};
  ```

- **app/components/TaskRow.tsx**

  *Exports: `TaskRow`*
  ```tsx
const TaskRow = memo(({ task }: { task: Task }) => (
  <Stack className="flex-row items-center py-3 px-4 bg-parchment/80 dark:bg-darkTealBg/50">
    {task.status === 'completed' && (
      <Ionicons 
        name="checkmark-circle" 
        size={18} 
        color="#92C582" // korokGreen
        style={{ marginRight: 8 }} 
      />
    )}
    <Text 
      className={`flex-1 ${task.status === 'completed' 
        ? 'text-darkText/50 line-through' 
        : 'text-darkText dark:text-parchment'}`}
    >
      {task.name}
    </Text>
    {task.due_date && (
      <Text className="text-xs text-darkText/70 dark:text-parchment/70">
        {new Date(task.due_date).toLocaleDateString()}
      </Text>
    )}
  </Stack>
));
  ```

- **app/compose.tsx**

  *Exports: `default`*
  ```tsx
export default function ComposeModal() {
  const router = useRouter();
  const params = useLocalSearchParams<{ type: string }>();
  const type = params.type === 'value' || params.type === 'state' ? params.type : undefined;
  const toast = useToastController();
  const utils = trpc.useUtils();

  const isValue = type === 'value';

  // 2️⃣ Define stricter default values using tagged types
  const defaultValueValues: CreateValueInputTagged = {
    __type: 'value',
    title: '', // Use 'title' instead of 'name' - Patch #4
    description: ''
  };
  const defaultStateValues: CreateStateInputTagged = {
    __type: 'state',
    name: '',
    scale: '1-5',
    description: '',
    active: true,
    priority: 50
  };

  // --- Separate useMutation hooks ---
  const createValueMutation = trpc.value.createValue.useMutation({
    onSuccess: (data) => handleSuccess(data),
    onError: (error) => handleError(error),
  });
  const createStateDefMutation = trpc.state.createDefinition.useMutation({
    onSuccess: (data) => handleSuccess(data),
    onError: (error) => handleError(error),
  });

  // --- Form setup ---
  const { control, handleSubmit, formState: { errors }, reset } = useForm<FormValues>({
    // Note: ZodResolver might need specific configuration if schemas differ vastly
    // or consider not using it if relying solely on backend validation for this dynamic form.
    // Use the new stricter default value constants
    defaultValues: isValue ? defaultValueValues : defaultStateValues,
  });

  // Reset form if the type changes dynamically
  React.useEffect(() => {
    // Use the new stricter default value constants for reset
    reset(isValue ? defaultValueValues : defaultStateValues);
  }, [isValue, reset]);

  // --- Shared success/error handlers ---
  const handleSuccess = (data: any) => {
      toast.show('Created successfully!', { native: true });
      haptics.success();
      if (isValue) {
        utils.value.getValues.invalidate();
      } else {
        utils.state.getDefinitions.invalidate();
      }
      if (router.canGoBack()) {
        router.dismiss(); // Apply patch #5 - Use dismiss for modals
      } else {
        router.replace('/(tabs)/compass');
      }
  }

  const handleError = (error: any) => {
       toast.show(`Error: ${error.message}`, { type: 'error', native: true });
       haptics.error();
  }

  // --- Corrected onSubmit ---
  const onSubmit = (formData: FormValues) => {
    // 3️⃣ Use discriminant (__type) for type safety, remove casts
    if (formData.__type === 'value') {
      createValueMutation.mutate(formData);
    } else { // formData.__type === 'state'
      createStateDefMutation.mutate(formData);
    }
  };

  // Handle invalid type parameter gracefully
  if (!type) {
    return (
        <YStack flex={1} justifyContent="center" alignItems="center" padding="$4">
            <Paragraph color="$error">Invalid type specified.</Paragraph> {/* Use $error */}
            <Button onPress={() => router.back()} marginTop="$4">Go Back</Button>
        </YStack>
    );
  }

  // Determine current mutation state for button
  const isPending = isValue ? createValueMutation.isPending : createStateDefMutation.isPending;

  return (
    <ScrollView contentContainerStyle={{ flexGrow: 1 }}>
      <Form onSubmit={handleSubmit(onSubmit)} flex={1} padding="$4" space="$4" backgroundColor="$background">
        <Stack.Screen options={{ title: isValue ? 'Add Principle' : 'Define State' }} />

        {/* Conditionally render form fields */}
        {isValue ? (
          <>
            {/* --- Fields for Principle/Value --- */}
            <YStack space="$2">
              <Label htmlFor="title">Title</Label> {/* Patch #4: name -> title */}
              <Controller
                name="title" /* Patch #4: name -> title */
                control={control}
                rules={{ required: 'Title is required' }} /* Patch #4 */
                render={({ field }) => ( /* Use inferred types from FormValues */
                  <Input
                    id="title"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value}
                    placeholder="Principle Title"
                  />
                )}
              />
              {/* Use $error token */}
              {errors.title && <Paragraph color="$error">{errors.title?.message}</Paragraph>}
            </YStack>

            <YStack space="$2">
              <Label htmlFor="description">Description (Optional)</Label>
              <Controller
                name="description"
                control={control}
                render={({ field }) => ( // Use inferred types
                  <TextArea
                    id="description"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value ?? ''}
                    placeholder="Describe the principle..."
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && <Paragraph color="$error">{errors.description?.message}</Paragraph>}
            </YStack>
          </>
        ) : (
          <>
            {/* --- Fields for State Definition --- */}
            <YStack space="$2">
              <Label htmlFor="name">State Name</Label>
              <Controller
                name="name"
                control={control}
                rules={{ required: 'Name is required' }}
                render={({ field }) => ( // Use inferred types // Explicit type
                  <Input
                    id="name"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value}
                    placeholder="e.g., Energy Level, Mood" />
                )}
              />
              {errors.name && <Paragraph color="$error">{errors.name?.message}</Paragraph>}
            </YStack>

             <YStack space="$2">
               <Label htmlFor="scale">Scale</Label>
               <Controller
                 name="scale"
                 control={control}
                 rules={{ required: 'Scale is required' }}
                 render={({ field }) => ( // Use inferred types
                   <>
                    <Paragraph>Scale Selector Placeholder (Selected: {field.value})</Paragraph>
                    <XStack space="$2">
                      {/* Removed invalid theme prop */}
                      <Button size="$2" onPress={() => field.onChange('1-5')} theme={field.value === '1-5' ? 'active' : undefined}>1-5</Button>
                      <Button size="$2" onPress={() => field.onChange('1-10')} theme={field.value === '1-10' ? 'active' : undefined}>1-10</Button>
                    </XStack>
                   </>
                 )}
               />
                {errors.scale && <Paragraph color="$error">{errors.scale?.message}</Paragraph>}
             </YStack>

             <YStack space="$2">
              <Label htmlFor="description">Description (Optional)</Label>
              <Controller
                name="description"
                control={control}
                render={({ field }) => ( // Use inferred types
                  <TextArea
                    id="description"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value ?? ''}
                    placeholder="Describe when/how to track this state..."
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && <Paragraph color="$error">{errors.description?.message}</Paragraph>}
            </YStack>

            <XStack space="$4" alignItems="center">
               <Label htmlFor="active" flex={1}>Active</Label>
               <Controller
                 name="active"
                 control={control}
                 render={({ field }: { field: ControllerRenderProps<FieldValues, 'active'> }) => ( // Explicit type
                    <Switch
                      id="active"
                      checked={!!field.value} // Use checked
                      onCheckedChange={field.onChange} // Use onCheckedChange
                      size="$3"
                    >
                        <Switch.Thumb animation="quick" />
                    </Switch>
                 )}
               />
            </XStack>
          </>
        )}

        {/* Removed invalid theme prop */}
        <Form.Trigger asChild disabled={isPending}>
          <Button icon={isPending ? <Spinner /> : undefined}>
            {isPending ? 'Saving...' : 'Save'}
          </Button>
        </Form.Trigger>
      </Form>
    </ScrollView>
  );
}
  ```

- **app/index.tsx**

  *Exports: `default`*
  ```tsx
export default function RootIndex() {
  // Redirect directly to a specific tab without causing infinite redirects
  // Use the path that matches how it's accessed in the proper format
  // TypeScript suggests this is the correct format for Expo Router
  return <Redirect href="/(tabs)/home" />;
}
  ```

- **app/lib/useDashboardQuery.ts**

  *Exports: `DashboardData`*
  ```ts
export type DashboardData = RouterOutputs['dashboard']['getDashboardData'];
  ```

  *Exports: `useDashboardQuery`*
  ```ts
const useDashboardQuery = () =>
trpc.dashboard.getDashboardData.useQuery(undefined, { 
  staleTime: 60_000, // 1 minute stale time
  refetchOnMount: 'always', // Always refetch when component mounts
});
  ```

- **app/lib/useToggleTaskStatus.ts**

  *Exports: `useToggleTaskStatus`*
  ```ts
const useToggleTaskStatus = () => {
  const utils = trpc.useUtils();
  
  return trpc.task.toggleTask.useMutation({
    // Optimistically update UI before server responds
    onMutate: async ({ taskId, completed }) => {
      // Cancel any outgoing refetches
      await utils.dashboard.getDashboardData.cancel();
      
      // Snapshot current data for potential rollback
      const previous = utils.dashboard.getDashboardData.getData();
      
      // Optimistically update to the new value
      utils.dashboard.getDashboardData.setData(undefined, (oldData) => {
        if (!oldData) return oldData;
        return {
          ...oldData,
          tasks: oldData.tasks.map((task) => 
            task.id === taskId ? { ...task, status: completed ? 'completed' : 'in-progress' } : task
          ),
        };
      });
      
      return { previous };
    },
    
    // On successful mutation, show success message (silent in production)
    onSuccess: () => {
      if (__DEV__) {
        Alert.alert('Success', 'Task status updated');
      }
    },
    
    // If mutation fails, roll back optimistic update
    onError: (error, variables, context) => {
      if (context?.previous) {
        utils.dashboard.getDashboardData.setData(undefined, context.previous);
      }
      Alert.alert('Error', error.message || 'Failed to update task');
    },
    
    // Regardless of outcome, invalidate queries to refetch data
    onSettled: () => {
      utils.dashboard.getDashboardData.invalidate();
    },
  });
};
  ```

- **app/planner/add-habit.tsx**

  *Exports: `default`*
  ```tsx
export default function AddHabitScreen() {
  return (
    <SafeAreaView style={{ flex: 1 }}>
      <ScrollView>
        <YStack flex={1} padding="$4" space="$4">
          <H1>Add New Habit</H1>
          <Text>Form to add a new habit will go here.</Text>
          <Button onPress={() => router.back()}>Go Back</Button>
        </YStack>
      </ScrollView>
    </SafeAreaView>
  );
}
  ```

- **app/planner/index.tsx**

  *Exports: `default`*
  ```tsx
export default () => <YStack f={1} jc="center" ai="center"><H2>Planner coming soon</H2></YStack>
  ```

- **app/settings/index.tsx**

  *Exports: `default`*
  ```tsx
export default () => <YStack f={1} jc="center" ai="center"><H2>Settings coming soon</H2></YStack>
  ```

- **app/states/[id].tsx**

  *Exports: `default`*
  ```tsx
export default function StateDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const router = useRouter();

  // TODO: Fetch state definition details using trpc.state.getDefinitionById.useQuery({ id })

  return (
    <SafeAreaView style={{ flex: 1 }}>
      <YStack flex={1} padding="$4" space="$4">
        <H2>State Definition Detail</H2>
        <Paragraph>Details for State Definition with ID: {id}</Paragraph>
        {/* TODO: Display actual state definition details and add edit functionality */}
        <Button onPress={() => router.back()}>Go Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/utils/api-types.ts**

  *Exports: `RouterInputs`*
  ```ts
export type RouterInputs = inferRouterInputs<AppRouter>;
  ```

  *Exports: `RouterOutputs`*
  ```ts
export type RouterOutputs = inferRouterOutputs<AppRouter>;
  ```

- **app/values/[id].tsx**

  *Exports: `default`*
  ```tsx
export default function ValueDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const router = useRouter();

  // TODO: Fetch value details using trpc.value.getValueById.useQuery({ id })

  return (
    <SafeAreaView style={{ flex: 1 }}>
      <YStack flex={1} padding="$4" space="$4">
        <H2>Principle Detail</H2>
        <Paragraph>Details for Principle (Value) with ID: {id}</Paragraph>
        {/* TODO: Display actual value details and add edit functionality */}
        <Button onPress={() => router.back()}>Go Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

### assets

- **assets/refresh-sheikah.json**
  *(No explicit exports found)*

### components

- **components/EmptyOrSkeleton.tsx**

  *Exports: `default`*
  ```tsx
export default function EmptyOrSkeleton({
  isLoading,
  isEmpty = false,
  children,
  skeletonCount = 3,
  skeletonHeight = 80,
  skeletonWidth = '100%',
  skeletonGap = 12,
  skeletonBorderRadius = 8,
  customSkeletonComponent,
  customEmptyComponent,
  skeletonOptions,
  title,
  message,
  image,
  containerStyle,
  titleStyle,
  messageStyle,
  imageContainerStyle,
  imageStyle,
  ...stackProps
}: EmptyOrSkeletonProps) {
  // If loading, show skeleton
  if (isLoading) {
    if (customSkeletonComponent) {
      return <>{customSkeletonComponent}</>;
    }
    
    return (
      <YStack space={skeletonGap} width="100%" {...stackProps}>
        {Array.from({ length: skeletonCount }).map((_, index) => (
          <SkeletonPlaceholder
            key={`skeleton-${index}`}
            height={skeletonHeight}
            width={skeletonWidth}
            borderRadius={skeletonBorderRadius}
            options={skeletonOptions}
          />
        ))}
      </YStack>
    );
  }
  
  // If empty, show empty state
  if (isEmpty) {
    if (customEmptyComponent) {
      return <>{customEmptyComponent}</>;
    }
    
    return (
      <EmptyState
        title={title}
        message={message}
        image={image}
        containerStyle={containerStyle}
        titleStyle={titleStyle}
        messageStyle={messageStyle}
        imageContainerStyle={imageContainerStyle}
        imageStyle={imageStyle}
      />
    );
  }
  
  // Otherwise, show children
  return <>{children}</>;
}
  ```

  *Exports: `EmptyOrSkeletonProps`*
  ```tsx
export interface EmptyOrSkeletonProps extends EmptyStateProps, StackProps {
  /** Whether data is loading */
  isLoading: boolean;
  /** Children to display when not loading and not empty */
  children: ReactNode;
  /** Whether the content is empty (no data) */
  isEmpty?: boolean;
  /** Number of skeleton placeholders to display when loading */
  skeletonCount?: number;
  /** Height of each skeleton item */
  skeletonHeight?: number;
  /** Width of each skeleton item (default: 100%) */
  skeletonWidth?: number | string;
  /** Gap between skeleton items */
  skeletonGap?: number;
  /** Border radius for skeleton items */
  skeletonBorderRadius?: number;
  /** Custom skeleton component */
  customSkeletonComponent?: ReactNode;
  /** Options for the skeleton animation */
  skeletonOptions?: SkeletonOptions;
}
  ```

  *Exports: `EmptyStateProps`*
  ```tsx
export interface EmptyStateProps {
  /** Title text for the empty state */
  title?: string;
  /** Subtitle/description text for the empty state */
  message?: string;
  /** Optional image/illustration to display */
  image?: ImageSourcePropType;
  /** Optional custom component to render instead of default empty state */
  customEmptyComponent?: ReactNode;
  /** Style for the container */
  containerStyle?: StyleProp<ViewStyle>;
  /** Style for the title */
  titleStyle?: StyleProp<TextStyle>;
  /** Style for the message */
  messageStyle?: StyleProp<TextStyle>;
  /** Style for the image container */
  imageContainerStyle?: StyleProp<ViewStyle>;
  /** Style for the image */
  imageStyle?: StyleProp<ImageStyle>;
}
  ```

- **components/aether/ProgressRing.tsx**

  *Exports: `default`*
  ```tsx
export default function ProgressRing({
  progress: rawProgress,
  size = 60,
  strokeWidth = 6,
  primaryColor,
  secondaryColor,
  backgroundColor = 'transparent',
}: ProgressRingProps) {
  const theme = useTheme();
  
  // Normalize progress to 0-1 range
  const progress = rawProgress > 1 ? rawProgress / 100 : rawProgress;
  
  // Calculate radius and other dimensions
  const radius = (size - strokeWidth) / 2;
  const circumference = radius * 2 * Math.PI;
  const strokeDashoffset = circumference - progress * circumference;

  // Use theme colors if not explicitly provided
  const primary = primaryColor || theme.blue10.val;
  const secondary = secondaryColor || theme.gray4.val;

  return (
    <Stack width={size} height={size} backgroundColor={backgroundColor} alignItems="center" justifyContent="center">
      <Svg width={size} height={size}>
        {/* Background circle */}
        <Circle
          stroke={secondary}
          fill="none"
          cx={size / 2}
          cy={size / 2}
          r={radius}
          strokeWidth={strokeWidth}
        />
        
        {/* Progress circle */}
        <Circle
          stroke={primary}
          fill="none"
          cx={size / 2}
          cy={size / 2}
          r={radius}
          strokeWidth={strokeWidth}
          strokeDasharray={circumference}
          strokeDashoffset={strokeDashoffset}
          strokeLinecap="round"
          transform={`rotate(-90, ${size / 2}, ${size / 2})`} // Start from top
        />
      </Svg>
    </Stack>
  );
}
  ```

- **components/auth/FloatingInput.tsx**

  *Exports: `default`*
  ```tsx
export default function FloatingInput({
  label,
  value,
  error,
  containerStyle,
  labelStyle,
  errorStyle,
  onFocusChange,
  leftIcon,
  rightIcon,
  adjustLabel = true,
  style,
  ...props
}: FloatingInputProps) {
  const [isFocused, setIsFocused] = useState(false);
  const inputRef = useRef<RNTextInput | null>(null);
  const animatedLabelValue = useSharedValue(value ? 1 : 0);
  const theme = useTheme();
  
  // Handle label animation when focus or value changes
  useEffect(() => {
    animatedLabelValue.value = withTiming(
      (isFocused || !!value) ? 1 : 0,
      {
        duration: 200, // Match durations.standard
        easing: Easing.bezier(0.4, 0.0, 0.2, 1.0),
      }
    );
  }, [isFocused, value, animatedLabelValue]);
  
  // Get dynamic colors from theme
  const colors = {
    input: {
      background: theme.inputBackground?.get() || theme.backgroundHover?.get() || '#F3F4F6',
      text: theme.color?.get() || '#111827',
      border: theme.borderColor?.get() || '#E5E7EB',
      focusBorder: theme.borderColorFocus?.get() || '#93C5FD',
      placeholderText: theme.colorTransparent?.get() || '#6B7280',
    },
    error: theme.red10?.get() || '#EF4444',
  };
  
  // Determine text color based on disabled state
  const textColor = props.editable === false 
    ? theme.colorTransparent?.get() || '#9CA3AF'
    : colors.input.text;
  
  // Handle focus changes
  const handleFocus = (event: any) => {
    setIsFocused(true);
    if (onFocusChange) onFocusChange(true);
    if (props.onFocus) props.onFocus(event);
  };
  
  const handleBlur = (event: any) => {
    setIsFocused(false);
    if (onFocusChange) onFocusChange(false);
    if (props.onBlur) props.onBlur(event);
  };
  
  // Animated styles
  const animatedLabelStyle = useAnimatedStyle(() => {
    return {
      position: 'absolute',
      left: leftIcon ? 40 : 16,
      top: adjustLabel ? 
        (16 + (-24 * animatedLabelValue.value)) : 
        (12 + (-20 * animatedLabelValue.value)),
      fontSize: 16 - (4 * animatedLabelValue.value),
      color: error ? colors.error : 
        animatedLabelValue.value > 0 ? 
          (isFocused ? colors.input.focusBorder : colors.input.placeholderText) : 
          colors.input.placeholderText,
      backgroundColor: animatedLabelValue.value > 0 ? 
        (theme.background?.get() || '#FFFFFF') : 'transparent',
      paddingHorizontal: 4 * animatedLabelValue.value,
      zIndex: 10,
    };
  });
  
  // Focus the input when the component is tapped
  const handleContainerPress = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };
  
  // Prepare input styles - flatten the array and provide default
  const inputStyles = StyleSheet.flatten([
    styles.input, 
    { color: textColor },
    leftIcon && { paddingLeft: 40 },
    rightIcon && { paddingRight: 40 },
    style // Style prop from component props
  ]) || {}; // Provide default empty style object
  
  return (
    <View style={[styles.container, containerStyle]}>
      <View 
        style={[
          styles.inputContainer, 
          { backgroundColor: colors.input.background },
          { borderColor: isFocused ? colors.input.focusBorder : colors.input.border },
          error && { borderColor: colors.error },
        ]} 
        onTouchStart={handleContainerPress}
      >
        {leftIcon && <View style={styles.leftIcon}>{leftIcon}</View>}
        
        <RNTextInput
          ref={inputRef}
          style={inputStyles}
          value={value}
          onFocus={handleFocus}
          onBlur={handleBlur}
          placeholderTextColor={colors.input.placeholderText}
          {...props}
        />
        
        {rightIcon && <View style={styles.rightIcon}>{rightIcon}</View>}
        
        <Animated.Text style={[animatedLabelStyle, labelStyle]}>
          {label}
        </Animated.Text>
      </View>
      
      {error && (
        <Text
          style={[styles.errorText, { color: colors.error }, errorStyle]}
          fontSize="$3"
          marginTop="$1"
        >
          {error}
        </Text>
      )}
    </View>
  );
}
  ```

  *Exports: `FloatingInputProps`*
  ```tsx
export interface FloatingInputProps extends RNTextInputProps {
  /** Label for the input */
  label: string;
  /** Error message to display */
  error?: string;
  /** Container style */
  containerStyle?: object;
  /** Label style */
  labelStyle?: object;
  /** Error style */
  errorStyle?: object;
  /** Tamagui tokens for theming */
  tokens?: ReturnType<typeof getTokens>;
  /** Called when focus changes */
  onFocusChange?: (focused: boolean) => void;
  /** Left icon to display */
  leftIcon?: React.ReactNode;
  /** Right icon to display */
  rightIcon?: React.ReactNode;
  /** Whether to adjust label position */
  adjustLabel?: boolean;
}
  ```

- **components/compass/PrincipleCard.tsx**

  *Exports: `PrincipleCard`*
  ```tsx
export function PrincipleCard({ principle, onPress }: PrincipleCardProps) {
  return (
    <Card
      bordered
      padding="$4"
      elevation="$1"
      pressTheme
      hoverTheme
      onPress={onPress}
      animation="bouncy"
      scale={onPress ? 0.98 : 1} // Only apply scale if pressable
      hoverStyle={onPress ? { scale: 0.99 } : {}}
      pressStyle={onPress ? { scale: 0.96 } : {}}
    >
      <YStack>
        <Text fontSize="$5" fontWeight="bold">
          {principle.name}
        </Text>
        {principle.description && (
          <Text color="$colorFocus" marginTop="$2">
            {principle.description}
          </Text>
        )}
      </YStack>
    </Card>
  );
}
  ```

- **components/compass/PrinciplesTab.tsx**

  *Exports: `default`*
  ```tsx
export default function PrinciplesTab() {
  const { data, isLoading, error, refetch } =
    trpc.value.getValues.useQuery();

  if (isLoading) return <EmptyOrSkeleton isLoading count={3} type="card" />;

  if (error)
    return (
      <EmptyOrSkeleton
        isError
        onRetry={refetch}
        text={error.message ?? 'Failed to load principles'}
      />
    );

  if (!Array.isArray(data) || !data.length)
    return (
      <EmptyOrSkeleton
        isEmpty
        text="No principles yet"
        actionText="Add Principle"
        onAction={() => router.push('/compose?type=value' as Href)}
      />
    );

  return (
    <YStack space="$3">
      {data.map((p: Principle) => (
        <PrincipleCard
          key={p.id}
          principle={p}
          onPress={() => router.push(`/values/${p.id}` as Href)}
        />
      ))}
    </YStack>
  );
}
  ```

- **components/compass/StateDefinitionCard.tsx**

  *Exports: `StateDefinitionCard`*
  ```tsx
export function StateDefinitionCard({ state, onPress }: StateDefinitionCardProps) {
  return (
    <Card
      bordered
      padding="$4"
      elevation="$1"
      pressTheme
      hoverTheme
      onPress={onPress}
      animation="bouncy"
      scale={onPress ? 0.98 : 1} // Only apply scale if pressable
      hoverStyle={onPress ? { scale: 0.99 } : {}}
      pressStyle={onPress ? { scale: 0.96 } : {}}
    >
      <YStack>
        <XStack alignItems="center" space="$3">
          <Text fontSize="$5" fontWeight="bold">
            {state.name}
          </Text>
          {/* Display scale type if available */}
          {state.scale && (
            <Text color="$colorFocus" fontSize="$2">({state.scale})</Text>
          )}
        </XStack>
        {state.description && (
          <Text color="$colorFocus" marginTop="$2">
            {state.description}
          </Text>
        )}
      </YStack>
    </Card>
  );
}
  ```

- **components/dashboard/DailyProgressBanner.tsx**

  *Exports: `default`*
  ```tsx
export default function DailyProgressBanner({ 
  tasksCompleted = 3, // Placeholder
  totalTasks = 5, // Placeholder
  habitsChecked = 2, // Placeholder
  totalHabits = 4 // Placeholder
}: DailyProgressBannerProps) {
  const theme = useTheme();
  const taskProgress = totalTasks > 0 ? (tasksCompleted / totalTasks) * 100 : 0;
  const habitProgress = totalHabits > 0 ? (habitsChecked / totalHabits) * 100 : 0;

  return (
    <BlurView intensity={50} tint="default" style={{ borderRadius: 12, overflow: 'hidden', marginBottom: 16 }}>
      <XStack 
        padding="$3"
        space="$4"
        alignItems="center" 
        backgroundColor="$surfaceSubtle" // Use subtle background from theme
      >
        {/* Tasks Progress */}
        <YStack flex={1} space="$1">
          <XStack space="$2" alignItems="center">
            <CheckSquare size={16} color={theme.accent?.get()} />
            <Text fontSize="$3" fontWeight="bold" color="$onSurface">
              Tasks
            </Text>
          </XStack>
          <Progress size="$1" value={taskProgress}>
            <Progress.Indicator animation="bouncy" backgroundColor="$accent" />
          </Progress>
          <Text fontSize="$1" color="$onSurfaceSubtle">
            {tasksCompleted} / {totalTasks} done
          </Text>
        </YStack>

        {/* Habits Progress */}
        <YStack flex={1} space="$1">
          <XStack space="$2" alignItems="center">
            <Target size={16} color={theme.accent?.get()} />
            <Text fontSize="$3" fontWeight="bold" color="$onSurface">
              Habits
            </Text>
          </XStack>
          <Progress size="$1" value={habitProgress}>
            <Progress.Indicator animation="bouncy" backgroundColor="$accent" />
          </Progress>
          <Text fontSize="$1" color="$onSurfaceSubtle">
            {habitsChecked} / {totalHabits} checked
          </Text>
        </YStack>
      </XStack>
    </BlurView>
  );
}
  ```

- **components/dashboard/DashboardSection.tsx**

  *Exports: `default`*
  ```tsx
export default function DashboardSection<T>({ 
  title, 
  data, 
  isLoading, 
  emptyMessage,
  seeAllRoute,
  renderItem,
  skeletonCount = 2,
  error,
  onRetry,
  children,
  onSeeAll
}: DashboardSectionProps<T>) {
  return (
    <YStack space="$2">
      <XStack justifyContent="space-between" alignItems="center" marginBottom="$2" paddingHorizontal="$2">
        <H4>{title}</H4>
        {((data && data.length > 0 && seeAllRoute) || onSeeAll) && (
          <Button 
            chromeless 
            size="$2" 
            onPress={() => {
              if (onSeeAll) {
                onSeeAll();
              } else if (seeAllRoute) {
                // Navigate to route using type assertions
                // Safe because the route will be a tab/screen name within the app
                router.push(seeAllRoute as any);
              }
            }}
          >
            See All
          </Button>
        )}
      </XStack>
      
      {/* Wrap content in BlurView */}
      <BlurView 
        intensity={50} 
        tint="default" 
        style={{ borderRadius: 12, overflow: 'hidden' }} 
      >
        <YStack padding="$3">
          {/* If children are provided, render them */}
          {children ? (
            children
          ) : isLoading ? (
            <SkeletonRow lines={skeletonCount} />
          ) : error ? (
            <SectionError message={error ? String(error) : 'An error occurred'} onRetry={onRetry} />
          ) : data && data.length === 0 ? (
            <YStack alignItems="center" padding="$4">
              <Text color="$gray10">{emptyMessage ?? 'No items found'}</Text>
            </YStack>
          ) : (
            data && renderItem && data.map(renderItem)
          )}
        </YStack>
      </BlurView>
    </YStack>
  );
}
  ```

- **components/dashboard/GoalSummaryCard.tsx**

  *Exports: `default`*
  ```tsx
export default function GoalSummaryCard({ goal, onPress }: GoalSummaryCardProps) {
  return (
    <BlurView 
      intensity={50} 
      tint="default" 
      style={{ borderRadius: 12, overflow: 'hidden' }}
    >
      <Button 
        chromeless // Remove default button styling
        padding="$3" 
        onPress={onPress}
        width="100%" // Ensure it fills the BlurView
      >
        <XStack alignItems="center" space="$3" flex={1}> 
          <ProgressRing
            progress={goal.progress}
            size={40}
            primaryColor="$primary"
          />
          <XStack flex={1} flexDirection="column">
            <Text fontSize="$4" fontWeight="500" color="$color">
              {goal.title}
            </Text>
            {goal.tasks && (
              <Text color="$gray9" fontSize="$2">
                {goal.tasks.completed}/{goal.tasks.total} tasks completed
              </Text>
            )}
          </XStack>
        </XStack>
      </Button>
    </BlurView>
  );
}
  ```

- **components/dashboard/HabitCheckItem.tsx**

  *Exports: `default`*
  ```tsx
export default function HabitCheckItem({ habit, onToggle }: HabitCheckItemProps) {
  const [checked, setChecked] = useState(habit.completed);
  const [isUpdating, setIsUpdating] = useState(false);
  const theme = useTheme(); 
  const utils = trpc.useUtils(); 

  // Define specific theme colors with safe access and fallbacks to theme variables
  const green10 = theme?.green10?.val ?? '$green10'; 
  const gray10 = theme?.gray10?.val ?? '$gray10'; 
  const orange10 = theme?.orange10?.val ?? '$orange10'; 


  const createEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: (updatedHabit) => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error creating habit entry:', error);
    }
  });

  const deleteEntryMutation = trpc.habit.deleteHabitEntry.useMutation({
    onSuccess: () => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error deleting habit entry:', error);
    }
  });

  useEffect(() => {
    setChecked(habit.completed);
  }, [habit.completed]);

  const handleToggle = () => {
    const newValue = !checked;
    setChecked(newValue); 
    setIsUpdating(true);

    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);

    const todayDateString = new Date().toISOString().split('T')[0];

    if (newValue) {
      const createInput: CreateHabitEntryInput = {
        habit_id: habit.id,
        date: todayDateString,
        completed: true, 
        quantity_value: null, 
        notes: null, 
      };
      createEntryMutation.mutate(createInput);
    } else {
      if (habit.last_entry_id) { 
        const deleteInput: DeleteHabitEntryInput = {
          id: habit.last_entry_id, 
        };
        deleteEntryMutation.mutate(deleteInput);
      } else {
        console.warn("Attempted to delete habit entry, but last_entry_id is missing.");
      }
    }

    if (onToggle) {
      onToggle(habit.id, newValue);
    }
  };

  const streakColor = checked ? green10 : gray10; // Use safe theme value
  const habitTypeColor = orange10; // Use safe theme value

  return (
    <XStack 
      backgroundColor="$backgroundStrong" // Use theme variable
      padding="$3"
      borderRadius="$4"
      alignItems="center"
      justifyContent="space-between"
      space="$3"
    >
      <YStack flex={1} gap="$1">
        <Text fontSize="$4" fontWeight="500" color="$color"> // Use theme variable
          {habit.name}
        </Text>
        
        {habit.streak != null && habit.streak > 0 && ( // Add null check
          <Text fontSize="$2" color={streakColor}> 
            Streak: {habit.streak ?? 0}
          </Text>
        )}
        {habit.habit_type && (
          <Text fontSize="$2" color={habitTypeColor}> // Use safe theme value
            ({habit.habit_type})
          </Text>
        )}
      </YStack>
      
      <Button
        size="$3"
        variant={checked ? undefined : 'outlined'} // Let variant handle appearance
        // Remove explicit colors - rely on theme/variant
        theme={checked ? 'green' : undefined} // Apply green theme when checked
        onPress={handleToggle}
        disabled={isUpdating} 
        iconAfter={checked ? <Text>✓</Text> : undefined}
      >
        {checked ? "Done" : "Check-in"}
      </Button>
    </XStack>
  );
}
  ```

- **components/dashboard/StateIndicator.tsx**

  *Exports: `default`*
  ```tsx
export default function StateIndicator({ state, onPress, lastEntry }: StateIndicatorProps) {
  // Format the last updated time
  const formattedTime = state.lastUpdated 
    ? new Date(state.lastUpdated).toLocaleTimeString([], { 
        hour: '2-digit', 
        minute: '2-digit' 
      })
    : 'N/A';
  
  // Use Tamagui Card component
  return (
    <Card 
      onPress={onPress} 
      pressStyle={{ opacity: 0.8 }}
      padding="$3"
      // No explicit background, will use default Card background from theme
    >
      <YStack space="$1"> {/* Main container for text */}
        <XStack flex={1} alignItems="center">
          <Text fontSize="$4" fontWeight="500">{state.name}</Text>
          {lastEntry && (
            <Text fontSize="$2" color="$gray10" marginLeft="$2">
              ({formattedTime})
            </Text>
          )}
        </XStack>
        <XStack alignItems="baseline" space="$2"> {/* Align text by baseline, add space */}
          <Text fontSize="$5" fontWeight="600" color="$color"> {/* Use tokens */}
            {state.currentValue}
          </Text>
        </XStack>
        {!lastEntry && (
          <Text fontSize="$2" color="$gray10" marginTop="$1">
            No data recorded yet.
          </Text>
        )}
      </YStack>
    </Card>
  );
}
  ```

- **components/dashboard/TaskItem.tsx**

  *Exports: `default`*
  ```tsx
export default function TaskItem({ task, onPress }: TaskItemProps) {
  
  // Setup toggleTask mutation with optimistic updates
  const utils = trpc.useContext();
  // Setup mutation for task toggling
  const toggleTaskMutation = trpc.task.toggleTask.useMutation({
    // Optimistically update the UI
    onMutate: async ({ taskId, completed }: { taskId: string; completed?: boolean }) => {
      // Default to toggling the current state if completed is not provided
      const newCompleted = completed !== undefined ? completed : !isCompleted;
      // Cancel outgoing fetches that might overwrite our optimistic update
      await utils.task.getTasks.cancel();
      await utils.dashboard.getDashboardData.cancel();
      
      // Get previous data for potential rollback
      const prevTasksData = utils.task.getTasks.getData();
      const prevDashboardData = utils.dashboard.getDashboardData.getData();
      
      // Optimistically update tasks data if present
      if (prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return old.map((t: any) => {
            if (t.id === taskId) {
              return {
                ...t,
                status: completed ? 'completed' : 'in-progress'
              };
            }
            return t;
          });
        });
      }
      
      // Optimistically update dashboard data if present
      if (prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return {
            ...old,
            tasks: old.tasks.map((t: any) => {
              if (t.id === taskId) {
                return {
                  ...t,
                  status: newCompleted ? 'completed' : 'in-progress'
                };
              }
              return t;
            }),
          };
        });
      }
      
      // Return previous data for rollback
      return { prevTasksData, prevDashboardData };
    },
    
    // If something goes wrong, rollback optimistic updates
    onError: (err: any, variables: any, context: any) => {
      if (context?.prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, context.prevTasksData);
      }
      if (context?.prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, context.prevDashboardData);
      }
      console.error('Error toggling task:', err);
    },
    
    // Always refetch after error or success
    onSettled: () => {
      utils.task.getTasks.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    }
  });

  // Handle checkbox toggle
  const handleToggle = () => {
    toggleTaskMutation.mutate({
      taskId: task.id, // Using taskId as expected by the backend
      completed: !isCompleted
    });
  };

  // Map priority to color
  const priorityColor = task.priority === 1 ? '$brandRed' : 
                        task.priority === 2 ? '$brandYellow' : 
                        '$brandGreen';
  
  // Format due date
  const formattedDate = task.due_date 
    ? new Date(task.due_date).toLocaleDateString(undefined, { 
        month: 'short', 
        day: 'numeric' 
      })
    : null;
    
  // Determine task completion status
  const isCompleted = task.status === 'completed';
  // No need for text style object since we use Tamagui props directly

  
  // Use YStack as the base component
  return (
    <YStack 
      backgroundColor="$backgroundStrong"
      padding="$3"
      borderRadius="$4"
      space="$1" // Add space between XStack and Date Text
    >
      <XStack alignItems="center" space="$2"> {/* Use XStack for horizontal layout */}
        {/* Checkbox for task completion */}
        <Checkbox
          size="$4"
          checked={isCompleted}
          onCheckedChange={handleToggle}
          disabled={toggleTaskMutation.isPending}
        >
          {toggleTaskMutation.isPending ? (
            <Spinner size="small" color="$brandPrimary" />
          ) : (
            <Checkbox.Indicator>
              <Check size={16} />
            </Checkbox.Indicator>
          )}
        </Checkbox>

        {/* Container for task details (clickable) */}
        <XStack flex={1} tag="pressable" onPress={onPress} pressStyle={{ opacity: 0.7 }}>
          {/* Priority Dot using YStack */}
          <YStack 
            width="$2" // Use size token for width
            height="$2" // Use size token for height
            borderRadius="$10" // Use a large radius token
            backgroundColor={priorityColor} 
            marginRight="$2" // Use space token for margin
          />
          <Text 
            fontSize="$4" // Use font size token
            fontWeight={task.priority === 1 ? '600' : '400'} // Keep fontWeight
            color="$color"
            flex={1} // Allow text to take remaining space
            opacity={isCompleted ? 0.7 : 1}
            textDecorationLine={isCompleted ? 'line-through' : undefined} // Proper Tamagui text decoration
          >
            {task.name}
          </Text>
        </XStack>
      </XStack>
      
      {formattedDate && (
        // Removed explicit margin, rely on outer YStack space
        <Text color="$gray9" fontSize="$2">
          Due: {formattedDate}
        </Text>
      )}
    </YStack>
  );
}
  ```

- **components/lists/GoalList.tsx**

  *Exports: `GoalCard`*
  ```tsx
export function GoalCard({ goal, onPress }: { goal: Goal; onPress: () => void }) {
  // Calculate progress percentage for the progress ring
  const progressPercent = goal.progress ? goal.progress : 0;
  
  // Format the target date
  const formattedDate = goal.target_date
    ? new Date(goal.target_date).toLocaleDateString(undefined, {
        month: 'short',
        day: 'numeric',
      })
    : 'No due date';

  return (
    <AetherCard 
      isInteractive 
      variant="default"
      onPress={onPress}
    >
      <YStack space="$2">
        {/* Title */}
        <YStack>
          <XStack space="$2" alignItems="center">
            <Ionicons name="trophy-outline" size={18} color="$primary" />
            <Text fontSize="$5" fontWeight="bold" color="$color">
              {goal.title}
            </Text>
          </XStack>
        </YStack>
        
        {/* Description if available */}
        {goal.description && (
          <Text color="$colorMuted" fontSize="$3" numberOfLines={2}>
            {goal.description}
          </Text>
        )}
        
        {/* Footer with date and progress */}
        <XStack justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center">
            <Ionicons name="calendar-outline" size={16} color="$colorMuted" />
            <Text fontSize="$2" color="$colorMuted">
              {formattedDate}
            </Text>
          </XStack>
          
          {/* Progress display */}
          <XStack backgroundColor="$background" paddingHorizontal="$2" paddingVertical="$1" borderRadius="$2">
            <Text fontSize="$2" fontWeight="bold" color={progressPercent >= 75 ? '$success' : '$primary'}>
              {progressPercent}%
            </Text>
          </XStack>
        </XStack>
      </YStack>
    </AetherCard>
  );
}
  ```

  *Exports: `GoalList`*
  ```tsx
export function GoalList({ goals, isLoading, isError, refetch, onSelectGoal }: GoalListProps) {
  const renderGoalItem: ListRenderItem<Goal> = ({ item }) => (
    <GoalCard 
      goal={item} 
      onPress={() => {
        if (onSelectGoal) {
          onSelectGoal(item);
        } else {
          // Default navigation
          router.push({ 
            pathname: '/planner/goal/[id]', 
            params: { id: item.id } 
          });
        }
      }} 
    />
  );

  if (isLoading) {
    return <EmptyOrSkeleton isLoading count={3} type="card" />;
  }

  if (isError) {
    return (
      <YStack padding="$4" space="$4" alignItems="center" justifyContent="center">
        <Ionicons name="alert-circle-outline" size={48} color="$error" />
        <YStack>
          <YStack alignItems="center">
            <Text fontSize="$5" fontWeight="bold" color="$color" textAlign="center">
              Unable to load goals
            </Text>
            <Text fontSize="$3" color="$colorMuted" textAlign="center" marginTop="$2">
              Please check your connection and try again
            </Text>
          </YStack>
        </YStack>
        <AetherCard onPress={refetch} isInteractive padding="$3" paddingHorizontal="$5">
          <XStack alignItems="center" space="$2">
            <Ionicons name="refresh-outline" size={18} color="$primary" />
            <Text fontSize="$4" fontWeight="500" color="$primary">
              Retry
            </Text>
          </XStack>
        </AetherCard>
      </YStack>
    );
  }

  if (!goals || goals.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty 
        text="No goals yet" 
        actionText="Create a goal" 
        onAction={() => router.push('/planner/add-goal')} 
      />
    );
  }

  return (
    <FlatList
      data={goals}
      keyExtractor={(item) => item.id}
      renderItem={renderGoalItem}
      contentContainerStyle={{ padding: 16, paddingBottom: 32 }}
      ItemSeparatorComponent={() => <YStack height="$4" />}
      refreshControl={
        <RefreshControl 
          refreshing={isLoading} 
          onRefresh={refetch} 
        />
      }
    />
  );
}
  ```

- **components/lists/HabitList.tsx**

  *Exports: `HabitCard`*
  ```tsx
export function HabitCard({ 
  habit, 
  onPress, 
  onToggle 
}: { 
  habit: Habit; 
  onPress: () => void; 
  onToggle?: (completed: boolean) => void;
}) {
  // Calculate progress streak display
  const streakText = habit.streak === 1 
    ? '1 day'
    : `${habit.streak} days`;

  const bestStreakText = habit.best_streak === 1
    ? '1 day'
    : `${habit.best_streak} days`;

  // Check if the habit has been completed today
  const [isCompleted, setIsCompleted] = React.useState(false); // This would come from habit entries

  const handleToggle = () => {
    const newStatus = !isCompleted;
    setIsCompleted(newStatus);
    if (onToggle) {
      onToggle(newStatus);
    }
  };

  return (
    <AetherCard 
      isInteractive 
      variant="default"
      onPress={onPress}
    >
      <YStack space="$2">
        {/* Title with completion toggle */}
        <XStack space="$3" justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center" flex={1}>
            <Ionicons name="repeat-outline" size={18} color="$primary" />
            <Text fontSize="$5" fontWeight="bold" color="$color" numberOfLines={1} flex={1}>
              {habit.title}
            </Text>
          </XStack>
          
          {/* Toggle button for completing today's habit */}
          <Stack 
            onPress={handleToggle}
            pressStyle={{ opacity: 0.8 }}
          >
            <Ionicons 
              name={isCompleted ? "checkmark-circle" : "checkmark-circle-outline"} 
              size={26} 
              color={isCompleted ? "$success" : "$colorMuted"} 
            />
          </Stack>
        </XStack>
        
        {/* Streak information */}
        <XStack justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center">
            <Ionicons name="flame-outline" size={16} color="$colorMuted" />
            <Text fontSize="$2" color="$colorMuted">
              Current: {streakText}
            </Text>
          </XStack>
          
          <XStack space="$2" alignItems="center">
            <Ionicons name="trophy-outline" size={16} color="$colorMuted" />
            <Text fontSize="$2" color="$colorMuted">
              Best: {bestStreakText}
            </Text>
          </XStack>
        </XStack>
      </YStack>
    </AetherCard>
  );
}
  ```

  *Exports: `HabitList`*
  ```tsx
export function HabitList({ 
  habits, 
  isLoading, 
  isError, 
  refetch, 
  onSelectHabit,
  onToggleHabit 
}: HabitListProps) {
  const renderHabitItem: ListRenderItem<Habit> = ({ item }) => (
    <HabitCard 
      habit={item} 
      onPress={() => {
        if (onSelectHabit) {
          onSelectHabit(item);
        } else {
          // Default navigation
          router.push({ 
            pathname: '/planner/habit/[id]', 
            params: { id: item.id } 
          });
        }
      }}
      onToggle={(completed) => {
        if (onToggleHabit) {
          onToggleHabit(item.id, completed);
        }
      }}
    />
  );

  if (isLoading) {
    return <EmptyOrSkeleton isLoading count={3} type="card" />;
  }

  if (isError) {
    return (
      <YStack padding="$4" space="$4" alignItems="center" justifyContent="center">
        <Ionicons name="alert-circle-outline" size={48} color="$error" />
        <YStack>
          <YStack alignItems="center">
            <Text fontSize="$5" fontWeight="bold" color="$color" textAlign="center">
              Unable to load habits
            </Text>
            <Text fontSize="$3" color="$colorMuted" textAlign="center" marginTop="$2">
              Please check your connection and try again
            </Text>
          </YStack>
        </YStack>
        <AetherCard onPress={refetch} isInteractive padding="$3" paddingHorizontal="$5">
          <XStack alignItems="center" space="$2">
            <Ionicons name="refresh-outline" size={18} color="$primary" />
            <Text fontSize="$4" fontWeight="500" color="$primary">
              Retry
            </Text>
          </XStack>
        </AetherCard>
      </YStack>
    );
  }

  if (!habits || habits.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty 
        text="No habits yet" 
        actionText="Create a habit" 
        onAction={() => router.push('/planner/add-habit')} 
      />
    );
  }

  return (
    <FlatList
      data={habits}
      keyExtractor={(item) => item.id}
      renderItem={renderHabitItem}
      contentContainerStyle={{ padding: 16, paddingBottom: 32 }}
      ItemSeparatorComponent={() => <YStack height="$4" />}
      refreshControl={
        <RefreshControl 
          refreshing={isLoading} 
          onRefresh={refetch} 
        />
      }
    />
  );
}
  ```

- **components/lists/TaskList.tsx**

  *Exports: `TaskCard`*
  ```tsx
export function TaskCard({ 
  task, 
  onPress, 
  onComplete 
}: { 
  task: Task; 
  onPress: () => void; 
  onComplete?: (completed: boolean) => void;
}) {
  // Get the completion status of the task
  const [isCompleted, setIsCompleted] = React.useState(Boolean(task.completed));
  
  // Format the due date
  const formattedDate = task.due
    ? new Date(task.due).toLocaleDateString(undefined, {
        month: 'short',
        day: 'numeric',
      })
    : 'No due date';
    
  // Check if task is overdue
  const isOverdue = task.due && new Date(task.due) < new Date() && !isCompleted;

  const handleToggle = () => {
    const newStatus = !isCompleted;
    setIsCompleted(newStatus);
    if (onComplete) {
      onComplete(newStatus);
    }
  };

  return (
    <AetherCard 
      isInteractive 
      variant="default"
      onPress={onPress}
    >
      <YStack space="$2">
        {/* Title with completion toggle */}
        <XStack space="$3" justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center" flex={1}>
            <Stack 
              onPress={handleToggle}
              pressStyle={{ opacity: 0.8 }}
            >
              <Ionicons 
                name={isCompleted ? "checkmark-circle" : "checkmark-circle-outline"} 
                size={26} 
                color={isCompleted ? "$success" : "$colorMuted"} 
              />
            </Stack>
            <Text 
              fontSize="$5" 
              fontWeight="bold" 
              color={isCompleted ? "$colorMuted" : "$color"} 
              numberOfLines={1} 
              flex={1}
              textDecorationLine={isCompleted ? 'line-through' : 'none'}
            >
              {task.title}
            </Text>
          </XStack>
        </XStack>
        
        {/* Notes if available */}
        {task.notes && !isCompleted && (
          <Text color="$colorMuted" fontSize="$3" numberOfLines={2} paddingLeft="$7">
            {task.notes}
          </Text>
        )}
        
        {/* Footer with due date and goal information */}
        <XStack justifyContent="space-between" alignItems="center" paddingLeft="$7">
          <XStack space="$2" alignItems="center">
            <Ionicons 
              name="calendar-outline" 
              size={16} 
              color={isOverdue ? "$error" : "$colorMuted"} 
            />
            <Text 
              fontSize="$2" 
              color={isOverdue ? "$error" : "$colorMuted"}
              fontWeight={isOverdue ? "bold" : "normal"}
            >
              {isOverdue ? "Overdue: " : ""}{formattedDate}
            </Text>
          </XStack>
          
          {/* If task is linked to a goal, show goal name */}
          {task.goal_id && (
            <XStack 
              backgroundColor="$backgroundStrong" 
              paddingHorizontal="$2" 
              paddingVertical="$1" 
              borderRadius="$2"
            >
              <Text fontSize="$2" color="$primary">
                {task.goal?.title || 'Linked goal'}
              </Text>
            </XStack>
          )}
        </XStack>
      </YStack>
    </AetherCard>
  );
}
  ```

  *Exports: `TaskList`*
  ```tsx
export function TaskList({ 
  tasks, 
  isLoading, 
  isError, 
  refetch, 
  onSelectTask,
  onCompleteTask 
}: TaskListProps) {
  const renderTaskItem: ListRenderItem<Task> = ({ item }) => (
    <TaskCard 
      task={item} 
      onPress={() => {
        if (onSelectTask) {
          onSelectTask(item);
        } else {
          // Default navigation
          router.push({ 
            pathname: '/planner/task/[id]', 
            params: { id: item.id } 
          });
        }
      }}
      onComplete={(completed) => {
        if (onCompleteTask) {
          onCompleteTask(item.id, completed);
        }
      }}
    />
  );

  if (isLoading) {
    return <EmptyOrSkeleton isLoading count={3} type="card" />;
  }

  if (isError) {
    return (
      <YStack padding="$4" space="$4" alignItems="center" justifyContent="center">
        <Ionicons name="alert-circle-outline" size={48} color="$error" />
        <YStack>
          <YStack alignItems="center">
            <Text fontSize="$5" fontWeight="bold" color="$color" textAlign="center">
              Unable to load tasks
            </Text>
            <Text fontSize="$3" color="$colorMuted" textAlign="center" marginTop="$2">
              Please check your connection and try again
            </Text>
          </YStack>
        </YStack>
        <AetherCard onPress={refetch} isInteractive padding="$3" paddingHorizontal="$5">
          <XStack alignItems="center" space="$2">
            <Ionicons name="refresh-outline" size={18} color="$primary" />
            <Text fontSize="$4" fontWeight="500" color="$primary">
              Retry
            </Text>
          </XStack>
        </AetherCard>
      </YStack>
    );
  }

  if (!tasks || tasks.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty 
        text="No tasks yet" 
        actionText="Create a task" 
        onAction={() => router.push('/planner/add-task')} 
      />
    );
  }

  return (
    <FlatList
      data={tasks}
      keyExtractor={(item) => item.id}
      renderItem={renderTaskItem}
      contentContainerStyle={{ padding: 16, paddingBottom: 32 }}
      ItemSeparatorComponent={() => <YStack height="$4" />}
      refreshControl={
        <RefreshControl 
          refreshing={isLoading} 
          onRefresh={refetch} 
        />
      }
    />
  );
}
  ```

- **components/lists/index.ts**

  *Exports: `GoalCard`*
  ```ts
export { GoalList, GoalCard } from './GoalList';
  ```

  *Exports: `GoalList`*
  ```ts
export { GoalList, GoalCard } from './GoalList';
  ```

  *Exports: `HabitCard`*
  ```ts
export { HabitList, HabitCard } from './HabitList';
  ```

  *Exports: `HabitList`*
  ```ts
export { HabitList, HabitCard } from './HabitList';
  ```

  *Exports: `TaskCard`*
  ```ts
export { TaskList, TaskCard } from './TaskList';
  ```

  *Exports: `TaskList`*
  ```ts
export { TaskList, TaskCard } from './TaskList';
  ```

- **components/planner/GoalsList.tsx**

  *Exports: `default`*
  ```tsx
export default function GoalsList({
  goals = [],
  isLoading = false,
  onGoalPress,
  onAddPress,
  style,
}: GoalsListProps) {
  const colors = useColors();
  
  return (
    <YStack flex={1} style={style}>
      <EmptyOrSkeleton
        isLoading={isLoading}
        isEmpty={goals.length === 0}
        skeletonCount={3}
        skeletonHeight={160}
        skeletonBorderRadius={12}
        title="No goals yet"
        message="Create a new goal to track your progress"
      >
        <FlashList
          data={goals}
          renderItem={({ item }) => (
            <GoalCard goal={item} onPress={onGoalPress} />
          )}
          estimatedItemSize={180}
          contentContainerStyle={styles.listContent}
          ItemSeparatorComponent={() => <View style={styles.separator} />}
        />
      </EmptyOrSkeleton>
      
      {onAddPress && (
        <Pressable
          onPress={onAddPress}
          style={({ pressed }) => [
            styles.addButton,
            {
              backgroundColor: colors.brand.primary,
              opacity: pressed ? 0.9 : 1,
              transform: [{ scale: pressed ? 0.97 : 1 }],
            }
          ]}
        >
          <Text fontSize="$4" fontWeight="$3" color="white">
            + Add Goal
          </Text>
        </Pressable>
      )}
    </YStack>
  );
}
  ```

  *Exports: `Goal`*
  ```tsx
export interface Goal {
  id: string;
  title: string;
  description?: string;
  progress: number; // 0 to 1
  deadline?: string; // ISO date string
  userId: string;
  createdAt: string;
  updatedAt: string;
}
  ```

  *Exports: `GoalsListProps`*
  ```tsx
export interface GoalsListProps {
  /** List of goals to display */
  goals?: Goal[];
  /** Whether the data is loading */
  isLoading?: boolean;
  /** Called when a goal is pressed */
  onGoalPress?: (goal: Goal) => void;
  /** Called when the add button is pressed */
  onAddPress?: () => void;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}
  ```

- **components/planner/HabitTracker.tsx**

  *Exports: `HabitTracker`*
  ```tsx
export function HabitTracker({
  habits = [],
  onAddHabit,
  onToggleHabit,
  onHabitPress,
}: HabitTrackerProps) {
  const today = format(new Date(), "yyyy-MM-dd");

  const handleToggleHabit = (habit: Habit) => {
    if (!onToggleHabit) return;
    
    const isCompleted = habit.completedDates.includes(today);
    onToggleHabit(habit.id, today, !isCompleted);
  };

  return (
    <YStack space="$4">
      <XStack justifyContent="space-between" alignItems="center">
        <H4>Habits</H4>
        <Button 
          size="$2" 
          circular 
          icon={<Plus size={16} />} 
          onPress={onAddHabit}
        />
      </XStack>

      {habits.length === 0 ? (
        <YStack 
          p="$4"
          alignItems="center" 
          justifyContent="center" 
          backgroundColor="$gray2" 
          borderRadius="$4"
        >
          <Text color="$gray11" textAlign="center">
            No habits yet. Add your first habit to start tracking.
          </Text>
        </YStack>
      ) : (
        <YStack space="$3">
          {habits.map((habit, index) => (
            <YStack key={habit.id} space="$2">
              {index > 0 && <Separator />}
              <HabitItem 
                habit={habit} 
                onToggle={() => handleToggleHabit(habit)}
                onPress={() => onHabitPress?.(habit)} 
              />
            </YStack>
          ))}
        </YStack>
      )}
    </YStack>
  );
}
  ```

- **components/planner/HabitsList.tsx**

  *Exports: `default`*
  ```tsx
export default function HabitsList({
  habits = [],
  isLoading = false,
  onToggleHabit,
  onHabitPress,
  onAddPress,
  style,
}: HabitsListProps) {
  const colors = useColors();
  
  return (
    <YStack flex={1} style={style}>
      <EmptyOrSkeleton
        isLoading={isLoading}
        isEmpty={habits.length === 0}
        skeletonCount={4}
        skeletonHeight={80}
        skeletonBorderRadius={12}
        title="No habits yet"
        message="Create a habit to track your daily progress"
      >
        <YStack space="$2" padding="$4">
          {habits.map((habit) => (
            <HabitItem
              key={habit.id}
              habit={habit}
              onToggle={onToggleHabit}
              onPress={onHabitPress}
            />
          ))}
        </YStack>
      </EmptyOrSkeleton>
      
      {onAddPress && (
        <Pressable
          onPress={onAddPress}
          style={({ pressed }) => [
            styles.addButton,
            {
              backgroundColor: colors.brand.primary,
              opacity: pressed ? 0.9 : 1,
              transform: [{ scale: pressed ? 0.97 : 1 }],
            }
          ]}
        >
          <Text fontSize="$4" fontWeight="$3" color="white">
            + Add Habit
          </Text>
        </Pressable>
      )}
    </YStack>
  );
}
  ```

  *Exports: `Habit`*
  ```tsx
export interface Habit {
  id: string;
  title: string;
  description?: string;
  frequency: 'daily' | 'weekly' | 'monthly';
  completedToday: boolean;
  streak: number;
  userId: string;
  createdAt: string;
  updatedAt: string;
}
  ```

  *Exports: `HabitsListProps`*
  ```tsx
export interface HabitsListProps {
  /** List of habits to display */
  habits?: Habit[];
  /** Whether the data is loading */
  isLoading?: boolean;
  /** Called when a habit's completion status is toggled */
  onToggleHabit?: (habitId: string, completed: boolean) => Promise<void>;
  /** Called when a habit item is pressed */
  onHabitPress?: (habit: Habit) => void;
  /** Called when the add button is pressed */
  onAddPress?: () => void;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}
  ```

- **components/planner/StreakCalendar.tsx**

  *Exports: `default`*
  ```tsx
export default function StreakCalendar({
  completedDates = [],
  weekCount = 4,
  style,
}: StreakCalendarProps) {
  const today = new Date();

  const completedDatesObjects = useMemo(() => {
    return completedDates.map(dateStr => new Date(dateStr));
  }, [completedDates]);

  // Generate weeks from the current week backwards
  const weeks = useMemo(() => {
    const result = [];
    const day = startOfWeek(today, { weekStartsOn: 0 }); // Sunday as first day

    // Get current week
    const currentWeek = Array(7)
      .fill(null)
      .map((_, i) => {
        const date = addDays(day, i);
        return {
          date,
          completed: completedDatesObjects.some((d) => isSameDay(d, date)),
          isToday: isSameDay(date, today),
          isPast: date < today,
          isFuture: date > today,
        };
      });
    result.push(currentWeek);

    // Get previous weeks
    for (let i = 1; i < weekCount; i++) {
      const startDay = subWeeks(day, i);
      const week = Array(7)
        .fill(null)
        .map((_, j) => {
          const date = addDays(startDay, j);
          return {
            date,
            completed: completedDatesObjects.some((d) => isSameDay(d, date)),
            isToday: false,
            isPast: date < today,
            isFuture: date > today,
          };
        });
      result.push(week);
    }

    // Reverse so most recent week is at the bottom
    return result.reverse();
  }, [completedDatesObjects, weekCount, today]);

  const dayNames = useMemo(() => {
    const firstDayOfWeek = startOfWeek(new Date(), { weekStartsOn: 0 });
    return Array(7)
      .fill(null)
      .map((_, i) => {
        return format(addDays(firstDayOfWeek, i), "EEE").charAt(0);
      });
  }, []);

  return (
    <YStack space="$3" style={style}>
      <Text fontSize="$3" fontWeight="$3" color="$content.primary">
        Activity
      </Text>
      
      <XStack justifyContent="space-between">
        {dayNames.map((day, index) => (
          <Text key={index} color="$gray11" textAlign="center" fontSize="$1">
            {day}
          </Text>
        ))}
      </XStack>
      
      <YStack space="$3">
        {weeks.map((week, weekIndex) => (
          <XStack key={`week-${weekIndex}`} justifyContent="space-between">
            {week.map((day, dayIndex) => (
              <YStack key={`day-${weekIndex}-${dayIndex}`} alignItems="center" space="$1">
                <Text 
                  fontSize="$1" 
                  color={day.isToday ? "$brand.primary" : "$content.subtle"}
                  fontWeight={day.isToday ? '$3' : '$2'}
                >
                  {day.date.getDate()}
                </Text>
                
                {/* Day circle */}
                <DayCircle 
                  completed={day.completed}
                  isToday={day.isToday}
                  isPast={day.isPast}
                  isFuture={day.isFuture}
                />
              </YStack>
            ))}
          </XStack>
        ))}
      </YStack>
      
      {/* Legend */}
      <XStack space="$4" justifyContent="center" marginTop="$2">
        <XStack space="$1" alignItems="center">
          <View
            style={{
              width: 8,
              height: 8,
              borderRadius: 4,
              backgroundColor: "$gray6",
            }}
          />
          <Text fontSize="$2" color="$content.subtle">Not completed</Text>
        </XStack>
        
        <XStack space="$1" alignItems="center">
          <View
            style={{
              width: 8,
              height: 8,
              borderRadius: 4,
              backgroundColor: "$primary9",
            }}
          />
          <Text fontSize="$2" color="$content.subtle">Completed</Text>
        </XStack>
      </XStack>
    </YStack>
  );
}
  ```

  *Exports: `StreakCalendarProps`*
  ```tsx
export interface StreakCalendarProps {
  /** Array of dates (ISO strings) when the habit was completed */
  completedDates: string[];
  /** Number of weeks to display (default: 4) */
  weekCount?: number;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}
  ```

- **components/rewards/ConfettiBurst.tsx**

  *Exports: `default`*
  ```tsx
export default function ConfettiBurst({
  isVisible,
  onComplete,
  count = CONFETTI_COUNT,
  colors = COLORS,
  duration = 2000,
}: ConfettiBurstProps) {
  // Create confetti pieces
  const pieces = React.useMemo(() => {
    const result: ConfettiPiece[] = [];
    
    for (let i = 0; i < count; i++) {
      result.push({
        id: i,
        x: Math.random() * SCREEN_WIDTH,
        y: -20, // Start above the screen
        size: Math.random() * 8 + 4, // Size between 4-12
        color: colors[Math.floor(Math.random() * colors.length)],
        rotation: Math.random() * 360,
        delay: Math.random() * 500, // Random delay up to 500ms
        duration: Math.random() * 1000 + 1500, // Duration between 1.5-2.5s
      });
    }
    
    return result;
  }, [count, colors]);
  
  // Trigger animation complete callback
  const animationComplete = () => {
    if (onComplete) {
      onComplete();
    }
  };
  
  return (
    <>
      {isVisible && (
        <View style={styles.container} pointerEvents="none">
          {pieces.map((piece) => (
            <ConfettiPiece
              key={piece.id}
              piece={piece}
              animationDuration={duration}
              onComplete={animationComplete}
            />
          ))}
        </View>
      )}
    </>
  );
}
  ```

- **components/settings/NotificationRow.tsx**

  *Exports: `default`*
  ```tsx
export default function NotificationRow({
  title,
  description,
  enabled,
  onToggle,
  icon,
  isLoading,
  switchProps,
  style,
}: NotificationRowProps) {
  const colors = useColors();
  
  const handleToggle = (value: boolean) => {
    if (!isLoading) {
      onToggle(value);
    }
  };
  
  return (
    <XStack
      style={[styles.container, style]}
      alignItems="center"
      justifyContent="space-between"
      padding="$4"
      backgroundColor={colors.background.card}
      borderRadius="$4"
    >
      <XStack alignItems="center" space="$3" flex={1}>
        {icon && <XStack opacity={isLoading ? 0.5 : 1}>{icon}</XStack>}
        
        <YStack space="$1" flex={1} opacity={isLoading ? 0.5 : 1}>
          <Text
            fontSize="$4"
            fontWeight="$2"
            color={colors.content.primary}
          >
            {title}
          </Text>
          
          {description && (
            <Text
              fontSize="$3"
              color={colors.content.secondary}
            >
              {description}
            </Text>
          )}
        </YStack>
      </XStack>
      
      <Switch
        size="$2"
        checked={enabled}
        onCheckedChange={handleToggle}
        disabled={isLoading}
        {...switchProps}
      />
    </XStack>
  );
}
  ```

  *Exports: `NotificationRowProps`*
  ```tsx
export interface NotificationRowProps {
  /** Title of the notification setting */
  title: string;
  /** Optional description */
  description?: string;
  /** Whether the notification is turned on */
  enabled: boolean;
  /** Called when the switch is toggled */
  onToggle: (value: boolean) => void;
  /** Icon to display in the row */
  icon?: ReactNode;
  /** Whether the control is in loading state */
  isLoading?: boolean;
  /** Switch props */
  switchProps?: Omit<SwitchProps, 'checked' | 'onCheckedChange'>;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}
  ```

- **components/settings/ThemePreview.tsx**

  *Exports: `default`*
  ```tsx
export default function ThemePreview({
  themeName,
  isSelected,
  onSelect,
  forceDark,
  forceLight,
  style,
}: ThemePreviewProps) {
  const currentTheme = useTheme();
  const previewTheme = forceDark ? 'dark' : forceLight ? 'light' : undefined;
  const colors = useColors();
  
  return (
    <Pressable 
      onPress={onSelect}
      style={({ pressed }) => [
        styles.container,
        {
          transform: [{ scale: pressed ? 0.97 : 1 }],
          borderColor: isSelected ? colors.border.focus : colors.border.default,
          borderWidth: isSelected ? 2 : 1,
        },
        style,
      ]}
    >
      <YStack space="$2">
        <Text
          fontSize="$4"
          fontWeight="$2"
          color={colors.content.primary}
          marginBottom="$1"
        >
          {themeName}
        </Text>
        
        <Theme name={previewTheme}>
          <YStack
            backgroundColor="$cardBackground"
            borderRadius="$3"
            padding="$2"
            space="$2"
          >
            {/* Header Preview */}
            <View 
              style={styles.header}
              backgroundColor="$primary"
            />
            
            {/* Content Preview */}
            <YStack space="$1">
              <View style={styles.textLine} backgroundColor="$color" opacity={0.9} />
              <View style={styles.textLine} backgroundColor="$color" opacity={0.7} width="80%" />
              <View style={styles.textLine} backgroundColor="$color" opacity={0.5} width="60%" />
            </YStack>
            
            {/* Button Preview */}
            <XStack space="$2">
              <View
                style={styles.button}
                backgroundColor="$primary"
              />
              <View
                style={styles.button}
                backgroundColor="$backgroundPress"
              />
            </XStack>
          </YStack>
        </Theme>
        
        {isSelected && (
          <View style={styles.checkContainer}>
            <XStack
              backgroundColor={colors.status.success}
              borderRadius={999}
              alignItems="center"
              justifyContent="center"
              width={24}
              height={24}
            >
              <Check color="white" size={16} />
            </XStack>
          </View>
        )}
      </YStack>
    </Pressable>
  );
}
  ```

  *Exports: `ThemePreviewProps`*
  ```tsx
export interface ThemePreviewProps {
  /** The theme name to display */
  themeName: string;
  /** Whether this theme is currently selected */
  isSelected: boolean;
  /** Called when this theme is selected */
  onSelect: () => void;
  /** Whether to force dark mode for this preview */
  forceDark?: boolean;
  /** Whether to force light mode for this preview */
  forceLight?: boolean;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}
  ```

- **components/ui/Container.tsx**

  *Exports: `Container`*
  ```tsx
const Container: React.FC<ContainerProps> = ({ style, children, ...props }) => {
  const theme = useTheme();
  return (
    <StyledSafeArea
      style={[
        { backgroundColor: theme.background.val },
        style as any
      ]}
      {...props}
    >
      <YStack flex={1}>{children}</YStack>
    </StyledSafeArea>
  );
};
  ```

  *Exports: `default`*
  ```tsx
export default Container;
  ```

- **components/ui/EmptyOrSkeleton.tsx**

  *Exports: `EmptyOrSkeleton`*
  ```tsx
const EmptyOrSkeleton = ({
  isLoading = false,
  count = 3,
  type = 'row',
  isEmpty = false,
  text = 'No items found',
  actionText = 'Add New',
  onAction,
  isError = false,
  onRetry,
  children
}: EmptyOrSkeletonProps) => {
  // Generate skeleton based on type
  const renderSkeletons = () => {
    const skeletons = [];
    for (let i = 0; i < count; i++) {
      if (type === 'card') {
        skeletons.push(<SkeletonCard key={i} />);
      } else if (type === 'circle') {
        skeletons.push(<SkeletonCircle key={i} />);
      } else {
        skeletons.push(<SkeletonRow key={i} />);
      }
    }
    return skeletons;
  };

  // Show skeleton if loading
  if (isLoading) {
    return (
      <YStack space="$3">
        {renderSkeletons()}
      </YStack>
    );
  }
  
  // Show error state if there's an error
  if (isError) {
    return (
      <SectionError 
        message={text} 
        onRetry={onRetry} 
      />
    );
  }
  
  // Show empty state if empty
  if (isEmpty) {
    return (
      <YStack
        padding="$4"
        alignItems="center"
        justifyContent="center"
        space="$3"
      >
        <Text textAlign="center" color="$gray11">
          {text}
        </Text>
        {onAction && (
          <Button size="$3" onPress={onAction}>
            {actionText}
          </Button>
        )}
      </YStack>
    );
  }
  
  // Default: return children
  return <>{children}</>;
};
  ```

  *Exports: `EmptyOrSkeletonProps`*
  ```tsx
export interface EmptyOrSkeletonProps {
  // Loading state
  isLoading?: boolean;
  count?: number;
  type?: 'card' | 'row' | 'circle';
  
  // Empty state
  isEmpty?: boolean;
  text?: string;
  actionText?: string;
  onAction?: () => void;
  
  // Error state
  isError?: boolean;
  onRetry?: () => void;
  
  // Children to render when not in any special state
  children?: React.ReactNode;
}
  ```

- **components/ui/ErrorBanner.tsx**

  *Exports: `ErrorBanner`*
  ```tsx
export function ErrorBanner({ title, message, onRetry }: ErrorBannerProps) {
  const theme = useTheme();

  const red3 = theme?.red3?.val ?? '#fee2e2';
  const red5 = theme?.red5?.val ?? '#f87171';
  const red6 = theme?.red6?.val ?? '#ef4444';
  const red7 = theme?.red7?.val ?? '#dc2626';
  const red10 = theme?.red10?.val ?? '#991b1b';
  const red11 = theme?.red11?.val ?? '#7f1d1d';

  return (
    <YStack 
      backgroundColor={red3} 
      borderColor={red7} 
      borderWidth={1} 
      borderRadius="$3"
      padding="$3"
      space="$2"
      alignItems="center"
    >
      <XStack width="100%" justifyContent="space-between" alignItems="center">
        <H4 color={red11}>{title || 'Error'}</H4> 
        {/* Optional: Add an icon */} 
        {/* <Ionicons name="alert-circle-outline" size={20} color={red10} /> */} 
      </XStack>
      <Text color={red11}>{message}</Text> 
      {onRetry && (
        <Button 
          // theme="red" 
          icon={<Ionicons name="refresh" size={16} color={red11} />} 
          onPress={onRetry}
          size="$2"
          backgroundColor={red5} 
          borderColor={red7} 
          borderWidth={1}
          pressStyle={{ backgroundColor: red6 }}
        >
          <Text color={red11}>Retry</Text>
        </Button>
      )}
    </YStack>
  );
}
  ```

  *Exports: `SectionError`*
  ```tsx
export function SectionError({ message, onRetry }: SectionErrorProps) {
  const theme = useTheme();

  const red3 = theme?.red3?.val ?? '#fee2e2';
  const red5 = theme?.red5?.val ?? '#f87171';
  const red6 = theme?.red6?.val ?? '#ef4444';
  const red7 = theme?.red7?.val ?? '#dc2626';
  const red10 = theme?.red10?.val ?? '#991b1b';
  const red11 = theme?.red11?.val ?? '#7f1d1d';

  return (
    <YStack 
      padding="$3" 
      borderRadius="$3" 
      borderWidth={1} 
      borderColor={red7} 
      backgroundColor={red3} 
      alignItems="center" 
      space="$2"
    >
      <Ionicons name="warning-outline" size={24} color={red10} /> 
      <Text color={red11} textAlign="center"> 
        {message || 'Failed to load this section.'}
      </Text>
      {onRetry && (
        <Button 
          size="$2" 
          // theme="red"
          backgroundColor={red5} 
          icon={<Ionicons name="refresh" size={16} color={red11} />} 
          onPress={onRetry}
          pressStyle={{ backgroundColor: red6 }}
          borderColor={red7} 
          borderWidth={1} 
        >
          <Text color={red11}>Retry</Text>
        </Button>
      )}
    </YStack>
  );
}
  ```

- **components/ui/InteractiveCard.tsx**

  *Exports: `default`*
  ```tsx
export default InteractiveCard;
  ```

- **components/ui/Section.tsx**

  *Exports: `default`*
  ```tsx
export default Section;
  ```

- **components/ui/Skeleton.tsx**

  *Exports: `Skeleton`*
  ```tsx
export function Skeleton({ width = '100%', height = 20, borderRadius = 4 }: SkeletonProps) {
  const colorScheme = useColorScheme();
  
  return (
    <SkeletonBase
      colorMode={colorScheme === 'dark' ? 'dark' : 'light'}
      width={width}
      height={height}
      borderRadius={borderRadius}
    />
  );
}
  ```

  *Exports: `SkeletonAvatar`*
  ```tsx
export function SkeletonAvatar({ size = 40 }: SkeletonAvatarProps) {
  return <Skeleton width={size} height={size} borderRadius={size / 2} />;
}
  ```

  *Exports: `SkeletonCard`*
  ```tsx
export function SkeletonCard({ height = 100, width = '100%' }: SkeletonCardProps) {
  return (
    <YStack space="$2">
      <Skeleton height={height} width={width} borderRadius={8} />
    </YStack>
  );
}
  ```

  *Exports: `SkeletonCircle`*
  ```tsx
export function SkeletonCircle({ size = 60 }: SkeletonCircleProps) {
  return <Skeleton width={size} height={size} borderRadius={size / 2} />;
}
  ```

  *Exports: `SkeletonProfile`*
  ```tsx
export function SkeletonProfile({ avatarSize = 40 }: SkeletonProfileProps) {
  return (
    <XStack space="$3" alignItems="center">
      <SkeletonAvatar size={avatarSize} />
      <YStack space="$1" flex={1}>
        <Skeleton width="60%" height={16} />
        <Skeleton width="40%" height={12} />
      </YStack>
    </XStack>
  );
}
  ```

  *Exports: `SkeletonRow`*
  ```tsx
export function SkeletonRow({ height = 20, width = '100%', lines = 3, spacing = 10 }: SkeletonRowProps) {
  return (
    <YStack space={spacing}>
      {Array.from({ length: lines }).map((_, i) => (
        <Skeleton 
          key={i}
          height={height}
          width={i === lines - 1 && typeof width === 'string' ? '70%' : width}
        />
      ))}
    </YStack>
  );
}
  ```

- **components/ui/SwipeableRow.tsx**

  *Exports: `default`*
  ```tsx
export default function SwipeableRow({ children, onDelete, onComplete }: SwipeableRowProps) {
  const theme = useTheme();

  const renderRightActions = () => {
    if (!onDelete) return null;
    return (
      <XStack flex={1} justifyContent="flex-end">
        <Button
          // size="$3" // Match ListItem size?
          backgroundColor="$destructive"
          borderTopRightRadius="$0" // Flatten edges
          borderBottomRightRadius="$0"
          icon={<Trash color={theme.color?.get()} />} // Use theme color for icon
          onPress={() => {
            Haptics.selectionAsync();
            onDelete();
            // Consider closing the Swipeable here if needed
          }}
          width={80} // Fixed width for the action button
          height="100%" // Fill height
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  const renderLeftActions = () => {
    if (!onComplete) return null;
    return (
      <XStack flex={1} justifyContent="flex-start">
        <Button
          // size="$3"
          backgroundColor="$success"
          borderTopLeftRadius="$0"
          borderBottomLeftRadius="$0"
          icon={<Check color={theme.color?.get()} />}
          onPress={() => {
            Haptics.selectionAsync();
            onComplete();
            // Consider closing the Swipeable here if needed
          }}
          width={80}
          height="100%"
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  return (
    <Swipeable
      renderRightActions={renderRightActions}
      renderLeftActions={renderLeftActions}
      overshootFriction={8} // Standard friction
      containerStyle={{ backgroundColor: '$background' }} // Ensure background matches item
    >
      {children}
    </Swipeable>
  );
}
  ```

- **components/ui/primitives/AetherCard.tsx**

  *Exports: `AetherCard`*
  ```tsx
export function AetherCard({ children, variant, isInteractive, ...props }: AetherCardProps) {
  return (
    <StyledCard variant={variant} isInteractive={isInteractive} {...props}>
      {children}
    </StyledCard>
  );
}
  ```

- **components/ui/primitives/AetherListItem.tsx**

  *Exports: `AetherListItem`*
  ```tsx
export function AetherListItem({
  title,
  subtitle,
  leftIcon,
  rightIcon,
  showChevron = false,
  badge,
  isLast,
  interactive,
  ...props
}: AetherListItemProps) {
  return (
    <ListItemContainer isLast={isLast} interactive={interactive} {...props}>
      {/* Left section with icon and text */}
      <XStack space="$3" flex={1} alignItems="center">
        {leftIcon && (
          <Stack marginRight="$2">{leftIcon}</Stack>
        )}
        
        <YStack>
          <Text fontWeight="500" fontSize="$4">{title}</Text>
          {subtitle && (
            <Text fontSize="$2" color="$gray10">{subtitle}</Text>
          )}
        </YStack>
      </XStack>
      
      {/* Right section with badge, custom icon or chevron */}
      <XStack space="$2" alignItems="center">
        {badge && (
          <XStack 
            backgroundColor="$primary"
            paddingHorizontal="$2"
            paddingVertical="$1"
            borderRadius="$2"
          >
            <Text color="white" fontSize="$1" fontWeight="bold">{badge}</Text>
          </XStack>
        )}
        
        {rightIcon && rightIcon}
        
        {showChevron && (
          <Ionicons name="chevron-forward" size={16} color="$gray10" />
        )}
      </XStack>
    </ListItemContainer>
  );
}
  ```

  *Exports: `AetherListItemProps`*
  ```tsx
export interface AetherListItemProps extends ListItemContainerProps {
  title: string;
  subtitle?: string;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  showChevron?: boolean;
  badge?: string | number;
}
  ```

- **components/ui/primitives/SectionHeader.tsx**

  *Exports: `SectionHeader`*
  ```tsx
export function SectionHeader({ 
  title, 
  actionLabel, 
  onAction, 
  ...props 
}: SectionHeaderProps) {
  return (
    <SectionContainer {...props}>
      <Text 
        fontSize="$5" 
        fontWeight="600" 
        color="$color"
      >
        {title}
      </Text>
      
      {actionLabel && onAction && (
        <Button
          onPress={onAction}
          fontSize="$2"
          backgroundColor="transparent"
          color="$primary"
          paddingHorizontal="$2"
          height="$5"
        >
          {actionLabel}
        </Button>
      )}
    </SectionContainer>
  );
}
  ```

  *Exports: `SectionHeaderProps`*
  ```tsx
export interface SectionHeaderProps extends SectionContainerProps {
  title: string;
  actionLabel?: string;
  onAction?: () => void;
}
  ```

- **components/ui/primitives/index.ts**

  *Exports: `AetherCard`*
  ```ts
export { AetherCard } from './AetherCard';
  ```

  *Exports: `AetherListItem`*
  ```ts
export { AetherListItem, type AetherListItemProps } from './AetherListItem';
  ```

  *Exports: `AetherListItemProps`*
  ```ts
export { AetherListItem, type AetherListItemProps } from './AetherListItem';
  ```

  *Exports: `SectionHeader`*
  ```ts
export { SectionHeader, type SectionHeaderProps } from './SectionHeader';
  ```

  *Exports: `SectionHeaderProps`*
  ```ts
export { SectionHeader, type SectionHeaderProps } from './SectionHeader';
  ```

### constants

- **constants/Colors.ts**

  *Exports: `Colors`*
  ```ts
const Colors = {
  light: {
    text: '#11181C',
    background: '#fff',
    tint: tintColorLight,
    icon: '#687076',
    tabIconDefault: '#687076',
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: '#ECEDEE',
    background: '#151718',
    tint: tintColorDark,
    icon: '#9BA1A6',
    tabIconDefault: '#9BA1A6',
    tabIconSelected: tintColorDark,
  },
};
  ```

- **constants/motion.ts**

  *Exports: `componentAnimations`*
  ```ts
const componentAnimations = {
  toast: {
    show: {
      duration: durations.modal,
      easing: easings.enter,
    },
    hide: {
      duration: durations.standard,
      easing: easings.exit,
    },
  },
  modal: {
    overlay: {
      show: {
        duration: durations.modal,
        easing: easings.standard,
      },
      hide: {
        duration: durations.modal,
        easing: easings.standard,
      },
    },
    content: {
      show: {
        duration: durations.modal,
        easing: easings.enter,
      },
      hide: {
        duration: durations.standard,
        easing: easings.exit,
      },
    },
  },
  button: {
    press: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
    release: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
  },
  navigation: {
    screen: {
      duration: durations.screen,
      easing: easings.standard,
    },
    tab: {
      duration: durations.standard,
      easing: easings.standard,
    },
  },
};
  ```

  *Exports: `durations`*
  ```ts
const durations = {
  /** Ultra-fast for micro-interactions */
  micro: 80,
  /** Tap/press feedback */
  tap: 120,
  /** Default animation speed for most UI transitions */
  standard: 200,
  /** For more noticeable animations */
  medium: 250,
  /** Modal entrances/exits, complex transitions */
  modal: 300,
  /** Full screen transitions */
  screen: 350,
  /** Extended animations for emphasis */
  long: 450,
};
  ```

  *Exports: `easings`*
  ```ts
const easings = {
  /** Quick acceleration, gradual deceleration - for elements entering the screen */
  enter: Easing.bezier(0.25, 0.1, 0.25, 1.0),
  /** Gradual acceleration, quick deceleration - for elements exiting the screen */
  exit: Easing.bezier(0.25, 0.0, 0.2, 1.0),
  /** For transitions between UI states */
  standard: Easing.bezier(0.4, 0.0, 0.2, 1.0),
  /** Quick in, quick out - for emphasis */
  energetic: Easing.bezier(0.55, 0.0, 0.1, 1.0),
  /** Linear - consistent motion with no acceleration/deceleration */
  linear: Easing.linear,
  /** Slow start, fast finish */
  accelerate: Easing.in(Easing.quad),
  /** Fast start, slow finish */
  decelerate: Easing.out(Easing.quad),
  /** Fast start and end, slower in the middle */
  emphasize: Easing.inOut(Easing.quad),
};
  ```

  *Exports: `presets`*
  ```ts
const presets = {
  fadeIn: {
    duration: durations.standard,
    easing: easings.enter,
  },
  fadeOut: {
    duration: durations.standard,
    easing: easings.exit,
  },
  slideIn: {
    duration: durations.modal,
    easing: easings.enter,
  },
  slideOut: {
    duration: durations.modal,
    easing: easings.exit,
  },
  scaleIn: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  scaleOut: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  tapFeedback: {
    duration: durations.tap,
    easing: easings.emphasize,
  },
  skeleton: {
    duration: durations.long * 2,
    easing: easings.linear,
  },
};
  ```

### debug

- **debug/toast-test.tsx**

  *Exports: `default`*
  ```tsx
export default function ToastTestScreen() {
  const { showToast } = useToast();

  const testSuccessToast = () => {
    showToast({
      type: 'success',
      title: 'Success',
      message: 'This is a success toast message',
      duration: 3000,
    });
  };

  const testErrorToast = () => {
    showToast({
      type: 'error',
      title: 'Error',
      message: 'This is an error toast message',
      duration: 3000,
    });
  };

  const testInfoToast = () => {
    showToast({
      type: 'info',
      message: 'This is an info toast without a title',
      duration: 3000,
    });
  };

  return (
    <View style={{ flex: 1 }}>
      <StatusBar style="auto" />
      <YStack
        flex={1}
        padding={20}
        space={16}
        justifyContent="center"
        alignItems="center"
      >
        <Text fontSize={24} fontWeight="bold" marginBottom={20}>
          Toast Test Screen
        </Text>
        
        <Button 
          onPress={testSuccessToast} 
          backgroundColor="$green6" 
          size="$4"
        >
          Show Success Toast
        </Button>
        
        <Button 
          onPress={testErrorToast} 
          backgroundColor="$red6" 
          size="$4"
        >
          Show Error Toast
        </Button>
        
        <Button 
          onPress={testInfoToast} 
          backgroundColor="$blue6" 
          size="$4"
        >
          Show Info Toast
        </Button>
      </YStack>
    </View>
  );
}
  ```

### design-system

- **design-system/Animations.ts**

  *Exports: `fadeInUp`*
  ```ts
const fadeInUp = {
  from: { opacity: 0, translateY: 16 },
  animate: { opacity: 1, translateY: 0 },
  exit: { opacity: 0, translateY: 16 },
  transition: { type: 'timing', duration: 350 },
};
  ```

  *Exports: `korokReveal`*
  ```ts
const korokReveal = {
  from: { opacity: 0, scale: 0.7, rotate: '-10deg' },
  animate: { opacity: 1, scale: 1, rotate: '0deg' },
  transition: { type: 'spring', dampingRatio: 0.6 },
};
  ```

  *Exports: `sheikahGlow`*
  ```ts
const sheikahGlow = {
  from: { opacity: 0.4, scale: 0.95 },
  animate: { opacity: 1, scale: 1 },
  exit: { opacity: 0.4, scale: 0.95 },
  transition: { type: 'timing', duration: 800, loop: true },
};
  ```

  *Exports: `slideOutLeft`*
  ```ts
const slideOutLeft = {
  from: { translateX: 0 },
  animate: { translateX: -100 },
  exit: { translateX: -100 },
  transition: { type: 'spring', dampingRatio: 0.7 },
};
  ```

  *Exports: `taskComplete`*
  ```ts
const taskComplete = {
  from: { opacity: 1, translateX: 0 },
  animate: { opacity: 0.6, translateX: -5 },
  transition: { type: 'spring', dampingRatio: 0.8 },
};
  ```

- **design-system/Primitives.tsx**

  *Exports: `Button`*
  ```tsx
const Button = styled(gs.Button);
  ```

  *Exports: `Center`*
  ```tsx
const Center = styled(gs.Center);
  ```

  *Exports: `gs`*
  ```tsx
export { gs };
  ```

  *Exports: `HStack`*
  ```tsx
const HStack = styled(gs.HStack);
  ```

  *Exports: `Pressable`*
  ```tsx
const Pressable = styled(gs.Pressable);
  ```

  *Exports: `ScrollView`*
  ```tsx
const ScrollView = styled(gs.ScrollView);
  ```

  *Exports: `Stack`*
  ```tsx
const Stack = styled(gs.View);
  ```

  *Exports: `Text`*
  ```tsx
const Text = styled(gs.Text);
  ```

  *Exports: `useColorMode`*
  ```tsx
const useColorMode = gs.useColorMode;
  ```

  *Exports: `useColorModeValue`*
  ```tsx
export function useColorModeValue<T>(light: T, dark: T) {
  const { colorMode } = useColorMode();
  return colorMode === 'dark' ? dark : light;
}
  ```

  *Exports: `useToast`*
  ```tsx
const useToast = gs.useToast;
  ```

  *Exports: `VStack`*
  ```tsx
const VStack = styled(gs.VStack);
  ```

- **design-system/theme.glue.ts**

  *Exports: `glueTheme`*
  ```ts
const glueTheme = {
  ...base,
  tokens: {
    ...base.tokens,
    ...tokens,          // merge Zelda palette
  },
} as const;
  ```

- **design-system/tokens.ts**

  *Exports: `colors`*
  ```ts
const colors = {
  // Zelda theme colors from memories
  'parchment': '#FDFFE0',
  'sheikahCyan': '#86A5A9',
  'korokGreen': '#92C582',
  'darkText': '#536F50',
  'guardianOrange': '#FF9F0A',
  'darkTealBg': '#1A2E3A',
  'cyanGlow': '#64FFDA',
  
  // Semantic aliases
  'surface': '#FDFFE0', // parchment in light mode
  'onSurface': '#536F50', // darkText in light mode
  'outline': '#86A5A9', // sheikahCyan in both modes
  
  // Shadow colors with opacities
  'shadowSm': 'rgba(83, 111, 80, 0.10)', // Light theme
  'shadowMd': 'rgba(83, 111, 80, 0.15)',
  'shadowLg': 'rgba(83, 111, 80, 0.20)',
  'shadowDarkSm': 'rgba(0, 0, 0, 0.20)', // Dark theme
  'shadowDarkMd': 'rgba(0, 0, 0, 0.30)',
  'shadowDarkLg': 'rgba(0, 0, 0, 0.40)',
};
  ```

  *Exports: `default`*
  ```ts
export default {
  colors,
  radii,
  space,
  sizes,
  fonts,
};
  ```

  *Exports: `fonts`*
  ```ts
const fonts = {
  'heading': 'HyliaSerif',
  'body': 'CalamitySans',
  'mono': 'SpaceMono',
};
  ```

  *Exports: `radii`*
  ```ts
const radii = {
  'sm': 4,
  'md': 8,
  'lg': 16,
  'xl': 24,
  'full': 9999,
};
  ```

  *Exports: `sizes`*
  ```ts
const sizes = {
  ...space,
};
  ```

  *Exports: `space`*
  ```ts
const space = {
  '0': 0,
  '0.5': 2,
  '1': 4,
  '2': 8,
  '3': 12,
  '4': 16,
  '5': 20,
  '6': 24,
  '8': 32,
  '10': 40,
  '12': 48,
  '16': 64,
};
  ```

### hooks

- **hooks/useColorScheme.ts**

  *Exports: `useColorScheme`*
  ```ts
export { useColorScheme } from 'react-native';
  ```

- **hooks/useColorScheme.web.ts**

  *Exports: `useColorScheme`*
  ```ts
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}
  ```

- **hooks/useOfflineSync.ts**

  *Exports: `useOfflineSync`*
  ```ts
export function useOfflineSync<T extends { id: string }>(entityType: string) {
  const [isOnline, setIsOnline] = useState(true);
  const [pendingItems, setPendingItems] = useState<PendingItem[]>([]);
  const [isSyncing, setIsSyncing] = useState(false);

  // Load pending items on mount
  useEffect(() => {
    loadPendingItems();
    
    // Set up network status listener
    const unsubscribe = NetInfo.addEventListener(state => {
      const online = state.isConnected !== false && state.isInternetReachable !== false;
      setIsOnline(online);
      
      // If going from offline to online, try to sync
      if (online) {
        syncItems();
      }
    });
    
    // Also set up background sync (network status changes outside this component)
    const unsubscribeBackground = setupBackgroundSync();
    
    return () => {
      unsubscribe();
      unsubscribeBackground();
    };
  }, [entityType]);

  // Load pending items from storage
  const loadPendingItems = useCallback(async () => {
    const items = await getPendingItems(entityType);
    setPendingItems(items);
  }, [entityType]);

  // Create an item (works offline)
  const createItem = useCallback(async (data: Omit<T, 'id'>): Promise<{ id: string, isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, create directly
        // In a real app, you'd use your API client (like supabase) here
        // const { data: newItem, error } = await supabase.from(entityType).insert(data).select();
        // if (error) throw error;
        // return { id: newItem.id, isOffline: false };
        
        // For demo purposes, simulate success
        return { id: `server-${Date.now()}`, isOffline: false };
      } else {
        // If offline, save to be synced later
        const tempId = await saveOfflineMutation('create', entityType, data);
        await loadPendingItems(); // Reload pending items
        return { id: tempId, isOffline: true };
      }
    } catch (error) {
      console.error('Error creating item:', error);
      // If API call fails, save offline
      const tempId = await saveOfflineMutation('create', entityType, data);
      await loadPendingItems(); // Reload pending items
      return { id: tempId, isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Update an item (works offline)
  const updateItem = useCallback(async (item: T): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, update directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).update(item).eq('id', item.id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('update', entityType, item);
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error updating item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('update', entityType, item);
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Delete an item (works offline)
  const deleteItem = useCallback(async (id: string): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, delete directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).delete().eq('id', id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('delete', entityType, { id });
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error deleting item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('delete', entityType, { id });
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Manually trigger sync
  const syncItems = useCallback(async (): Promise<boolean> => {
    if (isSyncing) return false;
    
    setIsSyncing(true);
    try {
      const success = await syncOfflineMutations();
      if (success) {
        await loadPendingItems(); // Reload pending items after successful sync
      }
      return success;
    } catch (error) {
      console.error('Error syncing items:', error);
      return false;
    } finally {
      setIsSyncing(false);
    }
  }, [isSyncing, loadPendingItems]);

  // Check if an item is pending sync
  const isItemPending = useCallback((id: string): boolean => {
    return pendingItems.some(item => item.id === id);
  }, [pendingItems]);

  return {
    isOnline,
    isSyncing,
    pendingItems,
    createItem,
    updateItem,
    deleteItem,
    syncItems,
    isItemPending,
  };
}
  ```

- **hooks/useSkeleton.ts**

  *Exports: `SkeletonOptions`*
  ```ts
export interface SkeletonOptions {
  /**
   * Width of the gradient shimmer (as % of the component width)
   * @default 0.7
   */
  shimmerWidth?: number;
  /**
   * Base color of the skeleton component
   * @default '#E1E9EE'
   */
  baseColor?: string;
  /**
   * Highlight color for the shimmer effect
   * @default '#F2F8FC'
   */
  highlightColor?: string;
  /**
   * Duration for a complete shimmer cycle in ms
   * @default 2000
   */
  duration?: number;
  /**
   * Delay before starting animation in ms
   * @default 0
   */
  delay?: number;
  /**
   * Whether animation should start automatically
   * @default true
   */
  autoStart?: boolean;
  /**
   * Loading state to determine if skeletons should be shown
   * @default false
   */
  isLoading?: boolean;
  /**
   * Number of skeleton items to generate
   * @default 1
   */
  count?: number;
  /**
   * Type of skeleton to generate
   * @default 'card'
   */
  type?: 'card' | 'row' | 'circle';
}
  ```

  *Exports: `useSkeleton`*
  ```ts
export function useSkeleton(options: SkeletonOptions = {}) {
  const {
    shimmerWidth = 0.7,
    baseColor = '#E1E9EE',
    highlightColor = '#F2F8FC',
    duration = durations.long * 2,
    delay = 0,
    autoStart = true,
  } = options;
  
  // Animation value to track shimmer position
  const translateX = useSharedValue(-1);
  
  // Start the animation
  useEffect(() => {
    if (autoStart) {
      translateX.value = withDelay(
        delay,
        withRepeat(
          withSequence(
            withTiming(-1, { duration: 0 }),
            withTiming(1, { 
              duration, 
              easing: easings.linear 
            }),
          ),
          -1, // Infinite repeat
        ),
      );
    }
  }, [translateX, duration, delay, autoStart]);
  
  // Generate the animated styles for the shimmer effect
  const shimmerStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateX: translateX.value * (1 + shimmerWidth) }],
    };
  });
  
  // Create styles for both container and shimmer
  const styles = StyleSheet.create({
    container: {
      backgroundColor: baseColor,
      overflow: 'hidden',
    },
    shimmer: {
      width: `${shimmerWidth * 100}%`,
      height: '100%',
      backgroundColor: highlightColor,
      position: 'absolute',
      top: 0,
      bottom: 0,
      opacity: 0.7,
    },
  });
  
  // Utility function to manually start the animation
  const startAnimation = () => {
    translateX.value = withDelay(
      delay,
      withRepeat(
        withSequence(
          withTiming(-1, { duration: 0 }),
          withTiming(1, { 
            duration, 
            easing: easings.linear 
          }),
        ),
        -1, // Infinite repeat
      ),
    );
  };
  
  // Utility function to stop the animation
  const stopAnimation = () => {
    translateX.value = withTiming(-1, { duration: 200 });
  };
  
  // Generate array of skeletons based on count and type
  const generateSkeletons = () => {
    if (!options.isLoading) return [];
    
    const count = options.count || 1;
    const type = options.type || 'card';
    
    return Array.from({ length: count }).map((_, index) => ({
      key: `skeleton-${index}`,
      type,
    }));
  };
  
  return {
    baseColor,
    shimmerStyle,
    styles,
    startAnimation,
    stopAnimation,
    skeletons: generateSkeletons(),
  };
}
  ```

- **hooks/useThemeColor.ts**

  *Exports: `useThemeColor`*
  ```ts
export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}
  ```

### modals

- **modals/compose.tsx**

  *Exports: `default`*
  ```tsx
export default function ComposeModal() {
  const router = useRouter();

  // Reanimated shared value for tracking vertical translation
  const translateY = useSharedValue(0);
  const context = useSharedValue({ y: 0 });

  // Gesture handler for swipe down
  const gesture = Gesture.Pan()
    .onStart(() => {
      context.value = { y: translateY.value };
    })
    .onUpdate((event) => {
      translateY.value = Math.max(0, context.value.y + event.translationY); // Only allow downward swipe
    })
    .onEnd(() => {
      if (translateY.value > DISMISS_THRESHOLD) {
        // Animate out and navigate back
        translateY.value = withTiming(SCREEN_HEIGHT, { duration: 200 }, () => {
          runOnJS(router.back)();
        });
      } else {
        // Snap back to original position
        translateY.value = withTiming(0, { duration: 150 });
      }
    });

  // Animated style for the view
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateY: translateY.value }],
    };
  });

  return (
    // Wrap with GestureDetector
    <GestureDetector gesture={gesture}>
      {/* Apply animated style and entrance animation */}
      <Animated.View 
        style={[styles.container, animatedStyle]}
        entering={SlideInDown.duration(300)} 
      >
        {/* Optional: Add a small drag handle indicator */}
        <View style={styles.handleIndicator} />

        {/* Use Stack.Screen to configure the modal title */}
        <Stack.Screen 
          options={{
            title: 'Compose New',
            // Ensure header interaction doesn't conflict with gesture
            // headerLeft: () => <Button title="Close" onPress={() => router.back()} />
          }} 
        />
        <Text style={{ fontSize: 20, marginBottom: 20 }}>Swipe Down to Dismiss</Text>
        <Button onPress={() => router.back()}>Close Modal</Button>
      </Animated.View>
    </GestureDetector>
  );
}
  ```

### providers

- **providers/AppProvider.tsx**

  *Exports: `AppProvider`*
  ```tsx
export function AppProvider({ children }: { children: ReactNode }) {
  // Create Query Client
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 1000, // 5 seconds
        retry: Platform.OS === 'web' ? 3 : 1, // Less retries on mobile to save battery
      },
    },
  }));
  
  // Create tRPC client
  const [trpcClient] = useState(() => 
    trpc.createClient({
      links: [
        httpBatchLink({
          url: 'http://localhost:3000/api/trpc',
          fetch: (input, init) => {
            return fetch(input, {
              ...init,
              credentials: 'include',
            });
          },
        }),
      ],
    })
  );
  
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';
  
  // You could add NATS initialization here
  useEffect(() => {
    // Example: Initialize NATS for real-time updates
    // Note: This is commented out since we don't have a real NATS server to connect to
    /*
    try {
      const url = 'ws://localhost:4222';
      initNatsClient(url, queryClient)
        .then(conn => {
          console.log('NATS client initialized successfully');
          // Set up subscriptions to relevant topics
          subscribeWithCache('users.updates', ['users']);
          subscribeWithCache('messages.updates', ['messages']);
        })
        .catch(err => {
          console.error('Failed to initialize NATS client:', err);
        });
    } catch (error) {
      console.error('Error in NATS setup:', error);
    }
    
    // Cleanup on unmount
    return () => {
      closeNatsConnection().catch(err => {
        console.error('Error closing NATS connection:', err);
      });
    };
    */
  }, [queryClient]);
  
  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <NativeWindProvider theme={currentTheme}>
          <TamaguiProvider config={config}>
            {children}
          </TamaguiProvider>
        </NativeWindProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
}
  ```

- **providers/ConfettiProvider.tsx**

  *Exports: `ConfettiProvider`*
  ```tsx
export function ConfettiProvider({ children }: { children: ReactNode }) {
  const [isVisible, setIsVisible] = useState(false);
  const animationTimeout = useRef<NodeJS.Timeout | null>(null);
  
  // Generate confetti pieces data
  const generateConfettiData = useCallback(() => {
    const pieces = [];
    for (let i = 0; i < CONFETTI_COUNT; i++) {
      pieces.push({
        id: i,
        size: Math.random() * 8 + 4, // Size between 4-12
        color: COLORS[Math.floor(Math.random() * COLORS.length)],
        initialX: Math.random() * SCREEN_WIDTH,
        initialY: -20, // Start just above the screen
        duration: Math.random() * 1000 + 2000, // Duration between 2-3 seconds
        delay: Math.random() * 500, // Random delay up to 500ms
      });
    }
    return pieces;
  }, []);

  const [confettiPieces, setConfettiPieces] = useState(generateConfettiData());

  const showConfetti = useCallback(() => {
    // Trigger haptic feedback
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    
    // Clear any existing timeout
    if (animationTimeout.current) {
      clearTimeout(animationTimeout.current);
    }
    
    // Generate new confetti data and show
    setConfettiPieces(generateConfettiData());
    setIsVisible(true);
    
    // Hide confetti after animation completes
    animationTimeout.current = setTimeout(() => {
      setIsVisible(false);
    }, 3500); // Slightly longer than the max animation time to ensure all pieces are gone
  }, [generateConfettiData]);

  return (
    <ConfettiContext.Provider value={{ showConfetti }}>
      {children}
      {isVisible && (
        <View style={styles.confettiContainer} pointerEvents="none">
          {confettiPieces.map((piece) => (
            <ConfettiPiece
              key={piece.id}
              size={piece.size}
              color={piece.color}
              initialX={piece.initialX}
              initialY={piece.initialY}
              duration={piece.duration}
              delay={piece.delay}
            />
          ))}
        </View>
      )}
    </ConfettiContext.Provider>
  );
}
  ```

  *Exports: `useConfetti`*
  ```tsx
const useConfetti = () => useContext(ConfettiContext);
  ```

- **providers/SupabaseProvider.tsx**

  *Exports: `SupabaseContext`*
  ```tsx
const SupabaseContext = createContext(supabase);
  ```

  *Exports: `SupabaseProvider`*
  ```tsx
export function SupabaseProvider({ children }: PropsWithChildren) {
  return (
    <SupabaseContext.Provider value={supabase}>
      {children}
    </SupabaseContext.Provider>
  );
}
  ```

  *Exports: `useSupabase`*
  ```tsx
const useSupabase = () => React.useContext(SupabaseContext);
  ```

- **providers/TRPCProvider.tsx**

  *Exports: `trpc`*
  ```tsx
const trpc = createTRPCReact<AppRouter>();
  ```

  *Exports: `TRPCProvider`*
  ```tsx
export function TRPCProvider({ children }: PropsWithChildren) {
  const url =
    process.env.EXPO_PUBLIC_API_URL ??
    `${process.env.EXPO_PUBLIC_SUPABASE_URL}/functions/trpc`;

  const client = React.useMemo(
    () =>
      trpc.createClient({
        links: [
          httpBatchLink({
            url,
            headers() {
              return {
                // you can inject the supabase JWT here later:
              };
            },
          }),
        ],
      }),
    [url]
  );

  return (
    <trpc.Provider client={client} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </trpc.Provider>
  );
}
  ```

- **providers/index.ts**
  *(No explicit exports found)*

### scripts

- **scripts/code_atlas.cjs**
  *(No explicit exports found)*

- **scripts/generate-all.js**
  *(No explicit exports found)*

- **scripts/generate-trpc-client.js**
  *(No explicit exports found)*

- **scripts/generate-trpc-types.js**
  *(No explicit exports found)*

- **scripts/generate_app_code_overview.sh**
  *(No explicit exports found)*

- **scripts/reset-project.js**
  *(No explicit exports found)*

### server

- **server/.env**
  *(No explicit exports found)*

- **server/package.json**
  *(No explicit exports found)*

- **server/src/context.ts**

  *Exports: `Context`*
  ```ts
export interface Context {
  supabaseAdmin: typeof supabaseAdmin;
  userId: string;
}
  ```

  *Exports: `createContext`*
  ```ts
export async function createContext({ req }: { req: any }): Promise<Context> {
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: 'Missing Authorization header' });
  }
  const token = authHeader.split(' ')[1];
  if (!token) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: 'Invalid Authorization header' });
  }

  // Validate JWT and get user
  const { data, error } = await supabaseAdmin.auth.getUser(token);
  if (error || !data.user) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: error?.message || 'Invalid token' });
  }

  return {
    supabaseAdmin,
    userId: data.user.id,
  };
}
  ```

  *Exports: `supabaseAdmin`*
  ```ts
const supabaseAdmin = createClient(
  supabaseUrl,
  supabaseServiceKey,
  {
    auth: {
        autoRefreshToken: false,
        persistSession: false
    }
  }
);
  ```

- **server/src/index.ts**
  *(No explicit exports found)*

- **server/src/router.ts**

  *Exports: `appRouter`*
  ```ts
const appRouter = router({
  greeting: {
    hello: publicProcedure
      .input(z.object({ name: z.string().optional() }))
      .query(async ({ input }) => {
        return { greeting: `Hello ${input.name ?? 'world'}` };
      }),
    goodbye: publicProcedure
      .query(() => {
        return { greeting: 'Goodbye!' };
      }),
  },
  user: userRouter,
  dashboard: dashboardRouter,
  value: valueRouter,
  principle: principleRouter,
  goal: goalRouter,
  task: taskRouter,
  habit: habitRouter,
  state: trackedStateRouter,
  rewards: rewardsRouter,
  reminder: reminderRouter,
  goalProgressNote: goalProgressNoteRouter,
});
  ```

  *Exports: `AppRouter`*
  ```ts
export type AppRouter = typeof appRouter;
  ```

  *Exports: `protectedProcedure`*
  ```ts
const protectedProcedure = t.procedure.use(({ ctx, next }) => {
  if (!ctx.userId) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }
  return next({ ctx: { supabaseAdmin: ctx.supabaseAdmin, userId: ctx.userId } });
});
  ```

  *Exports: `publicProcedure`*
  ```ts
const publicProcedure = t.procedure;
  ```

  *Exports: `router`*
  ```ts
const router = t.router;
  ```

- **server/src/routers/dashboardRouter.ts**

  *Exports: `dashboardRouter`*
  ```ts
const dashboardRouter = router({
getDashboardData: protectedProcedure
  .input(
    z.object({
      habitLimit: z.number().min(1).default(5),
      goalLimit: z.number().min(1).default(5),
      taskLimit: z.number().min(1).default(10)
    }).optional()
  )
  .query(async ({ ctx, input }) => {
    try {
      // Get limits from input or use defaults
      const habitLimit = input?.habitLimit || 5;
      const goalLimit = input?.goalLimit || 5;
      const taskLimit = input?.taskLimit || 10;

      // --- Fetch Habits ---
      const { data: habits, error: habitsError } = await ctx.supabaseAdmin
        .from('habits')
        .select(HABIT_FIELDS) // Use constant
        .eq('user_id', ctx.userId)
        .is('archived_at', null) // Filter out archived
        .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
        .limit(habitLimit);
      if (habitsError) throw habitsError;

      // --- Fetch Goals ---
      const { data: goals, error: goalsError } = await ctx.supabaseAdmin
        .from('goals')
        .select(GOAL_FIELDS) // Use constant
        .eq('user_id', ctx.userId)
        .is('archived_at', null) // Filter out archived
        .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
        .limit(goalLimit);
      if (goalsError) throw goalsError;

      // --- Fetch Upcoming Tasks (focus on upcoming tasks and prioritize those due soon) ---
      const today = new Date();
      const twoWeeksFromNow = new Date();
      twoWeeksFromNow.setDate(today.getDate() + 14);
      
      // We want to fetch tasks that are:
      // 1. Not completed
      // 2. Due within the next two weeks, or overdue
      // 3. Either unassigned or associated with the dashboard goals
      const { data: tasks, error: tasksError } = await ctx.supabaseAdmin
        .from('tasks')
        .select(TASK_FIELDS) // Use constant
        .eq('user_id', ctx.userId)
        .is('archived_at', null) // Filter out archived
        .neq('status', 'completed') // Use correct enum value
        .or(`due_date.lte.${twoWeeksFromNow.toISOString()},due_date.is.null`)
        .order('due_date', { ascending: true, nullsFirst: false }) // Use 'due_date'
        .limit(taskLimit);
      if (tasksError) throw tasksError;

      // --- Fetch Active Tracked State Definitions ---
      const { data: trackedStateDefinitions, error: statesError } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .select(TRACKED_STATE_DEF_FIELDS) // Use constant
        .eq('user_id', ctx.userId)
        .eq('active', true)
        .order('sort_order', { ascending: true, nullsFirst: false }); // Correct: nullsFirst: false for nulls last
      if (statesError) throw statesError;
      
      // --- Fetch Latest State Entries for Active Definitions ---
      let latestEntriesMap: Record<string, { value: any; created_at: string }> = {};
      const stateDefIds = (trackedStateDefinitions || []).map(s => s.id);

      if (stateDefIds.length > 0) {
        // Use a CTE and ROW_NUMBER() to get the latest entry per state_id
        const { data: latestEntries, error: entriesError } = await ctx.supabaseAdmin.rpc(
          'get_latest_state_entries_for_user', 
          { p_user_id: ctx.userId, p_state_ids: stateDefIds }
        );

        if (entriesError) {
          console.error('Error fetching latest state entries:', entriesError);
          // Decide how to handle this - throw, or continue with empty/default values?
          // For now, log and continue, states will show default value
        } else {
          // Define expected type for entries from RPC
          type LatestEntry = { state_id: string; value: any; created_at: string };
          
          latestEntriesMap = (latestEntries as LatestEntry[] || []).reduce(
            (acc: Record<string, { value: any; created_at: string }>, entry: LatestEntry) => {
            acc[entry.state_id] = { value: entry.value, created_at: entry.created_at };
            return acc;
          }, {} as typeof latestEntriesMap);
        }
      }

      // --- Process Habits for 'completed' flag ---
      const todayStr = new Date().toISOString().split('T')[0];
      const habitIds = (habits || []).map(h => h.id);
      const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
        .from('habit_entries')
        .select('habit_id') // Only need habit_id to check existence
        .eq('user_id', ctx.userId)
        .eq('date', todayStr) // Filter by date
        .in('habit_id', habitIds);
      if (todayEntriesError) throw todayEntriesError;

      const completedHabitIds = new Set((habitEntriesToday || []).map(e => e.habit_id));

      const formattedHabits = (habits || []).map(h => ({
        id: h.id,
        name: h.name, // Use name
        description: h.description, // Pass other potentially useful fields
        habit_type: h.habit_type,
        streak: h.streak,
        // Consider a habit completed if *any* entry exists for today
        completed: completedHabitIds.has(h.id)
      }));

      // --- Process Goals for 'progress' ---
      const goalIds = (goals || []).map(g => g.id);
      let tasksMap: Record<string, { total: number; completed: number }> = {};
      if (goalIds.length > 0) {
        const { data: allTasksForGoals, error: tasksError2 } = await ctx.supabaseAdmin
          .from('tasks')
          .select('goal_id, status')
          .eq('user_id', ctx.userId)
          .in('goal_id', goalIds);
        if (tasksError2) throw tasksError2;

        tasksMap = (allTasksForGoals || []).reduce<Record<string, { total: number; completed: number }>>((acc, task) => {
          if (task.goal_id) { // Ensure goal_id is not null
            const gid = task.goal_id;
            if (!acc[gid]) acc[gid] = { total: 0, completed: 0 };
            acc[gid].total++;
            if (task.status === 'completed') acc[gid].completed++;
          }
          return acc;
        }, {});
      }

      const formattedGoals = (goals || []).map((g) => {
        const { total = 0, completed: comp = 0 } = tasksMap[g.id] || {};
        // Calculate progress based on tasks, ignore goal.progress field for now
        const progress = total > 0 ? comp / total : 0;
        return {
          id: g.id,
          title: g.name, // Changed name to title to match frontend expectations
          status: g.status, // Pass status directly
          priority: g.priority, // Pass priority
          progress: Math.round(progress * 100) / 100, // Keep calculated progress
          tasks: { // Add tasks information expected by GoalSummaryCard
            total: total,
            completed: comp
          }
        };
      });

      // --- Format Tasks (Minimal formatting needed if TASK_FIELDS is correct) ---
      const formattedTasks = (tasks || []).map((t) => ({
        id: t.id,
        name: t.name,
        status: t.status,
        priority: t.priority,
        due_date: t.due_date, // Use due_date
        // Add other fields as needed by the dashboard UI
      }));

      // --- Format Tracked States with Latest Values ---
      const formattedTrackedStates = (trackedStateDefinitions || []).map((def) => {
        const latestEntry = latestEntriesMap[def.id];
        return {
          id: def.id,
          name: def.name,
          unit: def.unit, // Use 'unit' field
          currentValue: latestEntry ? latestEntry.value : null, // Default to null
          lastUpdated: latestEntry ? latestEntry.created_at : null,
        };
      });

      // Return formatted data including trackedStates
      return {
        habits: formattedHabits,
        goals: formattedGoals,
        tasks: tasks || [], // Ensure tasks is always an array
        trackedStates: formattedTrackedStates, // Use the newly formatted array
      };
    } catch (error: any) {
      console.error('Dashboard data fetch error:', error);
      
      // Handle specific error types with appropriate error codes
      if (error.code === '42P01') { // Table doesn't exist
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Database schema error',
        });
      }
      
      if (error.code === '23505') { // Unique violation
        throw new TRPCError({
          code: 'CONFLICT',
          message: 'Resource already exists',
        });
      }
      
      // Default error handling
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch dashboard data',
      });
    }
  }),

getWeeklyProgress: protectedProcedure
  .input(z.object({
    daysToInclude: z.number().min(1).optional().default(7),
    includeRawData: z.boolean().optional().default(false),
  }).optional())
  .query(async ({ ctx, input }) => {
    try {
      // Calculate date range based on input or default to past week
      const daysToInclude = input?.daysToInclude || 7;
      const includeRawData = input?.includeRawData || false;
      
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(endDate.getDate() - (daysToInclude - 1));
      
      const todayStr = endDate.toISOString().split('T')[0];
      const startDateStr = startDate.toISOString().split('T')[0];
      
      // Generate array of all dates in the range for daily aggregation
      const dateRange: string[] = [];
      const tempDate = new Date(startDate);
      while (tempDate <= endDate) {
        dateRange.push(tempDate.toISOS... /* snippet truncated */
  ```

- **server/src/routers/goalProgressNoteRouter.ts**

  *Exports: `goalProgressNoteRouter`*
  ```ts
const goalProgressNoteRouter = router({
  // Get all notes for a specific goal
  getNotesForGoal: protectedProcedure
    .input(GetGoalProgressNotesInput)
    .query(async ({ ctx, input }) => {
      try {
        // First, ensure the goal exists and belongs to the user
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        // Fetch the notes for that goal
        const { data, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .eq('user_id', ctx.userId) // Redundant check, but good practice
          .eq('goal_id', input.goal_id)
          .order('created_at', { ascending: false }); // Newest first

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal progress notes',
        });
      }
    }),

  createNote: protectedProcedure
    .input(createGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Ensure the goal exists and belongs to the user before adding a note
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        const { data: note, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return note;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal progress note',
        });
      }
    }),

  updateNote: protectedProcedure
    .input(updateGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership of the note
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { data: updatedNote, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return updatedNote;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal progress note',
        });
      }
    }),

  deleteNote: protectedProcedure
    .input(DeleteGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal progress note',
        });
      }
    }),
});
  ```

- **server/src/routers/goalRouter.ts**

  *Exports: `goalRouter`*
  ```ts
const goalRouter = router({
  getGoals: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;

        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals',
        });
      }
    }),

  getGoalById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!goal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found',
          });
        }

        return goal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal',
        });
      }
    }),

  createGoal: protectedProcedure
    .input(createGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return goal;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal',
        });
      }
    }),

  updateGoal: protectedProcedure
    .input(updateGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to update it',
          });
        }

        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal',
        });
      }
    }),

  deleteGoal: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to delete it',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goals')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal',
        });
      }
    }),

  listActive: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals (in listActive stub)',
        });
      }
    }),

  listArchived: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived goals',
        });
      }
    }),

  archiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') { 
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive goal',
        });
      }
    }),

  unarchiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive goal',
        });
      }
    }),
});
  ```

- **server/src/routers/habitRouter.ts**

  *Exports: `habitRouter`*
  ```ts
const habitRouter = router({
getHabits: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      const { data: habits, error: habitsError } = await ctx.supabaseAdmin
        .from('habits')
        .select(HABIT_FIELDS)
        .eq('user_id', ctx.userId)
        .is('archived_at', null)
        .order('sort_order', { ascending: true, nullsFirst: false })
        .order('created_at', { ascending: false });

      if (habitsError) throw habitsError;
      if (!habits) return [];

      const todayStr = new Date().toISOString().split('T')[0];

      const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
        .from('habit_entries')
        .select('habit_id')
        .eq('user_id', ctx.userId)
        .eq('date', todayStr)
        .in('habit_id', habits.map(h => h.id));

      if (todayEntriesError) throw todayEntriesError;

      const completedMap = (habitEntriesToday || []).reduce<Record<string, boolean>>((acc, entry) => {
        acc[entry.habit_id] = true;
        return acc;
      }, {});

      const formattedHabits = habits.map(h => ({
        ...h,
        completedToday: !!completedMap[h.id]
      }));

      return formattedHabits;
    } catch (error: any) {
      throw new TRPCError({ 
        code: 'INTERNAL_SERVER_ERROR', 
        message: error.message || 'Failed to fetch habits'
      });
    }
  }),

getHabitById: protectedProcedure
  .input(z.object({ id: z.string().uuid() }))
  .query(async ({ ctx, input }) => {
    const { data, error } = await ctx.supabaseAdmin
      .from("habits")
      .select(HABIT_FIELDS)
      .eq("id", input.id)
      .eq("user_id", ctx.userId)
      .single();

    if (error) throw new TRPCError({ 
      code: error.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
      message: error.message 
    });
    return data;
  }),

createHabit: protectedProcedure
  .input(createHabitInput)
  .mutation(async ({ ctx, input }) => {
    const { data, error } = await ctx.supabaseAdmin
      .from("habits")
      .insert({
        ...input,
        user_id: ctx.userId,
        streak: 0,
        best_streak: 0
      })
      .select(HABIT_FIELDS)
      .single();

    if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
    return data;
  }),

updateHabit: protectedProcedure
  .input(updateHabitInput)
  .mutation(async ({ ctx, input }) => {
    const { id, ...updateData } = input;

    const { data: habit, error: fetchError } = await ctx.supabaseAdmin
      .from("habits")
      .select("id")
      .eq("id", id)
      .eq("user_id", ctx.userId)
      .single();

    if (fetchError) throw new TRPCError({ 
      code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
      message: "Habit not found or access denied" 
    });

    const { data, error } = await ctx.supabaseAdmin
      .from("habits")
      .update(updateData)
      .eq("id", id)
      .eq('user_id', ctx.userId)
      .select(HABIT_FIELDS)
      .single();

    if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
    return data;
  }),

deleteHabit: protectedProcedure
  .input(z.object({ id: z.string().uuid() }))
  .mutation(async ({ ctx, input }) => {
    const { data: habit, error: fetchError } = await ctx.supabaseAdmin
      .from("habits")
      .select("id")
      .eq("id", input.id)
      .eq("user_id", ctx.userId)
      .single();

    if (fetchError) throw new TRPCError({ 
      code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
      message: "Habit not found or access denied" 
    });

    const { error } = await ctx.supabaseAdmin
      .from("habits")
      .delete()
      .eq("id", input.id);

    if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
    return { id: input.id };
  }),

listArchivedHabits: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      const { data: habits, error } = await ctx.supabaseAdmin
        .from('habits')
        .select(HABIT_FIELDS)
        .eq('user_id', ctx.userId)
        .not('archived_at', 'is', null)
        .order('archived_at', { ascending: false })
        .order('created_at', { ascending: false });

      if (error) throw error;
      return habits || [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch archived habits',
      });
    }
  }),

archiveHabit: protectedProcedure
  .input(z.object({ id: z.string().uuid() }))
  .mutation(async ({ ctx, input }) => {
    try {
      const { data: updatedHabit, error } = await ctx.supabaseAdmin
        .from('habits')
        .update({ archived_at: new Date().toISOString() })
        .eq('id', input.id)
        .eq('user_id', ctx.userId)
        .select(HABIT_FIELDS)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
        }
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      }
      return updatedHabit;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to archive habit' });
    }
  }),

unarchiveHabit: protectedProcedure
  .input(z.object({ id: z.string().uuid() }))
  .mutation(async ({ ctx, input }) => {
    try {
      const { data: updatedHabit, error } = await ctx.supabaseAdmin
        .from('habits')
        .update({ archived_at: null })
        .eq('id', input.id)
        .eq('user_id', ctx.userId)
        .select(HABIT_FIELDS)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
        }
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      }
      return updatedHabit;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to unarchive habit' });
    }
  }),

getHabitEntries: protectedProcedure
  .input(z.object({
    habitId: z.string().uuid(),
    startDate: z.string().optional(), 
    endDate: z.string().optional(),   
  }))
  .query(async ({ ctx, input }) => {
    try {
      const { error: habitError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", input.habitId)
        .eq("user_id", ctx.userId)
        .single();

      if (habitError) {
        if (habitError.code === 'PGRST116') {
           throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
        }
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: habitError.message });
      }

      let query = ctx.supabaseAdmin
        .from('habit_entries')
        .select(HABIT_ENTRY_FIELDS)
        .eq('user_id', ctx.userId)
        .eq('habit_id', input.habitId);

      if (input.startDate) query = query.gte('date', input.startDate);
      if (input.endDate) query = query.lte('date', input.endDate);

      const { data, error: entriesError } = await query.order('date', { ascending: false });

      if (entriesError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: entriesError.message });
      return data || [];
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to fetch habit entries' });
    }
  }),

getHabitEntriesForHabit: protectedProcedure
  .input(z.object({ habitId: z.string().uuid() }))
  .query(async ({ ctx, input }) => {
    // TODO: Implement logic to fetch habit entries for a specific habit
    console.log(`Fetching entries for habit: ${input.habitId}, user: ${ctx.userId}`);
    // Example fetch:
    // const { data, error } = await ctx.supabaseAdmin
    //   .from('habit_entries')
    //   .select(HABIT_ENTRY_FIELDS)
    //   .eq('habit_id', input.habitId)
    //   .eq('user_id', ctx.userId)
    //   .order('date', { ascending: false });
    // if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
    // return data || [];
    throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
  }),

createHabitEntry: protectedProcedure
  .input(createHabitEntryInput)
  .mutation(async ({ ctx, input }) => {
    try {
      const { data, error } = await ctx.supabaseAdmin
        .from('habit_entries')
        .insert({ ...input, user_id: ctx.userId })
        .select(HABIT_ENTRY_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });

      // Update streak after successful insert
      if (data) {
        await calculateAndUpdateStreak(input.habit_id, ctx.userId, ctx.supabaseAdmin);
      }

      return data;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to create habit entry',
      });
    }
  }),

updateHabitEntry: protectedProcedure
  .input(updateHabitEntryInput)
  .mutation(async ({ ctx, input }) => {
    try {
      const { id, ...updateData } = input;

      const { data: habitEntry, error: fetchError } = awa... /* snippet truncated */
  ```

- **server/src/routers/principleRouter.ts**

  *Exports: `principleRouter`*
  ```ts
const principleRouter = router({
  getPrinciples: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: principles, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principles || []; // Return empty array if null
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principles',
        });
      }
    }),

  getPrincipleById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) {
           if (error.code === 'PGRST116') { // Handle not found specifically
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found' });
           }
           throw error; // Rethrow other errors
        }
        // No need for !principle check if .single() is used and error isn't PGRST116

        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principle',
        });
      }
    }),

  createPrinciple: protectedProcedure
    .input(createPrincipleInput) // This Zod schema now expects 'title' and 'body'
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .insert({
            ...input, // Spread validated input, already contains 'title' and 'body'
            user_id: ctx.userId,
          })
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create principle',
        });
      }
    }),

  updatePrinciple: protectedProcedure
    .input(updatePrincipleInput) // This Zod schema now expects 'title' and 'body' (optional)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
           if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to update it' });
           }
           throw fetchError;
        }

        // Update
        const { data: updatedPrinciple, error } = await ctx.supabaseAdmin
          .from('principles')
          .update(updateData) // updateData contains validated 'title'/'body' if provided
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return updatedPrinciple;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update principle',
        });
      }
    }),

  deletePrinciple: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
            if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to delete it' });
           }
           throw fetchError;
        }

        // Delete
        const { error } = await ctx.supabaseAdmin
          .from('principles')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete principle',
        });
      }
    }),
});
  ```

- **server/src/routers/reminderRouter.ts**

  *Exports: `reminderRouter`*
  ```ts
const reminderRouter = router({
  // Get all active reminders for the user (might need refinement later)
  getActiveReminders: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('is_active', true)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch active reminders',
        });
      }
    }),

  // Get reminders linked to a specific entity
  getRemindersForEntity: protectedProcedure
    .input(GetRemindersForEntityInput)
    .query(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('related_entity_type', input.related_entity_type)
          .eq('related_entity_id', input.related_entity_id)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch reminders for entity',
        });
      }
    }),

  createReminder: protectedProcedure
    .input(createReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // TODO: Potentially validate that related_entity_id exists and belongs to user?
        // This requires knowing the related_entity_type and querying the correct table.
        // For now, assume valid input.
        const { data: reminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return reminder;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create reminder',
        });
      }
    }),

  updateReminder: protectedProcedure
    .input(updateReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { data: updatedReminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return updatedReminder;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update reminder',
        });
      }
    }),

  deleteReminder: protectedProcedure
    .input(DeleteReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('reminders')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete reminder',
        });
      }
    }),
});
  ```

- **server/src/routers/rewardsRouter.ts**

  *Exports: `rewardsRouter`*
  ```ts
const rewardsRouter = router({
// Get all rewards for current user
getUserRewards: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      // Select specific fields aligned with our Zod types
      const { data: rewards, error } = await ctx.supabaseAdmin
        .from('user_rewards')
        .select('id, user_id, reward_id, earned_at, rewards(id, name, description, emoji, image_url, required_points, type)')
        .eq('user_id', ctx.userId)
        .order('earned_at', { ascending: false });

      if (error) throw error;
      return rewards || [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch user rewards',
      });
    }
  }),

// Get available rewards that can be earned
getAvailableRewards: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      // Get all rewards with specific fields
      const { data: allRewards, error: rewardsError } = await ctx.supabaseAdmin
        .from('rewards')
        .select('id, name, description, emoji, image_url, required_points, type, can_earn_multiple')
        .order('required_points', { ascending: true });

      if (rewardsError) throw rewardsError;

      // Get already earned rewards
      const { data: earnedRewards, error: earnedError } = await ctx.supabaseAdmin
        .from('user_rewards')
        .select('reward_id')
        .eq('user_id', ctx.userId);

      if (earnedError) throw earnedError;

      // Filter out already earned one-time rewards
      const earnedIds = new Set((earnedRewards || []).map(er => er.reward_id));
      const availableRewards = allRewards?.filter(reward => 
        !earnedIds.has(reward.id) || reward.can_earn_multiple);

      return availableRewards || [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch available rewards',
      });
    }
  }),

// Get user points
getUserPoints: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      const { data: userProfile, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('points, lifetime_points')
        .eq('id', ctx.userId)
        .single();

      if (error) throw error;
      return {
        points: userProfile?.points || 0,
        lifetimePoints: userProfile?.lifetime_points || 0,
      };
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch user points',
      });
    }
  }),

// Earn a reward if eligible
earnReward: protectedProcedure
  .input(claimLootInput)
  .mutation(async ({ ctx, input }) => {
    try {
      // Get the reward details
      const { data: reward, error: rewardError } = await ctx.supabaseAdmin
        .from('rewards')
        .select('*')
        .eq('id', input.rewardId)
        .single();

      if (rewardError || !reward) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Reward not found',
        });
      }

      // Check if user has enough points
      const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
        .from('profiles')
        .select('points')
        .eq('id', ctx.userId)
        .single();

      if (profileError || !userProfile) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch user profile',
        });
      }

      if (userProfile.points < reward.required_points) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: 'Not enough points to earn this reward',
        });
      }

      // If the reward is one-time, check if already earned
      if (!reward.can_earn_multiple) {
        const { data: existingReward, error: existingError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('id')
          .eq('user_id', ctx.userId)
          .eq('reward_id', input.rewardId)
          .single();

        if (existingReward) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'You have already earned this one-time reward',
          });
        }
      }

      // Begin transaction
      // 1. Deduct points from user
      const { error: updateError } = await ctx.supabaseAdmin
        .from('profiles')
        .update({
          points: userProfile.points - reward.required_points,
        })
        .eq('id', ctx.userId);

      if (updateError) throw updateError;

      // 2. Add reward to user's earned rewards
      const { data: userReward, error: insertError } = await ctx.supabaseAdmin
        .from('user_rewards')
        .insert({
          user_id: ctx.userId,
          reward_id: input.rewardId,
          earned_at: new Date().toISOString(),
          points_spent: reward.required_points,
        })
        .select()
        .single();

      if (insertError) {
        // Rollback points if adding reward failed
        await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: userProfile.points,
          })
          .eq('id', ctx.userId);

        throw insertError;
      }

      return {
        success: true,
        reward: userReward,
        remainingPoints: userProfile.points - reward.required_points,
      };
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to earn reward',
      });
    }
  }),

// Award points to user (e.g., for completing habits, tasks)
awardPoints: protectedProcedure
  .input(awardBadgeInput)
  .mutation(async ({ ctx, input }) => {
    try {
      // Get current user points
      const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
        .from('profiles')
        .select('points, lifetime_points')
        .eq('id', ctx.userId)
        .single();

      if (profileError || !userProfile) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch user profile',
        });
      }

      // Get badge details
      const { data: badge, error: badgeError } = await ctx.supabaseAdmin
        .from('rewards')
        .select('*')
        .eq('id', input.badgeId)
        .eq('type', 'badge')
        .single();

      if (badgeError || !badge) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Badge not found',
        });
      }

      // Default points to award
      const pointsToAward = 10;
      const currentPoints = userProfile.points || 0;
      const lifetimePoints = userProfile.lifetime_points || 0;
      const newPoints = currentPoints + pointsToAward;
      const newLifetimePoints = lifetimePoints + pointsToAward;

      // Update user points
      const { error: updateError } = await ctx.supabaseAdmin
        .from('profiles')
        .update({
          points: newPoints,
          lifetime_points: newLifetimePoints,
        })
        .eq('id', ctx.userId);

      if (updateError) throw updateError;

      // Record the point transaction
      const { data: pointTransaction, error: transactionError } = await ctx.supabaseAdmin
        .from('point_transactions')
        .insert({
          user_id: ctx.userId,
          points: pointsToAward,
          reason: `Earned badge: ${badge.name}`,
          source_type: 'badge',
          source_id: input.badgeId,
        })
        .select()
        .single();

      if (transactionError) throw transactionError;

      // Add badge to user's earned rewards
      const { data: userBadge, error: badgeInsertError } = await ctx.supabaseAdmin
        .from('user_rewards')
        .insert({
          user_id: ctx.userId,
          reward_id: input.badgeId,
          reward_type: 'badge',
          earned_at: new Date().toISOString(),
          points_spent: 0, // Badges don't cost points
        })
        .select()
        .single();

      if (badgeInsertError) throw badgeInsertError;

      return {
        success: true,
        previousPoints: currentPoints,
        newPoints,
        pointsAdded: pointsToAward,
        transaction: pointTransaction,
        badge: userBadge,
      };
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to award badge',
      });
    }
  }),

// Get point transaction history
getPointHistory: protectedProcedure
  .input(z.object({
    limit: z.number().optional().default(20),
    cursor: z.string().optional(), // for pagination
  }))
  .query(async ({ ctx, input }) => {
    try {
      let query = ctx.supabaseAdmin
        .from('point_transactions')
        .select('*')
        .eq('user_id', ctx.userId)
        .order('created_at', { ascending: false })
        .limit(input.limit);
        
      // Handle cursor-based pagination
      if (input.cursor) {
        query = query.lt('created_at', input.cursor);
      }
      
      const { data: transactions, error } = await query;

      if (error) throw error;
      
      // Determine if there are more results
      const lastItem = transactions && transactions.length > 0 
        ? transactions[transactions.length - 1] 
        : null;
        
      return {
        items: tran... /* snippet truncated */
  ```

- **server/src/routers/taskRouter.ts**

  *Exports: `taskRouter`*
  ```ts
const taskRouter = router({
getTasks: protectedProcedure // Gets non-archived tasks
  .input(z.object({
    goalId: z.string().uuid().optional(),
    // TODO: Add filters for status, priority, dates etc.?
  }))
  .query(async ({ ctx, input }) => {
    try {
      let query = ctx.supabaseAdmin
        .from('tasks')
        .select(TASK_FIELDS)
        .eq('user_id', ctx.userId)
        .is('archived_at', null); // Filter out archived

      if (input.goalId) {
        query = query.eq('goal_id', input.goalId);
      }

      // TODO: Add complex priority enum sorting? (e.g. high > medium > low)
      const { data: tasks, error } = await query
        .order('sort_order', { ascending: true, nullsFirst: false })
        .order('due_date', { ascending: true, nullsFirst: false }) // Order by due date (nulls last)
        .order('created_at', { ascending: false });

      if (error) throw error;
      // TODO: Parse with Task schema?
      return tasks || [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch tasks',
      });
    }
  }),

getTaskById: protectedProcedure
  .input(z.object({
    id: z.string().uuid(), // Use uuid validation
  }))
  .query(async ({ ctx, input }) => {
    try {
      const { data: task, error } = await ctx.supabaseAdmin
        .from('tasks')
        .select(TASK_FIELDS)
        .eq('id', input.id)
        .eq('user_id', ctx.userId)
        .single();

      if (error) throw error;
      if (!task) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Task not found',
        });
      }

      // TODO: Parse with Task schema?
      return task;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch task',
      });
    }
  }),

createTask: protectedProcedure
  .input(createTaskInput) // Use imported input type
  .mutation(async ({ ctx, input }) => {
    try {
      // Verify goal_id if provided
      if (input.goal_id) {
        const { data: goal, error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId) // Ensure goal belongs to user
          .is('archived_at', null) // Ensure goal is not archived
          .single();

        if (goalError || !goal) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Invalid or archived goal ID',
          });
        }
      }

      // Verify parent_task_id if provided
      if (input.parent_task_id) {
        const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.parent_task_id)
          .eq('user_id', ctx.userId) // Ensure parent belongs to user
          .is('archived_at', null) // Ensure parent is not archived
          .single();

        if (parentError || !parentTask) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Invalid or archived parent task ID',
          });
        }
      }

      const { data: task, error } = await ctx.supabaseAdmin
        .from('tasks')
        .insert({
          ...input, // Spread validated input (includes new fields like parent_task_id, recurrence etc)
          user_id: ctx.userId,
          // Ensure due_date is used if present in input
          due_date: input.due_date ?? null, // Use correct field name
        })
        .select(TASK_FIELDS)
        .single();

      if (error) {
         // Handle specific errors like FK violations?
         console.error("Create task error:", error);
         throw error;
      }
      // TODO: Parse with Task schema?
      return task;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to create task',
      });
    }
  }),

updateTask: protectedProcedure
  .input(updateTaskInput) // Use imported input type
  .mutation(async ({ ctx, input }) => {
    try {
      const { id, ...updateData } = input; // Separate id from update payload

      // Check ownership
      const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
        .from('tasks')
        .select('id, parent_task_id') // Select parent_task_id for cycle check
        .eq('id', id)
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError || !existingTask) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Task not found or you do not have permission to update it',
        });
      }

      // Verify goal_id if being updated
      if (updateData.goal_id) {
        const { data: goal, error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', updateData.goal_id)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .single();

        if (goalError || !goal) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Invalid or archived goal ID',
          });
        }
      }
      // Handle setting goal_id to null
      if (updateData.goal_id === null) {
        updateData.goal_id = null;
      }

      // Verify parent_task_id if being updated
      if (updateData.parent_task_id) {
         // Basic cycle check
         if (updateData.parent_task_id === id) {
           throw new TRPCError({
             code: 'BAD_REQUEST',
             message: 'Task cannot be its own parent',
           });
         }
        const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', updateData.parent_task_id)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .single();

        if (parentError || !parentTask) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Invalid or archived parent task ID',
          });
        }
        // TODO: Add deeper cycle detection if needed (check if new parent is a descendant)
      }
       // Handle setting parent_task_id to null
      if (updateData.parent_task_id === null) {
        updateData.parent_task_id = null;
      }

      // Ensure correct field name for due date if provided
      const payload: Record<string, any> = { ...updateData };
      if ('due_date' in payload) {
        payload.due_date = payload.due_date ?? null;
      }

      const { data: updatedTask, error } = await ctx.supabaseAdmin
        .from('tasks')
        .update(payload) // Pass validated update data
        .eq('id', id)
        .eq('user_id', ctx.userId)
        .select(TASK_FIELDS)
        .single();

      if (error) {
           // Handle specific errors like FK violations?
         console.error("Update task error:", error);
         throw error;
      }
      // TODO: Parse with Task schema?
      return updatedTask;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to update task',
      });
    }
  }),

deleteTask: protectedProcedure
  .input(z.object({
    id: z.string().uuid(), // Use uuid validation
  }))
  .mutation(async ({ ctx, input }) => {
    try {
      // Check ownership
      const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
        .from('tasks')
        .select('id')
        .eq('id', input.id)
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError || !existingTask) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Task not found or you do not have permission to delete it',
        });
      }

      // Delete the task (consider implications for subtasks - maybe archive instead?)
      // For now, direct delete.
      const { error } = await ctx.supabaseAdmin
        .from('tasks')
        .delete()
        .eq('id', input.id)
        .eq('user_id', ctx.userId);

      if (error) throw error;
      return { success: true, id: input.id };
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to delete task',
      });
    }
  }),

// ---- Archive/Unarchive ----
listArchivedTasks: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      const { data: tasks, error } = await ctx.supabaseAdmin
        .from('tasks')
        .select(TASK_FIELDS)
        .eq('user_id', ctx.userId)
        .not('archived_at', 'is', null) // Filter for archived tasks
        .order('archived_at', { ascending: false })
        .order('created_at', { ascending: false });
      if (error) throw error;
      // TODO: Parse with Task schema?
      return tasks || [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch archived tasks',
      });
    }
  }),

archiveTask: protectedProcedure
  .input(z.object({ id: z.string().uuid() }))
  .mutation(async ({ ctx, input }) => {
    // TODO: Consider archivin... /* snippet truncated */
  ```

- **server/src/routers/trackedStateRouter.ts**

  *Exports: `trackedStateRouter`*
  ```ts
const trackedStateRouter = router({
getDefinitions: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      const { data, error } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .select(TRACKED_STATE_DEF_FIELDS)
        .eq('user_id', ctx.userId)
        .eq('active', true)
        .order('priority', { ascending: true, nullsFirst: false }) // Corrected: nullsFirst
        .order('created_at', { ascending: true });

      if (error) throw error;
      return data ?? [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch tracked state definitions',
      });
    }
  }),

getDefinitionById: protectedProcedure
  .input(GetTrackedStateDefByIdInput) // Use correct Zod schema
  .query(async ({ ctx, input }) => {
     try {
      const { data: definition, error } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .select(TRACKED_STATE_DEF_FIELDS)
        .eq('id', input.id) // input.id is now correctly typed
        .eq('user_id', ctx.userId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Tracked state definition not found.' });
        }
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      }
      return definition;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch tracked state definition',
      });
    }
  }),

createDefinition: protectedProcedure
  .input(createTrackedStateDefInput) // Use correct Zod schema
  .mutation(async ({ ctx, input }) => {
     try {
      const { data: definition, error } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .insert({
          ...input, // input is now correctly typed
          user_id: ctx.userId,
        })
        .select(TRACKED_STATE_DEF_FIELDS)
        .single();

      if (error) throw error;
      return definition;
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to create tracked state definition',
      });
    }
  }),

updateDefinition: protectedProcedure
  .input(updateTrackedStateDefInput) // Use correct Zod schema
  .mutation(async ({ ctx, input }) => {
     try {
      const { id, ...updateData } = input; // input is now correctly typed

      const { error: fetchError } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .select('id')
        .eq('id', id)
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError) {
        throw new TRPCError({
          code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
          message: 'Definition not found or access denied.',
        });
      }

      const { data: updatedDefinition, error } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .update(updateData)
        .eq('id', id)
        .eq('user_id', ctx.userId)
        .select(TRACKED_STATE_DEF_FIELDS)
        .single();

      if (error) throw error;
      return updatedDefinition;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to update tracked state definition',
      });
    }
  }),

deleteDefinition: protectedProcedure
  .input(DeleteTrackedStateDefInput) // Use correct Zod schema
  .mutation(async ({ ctx, input }) => {
     try {
      const { error: fetchError } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .select('id')
        .eq('id', input.id) // input.id is now correctly typed
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError) {
        throw new TRPCError({
          code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
          message: 'Definition not found or access denied.',
        });
      }

      const { error } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .delete()
        .eq('id', input.id) // input.id is now correctly typed
        .eq('user_id', ctx.userId);

      if (error) throw error;
      return { success: true, id: input.id }; // input.id is now correctly typed
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to delete tracked state definition',
      });
    }
  }),

// --- State Entry Procedures ---

getEntries: protectedProcedure
  .input(GetStateEntriesInput) // <<<--- ADDED .input() BINDING
  .query(async ({ ctx, input }) => {
    try {
      let query = ctx.supabaseAdmin
        .from('state_entries')
        .select(STATE_ENTRY_FIELDS)
        .eq('user_id', ctx.userId)
        .eq('definition_id', input.tracked_state_def_id); // input is now typed

      if (input.startDate) { // input is now typed
        query = query.gte('entry_timestamp', input.startDate);
      }
      if (input.endDate) { // input is now typed
        query = query.lte('entry_timestamp', input.endDate);
      }

      query = query.order('entry_timestamp', { ascending: false });

      if (input.limit) { // input is now typed
        query = query.limit(input.limit);
      }

      const { data: entries, error } = await query;

      if (error) throw error;
      return entries ?? [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch state entries',
      });
    }
  }),

createEntry: protectedProcedure
  .input(CreateStateEntryInput) // <<<--- ADDED .input() BINDING
  .mutation(async ({ ctx, input }) => {
    try {
      // Check definition ownership (already implemented correctly)
      const { error: defError } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .select('id')
        .eq('id', input.tracked_state_def_id) // input is now typed
        .eq('user_id', ctx.userId)
        .single();

      if (defError) {
        throw new TRPCError({
          code: defError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
          message: 'Tracked state definition not found or invalid.',
        });
      }

      // Insert typed data
      const { data: entry, error } = await ctx.supabaseAdmin
        .from('state_entries')
        .insert({
          user_id: ctx.userId,
          definition_id: input.tracked_state_def_id, // input is now typed
          value_numeric: input.value_numeric,     // input is now typed
          value_text: input.value_text,         // input is now typed
          entry_timestamp: input.entry_timestamp || new Date().toISOString(), // input is now typed
          notes: input.notes,                 // input is now typed
        })
        .select(STATE_ENTRY_FIELDS)
        .single();

      if (error) throw error;
      return entry;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to create state entry',
      });
    }
  }),

updateEntry: protectedProcedure
  .input(updateStateEntryInput) // <<<--- ADDED .input() BINDING
  .mutation(async ({ ctx, input }) => {
    try {
      const { id, ...updateData } = input; // input is now typed

      // Check ownership (already implemented correctly)
      const { error: fetchError } = await ctx.supabaseAdmin
        .from('state_entries')
        .select('id')
        .eq('id', id) // Use id from destructured input
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError) {
        throw new TRPCError({
          code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
          message: 'Entry not found or access denied.',
        });
      }

      // updateData is now correctly typed from the input schema
      const { data: updatedEntry, error } = await ctx.supabaseAdmin
        .from('state_entries')
        .update(updateData)
        .eq('id', id) // Use id from destructured input
        .eq('user_id', ctx.userId)
        .select(STATE_ENTRY_FIELDS)
        .single();

      if (error) throw error;
      return updatedEntry;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to update state entry',
      });
    }
  }),

deleteEntry: protectedProcedure
  .input(DeleteStateEntryInput) // <<<--- ADDED .input() BINDING
  .mutation(async ({ ctx, input }) => {
     try {
      // Check ownership (already implemented correctly)
      const { error: fetchError } = await ctx.supabaseAdmin
        .from('state_entries')
        .select('id')
        .eq('id', input.id) // input is now typed
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError) {
        throw new TRPCError({
          code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
          message: 'Entry not found or access denied.',
        });
      }

      const { error } = await ctx.supabaseAdmin
        .from('state_entries')
        .delete()
       ... /* snippet truncated */
  ```

- **server/src/routers/userRouter.ts**

  *Exports: `userRouter`*
  ```ts
const userRouter = router({
  getProfile: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('id, username, avatar_url, full_name, bio, time_zone, onboarding_completed, created_at, updated_at')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  updateProfile: protectedProcedure
    .input(z.object({
      full_name: z.string().optional(),
      avatar_url: z.string().optional(),
      theme: z.string().optional(),
      time_zone: z.string().optional(),
      display_name: z.string().optional(),
      bio: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update(input)
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getUserSettings: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('id, user_id, notification_preferences, ui_preferences')
        .eq('user_id', ctx.userId)
        .single();
        
      if (error) {
        // If settings don't exist, create default settings
        if (error.code === 'PGRST116') {
          const { data: newSettings, error: createError } = await ctx.supabaseAdmin
            .from('user_settings')
            .insert({
              user_id: ctx.userId,
              notification_preferences: {
                email: true,
                push: true,
                task_reminders: true,
                goal_updates: true,
                habit_reminders: true
              },
              ui_preferences: {
                theme: 'system',
                compact_view: false,
                show_completed_tasks: true
              }
            })
            .select()
            .single();
            
          if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
          return newSettings;
        }
        
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      }
      
      return data;
    }),
    
  updateUserSettings: protectedProcedure
    .input(z.object({
      notification_preferences: z.object({
        email: z.boolean().optional(),
        push: z.boolean().optional(),
        task_reminders: z.boolean().optional(),
        goal_updates: z.boolean().optional(),
        habit_reminders: z.boolean().optional()
      }).optional(),
      ui_preferences: z.object({
        theme: z.string().optional(),
        compact_view: z.boolean().optional(),
        show_completed_tasks: z.boolean().optional()
      }).optional()
    }))
    .mutation(async ({ ctx, input }) => {
      // First check if settings exist
      const { data: existingSettings, error: fetchError } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('id')
        .eq('user_id', ctx.userId)
        .single();
        
      if (fetchError && fetchError.code === 'PGRST116') {
        // Create settings if they don't exist
        const defaultSettings = {
          user_id: ctx.userId,
          notification_preferences: {
            email: true,
            push: true,
            task_reminders: true,
            goal_updates: true,
            habit_reminders: true,
            ...input.notification_preferences
          },
          ui_preferences: {
            theme: 'system',
            compact_view: false,
            show_completed_tasks: true,
            ...input.ui_preferences
          }
        };
        
        const { data, error } = await ctx.supabaseAdmin
          .from('user_settings')
          .insert(defaultSettings)
          .select()
          .single();
          
        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        return data;
      } else if (fetchError) {
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: fetchError.message });
      }
      
      // Update existing settings
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .update(input)
        .eq('user_id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getOnboardingStatus: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('id, onboarding_completed')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { onboardingCompleted: data?.onboarding_completed || false };
    }),
    
  completeOnboarding: protectedProcedure
    .mutation(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update({ onboarding_completed: true })
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { success: true };
    }),
});
  ```

- **server/src/routers/valueRouter.ts**

  *Exports: `valueRouter`*
  ```ts
const valueRouter = router({
  getValues: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: values, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return values;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch values',
        });
      }
    }),

  getValueById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!value) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found',
          });
        }

        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch value',
        });
      }
    }),

  createValue: protectedProcedure
    .input(createValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create value',
        });
      }
    }),

  updateValue: protectedProcedure
    .input(updateValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // First check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to update it',
          });
        }

        // Update the value
        const { data: updatedValue, error } = await ctx.supabaseAdmin
          .from('values')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return updatedValue;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update value',
        });
      }
    }),

  deleteValue: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to delete it',
          });
        }

        // Delete the value
        const { error } = await ctx.supabaseAdmin
          .from('values')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete value',
        });
      }
    }),
});
  ```

- **server/src/types/index.ts**

  *Exports: `Badge`*
  ```ts
export interface Badge {
  id: BadgeId;
  title: string;
  icon: string; // Hero‑icons name or emoji
  earnedAt?: string; // ISO
  progress?: number; // 0‒1 for not‑yet
}
  ```

  *Exports: `BadgeId`*
  ```ts
export type BadgeId = string;
  ```

  *Exports: `Goal`*
  ```ts
export interface Goal {
  id: GoalId;
  title: string;
  description?: string;
  valueIds: ValueId[];
  progress: number; // 0‒1
  keyResults: KeyResult[];
  targetDate?: string; // ISO
}
  ```

  *Exports: `GoalId`*
  ```ts
export type GoalId = string;
  ```

  *Exports: `Habit`*
  ```ts
export interface Habit {
  id: HabitId;
  title: string;
  cue?: string;
  routine?: string;
  reward?: string;
  valueIds: ValueId[];
  streak: number; // current consecutive days
  bestStreak: number;
  history: Record<string, boolean>; // ISO day → done?
}
  ```

  *Exports: `HabitId`*
  ```ts
export type HabitId = string;
  ```

  *Exports: `KeyResult`*
  ```ts
export interface KeyResult {
  id: string;
  title: string;
  progress: number; // 0‒1
}
  ```

  *Exports: `Principle`*
  ```ts
export interface Principle {
  id: string;
  title: string;
  body: string;
  valueIds: ValueId[];
}
  ```

  *Exports: `Task`*
  ```ts
export interface Task {
  id: TaskId;
  title: string;
  notes?: string;
  status: 'todo' | 'doing' | 'done' | 'blocked';
  due?: string; // ISO date
  priority?: 1 | 2 | 3;
  goalId?: GoalId;
  valueIds?: ValueId[];
}
  ```

  *Exports: `TaskId`*
  ```ts
export type TaskId = string;
  ```

  *Exports: `TrackedStateDef`*
  ```ts
export interface TrackedStateDef {
  id: string;
  name: string;
  scale: '1-5' | 'low-high' | 'custom';
  customLabels?: string[];
  valueIds: ValueId[];
}
  ```

  *Exports: `Value`*
  ```ts
export interface Value {
  id: ValueId;
  name: string;
  description?: string;
  color: string; // tailwind color token (e.g. 'indigo-500')
  domainId?: string; // optional grouping
}
  ```

  *Exports: `ValueId`*
  ```ts
export type ValueId = string;
  ```

- **server/src/types/trpc-types.ts**

  *Exports: `awardBadgeInput`*
  ```ts
const awardBadgeInput = z.object({
  badgeId: z.string(), // Matches text ID in badge_definitions
  description: z.string().optional(), // Example custom field if needed
});
  ```

  *Exports: `BadgeDefinition`*
  ```ts
const BadgeDefinition = z.object({
  id: z.string(), // From DB: text primary key
  title: z.string(),
  description: z.string().nullish(),
  icon: z.string(),
});
  ```

  *Exports: `BadgeDefinition`*
  ```ts
export type BadgeDefinition = z.infer<typeof BadgeDefinition>;
  ```

  *Exports: `claimLootInput`*
  ```ts
const claimLootInput = z.object({
  rewardId: z.string().uuid(), // Use rewardId to match router
});
  ```

  *Exports: `createGoalInput`*
  ```ts
const createGoalInput = Goal.omit({ id: true, user_id: true, created_at: true, updated_at: true });
  ```

  *Exports: `createGoalProgressNoteInput`*
  ```ts
const createGoalProgressNoteInput = GoalProgressNote.omit({ id: true, user_id: true, created_at: true });
  ```

  *Exports: `createHabitEntryInput`*
  ```ts
const createHabitEntryInput = HabitEntry.omit({ id: true, user_id: true, created_at: true });
  ```

  *Exports: `createHabitInput`*
  ```ts
const createHabitInput = Habit.omit({ id: true, user_id: true, created_at: true, updated_at: true });
  ```

  *Exports: `createPrincipleInput`*
  ```ts
const createPrincipleInput = Principle.omit({ id: true, user_id: true, created_at: true, updated_at: true });
  ```

  *Exports: `createReminderInput`*
  ```ts
const createReminderInput = Reminder.omit({ id: true, user_id: true, created_at: true, updated_at: true });
  ```

  *Exports: `CreateStateEntryInput`*
  ```ts
const CreateStateEntryInput = StateEntry.omit({ id: true, user_id: true })
.extend({
  tracked_state_def_id: z.string().uuid(), // Ensure this is required
  // Values are optional in base schema
});
  ```

  *Exports: `createTaskInput`*
  ```ts
const createTaskInput = Task.omit({ id: true, user_id: true, created_at: true, updated_at: true });
  ```

  *Exports: `createTrackedStateDefInput`*
  ```ts
const createTrackedStateDefInput = TrackedStateDef.omit({ id: true, user_id: true, created_at: true, updated_at: true });
  ```

  *Exports: `createValueInput`*
  ```ts
const createValueInput = Value.omit({ id: true, user_id: true, created_at: true, updated_at: true });
  ```

  *Exports: `DeleteGoalProgressNoteInput`*
  ```ts
const DeleteGoalProgressNoteInput = z.object({ id: z.string().uuid() });
  ```

  *Exports: `DeleteReminderInput`*
  ```ts
const DeleteReminderInput = z.object({ id: z.string().uuid() });
  ```

  *Exports: `DeleteStateEntryInput`*
  ```ts
const DeleteStateEntryInput = z.object({ id: z.string().uuid() });
  ```

  *Exports: `DeleteTrackedStateDefInput`*
  ```ts
const DeleteTrackedStateDefInput = z.object({ id: z.string().uuid() });
  ```

  *Exports: `GetGoalProgressNotesInput`*
  ```ts
const GetGoalProgressNotesInput = z.object({ goal_id: z.string().uuid() });
  ```

  *Exports: `GetRemindersForEntityInput`*
  ```ts
const GetRemindersForEntityInput = z.object({
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
});
  ```

  *Exports: `GetStateEntriesInput`*
  ```ts
const GetStateEntriesInput = z.object({
  tracked_state_def_id: z.string().uuid(), // Renamed from definition_id to match DB? Check usage.
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  limit: z.number().int().positive().optional(),
});
  ```

  *Exports: `GetTrackedStateDefByIdInput`*
  ```ts
const GetTrackedStateDefByIdInput = z.object({ id: z.string().uuid() });
  ```

  *Exports: `Goal`*
  ```ts
const Goal = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  description: z.string().nullish(),
  progress: z.number().nullish(),
  target_date: z.string().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime().nullish(),
  updated_at: z.string().datetime().nullish(),
});
  ```

  *Exports: `Goal`*
  ```ts
export type Goal = z.infer<typeof Goal>;
  ```

  *Exports: `GoalProgressNote`*
  ```ts
const GoalProgressNote = z.object({
  id: z.string().uuid(),
  goal_id: z.string().uuid(),
  user_id: z.string().uuid(),
  note: z.string(),
  created_at: z.string().datetime(),
});
  ```

  *Exports: `GoalProgressNote`*
  ```ts
export type GoalProgressNote = z.infer<typeof GoalProgressNote>;
  ```

  *Exports: `greetingInput`*
  ```ts
const greetingInput = z.object({ name: z.string().optional() });
  ```

  *Exports: `greetingOutput`*
  ```ts
const greetingOutput = z.object({ greeting: z.string() });
  ```

  *Exports: `Habit`*
  ```ts
const Habit = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  cue: z.string().nullish(),
  routine: z.string().nullish(),
  reward: z.string().nullish(),
  streak: z.number().nonnegative().default(0),
  best_streak: z.number().nonnegative().default(0),
  habit_type: HabitTypeEnum.default('boolean'),
  goal_quantity: z.number().int().nullish(),
  goal_unit: z.string().nullish(),
  frequency_period: HabitFrequencyPeriodEnum.default('day'),
  goal_frequency: z.number().int().positive().default(1),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(), // <<< Added sort_order
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
  ```

  *Exports: `Habit`*
  ```ts
export type Habit = z.infer<typeof Habit>;
  ```

  *Exports: `HabitEntry`*
  ```ts
const HabitEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  habit_id: z.string().uuid(),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be in YYYY-MM-DD format"),
  completed: z.boolean().default(false),
  quantity_value: z.number().int().nullish(),
  notes: z.string().nullish(),
  created_at: z.string().datetime(),
});
  ```

  *Exports: `HabitEntry`*
  ```ts
export type HabitEntry = z.infer<typeof HabitEntry>;
  ```

  *Exports: `HabitFrequencyPeriodEnum`*
  ```ts
const HabitFrequencyPeriodEnum = z.enum(['day', 'week', 'month']);
  ```

  *Exports: `HabitTypeEnum`*
  ```ts
const HabitTypeEnum = z.enum(['boolean', 'quantity']);
  ```

  *Exports: `NotificationPrefs`*
  ```ts
const NotificationPrefs = z.object({
  email: z.boolean().default(true),
  push: z.boolean().default(true),
  task_reminders: z.boolean().default(true),
  goal_updates: z.boolean().default(true),
  habit_reminders: z.boolean().default(true),
});
  ```

  *Exports: `PointTransaction`*
  ```ts
const PointTransaction = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  points: z.number().int(),
  reason: z.string(),
  source_type: z.string(),
  source_id: z.string().uuid().nullish(),
  created_at: z.string().datetime(),
});
  ```

  *Exports: `PointTransaction`*
  ```ts
export type PointTransaction = z.infer<typeof PointTransaction>;
  ```

  *Exports: `Principle`*
  ```ts
const Principle = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), // <<< Changed from 'name' to 'title'
  body: z.string(), // <<< Renamed from description for clarity, matching migration
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
  ```

  *Exports: `Principle`*
  ```ts
export type Principle = z.infer<typeof Principle>;
  ```

  *Exports: `Reminder`*
  ```ts
const Reminder = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
  reminder_time: z.string().datetime(),
  is_active: z.boolean().default(true),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
  ```

  *Exports: `Reminder`*
  ```ts
export type Reminder = z.infer<typeof Reminder>;
  ```

  *Exports: `Reward`*
  ```ts
const Reward = z.object({
  id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullish(),
  type: RewardTypeEnum,
  required_points: z.number().int().nonnegative().default(0),
  can_earn_multiple: z.boolean().default(false),
  image_url: z.string().url().nullish(),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
  ```

  *Exports: `Reward`*
  ```ts
export type Reward = z.infer<typeof Reward>;
  ```

  *Exports: `RewardTypeEnum`*
  ```ts
const RewardTypeEnum = z.enum(['badge', 'achievement', 'item', 'discount']);
  ```

  *Exports: `RouterInputs`*
  ```ts
export type RouterInputs = inferRouterInputs<AppRouter>;
  ```

  *Exports: `RouterOutputs`*
  ```ts
export type RouterOutputs = inferRouterOutputs<AppRouter>;
  ```

  *Exports: `StateEntry`*
  ```ts
const StateEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  definition_id: z.string().uuid(), // <<< Renamed from tracked_state_def_id for consistency? check DB
  value_numeric: z.number().optional().nullable(),
  value_text: z.string().optional().nullable(),
  entry_timestamp: z.string().datetime({ message: "Invalid datetime string. Must be UTC ISO 8601" }).optional(),
  notes: z.string().optional().nullable(), // <<< Added notes
});
  ```

  *Exports: `StateEntry`*
  ```ts
export type StateEntry = z.infer<typeof StateEntry>;
  ```

  *Exports: `Task`*
  ```ts
const Task = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  notes: z.string().nullish(),
  status: TaskStatusEnum.default('todo'),
  priority_enum: TaskPriorityEnum.nullish(), // <<< Renamed from priority
  due_date: z.string().datetime().nullish(),
  goal_id: z.string().uuid().nullish(),
  parent_task_id: z.string().uuid().nullish(),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
  ```

  *Exports: `Task`*
  ```ts
export type Task = z.infer<typeof Task>;
  ```

  *Exports: `TaskPriorityEnum`*
  ```ts
const TaskPriorityEnum = z.enum(['low', 'medium', 'high']);
  ```

  *Exports: `TaskStatusEnum`*
  ```ts
const TaskStatusEnum = z.enum(['todo', 'doing', 'done', 'blocked', 'pending']);
  ```

  *Exports: `TrackedStateDef`*
  ```ts
const TrackedStateDef = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  name: z.string(),
  // category: z.string(), // Category seems removed/replaced in DB schema by scale/custom_labels
  scale: z.enum(['1-5', 'low-high', 'custom']), // <<< Added scale
  custom_labels: z.array(z.string()).nullish(), // <<< Added custom_labels
  unit: z.string().nullish(), // Keep unit if still used alongside scale
  icon: z.string().nullish(), // Keep icon if still used
  target_min_value: z.number().nullish(), // <<< Added
  target_max_value: z.number().nullish(), // <<< Added
  active: z.boolean().default(true), // <<< Added active
  priority: z.number().int().default(1), // <<< Added priority
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
  ```

  *Exports: `TrackedStateDef`*
  ```ts
export type TrackedStateDef = z.infer<typeof TrackedStateDef>;
  ```

  *Exports: `UiPrefs`*
  ```ts
const UiPrefs = z.object({
  theme: z.enum(['system', 'light', 'dark']).default('system'),
  compact_view: z.boolean().default(false),
  show_completed_tasks: z.boolean().default(true),
  first_day_of_week: z.number().int().min(0).max(6).default(0),
});
  ```

  *Exports: `updateGoalInput`*
  ```ts
const updateGoalInput = createGoalInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updateGoalProgressNoteInput`*
  ```ts
const updateGoalProgressNoteInput = createGoalProgressNoteInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updateHabitEntryInput`*
  ```ts
const updateHabitEntryInput = createHabitEntryInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updateHabitInput`*
  ```ts
const updateHabitInput = createHabitInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updatePrincipleInput`*
  ```ts
const updatePrincipleInput = createPrincipleInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updateProfileInput`*
  ```ts
const updateProfileInput = UserProfile.partial().omit({ id: true, created_at: true, updated_at: true });
  ```

  *Exports: `updateReminderInput`*
  ```ts
const updateReminderInput = createReminderInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updateSettingsInput`*
  ```ts
const updateSettingsInput = z.object({
  notification_preferences: NotificationPrefs.partial().optional(),
  ui_preferences: UiPrefs.partial().optional(),
});
  ```

  *Exports: `updateStateEntryInput`*
  ```ts
const updateStateEntryInput = CreateStateEntryInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updateTaskInput`*
  ```ts
const updateTaskInput = createTaskInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updateTaskStatusInput`*
  ```ts
const updateTaskStatusInput = z.object({ id: z.string().uuid(), status: TaskStatusEnum });
  ```

  *Exports: `updateTrackedStateDefInput`*
  ```ts
const updateTrackedStateDefInput = createTrackedStateDefInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updateValueInput`*
  ```ts
const updateValueInput = createValueInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `UserBadge`*
  ```ts
const UserBadge = z.object({
  // Note: user_badges might be merged into user_rewards with type='badge'
  user_id: z.string().uuid(),
  badge_id: z.string(), // Matches badge_definitions.id (text)
  earned_at: z.string().datetime(),
  progress: z.number().nullish(), // From DB schema
});
  ```

  *Exports: `UserBadge`*
  ```ts
export type UserBadge = z.infer<typeof UserBadge>;
  ```

  *Exports: `UserProfile`*
  ```ts
const UserProfile = z.object({
  id: z.string().uuid(),
  username: z.string().nullish(),
  avatar_url: z.string().url().nullish(),
  full_name: z.string().nullish(),
  bio: z.string().nullish(),
  points: z.number().int().nonnegative().default(0),
  time_zone: z.string().nullish(),
  onboarding_completed: z.boolean().default(false),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
  ```

  *Exports: `UserProfile`*
  ```ts
export type UserProfile = z.infer<typeof UserProfile>;
  ```

  *Exports: `UserReward`*
  ```ts
const UserReward = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  reward_id: z.string().uuid(),
  reward_type: z.string().nullish(), // From DB schema
  earned_at: z.string().datetime(),
  points_spent: z.number().int().nonnegative().default(0),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
  ```

  *Exports: `UserReward`*
  ```ts
export type UserReward = z.infer<typeof UserReward>;
  ```

  *Exports: `UserSettings`*
  ```ts
const UserSettings = z.object({
  id: z.string().uuid().optional(),
  user_id: z.string().uuid(),
  notification_preferences: NotificationPrefs,
  ui_preferences: UiPrefs,
});
  ```

  *Exports: `UserSettings`*
  ```ts
export type UserSettings = z.infer<typeof UserSettings>;
  ```

  *Exports: `Value`*
  ```ts
const Value = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), 
  description: z.string().nullish(),
  color: z.string().nullish(),
  icon: z.string().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
  ```

  *Exports: `Value`*
  ```ts
export type Value = z.infer<typeof Value>;
  ```

- **server/tsconfig.json**
  *(No explicit exports found)*

### stores

- **stores/uiStore.ts**

  *Exports: `useUiStore`*
  ```ts
const useUiStore = create<UiState>((set) => ({
  isDarkMode: false, // Default to light mode
  toggleTheme: () => set((state) => ({ isDarkMode: !state.isDarkMode })),
}));
  ```

### supabase

- **supabase/.gitignore**
  *(No explicit exports found)*

- **supabase/config.toml**
  *(No explicit exports found)*

- **supabase/migrations/20250424033333_initial_schema.sql**
  *(No explicit exports found)*

- **supabase/migrations/20250424035232_add_missing_tables.sql**
  *(No explicit exports found)*

- **supabase/migrations/20250424035717_add_missing_tables.sql**
  *(No explicit exports found)*

- **supabase/migrations/20250425000000_create_user_settings_table.sql**
  *(No explicit exports found)*

- **supabase/migrations/20250426000000_create_rewards_tables.sql**
  *(No explicit exports found)*

- **supabase/migrations/20250428124230_standardize_field_naming.sql**
  *(No explicit exports found)*

- **supabase/migrations/20250428130834_enhance_functional_schema.sql**
  *(No explicit exports found)*

### types

- **types/database.types.ts**

  *Exports: `CompositeTypes`*
  ```ts
export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof Database },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends { schema: keyof Database }
  ? Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never
  ```

  *Exports: `Constants`*
  ```ts
const Constants = {
  public: {
    Enums: {
      habit_frequency_period: ["day", "week", "month"],
      habit_type: ["boolean", "quantity"],
      reward_type: ["badge", "achievement", "item", "discount"],
      task_priority: ["low", "medium", "high"],
      task_status: ["todo", "doing", "done", "blocked", "pending"],
      tracked_state_scale: ["1-5", "low-high", "custom"],
    },
  },
} as const
  ```

  *Exports: `Database`*
  ```ts
export type Database = {
public: {
  Tables: {
    badge_definitions: {
      Row: {
        description: string | null
        icon: string
        id: string
        title: string
      }
      Insert: {
        description?: string | null
        icon: string
        id: string
        title: string
      }
      Update: {
        description?: string | null
        icon?: string
        id?: string
        title?: string
      }
      Relationships: []
    }
    goal_progress_notes: {
      Row: {
        created_at: string
        goal_id: string
        id: string
        note: string
        user_id: string
      }
      Insert: {
        created_at?: string
        goal_id: string
        id?: string
        note: string
        user_id: string
      }
      Update: {
        created_at?: string
        goal_id?: string
        id?: string
        note?: string
        user_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "goal_progress_notes_goal_id_fkey"
          columns: ["goal_id"]
          isOneToOne: false
          referencedRelation: "goals"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "goal_progress_notes_user_id_fkey"
          columns: ["user_id"]
          isOneToOne: false
          referencedRelation: "profiles"
          referencedColumns: ["id"]
        },
      ]
    }
    goal_values: {
      Row: {
        goal_id: string
        user_id: string
        value_id: string
      }
      Insert: {
        goal_id: string
        user_id: string
        value_id: string
      }
      Update: {
        goal_id?: string
        user_id?: string
        value_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "goal_values_goal_id_fkey"
          columns: ["goal_id"]
          isOneToOne: false
          referencedRelation: "goals"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "goal_values_user_id_fkey"
          columns: ["user_id"]
          isOneToOne: false
          referencedRelation: "profiles"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "goal_values_value_id_fkey"
          columns: ["value_id"]
          isOneToOne: false
          referencedRelation: "values"
          referencedColumns: ["id"]
        },
      ]
    }
    goals: {
      Row: {
        archived_at: string | null
        created_at: string | null
        description: string | null
        id: string
        progress: number | null
        sort_order: number | null
        target_date: string | null
        title: string
        updated_at: string | null
        user_id: string
      }
      Insert: {
        archived_at?: string | null
        created_at?: string | null
        description?: string | null
        id?: string
        progress?: number | null
        sort_order?: number | null
        target_date?: string | null
        title: string
        updated_at?: string | null
        user_id: string
      }
      Update: {
        archived_at?: string | null
        created_at?: string | null
        description?: string | null
        id?: string
        progress?: number | null
        sort_order?: number | null
        target_date?: string | null
        title?: string
        updated_at?: string | null
        user_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "goals_user_id_fkey"
          columns: ["user_id"]
          isOneToOne: false
          referencedRelation: "profiles"
          referencedColumns: ["id"]
        },
      ]
    }
    habit_entries: {
      Row: {
        completed: boolean
        created_at: string
        date: string
        habit_id: string
        id: string
        notes: string | null
        quantity_value: number | null
        user_id: string
      }
      Insert: {
        completed?: boolean
        created_at?: string
        date: string
        habit_id: string
        id?: string
        notes?: string | null
        quantity_value?: number | null
        user_id: string
      }
      Update: {
        completed?: boolean
        created_at?: string
        date?: string
        habit_id?: string
        id?: string
        notes?: string | null
        quantity_value?: number | null
        user_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "habit_entries_habit_id_fkey"
          columns: ["habit_id"]
          isOneToOne: false
          referencedRelation: "habits"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "habit_entries_user_id_fkey"
          columns: ["user_id"]
          isOneToOne: false
          referencedRelation: "profiles"
          referencedColumns: ["id"]
        },
      ]
    }
    habit_values: {
      Row: {
        habit_id: string
        user_id: string
        value_id: string
      }
      Insert: {
        habit_id: string
        user_id: string
        value_id: string
      }
      Update: {
        habit_id?: string
        user_id?: string
        value_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "habit_values_habit_id_fkey"
          columns: ["habit_id"]
          isOneToOne: false
          referencedRelation: "habits"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "habit_values_user_id_fkey"
          columns: ["user_id"]
          isOneToOne: false
          referencedRelation: "profiles"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "habit_values_value_id_fkey"
          columns: ["value_id"]
          isOneToOne: false
          referencedRelation: "values"
          referencedColumns: ["id"]
        },
      ]
    }
    habits: {
      Row: {
        archived_at: string | null
        best_streak: number
        created_at: string
        cue: string | null
        frequency_period: Database["public"]["Enums"]["habit_frequency_period"]
        goal_frequency: number
        goal_quantity: number | null
        goal_unit: string | null
        habit_type: Database["public"]["Enums"]["habit_type"]
        id: string
        recurrence_end_date: string | null
        recurrence_rule: string | null
        reward: string | null
        routine: string | null
        streak: number
        title: string
        updated_at: string
        user_id: string
      }
      Insert: {
        archived_at?: string | null
        best_streak?: number
        created_at?: string
        cue?: string | null
        frequency_period?: Database["public"]["Enums"]["habit_frequency_period"]
        goal_frequency?: number
        goal_quantity?: number | null
        goal_unit?: string | null
        habit_type?: Database["public"]["Enums"]["habit_type"]
        id?: string
        recurrence_end_date?: string | null
        recurrence_rule?: string | null
        reward?: string | null
        routine?: string | null
        streak?: number
        title: string
        updated_at?: string
        user_id: string
      }
      Update: {
        archived_at?: string | null
        best_streak?: number
        created_at?: string
        cue?: string | null
        frequency_period?: Database["public"]["Enums"]["habit_frequency_period"]
        goal_frequency?: number
        goal_quantity?: number | null
        goal_unit?: string | null
        habit_type?: Database["public"]["Enums"]["habit_type"]
        id?: string
        recurrence_end_date?: string | null
        recurrence_rule?: string | null
        reward?: string | null
        routine?: string | null
        streak?: number
        title?: string
        updated_at?: string
        user_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "habits_user_id_fkey"
          columns: ["user_id"]
          isOneToOne: false
          referencedRelation: "profiles"
          referencedColumns: ["id"]
        },
      ]
    }
    key_results: {
      Row: {
        created_at: string
        goal_id: string
        id: string
        progress: number | null
        title: string
        updated_at: string
        user_id: string
      }
      Insert: {
        created_at?: string
        goal_id: string
        id?: string
        progress?: number | null
        title: string
        updated_at?: string
        user_id: string
      }
      Update: {
        created_at?: string
        goal_id?: string
        id?: string
        progress?: number | null
        title?: string
        updated_at?: string
        user_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "key_results_goal_id_fkey"
          columns: ["goal_id"]
          isOneToOne: false
          referencedRelation: "goals"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "key_results_user_id_fkey"
          columns: ["user_id"]
          isOneToOne: false
          referencedRelation: "profiles"
          referencedColumns: ["id"]
        },
      ]
    }
    point_transactions: {
      Row: {
        created_at: string
        id: string
        points: number
        reason: string
        source_id: string | null
        source_type: string
   ... /* snippet truncated */
  ```

  *Exports: `Enums`*
  ```ts
export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof Database },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never
  ```

  *Exports: `Json`*
  ```ts
export type Json =
| string
| number
| boolean
| null
| { [key: string]: Json | undefined }
| Json[]
  ```

  *Exports: `Tables`*
  ```ts
export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof (Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        Database[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? (Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      Database[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never
  ```

  *Exports: `TablesInsert`*
  ```ts
export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never
  ```

  *Exports: `TablesUpdate`*
  ```ts
export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never
  ```

### utils

- **utils/api-types.ts**

  *Exports: `RouterInputs`*
  ```ts
export type RouterInputs = inferRouterInputs<AppRouter>;
  ```

  *Exports: `RouterOutputs`*
  ```ts
export type RouterOutputs = inferRouterOutputs<AppRouter>;
  ```

- **utils/auth.ts**

  *Exports: `getUserProfile`*
  ```ts
export async function getUserProfile() {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) return null;
    
    // If we have a user, get their profile from the profiles table
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', user.id)
      .single();
    
    if (error) {
      // If profile doesn't exist yet, return basic user info
      return {
        id: user.id,
        email: user.email,
        username: user.user_metadata?.username || 'User',
        created_at: user.created_at,
      };
    }
    
    return data;
  } catch (error) {
    console.error('Error getting user profile:', error);
    return null;
  }
}
  ```

  *Exports: `logout`*
  ```ts
export async function logout() {
  try {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
    
    // Navigate to login screen
    router.replace('/auth/login');
  } catch (error) {
    console.error('Error signing out:', error);
    // Force navigation even if there was an error
    router.replace('/auth/login');
  }
}
  ```

- **utils/colors.ts**

  *Exports: `palette`*
  ```ts
const palette = {
  // Main UI colors
  black: '#000000',
  white: '#FFFFFF',
  
  // Grays
  gray: {
    50: '#F9FAFB',
    100: '#F3F4F6',
    200: '#E5E7EB',
    300: '#D1D5DB',
    400: '#9CA3AF',
    500: '#6B7280',
    600: '#4B5563',
    700: '#374151',
    800: '#1F2937',
    900: '#111827',
  },
  
  // Blues
  blue: {
    50: '#EFF6FF',
    100: '#DBEAFE',
    200: '#BFDBFE',
    300: '#93C5FD',
    400: '#60A5FA',
    500: '#3B82F6',
    600: '#2563EB',
    700: '#1D4ED8',
    800: '#1E40AF',
    900: '#1E3A8A',
  },
  
  // Greens
  green: {
    50: '#ECFDF5',
    100: '#D1FAE5',
    200: '#A7F3D0',
    300: '#6EE7B7',
    400: '#34D399',
    500: '#10B981',
    600: '#059669',
    700: '#047857',
    800: '#065F46',
    900: '#064E3B',
  },
  
  // Reds
  red: {
    50: '#FEF2F2',
    100: '#FEE2E2',
    200: '#FECACA',
    300: '#FCA5A5',
    400: '#F87171',
    500: '#EF4444',
    600: '#DC2626',
    700: '#B91C1C',
    800: '#991B1B',
    900: '#7F1D1D',
  },
  
  // Yellows
  yellow: {
    50: '#FFFBEB',
    100: '#FEF3C7',
    200: '#FDE68A',
    300: '#FCD34D',
    400: '#FBBF24',
    500: '#F59E0B',
    600: '#D97706',
    700: '#B45309',
    800: '#92400E',
    900: '#78350F',
  },
  
  // Purples
  purple: {
    50: '#F5F3FF',
    100: '#EDE9FE',
    200: '#DDD6FE',
    300: '#C4B5FD',
    400: '#A78BFA',
    500: '#8B5CF6',
    600: '#7C3AED',
    700: '#6D28D9',
    800: '#5B21B6',
    900: '#4C1D95',
  },
};
  ```

  *Exports: `semanticTokens`*
  ```ts
const semanticTokens = {
  // Background colors
  background: {
    /** Main app background */
    app: '$background',
    /** Card/surface background */
    card: '$backgroundHover',
    /** Secondary surface background */
    secondary: '$backgroundPress',
    /** Tertiary surface background */
    tertiary: '$backgroundStrong',
    /** Input background */
    input: '$backgroundTransparent',
  },
  
  // Foreground/content colors
  content: {
    /** Primary text */
    primary: '$color',
    /** Secondary/dimmed text */
    secondary: '$colorTransparent',
    /** Subtle text - least emphasis */
    subtle: '$colorTransparent2',
    /** Disabled text */
    disabled: '$colorTransparent3',
  },
  
  // Border colors
  border: {
    /** Default border */
    default: '$borderColor',
    /** Focused border */
    focus: '$borderColorFocus',
    /** Border for hover state */
    hover: '$borderColorHover',
  },
  
  // Status colors
  status: {
    /** Success indicators */
    success: '$green10',
    /** Error indicators */
    error: '$red10',
    /** Warning indicators */
    warning: '$yellow10',
    /** Information indicators */
    info: '$blue10',
  },
  
  // Brand colors (adjust to match your brand)
  brand: {
    /** Primary brand color */
    primary: '$blue10',
    /** Secondary brand color */
    secondary: '$purple10',
    /** Accent brand color */
    accent: '$green10',
  }
};
  ```

  *Exports: `useColors`*
  ```ts
export function useColors() {
  const theme = useTheme();
  
  return {
    background: {
      app: theme?.background?.get() || '#FFFFFF',
      card: theme?.backgroundHover?.get() || '#F3F4F6',
      secondary: theme?.backgroundPress?.get() || '#E5E7EB',
      tertiary: theme?.backgroundStrong?.get() || '#D1D5DB',
      input: theme?.backgroundTransparent?.get() || '#FFFFFF',
    },
    content: {
      primary: theme?.color?.get() || '#111827',
      secondary: theme?.colorTransparent?.get() || '#4B5563',
      subtle: theme?.colorTransparent2?.get() || theme?.colorTransparent?.get() || '#6B7280',
      disabled: theme?.colorTransparent3?.get() || theme?.colorTransparent?.get() || '#9CA3AF',
    },
    border: {
      default: theme?.borderColor?.get() || '#E5E7EB',
      focus: theme?.borderColorFocus?.get() || '#93C5FD',
      hover: theme?.borderColorHover?.get() || '#BFDBFE',
    },
    status: {
      success: theme?.green10?.get() || '#10B981',
      error: theme?.red10?.get() || '#EF4444',
      warning: theme?.yellow10?.get() || '#F59E0B',
      info: theme?.blue10?.get() || '#3B82F6',
    },
    brand: {
      primary: theme?.blue10?.get() || '#3B82F6',
      secondary: theme?.purple10?.get() || '#8B5CF6',
      accent: theme?.green10?.get() || '#10B981',
    }
  };
}
  ```

  *Exports: `withOpacity`*
  ```ts
export function withOpacity(hex: string, alpha: number): string {
  // Extract RGB components from hex
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}
  ```

- **utils/generated-hooks.ts**

  *Exports: `useDashboard`*
  ```ts
const useDashboard = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useGoal`*
  ```ts
const useGoal = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useGoalProgressNote`*
  ```ts
const useGoalProgressNote = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useHabit`*
  ```ts
const useHabit = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `usePrinciple`*
  ```ts
const usePrinciple = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useReminder`*
  ```ts
const useReminder = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useRewards`*
  ```ts
const useRewards = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useState`*
  ```ts
const useState = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useTask`*
  ```ts
const useTask = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useUser`*
  ```ts
const useUser = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useValue`*
  ```ts
const useValue = {
  // Add strongly typed hooks here
};
  ```

- **utils/haptics.ts**

  *Exports: `haptics`*
  ```ts
const haptics = {
  /**
   * Light impact - subtle tap for small UI elements (buttons, toggles)
   */
  light: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light),
  
  /**
   * Medium impact - standard tap for medium elements (picker selections)
   */
  medium: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium),
  
  /**
   * Heavy impact - stronger bump for significant actions
   */
  heavy: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy),
  
  /**
   * Selection feedback - subtle tap for navigating through options
   */
  selection: () => Haptics.selectionAsync(),
  
  /**
   * Success notification - double-tap vibration for completed actions
   */
  success: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success),
  
  /**
   * Warning notification - attention-grabbing pattern for warnings
   */
  warning: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning),
  
  /**
   * Error notification - strong buzz pattern for errors
   */
  error: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error),
};
  ```

- **utils/mock-api.ts**

  *Exports: `appRouter`*
  ```ts
const appRouter = router({
  greeting: {
    hello: publicProcedure
      .input(z.object({ name: z.string().optional() }))
      .query(({ input }) => {
        return {
          greeting: `Hello ${input.name ?? 'world'}`,
        };
      }),
    goodbye: publicProcedure
      .query(() => {
        return {
          greeting: 'Goodbye!',
        };
      }),
  },
  user: {
    get: publicProcedure
      .input(z.object({ id: z.string() }))
      .query(({ input }) => {
        return {
          id: input.id,
          name: 'Mock User',
        };
      }),
    list: publicProcedure
      .query(() => {
        return [
          { id: '1', name: 'Mock User 1' },
          { id: '2', name: 'Mock User 2' },
        ];
      }),
  },
  auth: {
    refreshToken: publicProcedure
      .input(z.object({ refreshToken: z.string() }))
      .mutation(async ({ input }) => {
        console.log('Mock API: refreshToken called with', input.refreshToken);
        // Simulate checking refresh token and issuing new ones
        await new Promise(resolve => setTimeout(resolve, 300));
        if (input.refreshToken === 'valid-refresh-token') { // Example valid token
          return {
            accessToken: `mock-access-${Date.now()}`,
            refreshToken: `mock-refresh-${Date.now()}`,
          };
        } else {
          // Throw error for invalid refresh token
          throw new Error('Invalid refresh token'); 
        }
      }),
    // Add login/logout mutations here later
  },
  item: {
    add: publicProcedure
      .input(z.object({ name: z.string() }))
      .mutation(async ({ input }) => {
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 500));
        // In a real backend, save to DB
        console.log('Mock API: Adding item', input);
        return {
          id: Math.random().toString(36).substring(7), // Generate random ID
          name: input.name,
          status: 'added'
        };
      }),
  },
});
  ```

  *Exports: `AppRouter`*
  ```ts
export type AppRouter = typeof appRouter;
  ```

- **utils/nats-client.ts**

  *Exports: `addSubjectHandler`*
  ```ts
export function addSubjectHandler(subject: string, handler: CacheUpdateHandler): () => void {
  if (!handlers[subject]) {
    handlers[subject] = [];
  }
  
  handlers[subject].push(handler);
  
  // Return a function to remove the handler
  return () => {
    if (handlers[subject]) {
      handlers[subject] = handlers[subject].filter(h => h !== handler);
    }
  };
}
  ```

  *Exports: `closeNatsConnection`*
  ```ts
export async function closeNatsConnection(): Promise<void> {
  if (natsConnection) {
    await natsConnection.close();
    natsConnection = null;
  }
}
  ```

  *Exports: `getNatsConnection`*
  ```ts
export function getNatsConnection(): NatsConnection | null {
  return natsConnection;
}
  ```

  *Exports: `initNatsClient`*
  ```ts
export async function initNatsClient(
  url: string, 
  qc: QueryClient,
  options: Partial<ConnectionOptions> = {}
): Promise<NatsConnection> {
  if (natsConnection) {
    return natsConnection;
  }
  
  if (isConnecting) {
    throw new Error('NATS connection is already in progress');
  }
  
  isConnecting = true;
  
  try {
    // Set the query client for cache updates
    queryClient = qc;
    
    // Connect to NATS server
    natsConnection = await connect({
      servers: url,
      // Add required polyfills for React Native
      // These would need to be properly implemented in a real app
      ...options,
    });
    
    console.log('Connected to NATS server');
    
    // Setup ping interval to keep connection alive
    const pingInterval = setInterval(() => {
      if (natsConnection && !natsConnection.isClosed) {
        // Note: Using a custom ping mechanism instead of the built-in one
        try {
          const start = Date.now();
          // Simple ping using a request to a dummy subject
          natsConnection.request('_PING_', undefined, { timeout: 1000 })
            .then(() => {
              const latency = Date.now() - start;
              console.log(`NATS server latency: ${latency}ms`);
            })
            .catch((err: Error) => {
              console.error('NATS ping error:', err.message);
            });
        } catch (err) {
          const error = err as Error;
          console.error('NATS ping error:', error.message);
        }
      } else {
        clearInterval(pingInterval);
      }
    }, 30000);
    
    // Handle connection close
    natsConnection.closed().then(() => {
      console.log('NATS connection closed');
      natsConnection = null;
      clearInterval(pingInterval);
      // Could implement reconnection logic here
    });
    
    return natsConnection;
  } catch (error) {
    console.error('Failed to connect to NATS server:', error);
    isConnecting = false;
    throw error;
  }
}
  ```

  *Exports: `subscribeWithCache`*
  ```ts
export async function subscribeWithCache(
  subject: string,
  queryKey: unknown[],
  updateType: 'invalidate' | 'setData' = 'invalidate'
): Promise<() => void> {
  if (!natsConnection) {
    throw new Error('NATS client not initialized');
  }
  
  if (!queryClient) {
    throw new Error('QueryClient not set');
  }
  
  // Create subscription
  const subscription = natsConnection.subscribe(subject);
  
  // Setup message handler
  (async () => {
    for await (const msg of subscription) {
      try {
        const data = JSON.parse(sc.decode(msg.data));
        
        if (updateType === 'invalidate') {
          // Invalidate the cache for this query key
          queryClient.invalidateQueries({ queryKey });
        } else {
          // Update the cache directly
          queryClient.setQueryData(queryKey, data);
        }
        
        // Call any custom handlers
        if (handlers[subject]) {
          handlers[subject].forEach(handler => handler(data));
        }
      } catch (error) {
        const err = error as Error;
        console.error(`Error handling message for ${subject}:`, err.message);
      }
    }
  })();
  
  // Return unsubscribe function
  return () => {
    subscription.unsubscribe();
  };
}
  ```

- **utils/offline-mutations.ts**

  *Exports: `asyncStoragePersister`*
  ```ts
const asyncStoragePersister = createAsyncStoragePersister({
  storage: AsyncStorage,
});
  ```

  *Exports: `configureQueryClientForOffline`*
  ```ts
export function configureQueryClientForOffline(queryClient: QueryClient): NetInfoSubscription {
  // Listen to network status changes and update onlineManager
  const unsubscribe = NetInfo.addEventListener(state => {
    onlineManager.setOnline(state.isConnected === true);
  });
  
  // When a mutation fails due to network error, pause it instead of failing
  queryClient.getMutationCache().config.onError = (error: unknown, _variables: unknown, _context: unknown, mutation: any) => {
    // Check if the error is a network error
    if (
      error instanceof Error && 
      (
        error.message.includes('network') || 
        error.message.includes('Network Error') ||
        error.message.includes('Failed to fetch')
      )
    ) {
      console.log('Network error detected, pausing mutation for later retry');
      
      // Pause the mutation instead of failing permanently
      mutation.state.isPaused = true;
    }
  };
  
  // Set up persistence
  persistQueryClient({
    queryClient,
    ...reactQueryPersistOptions,
  });

  // Return unsubscribe function for cleanup
  return unsubscribe;
}
  ```

  *Exports: `getPendingMutations`*
  ```ts
export function getPendingMutations(mutationCache: MutationCache): Mutation[] {
  return mutationCache.getAll().filter((mutation: any) => 
    mutation?.state?.status === 'loading' || 
    (mutation?.state?.status === 'error' && mutation?.state?.isPaused)
  );
}
  ```

  *Exports: `markItemAsOffline`*
  ```ts
export function markItemAsOffline<T>(item: T): T & { isOffline: boolean } {
  return {
    ...item,
    isOffline: true,
  };
}
  ```

  *Exports: `markItemAsSynced`*
  ```ts
export function markItemAsSynced<T extends { isOffline?: boolean }>(item: T): T {
  const result = { ...item };
  delete result.isOffline;
  return result;
}
  ```

  *Exports: `reactQueryPersistOptions`*
  ```ts
const reactQueryPersistOptions: Omit<PersistQueryClientOptions, 'queryClient'> = {
  persister: asyncStoragePersister,
  // Add custom serialization/deserialization if needed
  // We want to persist mutations especially for offline support
  buster: 'v1',
  dehydrateOptions: {
    shouldDehydrateMutation: () => true,
  },
};
  ```

  *Exports: `useResumeNetworkMutations`*
  ```ts
export function useResumeNetworkMutations(queryClient: QueryClient) {
  const netInfo = useNetInfo();
  const previousNetworkState = useRef(netInfo.isConnected);
  
  // Update React Query's online status manager
  useEffect(() => {
    onlineManager.setOnline(netInfo.isConnected === true);
  }, [netInfo.isConnected]);
  
  useEffect(() => {
    const isConnectedNow = netInfo.isConnected === true;
    const wasConnected = previousNetworkState.current === true;
    
    // If we just reconnected to the network
    if (isConnectedNow && !wasConnected) {
      console.log('Internet connection restored, resuming paused mutations');
      
      // Resume any paused mutations
      queryClient.resumePausedMutations().then(() => {
        // After resuming mutations, invalidate queries to refresh data
        queryClient.invalidateQueries();
      }).catch((error: Error) => {
        console.error('Error resuming mutations:', error.message);
      });
    }
    
    // Update our ref
    previousNetworkState.current = isConnectedNow;
  }, [netInfo.isConnected, queryClient]);
}
  ```

- **utils/offline-sync.ts**

  *Exports: `getPendingItems`*
  ```ts
export async function getPendingItems(type: string): Promise<PendingItem[]> {
  try {
    const itemsStr = await AsyncStorage.getItem(PENDING_ITEMS_KEY);
    if (!itemsStr) return [];
    
    const items: PendingItem[] = JSON.parse(itemsStr);
    return items.filter(item => item.type === type);
  } catch (error) {
    console.error('Error getting pending items:', error);
    return [];
  }
}
  ```

  *Exports: `PendingItem`*
  ```ts
export interface PendingItem {
  id: string;
  type: string;
  data: any;
  createdAt: number;
  isNotSynced: boolean;
}
  ```

  *Exports: `saveOfflineMutation`*
  ```ts
export async function saveOfflineMutation(
  type: 'create' | 'update' | 'delete',
  entity: string,
  data: any
): Promise<string> {
  try {
    // Generate a temporary ID for new items
    const id = `temp-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
    
    // Create mutation object
    const mutation: OfflineMutation = {
      id,
      type,
      entity,
      data,
      timestamp: Date.now(),
    };
    
    // Get existing mutations
    const existingMutationsStr = await AsyncStorage.getItem(OFFLINE_MUTATIONS_KEY);
    const existingMutations: OfflineMutation[] = existingMutationsStr 
      ? JSON.parse(existingMutationsStr) 
      : [];
    
    // Add new mutation
    existingMutations.push(mutation);
    
    // Save mutations back to storage
    await AsyncStorage.setItem(OFFLINE_MUTATIONS_KEY, JSON.stringify(existingMutations));
    
    // Also add to pending items for UI
    if (type === 'create' || type === 'update') {
      await addToPendingItems(id, entity, data);
    }
    
    return id;
  } catch (error) {
    console.error('Error saving offline mutation:', error);
    throw error;
  }
}
  ```

  *Exports: `setupBackgroundSync`*
  ```ts
export function setupBackgroundSync(): () => void {
  // Subscribe to network changes
  const unsubscribe = NetInfo.addEventListener(state => {
    // When we go from offline to online, sync mutations
    if (state.isConnected && state.isInternetReachable !== false) {
      syncOfflineMutations()
        .then(success => {
          console.log('Background sync completed:', success ? 'success' : 'with errors');
        })
        .catch(error => {
          console.error('Background sync failed:', error);
        });
    }
  });
  
  return unsubscribe;
}
  ```

  *Exports: `syncOfflineMutations`*
  ```ts
export async function syncOfflineMutations(): Promise<boolean> {
  try {
    // Check if we're online
    const netInfo = await NetInfo.fetch();
    if (!netInfo.isConnected || netInfo.isInternetReachable === false) {
      console.log('Not connected to the internet, skipping sync');
      return false;
    }
    
    // Get all pending mutations
    const mutationsStr = await AsyncStorage.getItem(OFFLINE_MUTATIONS_KEY);
    if (!mutationsStr) return true; // Nothing to sync
    
    const mutations: OfflineMutation[] = JSON.parse(mutationsStr);
    if (!mutations.length) return true; // Nothing to sync
    
    console.log(`Syncing ${mutations.length} offline mutations...`);
    
    // Process each mutation in order
    const results = await Promise.allSettled(
      mutations.map(async (mutation) => {
        try {
          switch (mutation.type) {
            case 'create':
              return await processMutation('create', mutation);
            case 'update':
              return await processMutation('update', mutation);
            case 'delete':
              return await processMutation('delete', mutation);
            default:
              console.error('Unknown mutation type:', mutation.type);
              return false;
          }
        } catch (error) {
          console.error('Error processing mutation:', error);
          return false;
        }
      })
    );
    
    // Check results
    const allSucceeded = results.every(
      result => result.status === 'fulfilled' && result.value === true
    );
    
    if (allSucceeded) {
      // Clear pending mutations if all succeeded
      await AsyncStorage.removeItem(OFFLINE_MUTATIONS_KEY);
      await AsyncStorage.removeItem(PENDING_ITEMS_KEY);
      
      // Invalidate queries to refresh data
      queryClient.invalidateQueries();
      
      return true;
    } else {
      // Some mutations failed, remove the successful ones
      const successfulMutationIndexes = results.map((result, index) => 
        result.status === 'fulfilled' && result.value === true ? index : -1
      ).filter(index => index !== -1);
      
      const remainingMutations = mutations.filter(
        (_, index) => !successfulMutationIndexes.includes(index)
      );
      
      // Save remaining mutations
      await AsyncStorage.setItem(
        OFFLINE_MUTATIONS_KEY, 
        JSON.stringify(remainingMutations)
      );
      
      // Refresh query data
      queryClient.invalidateQueries();
      
      return false;
    }
  } catch (error) {
    console.error('Error syncing offline mutations:', error);
    return false;
  }
}
  ```

- **utils/query-client.ts**

  *Exports: `queryClient`*
  ```ts
const queryClient = new QueryClient();
  ```

- **utils/settings.ts**

  *Exports: `APP_SETTINGS_KEY`*
  ```ts
const APP_SETTINGS_KEY = 'aether_app_settings';
  ```

  *Exports: `AppSettings`*
  ```ts
export type AppSettings = typeof DEFAULT_SETTINGS;
  ```

  *Exports: `getAppVersion`*
  ```ts
export function getAppVersion(): string {
  // In a real app, you would use expo-constants to get the app version
  // import Constants from 'expo-constants';
  // return Constants.expoConfig.version;
  return '1.0.0';
}
  ```

  *Exports: `getPlatformInfo`*
  ```ts
export function getPlatformInfo(): string {
  return `${Platform.OS} ${Platform.Version}`;
}
  ```

  *Exports: `getSettings`*
  ```ts
export async function getSettings(): Promise<AppSettings> {
  try {
    const storedSettings = await SecureStore.getItemAsync(APP_SETTINGS_KEY);
    if (!storedSettings) return DEFAULT_SETTINGS;
    
    return { ...DEFAULT_SETTINGS, ...JSON.parse(storedSettings) };
  } catch (error) {
    console.error('Error getting settings:', error);
    return DEFAULT_SETTINGS;
  }
}
  ```

  *Exports: `saveSettings`*
  ```ts
export async function saveSettings(settings: Partial<AppSettings>): Promise<void> {
  try {
    const currentSettings = await getSettings();
    const newSettings = { ...currentSettings, ...settings };
    
    await SecureStore.setItemAsync(
      APP_SETTINGS_KEY, 
      JSON.stringify(newSettings)
    );
  } catch (error) {
    console.error('Error saving settings:', error);
  }
}
  ```

  *Exports: `updateSetting`*
  ```ts
export async function updateSetting<K extends keyof AppSettings>(
  key: K, 
  value: AppSettings[K]
): Promise<void> {
  await saveSettings({ [key]: value } as Partial<AppSettings>);
}
  ```

- **utils/supabase.ts**

  *Exports: `getCurrentUser`*
  ```ts
const getCurrentUser = async () => {
  const { data, error } = await supabase.auth.getUser();
  if (error) {
    console.error('Error getting user:', error.message);
    return null;
  }
  return data.user;
};
  ```

  *Exports: `isAuthenticated`*
  ```ts
const isAuthenticated = async () => {
  const { data, error } = await supabase.auth.getSession();
  return !!data.session;
};
  ```

  *Exports: `supabase`*
  ```ts
const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: ExpoSecureStoreAdapter,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
});
  ```

- **utils/trpc.ts**

  *Exports: `RouterInputs`*
  ```ts
export type RouterInputs = TypedRouterInputs;
  ```

  *Exports: `RouterOutputs`*
  ```ts
export type RouterOutputs = TypedRouterOutputs;
  ```

  *Exports: `trpc`*
  ```ts
const trpc = createTRPCReact<AppRouter>();
  ```
