# Aether App Code Overview
Generated on Thu Apr 24 05:01:10 CDT 2025

## File: ./.eslintrc.js
```
// https://docs.expo.dev/guides/using-eslint/
module.exports = {
  extends: 'expo',
  ignorePatterns: ['/dist/*'],
  env: {
    'react-native/react-native': true, // for React Native environment (e.g. __DEV__)
    node: true,                      // allows Node globals like process, module
    jest: true                       // if you have test files using Jest globals
  },
  globals: {
    __DEV__: 'readonly',
  },
  rules: {
    // Optional: adjust specific lint rules if needed
  }
};
```

## File: ./AETHER_TODO.md
```
# AETHER ― UI / UX & CODE UPGRADE TODO

## 1. GLOBAL DESIGN PRINCIPLES
- [ ] One source of truth → Tamagui theme tokens only (no hex)  
- [ ] Hierarchy first → large titles, section headers, cards  
- [ ] Micro-feedback everywhere → haptics + 200–300 ms fade / slide  
- [ ] Three state rule → loading ⬩ empty ⬩ error for every list / card  
- [ ] Motion restraint → 60 fps on low-end device; keep Lottie / confetti ≤2 s  

## 2. APP-LEVEL TASK LIST (sorted by impact / effort ratio)
- [ ] Finish TypeScript wiring for tRPC & Expo-router: remove all `as any`, `// @ts-ignore`
- [ ] Replace Tabs-in-Settings with list-style grouped sections
- [ ] Add pull-to-refresh to Home dashboard (`RefreshControl`)
- [ ] Introduce global `<ErrorToast>` + dashboard section `error` prop
- [ ] Introduce Floating-Action-Button (FAB) that speed-dials to "New Task / Habit / Goal"
- [ ] Add confetti + haptic success when reward claimed
- [ ] Skeleton component refactor – consume everywhere
- [ ] Dark-mode safe "frosted card" variant wrapped in Tamagui `styled(Card)`

## 3. SCREEN-BY-SCREEN GUIDANCE
### A. HOME (DASHBOARD)
- [ ] Header: `headerLargeTitle ("Good Morning")` with date sub-title
- [ ] Each section = `DashboardSection` (show 3 items + "See All")
  - [ ] Props to add: `skeletonCount`, `error`, `onRetry`
- [ ] Quick Actions → replace 3 buttons with FAB (`@expo/react-native-action-sheet` or custom)
- [ ] Animations: `AnimatePresence` fade-in list items; bounce card on habit check
- [ ] Pull-to-refresh: `<ScrollView refreshControl={<RefreshControl …/>}>`

### B. PLANNER (Tabs Goals / Habits / Calendar)
- [ ] Goals Tab → mount `GoalsList`; pass `isLoading`, `error`
  - [ ] Goal card progress bar animates width on mount (`withTiming`)
- [ ] Habits Tab → reuse `HabitsList`; optimistic toggle + revert on error
- [ ] Calendar Tab → prototype with `react-native-calendars`; dots = tasks/habits
- [ ] Tab switch animation: wrap each `<Tabs.Content>` in `<MotiView from={{opacity:0}} animate={{opacity:1}}>`

### C. COMPASS (Principles / States)
- [ ] Principles list (Card per principle). Empty state with 🧭 illustration
- [ ] State Definitions list: reuse `StateIndicator`; allow swipe-to-edit
- [ ] Add "Add Principle / Add State" FAB local to tab

### D. REWARDS
- [ ] Points card: count-up animation (`useValue, withTiming`)
- [ ] Earned rewards → horizontal `FlatList` (keyExtractor)
- [ ] Available rewards → 2-col grid; button shows `<Spinner>` while claiming
- [ ] Success: confetti (`react-native-confetti-cannon`) + `Haptics.notificationAsync(success)`

### E. SETTINGS
- [ ] Convert Tabs to grouped list:  
  - [ ] Profile (username, avatar)  
  - [ ] Account (password, 2FA, delete)  
  - [ ] Appearance (Dark Mode, System-theme)  
  - [ ] Notifications (push, email toggles)  
- [ ] Dark-mode switch: tri-state (Light / Dark / System)
- [ ] Each row: Tamagui `ListItem` variant with right-chevron

### F. AUTH FLOW
- [ ] Add logo to Login / Register
- [ ] Use Toast (non-blocking) for basic errors; Alert for critical
- [ ] Show / hide password icon inside Inputs (`secureTextEntry` toggle)
- [ ] After Register → Verify screen: add "Open email app" deep-link button (`Linking.openURL('message://')`)

## 4. COMPONENT REFACTOR NOTES
### 1. DashboardSection
```typescript
interface DashboardSectionProps<T> {  
  title: string;  
  data: T[];  
  renderItem(item:T): ReactNode;  
  seeAllRoute?: string;  
  isLoading?: boolean;  
  skeletonCount?: number;   // NEW  
  error?: string;           // NEW  
  onRetry?(): void;         // NEW  
}
```

### 2. Skeleton
- [ ] `Skeleton` = Tamagui `Stack` with animated opacity pulse
- [ ] Use in DashboardSection, GoalsList, HabitsList, etc.

### 3. HabitCheckItem vs HabitsList item
- [ ] Extract pure dumb `HabitToggleRow` (checkbox + title + streak)
- [ ] Dashboard & list reuse; parent passes `onToggle()` & disables during mutation

### 4. GoalSummaryCard vs GoalCard
- [ ] Keep Summary (ring) for dashboard; Detailed (bars) for Goals tab / Details
- [ ] Both share style variant via Tamagui `styled(Card)`

### 5. OfflineIndicator
- [ ] Replace hardcoded red with `$errorBackground`; use `safeAreaInsets.top` on Android too

## 5. TYPESCRIPT / ESLINT REMEDIATION
### A. Server build error (TS6059)
- [ ] Fix: extend `rootDir` OR move shared `types/` under `server/src/`
  Quick fix in `server/tsconfig.json`:
  ```json
  "rootDir": "../",
  "include": ["src/**/*", "../types/**/*"]
  ```

### B. tRPC client typing
- [ ] Generate helper type once:  
  ```typescript
  import type { AppRouter } from 'server/src/router';  
  export const trpc = createTRPCReact<AppRouter>();  
  ```
- [ ] Remove every `// @ts-ignore` + `as any` route cast

### C. Expo-router path types
- [ ] `app.d.ts`
  ```typescript
  declare module 'expo-router' {  
    interface LinkProps { href: `/compose` | `/planner` | ... }  
  }
  ```
- [ ] Or simpler: `router.push({ pathname:'/planner' })`

### D. Missing type-defs packages
- [ ] `@types/shopify__flash-list`, `@types/react-native-reanimated`, etc.  
  `yarn add -D @types/shopify__flash-list`

### E. Lint script
- [ ] `"lint": "eslint \"{app,components,server}/**/*.{ts,tsx}\" --fix"`  
- [ ] Fix all unused vars / imports; prefer `catch (err: unknown)`

## 6. TAMAGUI BEST PRACTICES CHECKLIST
- [ ] Only Tamagui components for layout (YStack/XStack/Text/Card)
- [ ] Use theme tokens (`$color`, `$backgroundStrong`)
- [ ] Create `styled()` variants for repeatable styles (frostedCard, sectionHeader)
- [ ] Configure Tamagui Compiler (metro) for perf
- [ ] Use `AnimatePresence` & `Stack animation="quick"` rather than StyleSheet animations where possible

## 7. IMPLEMENTATION PLAN (2-Week Sprint)
- [ ] Day 1-2   → Fix TypeScript config, remove ignores, green CI
- [ ] Day 3-4   → Refactor Skeleton + DashboardSection; integrate error prop
- [ ] Day 5     → FAB component + swap into Home
- [ ] Day 6-7   → Settings redesign to grouped list
- [ ] Day 8     → Rewards polish (confetti, claim spinner)
- [ ] Day 9-10  → Minor screens (Compass, Planner animations), QA, polish

## Deliverables for this sprint
- [ ] All TS errors resolved, no `@ts-ignore` in `app/` or `server/`  
- [ ] Dashboard displays error banners and supports pull-to-refresh  
- [ ] FAB replaces "Quick Actions" buttons  
- [ ] Settings → grouped list; Dark-Mode tri-state switch  
- [ ] Claiming a reward plays confetti + haptic  
- [ ] 100% ESLint clean (`npm run lint` passes) ```

## File: ./README.md
```
# Aether App

A modern mobile application built with Expo, React Native, tRPC, and Tamagui.

## Project Structure

- `/app` - Expo Router app screens and navigation
- `/components` - Reusable UI components
- `/utils` - Utility functions and helpers
- `/server` - Express/tRPC backend server

## Getting Started

### Prerequisites

- Node.js 18+ 
- npm or yarn
- iOS Simulator or Android Emulator for mobile testing

### Installing

1. Clone the repository
2. Install dependencies:

```bash
npm install
```

3. Install server dependencies:

```bash
cd server
npm install
cd ..
```

### Running the App

**Start the backend server:**

```bash
cd server
npm run dev
```

This will start the tRPC server on [http://localhost:3000](http://localhost:3000).

**Start the Expo app:**

In a separate terminal:

```bash
npm start
```

This will launch the Expo development server. Press:
- `i` to open in iOS simulator
- `a` to open in Android emulator
- `w` to open in web browser

## Authentication

The app uses Supabase for secure authentication:

1. Create a free Supabase account at [supabase.com](https://supabase.com)
2. Create a new project and note your project URL and anon key
3. Create a `.env` file in the root of the project (copy from `.env.example`) and add your Supabase credentials
4. Authentication is already set up with the following features:
   - Email/password sign up and login
   - Session persistence with SecureStore
   - Password reset (through Supabase)

Demo credentials:
  - Email: `demo@example.com`
  - Password: `password`

## Development

### Backend Server

The backend server uses:
- Express
- tRPC for type-safe API
- In-memory data store (replace with a real DB in production)

Key endpoints:
- `/health` - Health check endpoint
- `/api/trpc` - tRPC API endpoint

### Mobile App

The app is organized using Expo Router file-based routing:
- `/app/(tabs)` - Main tabs after login
- `/app/auth` - Authentication screens (login/register)
- `/app/compose` - Modal screen example

## Project Roadmap

Phase 1 (In Progress):
- Core authentication flow
- Basic UI components
- API integration

Phase 2 (Upcoming):
- Offline sync capabilities
- Push notifications
- Performance optimizations

## Technologies

- Expo SDK 52
- React Native 0.76.x
- React 18.3
- TypeScript
- tRPC
- Tamagui UI
- NativeWind/Tailwind CSS
- React Query for data fetching/caching
```

## File: ./SUPABASE_INTEGRATION.md
```
# Aether App - Supabase Integration

## What's Been Integrated

1. **Supabase Authentication**
   - Email/password login and registration
   - Secure token storage using Expo SecureStore
   - Authentication state management
   - Automatic session refresh

2. **User Profiles**
   - Basic profile retrieval through Supabase
   - User metadata storage

3. **App Configuration**
   - Added settings management with SecureStore
   - Environment variable setup for Supabase credentials

## Setup Instructions

1. **Create a Supabase Project**
   - Sign up at [supabase.com](https://supabase.com)
   - Create a new project
   - Note your project URL and anon key

2. **Local Setup**
   - Copy `.env.example` to `.env`
   - Fill in your Supabase URL and anon key
   ```
   EXPO_PUBLIC_SUPABASE_URL=your_supabase_url_here
   EXPO_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key_here
   ```

3. **Database Setup in Supabase**
   - Create a `profiles` table with the SQL below:

   ```sql
   create table public.profiles (
     id uuid references auth.users not null primary key,
     username text,
     avatar_url text,
     created_at timestamp with time zone default now(),
     updated_at timestamp with time zone default now()
   );

   -- Enable RLS
   alter table public.profiles enable row level security;

   -- Create a policy that allows users to read all profiles
   create policy "Profiles are viewable by everyone" on profiles
     for select using (true);

   -- Create a policy that allows users to update only their own profile
   create policy "Users can update their own profile" on profiles
     for update using (auth.uid() = id);

   -- Function to create a profile when a user signs up
   create or replace function public.handle_new_user()
   returns trigger as $$
   begin
     insert into public.profiles (id, username, avatar_url)
     values (new.id, new.raw_user_meta_data->>'username', null);
     return new;
   end;
   $$ language plpgsql security definer;

   -- Trigger to create a profile when a user signs up
   create trigger on_auth_user_created
     after insert on auth.users
     for each row execute procedure public.handle_new_user();
   ```

## Next Steps

1. **Real-time Data Sync**
   - Set up Supabase Realtime for subscriptions
   - Implement data sync with React Query + Supabase

2. **Storage**
   - Implement Supabase Storage for file uploads (profile pictures, attachments)

3. **Offline Support**
   - Implement offline queue for mutations
   - Set up background sync

4. **Testing**
   - Create a test project in Supabase for CI/CD environments

## Implementation Details

### Authentication Flow

1. User enters credentials in login/register screen
2. Supabase SDK handles authentication
3. Supabase stores tokens in SecureStore
4. Authentication state is managed in _layout.tsx
5. Pages use authentication state to redirect as needed

### Profile Management

The `getUserProfile` function demonstrates how to:
1. Get the current authenticated user
2. Query their profile information from the database
3. Handle cases where the profile hasn't been created yet

### Logout Flow

The logout function:
1. Calls Supabase signOut
2. Clears session state
3. Redirects to login 

## Offline Support

We've implemented a comprehensive offline-first architecture using:

1. **React Query Persistence**
   - Queries are cached in AsyncStorage
   - Mutations are paused when offline and resumed when online
   - Cache is rehydrated on app restart

2. **Visual Indicators**
   - OfflineIndicator component shows network status
   - Pending items are marked with a visual badge

3. **Custom Offline Sync System**
   - Mutations are stored in AsyncStorage when offline
   - Automatic sync when the device reconnects
   - Support for create, update, and delete operations

### Using Offline Sync in Components

```tsx
import { useOfflineSync } from '@/hooks/useOfflineSync';

// In your component
function TaskList() {
  // Set up offline sync for the 'tasks' entity
  const { 
    isOnline, 
    pendingItems, 
    createItem, 
    updateItem, 
    deleteItem, 
    isItemPending 
  } = useOfflineSync<Task>('tasks');

  // Create a new task (works offline)
  const handleAddTask = async () => {
    const { id, isOffline } = await createItem({ 
      title: 'New Task',
      completed: false
    });
    
    // The task is created with a temporary ID if offline
    console.log(`Task created with ID: ${id}, offline: ${isOffline}`);
  };

  // In your render function, show pending state
  return (
    <View>
      {tasks.map(task => (
        <View key={task.id}>
          <Text>{task.title}</Text>
          {isItemPending(task.id) && (
            <Badge>Pending Sync</Badge>
          )}
        </View>
      ))}
    </View>
  );
}
``` ```

## File: ./app.d.ts
```
/// <reference types="nativewind/types" />

```

## File: ./app/(auth)/_layout.tsx
```
import { Stack } from 'expo-router';

// This layout simply defines the stack structure for the auth screens.
// The auth check and redirection happen in the root layout (app/_layout.tsx).
export default function AuthLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      {/* Define screens within the auth flow */}
      {/* Titles can be set here or within each screen file using Stack.Screen */}
      {/* Example:
      <Stack.Screen name="login" options={{ title: 'Sign In' }} />
      <Stack.Screen name="register" options={{ title: 'Sign Up' }} />
      <Stack.Screen name="forgot-password" options={{ title: 'Reset Password' }} />
      ... etc ...
      */}
    </Stack>
  );
} ```

## File: ./app/(auth)/forgot-password.tsx
```
import React, { useState } from 'react';
import { KeyboardAvoidingView, Platform, TouchableOpacity, Alert } from 'react-native';
import { Stack, router } from 'expo-router';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Input, Button, YStack, Text, Paragraph, View } from 'tamagui';
import { supabase } from '@/utils/supabase';

export default function ForgotPasswordScreen() {
  const [email, setEmail] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [resetSent, setResetSent] = useState(false);

  const handleResetPassword = async () => {
    if (!email) {
      Alert.alert('Error', 'Please enter your email address');
      return;
    }

    setIsLoading(true);
    
    try {
      const { error } = await supabase.auth.resetPasswordForEmail(email, {
        redirectTo: 'aether://update-password',
      });
      
      if (error) throw error;
      
      setResetSent(true);
    } catch (error: any) {
      Alert.alert('Error', error.message || 'Failed to send password reset email');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <View flex={1} backgroundColor="$background">
      <SafeAreaView style={{ flex: 1 }}>
        <Stack.Screen 
          options={{
            title: 'Reset Password',
          }}
        />
        
        <KeyboardAvoidingView 
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <View flex={1} padding="$6" justifyContent="center">
            <YStack space="$5" alignItems="center" width="100%">
              <Text 
                fontSize={28} 
                fontWeight="bold" 
                color="$primary" 
                marginBottom="$6"
                textAlign="center"
              >
                {resetSent ? 'Check Your Email' : 'Reset Your Password'}
              </Text>
              
              {!resetSent ? (
                <>
                  <Paragraph textAlign="center" marginBottom="$4" color="$colorSecondary" fontSize={15}>
                    Enter your email address and we'll send you a link to reset your password.
                  </Paragraph>
                  
                  <Input
                    placeholder="Email"
                    value={email}
                    onChangeText={setEmail}
                    autoCapitalize="none"
                    keyboardType="email-address"
                    size="$4"
                    width="100%"
                    fontSize={16}
                    height={56}
                    paddingHorizontal="$4"
                    borderWidth={1}
                    borderColor="$borderColor"
                    borderRadius="$4"
                  />
                  
                  <Button 
                    size="$4" 
                    theme="light_Button"
                    onPress={handleResetPassword}
                    disabled={isLoading}
                    marginTop="$4"
                    width="100%"
                    height={56}
                    opacity={isLoading ? 0.7 : 1}
                    fontSize={16}
                    fontWeight="600"
                  >
                    {isLoading ? 'Sending...' : 'Send Reset Link'}
                  </Button>
                </>
              ) : (
                <>
                  <Paragraph textAlign="center" marginBottom="$4" color="$colorSecondary" fontSize={15}>
                    If an account exists with {email}, we've sent a password reset link. 
                    Please check your email inbox and spam folder.
                  </Paragraph>
                  
                  <Button 
                    size="$4" 
                    theme="light_Button"
                    onPress={() => router.back()}
                    marginTop="$4"
                    width="100%"
                    height={56}
                    fontSize={16}
                    fontWeight="600"
                  >
                    Back to Login
                  </Button>
                </>
              )}
              
              <TouchableOpacity 
                onPress={() => router.back()} 
                style={{ marginTop: 12 }}
              >
                <Text color="$primary" fontWeight="500" fontSize={15}>Back to Login</Text>
              </TouchableOpacity>
            </YStack>
          </View>
        </KeyboardAvoidingView>
      </SafeAreaView>
    </View>
  );
} ```

## File: ./app/(auth)/login.tsx
```
import React, { useState } from 'react';
import { KeyboardAvoidingView, Platform, TouchableOpacity, Alert } from 'react-native';
import { Stack, router } from 'expo-router';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Input, Button, YStack, XStack, Text, Paragraph, View, H1, Spinner } from 'tamagui';
import { supabase } from '@/utils/supabase';

export default function LoginScreen() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleLogin = async () => {
    if (!email || !password) {
      Alert.alert('Error', 'Please enter email and password');
      return;
    }

    setIsLoading(true);
    
    try {
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });
      
      if (error) throw error;
      
      if (data.session) {
        // Check if email is verified (Supabase doesn't automatically check this)
        const { data: userData } = await supabase.auth.getUser();
        
        if (userData?.user?.email_confirmed_at) {
          router.replace('/');
        } else {
          // Email not verified, redirect to verification screen
          router.replace({
            pathname: '/auth/verify-email',
            params: { email: email }
          });
        }
      }
    } catch (error: any) {
      if (email === 'demo@example.com' && password === 'password') {
        Alert.alert('Demo Mode', 'Using demo account. In production, please create a Supabase account.');
        router.replace('/');
        setIsLoading(false);
        return;
      }
      
      // Check if the error is related to email verification
      if (error.message?.includes('email') && error.message?.includes('confirm')) {
        Alert.alert(
          'Email Not Verified', 
          'Please verify your email address before logging in.',
          [
            { 
              text: 'Resend Email', 
              onPress: () => {
                router.replace({
                  pathname: '/auth/verify-email',
                  params: { email: email }
                });
              } 
            },
            { text: 'OK', style: 'cancel' }
          ]
        );
      } else {
        Alert.alert('Login failed', error.message || 'Invalid credentials. Try demo@example.com/password.');
      }
    } finally {
      if (isLoading) setIsLoading(false);
    }
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: '$background' }}>
      <Stack.Screen options={{ title: 'Login' }} />
      <KeyboardAvoidingView 
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={{ flex: 1 }}
      >
        {/* @ts-ignore // TODO: Investigate Tamagui prop type issue */}
        <YStack flex={1} p="$6" jc="center" ai="center" space="$5">
          {/* Logo Placeholder */}
          <View style={{ width: 80, height: 80, backgroundColor: '$gray5', borderRadius: 40, marginBottom: 16 }} /> 
          
          {/* @ts-ignore // TODO: Investigate Tamagui prop type issue */}
          <H1 textAlign="center" mb="$8">
            Welcome to Aether
          </H1>
          
          <Input
            placeholder="Email"
            value={email}
            onChangeText={setEmail}
            autoCapitalize="none"
            keyboardType="email-address"
            size="$4" 
          />
          <Input
            placeholder="Password"
            value={password}
            onChangeText={setPassword}
            secureTextEntry
            size="$4"
          />
          
          <Button 
            onPress={handleLogin} 
            disabled={isLoading} 
            theme="light_Button"
            size="$4"
            // @ts-ignore // TODO: Investigate Tamagui prop type issue
            style={{ width: '100%' }}
            icon={isLoading ? () => <Spinner /> : undefined}
          >
            {isLoading ? 'Logging In...' : 'Login'}
          </Button>
          
          {/* @ts-ignore // TODO: Investigate Tamagui prop type issue */}
          <XStack jc="center" ai="center" space="$2" mt="$4">
            <Paragraph color="$colorSecondary" fontSize={15}>
              Don't have an account?
            </Paragraph>
            <TouchableOpacity onPress={() => router.push('/auth/register')}>
              <Text color="$primary" fontWeight="500" fontSize={15}>Register</Text>
            </TouchableOpacity>
          </XStack>
          
          <TouchableOpacity onPress={() => router.push('/auth/forgot-password')} style={{ marginTop: 12 }}>
            <Text color="$primary" fontWeight="500" fontSize={15}>Forgot Password?</Text>
          </TouchableOpacity>
          
          {/* Demo account info */}
          {/* @ts-ignore // TODO: Investigate Tamagui prop type issue */}
          <YStack 
            mt="$8" 
            p="$4" 
            backgroundColor="$backgroundStrong" 
            borderRadius="$4"
            space="$2"
            alignItems="center"
            // @ts-ignore // TODO: Investigate Tamagui prop type issue
            style={{ width: '100%' }}
          >
            <Text fontSize={14} fontWeight="bold">Demo Account</Text>
            <Text fontSize={13} color="$colorSecondary">Email: demo@example.com</Text>
            <Text fontSize={13} color="$colorSecondary">Password: password</Text>
            {/* @ts-ignore // TODO: Investigate Tamagui prop type issue */}
            <Button 
              onPress={handleLogin} 
              disabled={isLoading} 
              size="$3"
              chromeless
              // @ts-ignore // TODO: Investigate Tamagui prop type issue
              mt="$2"
              icon={isLoading ? () => <Spinner size="small" /> : undefined}
            >
              Login as Demo User
            </Button>
          </YStack>
        </YStack>
      </KeyboardAvoidingView>
    </SafeAreaView>
  );
} ```

## File: ./app/(auth)/register.tsx
```
import React, { useState } from 'react';
import { KeyboardAvoidingView, Platform, TouchableOpacity, Alert } from 'react-native';
import { Stack, router } from 'expo-router';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Input, Button, YStack, XStack, Text, Paragraph, View } from 'tamagui';
import { supabase } from '@/utils/supabase';

export default function RegisterScreen() {
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  const handleRegister = async () => {
    // Basic form validation
    if (!username || !email || !password || !confirmPassword) {
      Alert.alert('Error', 'Please fill in all fields');
      return;
    }

    if (password !== confirmPassword) {
      Alert.alert('Error', 'Passwords do not match');
      return;
    }
    
    if (password.length < 6) {
      Alert.alert('Error', 'Password must be at least 6 characters');
      return;
    }

    setIsLoading(true);
    
    try {
      // Sign up with Supabase auth
      const { data, error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          data: {
            username, // Store username in user metadata
          },
        },
      });
      
      if (error) throw error;
      
      if (data.user) {
        // Redirect to the verification screen
        router.replace({
          pathname: '/auth/verify-email',
          params: { email: email }
        });
      }
    } catch (error: any) {
      // Provide more specific error messages based on the Supabase error
      let errorMessage = 'An error occurred during registration';
      
      if (error.message) {
        if (error.message.includes('email already registered')) {
          errorMessage = 'This email is already registered. Please use a different email or login.';
        } else if (error.message.includes('password')) {
          errorMessage = error.message; // Use Supabase's password validation error messages
        } else if (error.message.includes('invalid email')) {
          errorMessage = 'The email address is invalid. Please enter a valid email.';
        } else {
          errorMessage = error.message;
        }
      }
      
      Alert.alert('Registration Failed', errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <View flex={1} backgroundColor="$background">
      <SafeAreaView style={{ flex: 1 }}>
        <Stack.Screen 
          options={{
            title: 'Create Account',
            headerLargeTitle: true,
          }}
        />
        
        <KeyboardAvoidingView 
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <View flex={1} padding="$6" justifyContent="center">
            <YStack space="$5" alignItems="center" width="100%">
              <Text 
                fontSize={30} 
                fontWeight="bold" 
                color="$primary" 
                marginBottom="$6"
                textAlign="center"
              >
                Join Aether
              </Text>
              
              {/* Username Input */}
              <Input
                placeholder="Username"
                value={username}
                onChangeText={setUsername}
                autoCapitalize="none"
                fontSize={16}
                height={56}
                paddingHorizontal="$4"
                width="100%"
                borderWidth={1}
                borderColor="$borderColor"
                borderRadius="$4"
              />
              
              {/* Email Input */}
              <Input
                placeholder="Email"
                value={email}
                onChangeText={setEmail}
                autoCapitalize="none"
                keyboardType="email-address"
                fontSize={16}
                height={56}
                paddingHorizontal="$4"
                width="100%"
                borderWidth={1}
                borderColor="$borderColor"
                borderRadius="$4"
                marginTop="$2"
              />
              
              {/* Password Input */}
              <Input
                placeholder="Password"
                value={password}
                onChangeText={setPassword}
                secureTextEntry
                fontSize={16}
                height={56}
                paddingHorizontal="$4"
                width="100%"
                borderWidth={1}
                borderColor="$borderColor"
                borderRadius="$4"
                marginTop="$2"
              />
              
              {/* Confirm Password Input */}
              <Input
                placeholder="Confirm Password"
                value={confirmPassword}
                onChangeText={setConfirmPassword}
                secureTextEntry
                fontSize={16}
                height={56}
                paddingHorizontal="$4"
                width="100%"
                borderWidth={1}
                borderColor="$borderColor"
                borderRadius="$4"
                marginTop="$2"
              />
              
              {/* Register Button */}
              <Button 
                theme="light_Button"
                onPress={handleRegister}
                disabled={isLoading}
                width="100%"
                height={56}
                marginTop="$5"
                paddingHorizontal="$4"
                borderRadius="$4"
                opacity={isLoading ? 0.7 : 1}
                fontSize={16}
                fontWeight="600"
              >
                {isLoading ? 'Creating Account...' : 'Create Account'}
              </Button>
              
              {/* Login link */}
              <XStack justifyContent="center" alignItems="center" space="$2" marginTop="$6">
                <Paragraph color="$colorSecondary" fontSize={15}>
                  Already have an account?
                </Paragraph>
                <TouchableOpacity 
                  onPress={() => router.back()}
                  style={{ padding: 6 }} // Increased touch target
                >
                  <Text color="$primary" fontWeight="600" fontSize={15}>Login</Text>
                </TouchableOpacity>
              </XStack>
            </YStack>
          </View>
        </KeyboardAvoidingView>
      </SafeAreaView>
    </View>
  );
} ```

## File: ./app/(auth)/update-password.tsx
```
import React, { useState, useEffect } from 'react';
import { KeyboardAvoidingView, Platform, TouchableOpacity, Alert } from 'react-native';
import { Stack, router } from 'expo-router';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Input, Button, YStack, Text, Paragraph, View } from 'tamagui';
import { supabase } from '@/utils/supabase';

export default function UpdatePasswordScreen() {
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [success, setSuccess] = useState(false);

  // Check if we have a password reset session
  useEffect(() => {
    const checkSession = async () => {
      const { data, error } = await supabase.auth.getSession();
      if (error || !data.session) {
        Alert.alert(
          'Invalid Session', 
          'This password reset link is invalid or has expired. Please request a new password reset.',
          [{ text: 'OK', onPress: () => router.replace('/auth/login') }]
        );
      }
    };
    
    checkSession();
  }, []);

  const handleUpdatePassword = async () => {
    if (!password || !confirmPassword) {
      Alert.alert('Error', 'Please enter your new password');
      return;
    }

    if (password !== confirmPassword) {
      Alert.alert('Error', 'Passwords do not match');
      return;
    }
    
    if (password.length < 6) {
      Alert.alert('Error', 'Password must be at least 6 characters');
      return;
    }

    setIsLoading(true);
    
    try {
      const { error } = await supabase.auth.updateUser({
        password: password
      });
      
      if (error) throw error;
      
      setSuccess(true);
      // Wait 2 seconds before redirecting to login
      setTimeout(() => {
        router.replace('/auth/login');
      }, 2000);
    } catch (error: any) {
      Alert.alert('Error', error.message || 'Failed to update password');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <View flex={1} backgroundColor="$background">
      <SafeAreaView style={{ flex: 1 }}>
        <Stack.Screen 
          options={{
            title: 'Update Password',
          }}
        />
        
        <KeyboardAvoidingView 
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <View flex={1} padding="$6" justifyContent="center">
            <YStack space="$5" alignItems="center" width="100%">
              <Text 
                fontSize={28} 
                fontWeight="bold" 
                color="$primary" 
                marginBottom="$6"
                textAlign="center"
              >
                {success ? 'Password Updated' : 'Create New Password'}
              </Text>
              
              {!success ? (
                <>
                  <Paragraph textAlign="center" marginBottom="$4" color="$colorSecondary" fontSize={15}>
                    Enter your new password below.
                  </Paragraph>
                  
                  <Input
                    placeholder="New Password"
                    value={password}
                    onChangeText={setPassword}
                    secureTextEntry
                    size="$4"
                    width="100%"
                    marginBottom="$2"
                    fontSize={16}
                    height={56}
                    paddingHorizontal="$4"
                    borderWidth={1}
                    borderColor="$borderColor"
                    borderRadius="$4"
                  />
                  
                  <Input
                    placeholder="Confirm New Password"
                    value={confirmPassword}
                    onChangeText={setConfirmPassword}
                    secureTextEntry
                    size="$4"
                    width="100%"
                    fontSize={16}
                    height={56}
                    paddingHorizontal="$4"
                    borderWidth={1}
                    borderColor="$borderColor"
                    borderRadius="$4"
                  />
                  
                  <Button 
                    size="$4" 
                    theme="light_Button"
                    onPress={handleUpdatePassword}
                    disabled={isLoading}
                    marginTop="$4"
                    width="100%"
                    height={56}
                    opacity={isLoading ? 0.7 : 1}
                    fontSize={16}
                    fontWeight="600"
                  >
                    {isLoading ? 'Updating...' : 'Update Password'}
                  </Button>
                </>
              ) : (
                <Paragraph textAlign="center" marginBottom="$4" color="$colorSecondary" fontSize={15}>
                  Your password has been updated successfully. You will be redirected to the login screen.
                </Paragraph>
              )}
            </YStack>
          </View>
        </KeyboardAvoidingView>
      </SafeAreaView>
    </View>
  );
} ```

## File: ./app/(auth)/verify-email.tsx
```
import React, { useState } from 'react';
import { KeyboardAvoidingView, Platform, TouchableOpacity, Alert } from 'react-native';
import { Stack, router, useLocalSearchParams } from 'expo-router';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Button, YStack, Text, Paragraph, View } from 'tamagui';
import { supabase } from '@/utils/supabase';

export default function VerifyEmailScreen() {
  const { email } = useLocalSearchParams<{ email: string }>();
  const [isResending, setIsResending] = useState(false);

  const handleResendEmail = async () => {
    if (!email) {
      Alert.alert('Error', 'Email address is missing');
      return;
    }

    setIsResending(true);
    
    try {
      const { error } = await supabase.auth.resend({
        type: 'signup',
        email: email as string,
      });
      
      if (error) throw error;
      
      Alert.alert('Email Sent', 'Verification email has been resent');
    } catch (error: any) {
      Alert.alert('Error', error.message || 'Failed to resend verification email');
    } finally {
      setIsResending(false);
    }
  };

  return (
    <View flex={1} backgroundColor="$background">
      <SafeAreaView style={{ flex: 1 }}>
        <Stack.Screen 
          options={{
            title: 'Verify Email',
          }}
        />
        
        <KeyboardAvoidingView 
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <View flex={1} padding="$6" justifyContent="center">
            <YStack space="$5" alignItems="center" width="100%">
              <Text 
                fontSize={28} 
                fontWeight="bold" 
                color="$primary" 
                marginBottom="$6"
                textAlign="center"
              >
                Verify Your Email
              </Text>
              
              <Paragraph textAlign="center" marginBottom="$4" color="$colorSecondary" fontSize={15}>
                We've sent a verification email to:
              </Paragraph>
              
              <Text 
                fontSize={18} 
                fontWeight="bold" 
                marginBottom="$6"
                textAlign="center"
              >
                {email || 'your email address'}
              </Text>
              
              <Paragraph textAlign="center" marginBottom="$4" color="$colorSecondary" fontSize={15}>
                Please check your inbox and click the verification link to activate your account.
                If you don't see it, check your spam folder.
              </Paragraph>
              
              <Button 
                size="$4" 
                theme="light_Button"
                onPress={handleResendEmail}
                disabled={isResending}
                marginTop="$4"
                width="100%"
                height={56}
                opacity={isResending ? 0.7 : 1}
                fontSize={16}
                fontWeight="600"
              >
                {isResending ? 'Sending...' : 'Resend Verification Email'}
              </Button>
              
              <TouchableOpacity 
                onPress={() => router.replace('/auth/login')} 
                style={{ marginTop: 12 }}
              >
                <Text color="$primary" fontWeight="500" fontSize={15}>Back to Login</Text>
              </TouchableOpacity>
            </YStack>
          </View>
        </KeyboardAvoidingView>
      </SafeAreaView>
    </View>
  );
} ```

## File: ./app/(tabs)/_layout.tsx
```
import { Tabs } from 'expo-router';
import React from 'react';
import { Platform } from 'react-native';

import { HapticTab } from '@/components/HapticTab';
import { IconSymbol } from '@/components/ui/IconSymbol';
import TabBarBackground from '@/components/ui/TabBarBackground';
import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function TabLayout() {
  const colorScheme = useColorScheme();

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: Colors[colorScheme ?? 'light'].tint,
        headerShown: false,
        tabBarButton: HapticTab,
        tabBarBackground: TabBarBackground,
        tabBarStyle: Platform.select({
          ios: {
            // Use a transparent background on iOS to show the blur effect
            position: 'absolute',
          },
          default: {},
        }),
      }}>
      <Tabs.Screen
        name="home"
        options={{
          title: 'Home',
          tabBarIcon: ({ color }) => <IconSymbol size={28} name="house.fill" color={color} />,
        }}
      />
      <Tabs.Screen
        name="planner"
        options={{
          title: 'Planner',
          tabBarIcon: ({ color }) => <IconSymbol size={28} name="calendar" color={color} />,
        }}
      />
      <Tabs.Screen
        name="compass"
        options={{
          title: 'Compass',
          tabBarIcon: ({ color }) => <IconSymbol size={28} name="location.north.fill" color={color} />,
        }}
      />
      <Tabs.Screen
        name="rewards"
        options={{
          title: 'Rewards',
          tabBarIcon: ({ color }) => <IconSymbol size={28} name="star.fill" color={color} />,
        }}
      />
      <Tabs.Screen
        name="settings"
        options={{
          title: 'Settings',
          tabBarIcon: ({ color }) => <IconSymbol size={28} name="gear" color={color} />,
        }}
      />
    </Tabs>
  );
}
```

## File: ./app/(tabs)/compass/index.tsx
```
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { Tabs, YStack, Card } from 'tamagui';
import { Stack, useRouter } from 'expo-router';
import { SafeAreaView } from 'react-native-safe-area-context';
import { IconSymbol } from '@/components/ui/IconSymbol';
import EmptyOrSkeleton from '@/components/EmptyOrSkeleton';
import { trpc } from '@/utils/trpc';
import { FloatingActionButton } from '@/components/ui/FloatingActionButton';

export default function CompassScreen() {
  const router = useRouter();
  
  // Fetch values data (principles) using tRPC
  const { 
    data: valuesData, 
    isLoading: valuesLoading, 
    error: valuesError,
    refetch: refetchValues
  } = trpc.value.getAll.useQuery();
  
  // Fetch tracked states using tRPC
  const { 
    data: statesData, 
    isLoading: statesLoading, 
    error: statesError,
    refetch: refetchStates
  } = trpc.state.getDefinitions.useQuery();
  
  return (
    <SafeAreaView className="flex-1 bg-ios-system">
      <Stack.Screen 
        options={{
          title: 'Compass',
          headerLargeTitle: true,
        }}
      />
      
      <View className="flex-1 p-4">
        <Tabs
          defaultValue="principles"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          backgroundColor="transparent"
        >
          <Tabs.List className="mx-auto mb-4">
            <Tabs.Tab value="principles" className="px-4 py-2">
              <Text className="text-ios-primary font-medium">Principles</Text>
            </Tabs.Tab>
            <Tabs.Tab value="states" className="px-4 py-2">
              <Text className="text-ios-primary font-medium">State Definitions</Text>
            </Tabs.Tab>
          </Tabs.List>
          
          <Tabs.Content value="principles" className="flex-1">
            <EmptyOrSkeleton
              isLoading={valuesLoading}
              isEmpty={!valuesData || valuesData.length === 0}
              title="No Principles Defined"
              message="Define your personal operating principles to guide your decisions"
              skeletonCount={3}
              skeletonHeight={150}
            >
              <YStack space="$3">
                {valuesData?.map((value) => (
                  <PrincipleCard
                    key={value.id}
                    principle={value}
                    onPress={() => router.push(`/values/${value.id}`)}
                  />
                ))}
              </YStack>
            </EmptyOrSkeleton>
            
            {valuesError && (
              <View className="p-4 mt-2 bg-red-50 rounded-md">
                <Text className="text-red-600">Error loading principles: {valuesError.message}</Text>
                <Text className="text-red-600 underline mt-2" onPress={() => refetchValues()}>
                  Retry
                </Text>
              </View>
            )}
          </Tabs.Content>
          
          <Tabs.Content value="states" className="flex-1">
            <EmptyOrSkeleton
              isLoading={statesLoading}
              isEmpty={!statesData || statesData.length === 0}
              title="No States Defined"
              message="Define your tracked states to monitor important metrics in your life"
              skeletonCount={4}
              skeletonHeight={100}
            >
              <YStack space="$3">
                {statesData?.map((state) => (
                  <StateDefinitionCard
                    key={state.id}
                    state={state}
                    onPress={() => router.push(`/states/${state.id}`)}
                  />
                ))}
              </YStack>
            </EmptyOrSkeleton>
            
            {statesError && (
              <View className="p-4 mt-2 bg-red-50 rounded-md">
                <Text className="text-red-600">Error loading state definitions: {statesError.message}</Text>
                <Text className="text-red-600 underline mt-2" onPress={() => refetchStates()}>
                  Retry
                </Text>
              </View>
            )}
          </Tabs.Content>
        </Tabs>
      </View>
      
      <FloatingActionButton
        actions={[
          {
            label: 'Add Principle',
            onPress: () => router.push('/compose?type=value'),
          },
          {
            label: 'Define State',
            onPress: () => router.push('/compose?type=state'),
          },
        ]}
      />
    </SafeAreaView>
  );
}

// Component for displaying personal values/principles
function PrincipleCard({ principle, onPress }) {
  return (
    <Card
      backgroundColor="$cardBackground"
      padding="$4"
      borderRadius="$4"
      onPress={onPress}
      pressStyle={{ opacity: 0.8 }}
    >
      <YStack>
        <Text className="text-lg font-semibold text-ios-primary">{principle.title}</Text>
        {principle.description && (
          <Text className="text-ios-gray-1 mt-2" numberOfLines={3}>
            {principle.description}
          </Text>
        )}
        <View className="flex-row mt-3 items-center">
          <IconSymbol name="star.fill" size={16} color="#FFD60A" />
          <Text className="text-ios-primary ml-1">Priority: {principle.priority || 'Medium'}</Text>
        </View>
      </YStack>
    </Card>
  );
}

// Component for displaying tracked state definitions
function StateDefinitionCard({ state, onPress }) {
  const getStateColor = (type) => {
    switch (type) {
      case 'energy': return '#FF9500';
      case 'mood': return '#5E5CE6';
      case 'focus': return '#34C759';
      default: return '#007AFF';
    }
  };
  
  return (
    <Card
      backgroundColor="$cardBackground"
      padding="$4"
      borderRadius="$4"
      onPress={onPress}
      pressStyle={{ opacity: 0.8 }}
    >
      <View className="flex-row items-center justify-between">
        <View>
          <Text className="text-lg font-semibold text-ios-primary">{state.name}</Text>
          <Text className="text-ios-gray-1 mt-1">
            {state.description ? state.description : `Track your ${state.name.toLowerCase()}`}
          </Text>
        </View>
        <View 
          style={{ 
            width: 32, 
            height: 32, 
            borderRadius: 16, 
            backgroundColor: getStateColor(state.type),
            justifyContent: 'center',
            alignItems: 'center'
          }}
        >
          <IconSymbol 
            name={state.type === 'energy' ? 'bolt.fill' : 
                 state.type === 'mood' ? 'heart.fill' : 
                 state.type === 'focus' ? 'brain.head.profile' : 'gauge'}
            size={18} 
            color="white" 
          />
        </View>
      </View>
    </Card>
  );
} ```

## File: ./app/(tabs)/home/_layout.tsx
```
import { Stack } from 'expo-router';
import React from 'react';

// This layout handles the stack navigation *within* the Home tab.
export default function HomeStackLayout() {
  return (
    <Stack
      screenOptions={{
        // Apply iOS large title styles
        headerLargeTitle: true,
        headerTransparent: true, // Often used with large titles
        headerBlurEffect: 'regular', // Matches iOS blur
      }}
    >
      <Stack.Screen 
        name="index" 
        options={{ title: 'Home Feed' }} // Set the title for the main screen
      />
      {/* Add other screens in the Home stack here, e.g.: */}
      <Stack.Screen 
        name="details" 
        options={{ 
          title: 'Details', 
          // Tab bar hiding is handled within the screen component itself
          // headerBackTitleVisible: false // Optional: Hide back button title
        }} 
      />
    </Stack>
  );
} ```

## File: ./app/(tabs)/home/details.tsx
```
import { View, Text } from 'react-native';
import { Stack, useNavigation } from 'expo-router';
import { useLayoutEffect } from 'react';

export default function DetailScreen() {
  const navigation = useNavigation();

  useLayoutEffect(() => {
    // Try to get the parent navigator (which should be the Tabs navigator)
    const parentNavigator = navigation.getParent();

    if (parentNavigator) {
      // Hide the tab bar
      parentNavigator.setOptions({ tabBarStyle: { display: 'none' } });
    }

    // Reset the tab bar style when the screen is unfocused
    return () => {
      if (parentNavigator) {
        parentNavigator.setOptions({ tabBarStyle: { display: 'flex' } }); // Or use the default style object
      }
    };
  }, [navigation]);

  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Stack.Screen options={{ title: 'Details' }} />
      <Text>Details Screen Content</Text>
    </View>
  );
} ```

## File: ./app/(tabs)/home/index.tsx
```
import React from 'react';
import { Stack, YStack, ScrollView, H3, H4, Button } from 'tamagui';
import { StatusBar } from 'expo-status-bar';
import { Link } from 'expo-router';
import { useState } from 'react';
import { Stack as ExpoStack } from 'expo-router';
import { router } from 'expo-router';
import * as Haptics from 'expo-haptics';
import { ListPlus, CheckSquare, Activity } from '@tamagui/lucide-icons';

import { trpc } from '@/utils/trpc';
import { useUiStore } from '@/stores/uiStore';

// Import dashboard components
import DashboardSection from '@/components/dashboard/DashboardSection';
import TaskItem from '@/components/dashboard/TaskItem';
import GoalSummaryCard from '@/components/dashboard/GoalSummaryCard';
import HabitCheckItem from '@/components/dashboard/HabitCheckItem';
import StateIndicator from '@/components/dashboard/StateIndicator';
import { HomeActionButton } from '@/components/ui/FloatingActionButton';

// Define mock types for development 
// (These would normally come from your types directory)
interface Task {
  id: string;
  title: string;
  status: string;
  due?: string;
  priority?: number;
}

interface Goal {
  id: string;
  title: string;
  progress: number;
  tasks?: {
    total: number;
    completed: number;
  };
}

interface Habit {
  id: string;
  title: string;
  streak: number;
  completedToday: boolean;
}

interface State {
  id: string;
  name: string;
  currentValue: number | string;
  lastUpdated: string | null;
}

export default function HomeScreen() {
  // tRPC Queries - Use correct procedure names
  const helloQuery = trpc.greeting.hello.useQuery({ name: 'from tRPC' });
  const profileQuery = trpc.user.getProfile.useQuery();

  // Mock queries - Use correct procedure names and input objects
  const activeTasks = trpc.task.getTasks.useQuery({});
  const activeGoals = trpc.goal.getGoals.useQuery();
  const dailyHabits = trpc.habit.getHabits.useQuery();
  const trackedStates = trpc.state.getTrackedStates.useQuery({});
  
  // Zustand State
  const { isDarkMode, toggleTheme } = useUiStore();
  
  // tRPC Mutation - Use correct procedure name and adjust input
  const createHabitEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: () => {
      // Refetch habits list (or maybe entries?)
      dailyHabits.refetch(); 
    }
  });
  
  // Function to handle habit toggle - Adjust input for createHabitEntry
  const handleHabitToggle = (habitId: string, completed: boolean) => {
    const todayDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
    createHabitEntryMutation.mutate({ 
      habitId: habitId, 
      date: todayDate, 
      completed: completed 
    });
    // Maybe use different haptic for create vs update?
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success); 
  };

  return (
    <YStack flex={1} backgroundColor="$background">
      <ScrollView contentContainerStyle={{ padding: '$4' }}>
        <YStack space="$6">
          {/* Header/Welcome */}
          {/* @ts-ignore // TODO: Investigate Tamagui prop type issue */}
          <YStack mb="$3" mt="$3">
            <H3>
              Dashboard
            </H3>
          </YStack>
          
          {/* Today's Focus Section */}
          <DashboardSection 
            title="Today's Focus" 
            data={activeTasks.data}
            isLoading={activeTasks.isLoading}
            emptyMessage="No tasks due today"
            error={activeTasks.error?.message}
            onRetry={() => activeTasks.refetch()}
            renderItem={(task: Task) => (
              <TaskItem 
                task={task}
                onPress={() => {
                  Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                  router.push("/planner");
                }}
              />
            )}
          />
          
          {/* Active Goals Section */}
          <DashboardSection 
            title="Active Goals" 
            data={activeGoals.data}
            isLoading={activeGoals.isLoading}
            emptyMessage="No active goals"
            error={activeGoals.error?.message}
            onRetry={() => activeGoals.refetch()}
            renderItem={(goal: Goal) => (
              <GoalSummaryCard 
                goal={goal}
                onPress={() => {
                  Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                  router.push("/planner");
                }}
              />
            )}
          />
          
          {/* Daily Habits Section */}
          <DashboardSection 
            title="Daily Habits" 
            data={dailyHabits.data}
            isLoading={dailyHabits.isLoading}
            emptyMessage="No habits for today"
            error={dailyHabits.error?.message}
            onRetry={() => dailyHabits.refetch()}
            renderItem={(habit: Habit) => (
              <HabitCheckItem 
                habit={habit}
                onToggle={handleHabitToggle}
              />
            )}
          />
          
          {/* Current State Section */}
          <DashboardSection 
            title="Current State" 
            data={trackedStates.data}
            isLoading={trackedStates.isLoading}
            emptyMessage="No tracked states"
            error={trackedStates.error?.message}
            onRetry={() => trackedStates.refetch()}
            renderItem={(state: State) => (
              <StateIndicator 
                state={state}
                onPress={() => {
                  Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
                  router.push("/compass");
                }}
              />
            )}
          />
        </YStack>
      </ScrollView>
      <StatusBar style="auto" />
      
      {/* Floating Action Button for Quick Actions */}
      <HomeActionButton />
    </YStack>
  );
} ```

## File: ./app/(tabs)/index.tsx
```
import { Redirect } from 'expo-router';

export default function TabsIndex() {
  // This ensures the tabs group has a default route
  return <Redirect href="/(tabs)/home" />;
} ```

## File: ./app/(tabs)/planner/index.tsx
```
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { Tabs, YStack } from 'tamagui';
import { Stack, useRouter } from 'expo-router';
import { SafeAreaView } from 'react-native-safe-area-context';
import { IconSymbol } from '@/components/ui/IconSymbol';
import EmptyOrSkeleton from '@/components/EmptyOrSkeleton';
import { trpc } from '@/utils/trpc';
import { FloatingActionButton } from '@/components/ui/FloatingActionButton';

export default function PlannerScreen() {
  const router = useRouter();
  
  // Fetch goals data using tRPC
  const { 
    data: goalsData, 
    isLoading: goalsLoading, 
    error: goalsError,
    refetch: refetchGoals
  } = trpc.goal.getAll.useQuery();
  
  // Fetch habits data using tRPC
  const { 
    data: habitsData, 
    isLoading: habitsLoading, 
    error: habitsError,
    refetch: refetchHabits
  } = trpc.habit.getAll.useQuery();
  
  return (
    <SafeAreaView className="flex-1 bg-ios-system">
      <Stack.Screen 
        options={{
          title: 'Planner',
          headerLargeTitle: true,
        }}
      />
      
      <View className="flex-1 p-4">
        <Tabs
          defaultValue="goals"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          backgroundColor="transparent"
        >
          <Tabs.List className="mx-auto mb-4">
            <Tabs.Tab value="goals" className="px-4 py-2">
              <Text className="text-ios-primary font-medium">Goals</Text>
            </Tabs.Tab>
            <Tabs.Tab value="habits" className="px-4 py-2">
              <Text className="text-ios-primary font-medium">Habits</Text>
            </Tabs.Tab>
            <Tabs.Tab value="calendar" className="px-4 py-2">
              <Text className="text-ios-primary font-medium">Calendar</Text>
            </Tabs.Tab>
          </Tabs.List>
          
          <Tabs.Content value="goals" className="flex-1">
            <EmptyOrSkeleton
              isLoading={goalsLoading}
              isEmpty={!goalsData || goalsData.length === 0}
              title="No Goals Yet"
              message="Create your first goal to start tracking your progress"
              skeletonCount={4}
              skeletonHeight={120}
            >
              <YStack space="$3">
                {goalsData?.map((goal) => (
                  <GoalCard
                    key={goal.id}
                    goal={goal}
                    onPress={() => router.push(`/goals/${goal.id}`)}
                  />
                ))}
              </YStack>
            </EmptyOrSkeleton>
            
            {goalsError && (
              <View className="p-4 mt-2 bg-red-50 rounded-md">
                <Text className="text-red-600">Error loading goals: {goalsError.message}</Text>
                <Text className="text-red-600 underline mt-2" onPress={() => refetchGoals()}>
                  Retry
                </Text>
              </View>
            )}
          </Tabs.Content>
          
          <Tabs.Content value="habits" className="flex-1">
            <EmptyOrSkeleton
              isLoading={habitsLoading}
              isEmpty={!habitsData || habitsData.length === 0}
              title="No Habits Yet"
              message="Add some habits to build consistency"
              skeletonCount={5}
              skeletonHeight={80}
            >
              <YStack space="$3">
                {habitsData?.map((habit) => (
                  <HabitListItem
                    key={habit.id}
                    habit={habit}
                    onPress={() => router.push(`/habits/${habit.id}`)}
                  />
                ))}
              </YStack>
            </EmptyOrSkeleton>
            
            {habitsError && (
              <View className="p-4 mt-2 bg-red-50 rounded-md">
                <Text className="text-red-600">Error loading habits: {habitsError.message}</Text>
                <Text className="text-red-600 underline mt-2" onPress={() => refetchHabits()}>
                  Retry
                </Text>
              </View>
            )}
          </Tabs.Content>
          
          <Tabs.Content value="calendar" className="flex-1">
            <View className="flex-1 items-center justify-center">
              <IconSymbol name="calendar" size={48} color="#ccc" />
              <Text className="text-ios-primary text-xl mt-4">Calendar View</Text>
              <Text className="text-ios-gray-1 mt-2 text-center">
                Calendar integration is coming in the next update.
                You'll be able to see all your tasks and goals in one place.
              </Text>
            </View>
          </Tabs.Content>
        </Tabs>
      </View>
      
      <FloatingActionButton
        actions={[
          {
            label: 'Add Goal',
            onPress: () => router.push('/compose?type=goal'),
          },
          {
            label: 'Add Habit',
            onPress: () => router.push('/compose?type=habit'),
          },
        ]}
      />
    </SafeAreaView>
  );
}

// Simple component for displaying Goal cards
function GoalCard({ goal, onPress }) {
  return (
    <YStack
      backgroundColor="$cardBackground"
      padding="$4"
      borderRadius="$4"
      onPress={onPress}
      pressStyle={{ opacity: 0.8 }}
    >
      <Text className="text-lg font-semibold text-ios-primary">{goal.title}</Text>
      {goal.description && (
        <Text className="text-ios-gray-1 mt-1" numberOfLines={2}>
          {goal.description}
        </Text>
      )}
      <View className="flex-row justify-between mt-3">
        <Text className="text-ios-primary">
          Progress: {Math.round(goal.progress * 100)}%
        </Text>
        <Text className="text-ios-primary">
          {new Date(goal.dueDate).toLocaleDateString()}
        </Text>
      </View>
    </YStack>
  );
}

// Simple component for displaying Habit list items
function HabitListItem({ habit, onPress }) {
  return (
    <YStack
      backgroundColor="$cardBackground"
      padding="$4"
      borderRadius="$4"
      onPress={onPress}
      pressStyle={{ opacity: 0.8 }}
      flexDirection="row"
      alignItems="center"
      justifyContent="space-between"
    >
      <View>
        <Text className="text-lg font-semibold text-ios-primary">{habit.title}</Text>
        <Text className="text-ios-gray-1 mt-1">
          {habit.frequency} • Streak: {habit.streak || 0} days
        </Text>
      </View>
      <IconSymbol 
        name={habit.completed ? "checkmark.circle.fill" : "circle"} 
        size={28} 
        color={habit.completed ? "#34C759" : "#ccc"} 
      />
    </YStack>
  );
} ```

## File: ./app/(tabs)/rewards/index.tsx
```
import React, { useState, useEffect, useMemo } from 'react';
import { View, ScrollView, RefreshControl, Image, Pressable, StyleSheet } from 'react-native';
import { Text, XStack, YStack, Button, Card, H3, H4, Paragraph, Separator, Spinner } from 'tamagui';
import { Stack } from 'expo-router';
import { useColorScheme } from 'react-native';
import { Colors } from '@/constants/Colors';
import { trpc } from '@/utils/trpc';
import { Award, Trophy, Gift, Star } from '@tamagui/lucide-icons';
import * as Haptics from 'expo-haptics';
import { PointsText } from '@/components/ui/AnimatedCountingText';
import { ConfettiButton } from '@/components/ui/ConfettiButton';

export default function RewardsScreen() {
  const [refreshing, setRefreshing] = useState(false);
  const colorScheme = useColorScheme();
  
  // Fetch user rewards data
  const { 
    data: points, 
    isLoading: pointsLoading,
    refetch: refetchPoints
  } = trpc.rewards.getUserPoints.useQuery();
  
  const {
    data: userRewards,
    isLoading: userRewardsLoading,
    refetch: refetchUserRewards
  } = trpc.rewards.getUserRewards.useQuery();
  
  const {
    data: availableRewards,
    isLoading: availableRewardsLoading,
    refetch: refetchAvailableRewards
  } = trpc.rewards.getAvailableRewards.useQuery();
  
  const { 
    mutateAsync: earnRewardMutate,
    isPending: isEarningReward,
    variables: earningRewardVariables
  } = trpc.rewards.earnReward.useMutation({
    onSuccess: () => {
      refetchPoints();
      refetchUserRewards();
      refetchAvailableRewards();
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    }
  });
  
  const onRefresh = async () => {
    setRefreshing(true);
    await Promise.all([
      refetchPoints(),
      refetchUserRewards(),
      refetchAvailableRewards()
    ]);
    setRefreshing(false);
  };
  
  const handleClaimReward = async (rewardId: string) => {
    try {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
      await earnRewardMutate({ lootId: rewardId });
    } catch (error: any) {
      console.error('Failed to claim reward:', error.message);
    }
  };
  
  const isLoading = pointsLoading || userRewardsLoading || availableRewardsLoading;
  
  return (
    <View style={styles.container}>
      <Stack.Screen options={{ title: 'Rewards' }} />
      
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
        }
      >
        {/* Points Display */}
        // @ts-ignore // TODO: Investigate Tamagui prop type issue
        <Card elevate bordered mb="$4">
          <Card.Header padded>
            <H3>Points Balance</H3>
          </Card.Header>
          <Card.Footer padded>
            <XStack justifyContent="space-between" alignItems="center" width="100%">
              <YStack>
                <Paragraph>Current Balance</Paragraph>
                <H4 color={Colors[colorScheme ?? 'light'].tint}>
                  {pointsLoading ? '--' : points?.points || 0} pts
                </H4>
              </YStack>
              <YStack>
                <Paragraph>Lifetime Points</Paragraph>
                <H4 color={Colors[colorScheme ?? 'light'].tint}>
                  {pointsLoading ? '--' : points?.lifetimePoints || 0} pts
                </H4>
              </YStack>
              <Star size={24} color={Colors[colorScheme ?? 'light'].tint} />
            </XStack>
          </Card.Footer>
        </Card>
        
        {/* Earned Rewards Section */}
        <H3 style={styles.sectionTitle}>Your Rewards</H3>
        {isLoading ? (
          <View style={styles.loadingContainer}>
            <Spinner size="large" />
          </View>
        ) : userRewards?.length === 0 ? (
          <Card bordered style={styles.emptyCard}>
            <Card.Header>
              <H4>No rewards yet</H4>
            </Card.Header>
            <Card.Footer padded>
              <Paragraph>Complete tasks and habits to earn points!</Paragraph>
            </Card.Footer>
          </Card>
        ) : (
          <ScrollView horizontal showsHorizontalScrollIndicator={false} style={styles.horizontalList}>
            {userRewards?.map((reward) => (
              <Card key={reward.id} size="$4" bordered width={150} height={180} margin={8}>
                <Card.Header paddingTop={16}>
                  <View style={styles.rewardImageContainer}>
                    {reward.rewards?.image_url ? (
                      <Image 
                        source={{ uri: reward.rewards.image_url }} 
                        style={styles.rewardImage} 
                      />
                    ) : (
                      <Trophy size={40} color={Colors[colorScheme ?? 'light'].tint} />
                    )}
                  </View>
                  <H4 numberOfLines={1}>{reward.rewards?.name || 'Reward'}</H4>
                </Card.Header>
                <Card.Footer padding={8}>
                  <Paragraph numberOfLines={2} size="$2">
                    {reward.rewards?.description || 'You earned this reward!'}
                  </Paragraph>
                  <Text style={styles.dateText}>
                    {new Date(reward.earned_at).toLocaleDateString()}
                  </Text>
                </Card.Footer>
              </Card>
            ))}
          </ScrollView>
        )}
        
        <Separator marginVertical={20} />
        
        {/* Available Rewards Section */}
        <H3 style={styles.sectionTitle}>Available Rewards</H3>
        {isLoading ? (
          <View style={styles.loadingContainer}>
            <Spinner size="large" />
          </View>
        ) : availableRewards?.length === 0 ? (
          <Card bordered style={styles.emptyCard}>
            <Card.Header>
              <H4>No available rewards</H4>
            </Card.Header>
            <Card.Footer padded>
              <Paragraph>Check back later for new rewards to unlock!</Paragraph>
            </Card.Footer>
          </Card>
        ) : (
          <View style={styles.gridContainer}>
            {availableRewards?.map((reward) => (
              <Card key={reward.id} size="$4" bordered width={160} height={200} margin={8}>
                <Card.Header paddingTop={16}>
                  <View style={styles.rewardImageContainer}>
                    {reward.image_url ? (
                      <Image 
                        source={{ uri: reward.image_url }} 
                        style={styles.rewardImage} 
                      />
                    ) : (
                      <Gift size={40} color={Colors[colorScheme ?? 'light'].tint} />
                    )}
                  </View>
                  <H4 numberOfLines={1}>{reward.name}</H4>
                </Card.Header>
                <Card.Footer padding={8}>
                  <Paragraph numberOfLines={2} size="$2">
                    {reward.description}
                  </Paragraph>
                  // @ts-ignore // TODO: Investigate Tamagui prop type issue
                  <XStack flex={1} jc="space-between" ai="center">
                    <Text fontSize="$6" fontWeight="bold">{reward.required_points} pts</Text>
                    <ConfettiButton 
                      size="$3" 
                      disabled={!points || points.points < reward.required_points}
                      onPress={() => handleClaimReward(reward.id)}
                      isLoading={isEarningReward && earningRewardVariables?.lootId === reward.id}
                      loadingText="Claiming..."
                    >
                      Claim
                    </ConfettiButton>
                  </XStack>
                </Card.Footer>
              </Card>
            ))}
          </View>
        )}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  scrollContent: {
    padding: 16,
  },
  pointsCard: {
    marginVertical: 16,
  },
  sectionTitle: {
    marginTop: 16,
    marginBottom: 8,
  },
  loadingContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    padding: 40,
  },
  horizontalList: {
    flexGrow: 0,
    marginBottom: 8,
  },
  gridContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
  },
  emptyCard: {
    marginVertical: 8,
  },
  rewardImageContainer: {
    height: 60,
    width: 60,
    borderRadius: 30,
    backgroundColor: 'rgba(0,0,0,0.05)',
    alignItems: 'center',
    justifyContent: 'center',
    alignSelf: 'center',
    marginBottom: 8,
  },
  rewardImage: {
    height: 50,
    width: 50,
    borderRadius: 25,
  },
  dateText: {
    fontSize: 12,
    opacity: 0.7,
    marginTop: 4,
  },
  pointsText: {
    fontWeight: 'bold',
  },
}); ```

## File: ./app/(tabs)/settings/index.tsx
```
import React, { useState } from 'react';
import { View, Text, StyleSheet, ScrollView } from 'react-native';
import { Stack } from 'expo-router';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Tabs, Card, Switch, YStack, XStack } from 'tamagui';
import { useUiStore } from '@/stores/uiStore';

export default function SettingsScreen() {
  const [activeTab, setActiveTab] = useState('profile');
  const { isDarkMode, toggleTheme } = useUiStore();

  return (
    <SafeAreaView className="flex-1 bg-ios-system">
      <Stack.Screen 
        options={{
          title: 'Settings',
          headerLargeTitle: true,
        }}
      />
      
      <View className="flex-1 p-4">
        <Tabs
          defaultValue="profile"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          backgroundColor="transparent"
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List className="mx-auto mb-4">
            <Tabs.Tab value="profile" className="px-4 py-2">
              <Text className="text-ios-primary font-medium">Profile</Text>
            </Tabs.Tab>
            <Tabs.Tab value="account" className="px-4 py-2">
              <Text className="text-ios-primary font-medium">Account</Text>
            </Tabs.Tab>
            <Tabs.Tab value="appearance" className="px-4 py-2">
              <Text className="text-ios-primary font-medium">Appearance</Text>
            </Tabs.Tab>
            <Tabs.Tab value="notifications" className="px-4 py-2">
              <Text className="text-ios-primary font-medium">Notifications</Text>
            </Tabs.Tab>
          </Tabs.List>
          
          <ScrollView>
            <Tabs.Content value="profile" className="min-h-[300px]">
              <Card className="p-4 mb-4 bg-white/5 backdrop-blur-md border border-white/10 rounded-lg">
                <YStack space="$3">
                  <Text className="text-ios-primary text-lg font-medium">Personal Info</Text>
                  <Text className="text-ios-gray-1 mt-2">Profile settings coming soon</Text>
                </YStack>
              </Card>
            </Tabs.Content>
            
            <Tabs.Content value="account" className="min-h-[300px]">
              <Card className="p-4 mb-4 bg-white/5 backdrop-blur-md border border-white/10 rounded-lg">
                <YStack space="$3">
                  <Text className="text-ios-primary text-lg font-medium">Account Settings</Text>
                  <Text className="text-ios-gray-1 mt-2">Account management coming soon</Text>
                </YStack>
              </Card>
            </Tabs.Content>
            
            <Tabs.Content value="appearance" className="min-h-[300px]">
              <Card className="p-4 mb-4 bg-white/5 backdrop-blur-md border border-white/10 rounded-lg">
                <YStack space="$3">
                  <Text className="text-ios-primary text-lg font-medium">Appearance</Text>
                  <XStack justifyContent="space-between" alignItems="center">
                    <Text className="text-ios-primary">Dark Mode</Text>
                    <Switch size="$3" checked={isDarkMode} onCheckedChange={toggleTheme} />
                  </XStack>
                </YStack>
              </Card>
            </Tabs.Content>
            
            <Tabs.Content value="notifications" className="min-h-[300px]">
              <Card className="p-4 mb-4 bg-white/5 backdrop-blur-md border border-white/10 rounded-lg">
                <YStack space="$3">
                  <Text className="text-ios-primary text-lg font-medium">Notification Settings</Text>
                  <Text className="text-ios-gray-1 mt-2">Notification preferences coming soon</Text>
                </YStack>
              </Card>
            </Tabs.Content>
          </ScrollView>
        </Tabs>
      </View>
    </SafeAreaView>
  );
} ```

## File: ./app/+not-found.tsx
```
import { Link, Stack } from 'expo-router';
import { StyleSheet } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <ThemedView style={styles.container}>
        <ThemedText type="title">This screen doesn't exist.</ThemedText>
        <Link href="/" style={styles.link}>
          <ThemedText type="link">Go to home screen!</ThemedText>
        </Link>
      </ThemedView>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});
```

## File: ./app/_layout.tsx
```
import React, { useEffect, useState, useCallback } from 'react';
import { useFonts } from 'expo-font';
import { Stack, SplashScreen } from 'expo-router';
import { StatusBar } from 'expo-status-bar';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { ActivityIndicator, Text, View } from 'react-native';
import 'react-native-reanimated';
import 'text-encoding'; // Polyfill for nats.ws if needed

import { Providers } from '@/providers/Providers';
import { useColorScheme } from '@/hooks/useColorScheme';
import { supabase } from '@/utils/supabase';
import { OfflineIndicator } from '@/components/OfflineIndicator';

// Prevent the splash screen from auto-hiding before we are ready.
SplashScreen.preventAutoHideAsync();
console.log('RootLayout: Initializing, Splash prevented.');

// Custom hook to manage session state
function useSession() {
  const [session, setSession] = useState<any | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  console.log('useSession: Initial state - isLoading: true, session: null');

  useEffect(() => {
    console.log('useSession: useEffect mounted.');
    let isMounted = true;

    async function getInitialSession() {
      console.log('useSession: getInitialSession called.');
      try {
        const { data: { session: initialSession }, error } = await supabase.auth.getSession();
        if (error) throw error;
        if (isMounted) {
          console.log('useSession: Initial session fetched - session:', initialSession ? 'Exists' : 'None');
          setSession(initialSession);
        } else {
           console.log('useSession: getInitialSession completed but component unmounted.');
        }
      } catch (e) {
        console.error('useSession: Error fetching initial session:', e);
        if (isMounted) setSession(null);
      } finally {
        if (isMounted) {
            console.log('useSession: getInitialSession finally block - setting isLoading false.');
            setIsLoading(false);
            SplashScreen.hideAsync(); // Hide splash only after initial check completes
            console.log('useSession: Initial session check finished, splash hidden.');
        } else {
            console.log('useSession: getInitialSession finally block but component unmounted.');
        }
      }
    }

    getInitialSession();

    const { data: authListener } = supabase.auth.onAuthStateChange(
      (_event, newSession) => {
        console.log('useSession: onAuthStateChange triggered - event:', _event, 'newSession:', newSession ? 'Exists' : 'None');
        setSession(newSession);
         if (isLoading && isMounted) {
             console.log('useSession: Auth state changed during load, setting isLoading false & hiding splash.');
             setIsLoading(false);
             SplashScreen.hideAsync();
         } else if (isLoading && !isMounted) {
             console.log('useSession: Auth state changed during load but component unmounted.');
         }
      }
    );

    return () => {
      console.log('useSession: useEffect cleanup - unsubscribing.');
      isMounted = false;
      authListener?.subscription.unsubscribe();
    };
  }, []);

  return { session, isLoading };
}

export default function RootLayout() {
  console.log('RootLayout: Component rendering...');
  const colorScheme = useColorScheme();
  const [fontsLoaded, fontError] = useFonts({
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
  });

  useEffect(() => {
    if (fontError) {
        console.error('RootLayout: Font loading error:', fontError);
    }
    if (fontsLoaded) {
        console.log('RootLayout: Fonts successfully loaded.');
    }
  }, [fontsLoaded, fontError]);

  const { session, isLoading: isAuthLoading } = useSession();
  console.log('RootLayout: Received state - fontsLoaded:', fontsLoaded, 'isAuthLoading:', isAuthLoading, 'session:', session ? 'Exists' : 'None');

  if (!fontsLoaded || isAuthLoading) {
    console.log('RootLayout: Rendering loading indicator.');
     return (
       <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: colorScheme === 'dark' ? '#000' : '#FFF' }}>
         <ActivityIndicator size="large" color={colorScheme === 'dark' ? '#FFF' : '#000'} />
         <Text style={{ color: colorScheme === 'dark' ? '#FFF' : '#000', marginTop: 10 }}>Loading...</Text>
       </View>
     );
  }

  console.log(`RootLayout: Rendering main navigator - ${session ? '(tabs)' : '(auth)'}`);
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <Providers>
        {session ? (
           // User is signed in, render the main app tabs and modals
           <Stack screenOptions={{ headerShown: false }}>
             <Stack.Screen name="(tabs)" />
             {/* Add modals accessible when logged in here */}
             <Stack.Screen name="compose" options={{ presentation: 'modal' }} />
             <Stack.Screen name="+not-found" />
           </Stack>
         ) : (
           // User is signed out, render only the auth flow and not found
           <Stack screenOptions={{ headerShown: false }}>
             <Stack.Screen name="(auth)" />
             <Stack.Screen name="+not-found" />
           </Stack>
         )}
        <StatusBar style={colorScheme === 'dark' ? 'light' : 'dark'} />
        <OfflineIndicator />
      </Providers>
    </GestureHandlerRootView>
  );
}```

## File: ./babel.config.js
```
module.exports = function (api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      // Inline env variables for Tamagui
      [
        'transform-inline-environment-variables',
        {
          include: ['TAMAGUI_TARGET'],
        },
      ],
      
      // Tamagui plugin for optimized compilation
      [
        '@tamagui/babel-plugin',
        {
          components: ['tamagui'],
          config: './tamagui.config.ts',
          logTimings: true,
          disableExtraction: process.env.NODE_ENV === 'development',
        },
      ],
      
      // Reanimated plugin must be last
      'react-native-reanimated/plugin',
    ],
  };
}; ```

## File: ./components/Collapsible.tsx
```
import { PropsWithChildren, useState } from 'react';
import { StyleSheet, TouchableOpacity } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { IconSymbol } from '@/components/ui/IconSymbol';
import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function Collapsible({ children, title }: PropsWithChildren & { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? 'light';

  return (
    <ThemedView>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}>
        <IconSymbol
          name="chevron.right"
          size={18}
          weight="medium"
          color={theme === 'light' ? Colors.light.icon : Colors.dark.icon}
          style={{ transform: [{ rotate: isOpen ? '90deg' : '0deg' }] }}
        />

        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>
      {isOpen && <ThemedView style={styles.content}>{children}</ThemedView>}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  heading: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});
```

## File: ./components/EmptyOrSkeleton.tsx
```
import React, { ReactNode } from 'react';
import { StyleSheet, StyleProp, ViewStyle, TextStyle, ImageStyle, ImageSourcePropType, View, Image } from 'react-native';
import Animated from 'react-native-reanimated';
import { Text, YStack, StackProps } from 'tamagui';
import { useSkeleton, SkeletonOptions } from '@/hooks/useSkeleton';

export interface EmptyStateProps {
  /** Title text for the empty state */
  title?: string;
  /** Subtitle/description text for the empty state */
  message?: string;
  /** Optional image/illustration to display */
  image?: ImageSourcePropType;
  /** Optional custom component to render instead of default empty state */
  customEmptyComponent?: ReactNode;
  /** Style for the container */
  containerStyle?: StyleProp<ViewStyle>;
  /** Style for the title */
  titleStyle?: StyleProp<TextStyle>;
  /** Style for the message */
  messageStyle?: StyleProp<TextStyle>;
  /** Style for the image container */
  imageContainerStyle?: StyleProp<ViewStyle>;
  /** Style for the image */
  imageStyle?: StyleProp<ImageStyle>;
}

export interface EmptyOrSkeletonProps extends EmptyStateProps, StackProps {
  /** Whether data is loading */
  isLoading: boolean;
  /** Children to display when not loading and not empty */
  children: ReactNode;
  /** Whether the content is empty (no data) */
  isEmpty?: boolean;
  /** Number of skeleton placeholders to display when loading */
  skeletonCount?: number;
  /** Height of each skeleton item */
  skeletonHeight?: number;
  /** Width of each skeleton item (default: 100%) */
  skeletonWidth?: number | string;
  /** Gap between skeleton items */
  skeletonGap?: number;
  /** Border radius for skeleton items */
  skeletonBorderRadius?: number;
  /** Custom skeleton component */
  customSkeletonComponent?: ReactNode;
  /** Options for the skeleton animation */
  skeletonOptions?: SkeletonOptions;
}

/**
 * Placeholder component for the skeleton loading state
 */
const SkeletonPlaceholder = ({
  height, 
  width = '100%',
  borderRadius = 8,
  options
}: {
  height: number;
  width?: number | string;
  borderRadius?: number;
  options?: SkeletonOptions;
}) => {
  const { shimmerStyle, styles } = useSkeleton(options);
  
  return (
    <Animated.View 
      style={[
        styles.container, 
        { 
          height,
          width: typeof width === 'string' ? width : width,
          borderRadius
        } as ViewStyle
      ]}
    >
      <Animated.View style={[styles.shimmer, shimmerStyle]} />
    </Animated.View>
  );
};

/**
 * Default empty state component
 */
const EmptyState = ({
  title = 'No data found',
  message = 'There is nothing to display at the moment.',
  image,
  containerStyle,
  titleStyle,
  messageStyle,
  imageContainerStyle,
  imageStyle
}: EmptyStateProps) => {
  return (
    <YStack
      alignItems="center"
      justifyContent="center"
      padding="$4"
      space="$3"
      style={containerStyle}
    >
      {image && (
        <View style={[styles.imageContainer, imageContainerStyle]}>
          <Image source={image} style={[styles.image, imageStyle]} />
        </View>
      )}
      <Text 
        fontSize="$6" 
        fontWeight="bold" 
        textAlign="center"
        style={titleStyle}
      >
        {title}
      </Text>
      <Text 
        fontSize="$4" 
        color="$gray10" 
        textAlign="center"
        style={messageStyle}
      >
        {message}
      </Text>
    </YStack>
  );
};

/**
 * A component that conditionally renders skeleton, empty state, or content
 * based on loading and data states.
 */
export default function EmptyOrSkeleton({
  isLoading,
  isEmpty = false,
  children,
  skeletonCount = 3,
  skeletonHeight = 80,
  skeletonWidth = '100%',
  skeletonGap = 12,
  skeletonBorderRadius = 8,
  customSkeletonComponent,
  customEmptyComponent,
  skeletonOptions,
  title,
  message,
  image,
  containerStyle,
  titleStyle,
  messageStyle,
  imageContainerStyle,
  imageStyle,
  ...stackProps
}: EmptyOrSkeletonProps) {
  // If loading, show skeleton
  if (isLoading) {
    if (customSkeletonComponent) {
      return <>{customSkeletonComponent}</>;
    }
    
    return (
      <YStack space={skeletonGap} width="100%" {...stackProps}>
        {Array.from({ length: skeletonCount }).map((_, index) => (
          <SkeletonPlaceholder
            key={`skeleton-${index}`}
            height={skeletonHeight}
            width={skeletonWidth}
            borderRadius={skeletonBorderRadius}
            options={skeletonOptions}
          />
        ))}
      </YStack>
    );
  }
  
  // If empty, show empty state
  if (isEmpty) {
    if (customEmptyComponent) {
      return <>{customEmptyComponent}</>;
    }
    
    return (
      <EmptyState
        title={title}
        message={message}
        image={image}
        containerStyle={containerStyle}
        titleStyle={titleStyle}
        messageStyle={messageStyle}
        imageContainerStyle={imageContainerStyle}
        imageStyle={imageStyle}
      />
    );
  }
  
  // Otherwise, show children
  return <>{children}</>;
}

const styles = StyleSheet.create({
  imageContainer: {
    marginBottom: 20,
  },
  image: {
    width: 150,
    height: 150,
    resizeMode: 'contain',
  },
}); ```

## File: ./components/ExternalLink.tsx
```
import { Link } from 'expo-router';
import { openBrowserAsync } from 'expo-web-browser';
import { type ComponentProps } from 'react';
import { Platform } from 'react-native';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href as any}
      onPress={async (event) => {
        if (Platform.OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href);
        }
      }}
    />
  );
}
```

## File: ./components/HapticTab.tsx
```
import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import * as Haptics from 'expo-haptics';

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === 'ios') {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}
```

## File: ./components/HelloWave.tsx
```
import { useEffect } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withRepeat,
  withSequence,
} from 'react-native-reanimated';

import { ThemedText } from '@/components/ThemedText';

export function HelloWave() {
  const rotationAnimation = useSharedValue(0);

  useEffect(() => {
    rotationAnimation.value = withRepeat(
      withSequence(withTiming(25, { duration: 150 }), withTiming(0, { duration: 150 })),
      4 // Run the animation 4 times
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotationAnimation.value}deg` }],
  }));

  return (
    <Animated.View style={animatedStyle}>
      <ThemedText style={styles.text}>👋</ThemedText>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  text: {
    fontSize: 28,
    lineHeight: 32,
    marginTop: -6,
  },
});
```

## File: ./components/OfflineIndicator.tsx
```
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet, Animated, Platform } from 'react-native';
import NetInfo from '@react-native-community/netinfo';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { useTheme } from 'tamagui';
import { IconSymbol } from './ui/IconSymbol';

export function OfflineIndicator() {
  const [isOffline, setIsOffline] = useState(false);
  const translateY = useState(new Animated.Value(-60))[0];
  const opacity = useState(new Animated.Value(0))[0];
  const insets = useSafeAreaInsets();
  const theme = useTheme();

  // iOS-style colors
  const bannerColor = theme.error?.val || '#FF3B30';
  const textColor = 'white';

  useEffect(() => {
    // Subscribe to network state changes
    const unsubscribe = NetInfo.addEventListener(state => {
      const offline = !(state.isConnected && state.isInternetReachable !== false);
      setIsOffline(offline);
      
      // Animate banner in or out based on network state
      if (offline) {
        // Animate in
        Animated.parallel([
          Animated.timing(translateY, {
            toValue: 0,
            duration: 300,
            useNativeDriver: true,
          }),
          Animated.timing(opacity, {
            toValue: 1,
            duration: 300,
            useNativeDriver: true,
          })
        ]).start();
      } else {
        // Animate out
        Animated.parallel([
          Animated.timing(translateY, {
            toValue: -60 - insets.top,
            duration: 300,
            useNativeDriver: true,
          }),
          Animated.timing(opacity, {
            toValue: 0,
            duration: 300,
            useNativeDriver: true,
          })
        ]).start();
      }
    });

    // Check initial network state
    NetInfo.fetch().then(state => {
      const offline = !(state.isConnected && state.isInternetReachable !== false);
      setIsOffline(offline);
      
      // Set initial position without animation
      translateY.setValue(offline ? 0 : -60 - insets.top);
      opacity.setValue(offline ? 1 : 0);
    });

    return () => {
      unsubscribe();
    };
  }, [translateY, opacity, insets.top]);

  return (
    <Animated.View 
      style={[
        styles.container, 
        { 
          backgroundColor: bannerColor,
          paddingTop: insets.top,
          transform: [{ translateY }],
          opacity
        }
      ]}
      pointerEvents={isOffline ? 'auto' : 'none'}
    >
      <View style={styles.content}>
        <IconSymbol name="wifi.slash" size={18} color={textColor} />
        <View style={styles.textContainer}>
          <Text style={[styles.text, { color: textColor }]}>You're offline</Text>
          <Text style={[styles.subtext, { color: textColor }]}>
            Changes will sync when your connection is restored
          </Text>
        </View>
      </View>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    zIndex: 999,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 2,
    elevation: 5,
  },
  content: {
    padding: 12,
    paddingHorizontal: 16,
    flexDirection: 'row',
    alignItems: 'center',
  },
  textContainer: {
    marginLeft: 10,
    flex: 1,
  },
  text: {
    fontWeight: '600',
    fontSize: 16,
  },
  subtext: {
    fontSize: 13,
    marginTop: 2,
    opacity: 0.8,
  },
}); ```

## File: ./components/ParallaxScrollView.tsx
```
import type { PropsWithChildren, ReactElement } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollViewOffset,
} from 'react-native-reanimated';

import { ThemedView } from '@/components/ThemedView';
import { useBottomTabOverflow } from '@/components/ui/TabBarBackground';
import { useColorScheme } from '@/hooks/useColorScheme';

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}>;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const colorScheme = useColorScheme() ?? 'light';
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollViewOffset(scrollRef);
  const bottom = useBottomTabOverflow();
  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    <ThemedView style={styles.container}>
      <Animated.ScrollView
        ref={scrollRef}
        scrollEventThrottle={16}
        scrollIndicatorInsets={{ bottom }}
        contentContainerStyle={{ paddingBottom: bottom }}>
        <Animated.View
          style={[
            styles.header,
            { backgroundColor: headerBackgroundColor[colorScheme] },
            headerAnimatedStyle,
          ]}>
          {headerImage}
        </Animated.View>
        <ThemedView style={styles.content}>{children}</ThemedView>
      </Animated.ScrollView>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: 'hidden',
  },
  content: {
    flex: 1,
    padding: 32,
    gap: 16,
    overflow: 'hidden',
  },
});
```

## File: ./components/ThemedText.tsx
```
import { Text, type TextProps, StyleSheet } from 'react-native';

import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color },
        type === 'default' ? styles.default : undefined,
        type === 'title' ? styles.title : undefined,
        type === 'defaultSemiBold' ? styles.defaultSemiBold : undefined,
        type === 'subtitle' ? styles.subtitle : undefined,
        type === 'link' ? styles.link : undefined,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: '#0a7ea4',
  },
});
```

## File: ./components/ThemedView.tsx
```
import { View, type ViewProps } from 'react-native';

import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');

  return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}
```

## File: ./components/__tests__/ThemedText-test.tsx
```
import * as React from 'react';
import renderer from 'react-test-renderer';

import { ThemedText } from '../ThemedText';

it(`renders correctly`, () => {
  const tree = renderer.create(<ThemedText>Snapshot test!</ThemedText>).toJSON();

  expect(tree).toMatchSnapshot();
});
```

## File: ./components/aether/AetherCard.tsx
```
import React, { ReactNode } from 'react';
import { View, StyleSheet, ViewStyle, TouchableOpacity, TouchableOpacityProps } from 'react-native';

interface AetherCardProps extends TouchableOpacityProps {
  children: ReactNode;
  style?: ViewStyle;
  touchable?: boolean;
}

const AetherCard: React.FC<AetherCardProps> = ({
  children,
  style,
  touchable = false,
  ...rest
}) => {
  const cardStyles = [
    styles.card,
    style,
  ];
  
  if (touchable) {
    return (
      <TouchableOpacity style={cardStyles} activeOpacity={0.8} {...rest}>
        {children}
      </TouchableOpacity>
    );
  }
  
  return (
    <View style={cardStyles}>
      {children}
    </View>
  );
};

const styles = StyleSheet.create({
  card: {
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderRadius: 16,
    padding: 16,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 3,
    // Note: backdrop-blur-md is handled via nativewind class
  },
});

export default AetherCard; ```

## File: ./components/aether/GoalCard.tsx
```
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import AetherCard from './AetherCard';
import ValueBadge from './ValueBadge';
import ProgressRing from './ProgressRing';
import { Goal, Value } from '@/server/src/types';

interface GoalCardProps {
  goal: Goal;
  values: Value[];
  onPress?: () => void;
}

const GoalCard: React.FC<GoalCardProps> = ({ goal, values, onPress }) => {
  // Find the matching Value objects for the goal's valueIds
  const goalValues = values.filter(v => goal.valueIds.includes(v.id));
  
  // If the goal has a target date, format it for display
  const formattedDate = goal.targetDate 
    ? new Date(goal.targetDate).toLocaleDateString(undefined, { month: 'short', day: 'numeric' })
    : null;
  
  // Count tasks linked to this goal (this would come from a real data source)
  const taskCount = 3; // placeholder
  
  return (
    <AetherCard touchable onPress={onPress} style={styles.container}>
      {/* Progress Ring - Absolute positioned in top right */}
      <View style={styles.progressRingContainer}>
        <ProgressRing 
          size={40} 
          progress={goal.progress} 
          strokeWidth={3}
        />
      </View>
      
      {/* Title */}
      <Text className="text-ios-primary text-lg font-medium mb-2">{goal.title}</Text>
      
      {/* Value badges */}
      <View style={styles.badgeContainer}>
        {goalValues.map(value => (
          <ValueBadge 
            key={value.id} 
            value={value} 
            size="small" 
            style={styles.badge} 
          />
        ))}
      </View>
      
      {/* Key Results */}
      {goal.keyResults.length > 0 && (
        <View style={styles.keyResultsContainer}>
          {goal.keyResults.slice(0, 3).map(kr => (
            <View key={kr.id} style={styles.keyResultRow}>
              <View style={styles.keyResultBar}>
                <View 
                  style={[
                    styles.keyResultProgress, 
                    { width: `${kr.progress * 100}%` }
                  ]} 
                />
              </View>
              <Text className="text-ios-gray-1 text-xs ml-2 flex-1" numberOfLines={1}>
                {kr.title}
              </Text>
            </View>
          ))}
        </View>
      )}
      
      {/* Footer with linked tasks and due date */}
      <View style={styles.footer}>
        <Text className="text-ios-gray-1 text-xs">
          {taskCount > 0 ? `${taskCount} Tasks linked` : 'No tasks linked'}
          {formattedDate ? ` • Due ${formattedDate}` : ''}
        </Text>
      </View>
    </AetherCard>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 12,
    minHeight: 140,
  },
  progressRingContainer: {
    position: 'absolute',
    top: 12,
    right: 12,
  },
  badgeContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 12,
  },
  badge: {
    marginRight: 6,
    marginBottom: 6,
  },
  keyResultsContainer: {
    marginTop: 8,
    marginBottom: 12,
  },
  keyResultRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 6,
  },
  keyResultBar: {
    height: 4,
    width: 60,
    backgroundColor: 'rgba(99, 102, 241, 0.2)',
    borderRadius: 2,
    overflow: 'hidden',
  },
  keyResultProgress: {
    height: '100%',
    backgroundColor: '#4F46E5', // indigo-600
    borderRadius: 2,
  },
  footer: {
    marginTop: 'auto',
    paddingTop: 8,
  },
});

export default GoalCard; ```

## File: ./components/aether/HabitCard.tsx
```
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import * as Haptics from 'expo-haptics';
import AetherCard from './AetherCard';
import ValueBadge from './ValueBadge';
import { Habit, Value } from '@/server/src/types';
import { Button, XStack } from 'tamagui';

interface HabitCardProps {
  habit: Habit;
  values: Value[];
  onCheckIn?: (habitId: string) => void;
  onPress?: () => void;
  isDailyCheckInCompleted?: boolean;
}

// Helper to get today's date in ISO format (YYYY-MM-DD)
const getTodayISODate = () => {
  const today = new Date();
  return today.toISOString().split('T')[0];
};

const HabitCard: React.FC<HabitCardProps> = ({
  habit,
  values,
  onCheckIn,
  onPress,
  isDailyCheckInCompleted = false,
}) => {
  // Find values related to this habit
  const habitValues = values.filter(v => habit.valueIds.includes(v.id));
  
  // Check if the habit was completed today
  const todayISO = getTodayISODate();
  const isTodayCompleted = habit.history[todayISO] || isDailyCheckInCompleted;
  
  const handleCheckIn = () => {
    if (onCheckIn) {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      onCheckIn(habit.id);
    }
  };
  
  return (
    <AetherCard touchable={!!onPress} onPress={onPress} style={styles.container}>
      {/* Title and streak badge */}
      <View style={styles.header}>
        <Text className="text-ios-primary text-lg font-medium flex-1 mr-2">{habit.title}</Text>
        
        {habit.streak > 0 && (
          <View style={styles.streakBadge}>
            <Text className="text-ios-primary text-sm font-medium">🔥 {habit.streak}</Text>
          </View>
        )}
      </View>
      
      {/* Heat map calendar placeholder */}
      <View style={styles.heatMapPlaceholder}>
        <Text className="text-ios-gray-1 text-xs">Calendar visualization coming soon</Text>
      </View>
      
      {/* Value badges */}
      <View style={styles.badgeContainer}>
        {habitValues.map(value => (
          <ValueBadge 
            key={value.id} 
            value={value} 
            size="small" 
            style={styles.badge} 
          />
        ))}
      </View>
      
      {/* Check-in button */}
      <View style={styles.footer}>
        <Button
          size="$3"
          themeInverse={!isTodayCompleted}
          onPress={handleCheckIn}
          disabled={isTodayCompleted}
          opacity={isTodayCompleted ? 0.6 : 1}
        >
          <XStack alignItems="center" space="$2">
            {isTodayCompleted ? "✓ Completed Today" : "Check-in"}
          </XStack>
        </Button>
      </View>
    </AetherCard>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: 12,
    minHeight: 180,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
  },
  streakBadge: {
    backgroundColor: 'rgba(251, 191, 36, 0.2)', // amber-400 with 0.2 opacity
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: 'rgba(251, 191, 36, 0.4)',
  },
  heatMapPlaceholder: {
    height: 48,
    marginBottom: 12,
    backgroundColor: 'rgba(255, 255, 255, 0.05)',
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  badgeContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 12,
  },
  badge: {
    marginRight: 6,
    marginBottom: 6,
  },
  footer: {
    marginTop: 'auto',
    paddingTop: 8,
  },
});

export default HabitCard; ```

## File: ./components/aether/ProgressRing.tsx
```
import React from 'react';
import { View, StyleSheet } from 'react-native';
import Svg, { Circle, G, Text as SvgText } from 'react-native-svg';

interface ProgressRingProps {
  size: number;
  progress: number; // 0-1
  strokeWidth?: number;
  showText?: boolean;
  primaryColor?: string;
  secondaryColor?: string;
  textColor?: string;
}

const ProgressRing: React.FC<ProgressRingProps> = ({
  size,
  progress,
  strokeWidth = 3,
  showText = false,
  primaryColor = '#4F46E5', // indigo-600
  secondaryColor = 'rgba(99, 102, 241, 0.2)', // indigo-500 with alpha
  textColor = '#4F46E5',
}) => {
  // Ensure progress is between 0-1
  const clampedProgress = Math.min(1, Math.max(0, progress));
  
  // Calculate values needed for the SVG
  const radius = (size - strokeWidth) / 2;
  const circumference = radius * 2 * Math.PI;
  const progressValue = circumference - circumference * clampedProgress;
  
  // Helper for proper font size based on ring size
  const getFontSize = (ringSize: number) => {
    if (ringSize < 30) return 8;
    if (ringSize < 60) return 12;
    return 16;
  };
  
  const fontSize = getFontSize(size);
  
  return (
    <View style={{ width: size, height: size }}>
      <Svg width={size} height={size}>
        <G rotation="-90" origin={`${size / 2}, ${size / 2}`}>
          {/* Background Circle */}
          <Circle
            cx={size / 2}
            cy={size / 2}
            r={radius}
            strokeWidth={strokeWidth}
            stroke={secondaryColor}
            fill="transparent"
          />
          
          {/* Progress Circle */}
          <Circle
            cx={size / 2}
            cy={size / 2}
            r={radius}
            strokeWidth={strokeWidth}
            stroke={primaryColor}
            fill="transparent"
            strokeDasharray={circumference}
            strokeDashoffset={progressValue}
            strokeLinecap="round"
          />
        </G>
        
        {/* Optional Text */}
        {showText && (
          <SvgText
            x={size / 2}
            y={size / 2 + fontSize / 3} // adjust for vertical centering
            fontSize={`${fontSize}px`}
            fontWeight="500"
            fill={textColor}
            textAnchor="middle"
          >
            {`${Math.round(clampedProgress * 100)}%`}
          </SvgText>
        )}
      </Svg>
    </View>
  );
};

export default ProgressRing; ```

## File: ./components/aether/ValueBadge.tsx
```
import React from 'react';
import { TouchableOpacity, Text, StyleSheet, ViewStyle, TextStyle, TouchableOpacityProps } from 'react-native';
import { Value } from '@/server/src/types';
import * as Haptics from 'expo-haptics';
import { YStack } from 'tamagui';
import { useThemeColor } from '@/hooks/useThemeColor';

interface ValueBadgeProps extends TouchableOpacityProps {
  value: Value;
  selected?: boolean;
  size?: 'small' | 'medium' | 'large';
  onPress?: () => void;
  style?: ViewStyle;
  textStyle?: TextStyle;
}

// Mapping of colors to hex values
const colorMap: Record<string, { bg: string, text: string }> = {
  'indigo-500': { bg: '#6366F1', text: '#FFFFFF' },
  'indigo-600': { bg: '#4F46E5', text: '#FFFFFF' },
  'amber-400': { bg: '#FBBF24', text: '#000000' },
  'emerald-500': { bg: '#10B981', text: '#FFFFFF' },
  'rose-500': { bg: '#F43F5E', text: '#FFFFFF' },
  'violet-500': { bg: '#8B5CF6', text: '#FFFFFF' },
  'cyan-500': { bg: '#06B6D4', text: '#FFFFFF' },
  'blue-500': { bg: '#3B82F6', text: '#FFFFFF' },
  'pink-500': { bg: '#EC4899', text: '#FFFFFF' },
  // Add more colors as needed
};

const ValueBadge: React.FC<ValueBadgeProps> = ({
  value,
  selected = false,
  size = 'medium',
  onPress,
  style,
  textStyle,
  ...rest
}) => {
  // Default to indigo if color not found
  const colorKey = value.color || 'indigo-500';
  const colorObj = colorMap[colorKey] || colorMap['indigo-500'];
  
  const handlePress = () => {
    if (onPress) {
      Haptics.selectionAsync();
      onPress();
    }
  };

  // Size mappings
  const sizeStyles = {
    small: {
      paddingHorizontal: 8,
      paddingVertical: 2,
      borderRadius: 8,
      fontSize: 12,
    },
    medium: {
      paddingHorizontal: 12,
      paddingVertical: 4,
      borderRadius: 12,
      fontSize: 14,
    },
    large: {
      paddingHorizontal: 16,
      paddingVertical: 6,
      borderRadius: 16,
      fontSize: 16,
    },
  };

  const selectedStyles = selected
    ? { shadowColor: colorObj.bg, shadowOffset: { width: 0, height: 0 }, shadowOpacity: 0.5, shadowRadius: 8, elevation: 4 }
    : {};

  return (
    <TouchableOpacity
      style={[
        {
          backgroundColor: colorObj.bg,
          ...sizeStyles[size],
          opacity: selected ? 1 : 0.85,
        },
        selectedStyles,
        style,
      ]}
      onPress={handlePress}
      disabled={!onPress}
      {...rest}
    >
      <Text
        style={[
          {
            color: colorObj.text,
            fontWeight: '500',
            fontSize: sizeStyles[size].fontSize,
          },
          textStyle,
        ]}
      >
        {value.name || ''}
      </Text>
    </TouchableOpacity>
  );
};

export default ValueBadge; ```

## File: ./components/auth/FloatingInput.tsx
```
import React, { useState, useRef, useEffect } from 'react';
import { StyleSheet, TextInput as RNTextInput, View, TextInputProps as RNTextInputProps } from 'react-native';
import { Text, InputProps, getTokens, useTheme } from 'tamagui';
import Animated, { useSharedValue, withTiming, useAnimatedStyle, Easing } from 'react-native-reanimated';
import { durations } from '@/constants/motion';

export interface FloatingInputProps extends RNTextInputProps {
  /** Label for the input */
  label: string;
  /** Error message to display */
  error?: string;
  /** Container style */
  containerStyle?: object;
  /** Label style */
  labelStyle?: object;
  /** Error style */
  errorStyle?: object;
  /** Tamagui tokens for theming */
  tokens?: ReturnType<typeof getTokens>;
  /** Called when focus changes */
  onFocusChange?: (focused: boolean) => void;
  /** Left icon to display */
  leftIcon?: React.ReactNode;
  /** Right icon to display */
  rightIcon?: React.ReactNode;
  /** Whether to adjust label position */
  adjustLabel?: boolean;
}

/**
 * Input component with animated floating label
 */
export default function FloatingInput({
  label,
  value,
  error,
  containerStyle,
  labelStyle,
  errorStyle,
  onFocusChange,
  leftIcon,
  rightIcon,
  adjustLabel = true,
  style,
  ...props
}: FloatingInputProps) {
  const [isFocused, setIsFocused] = useState(false);
  const inputRef = useRef<RNTextInput | null>(null);
  const animatedLabelValue = useSharedValue(value ? 1 : 0);
  const theme = useTheme();
  
  // Handle label animation when focus or value changes
  useEffect(() => {
    animatedLabelValue.value = withTiming(
      (isFocused || !!value) ? 1 : 0,
      {
        duration: 200, // Match durations.standard
        easing: Easing.bezier(0.4, 0.0, 0.2, 1.0),
      }
    );
  }, [isFocused, value, animatedLabelValue]);
  
  // Get dynamic colors from theme
  const colors = {
    input: {
      background: theme.inputBackground?.get() || theme.backgroundHover?.get() || '#F3F4F6',
      text: theme.color?.get() || '#111827',
      border: theme.borderColor?.get() || '#E5E7EB',
      focusBorder: theme.borderColorFocus?.get() || '#93C5FD',
      placeholderText: theme.colorTransparent?.get() || '#6B7280',
    },
    error: theme.red10?.get() || '#EF4444',
  };
  
  // Determine text color based on disabled state
  const textColor = props.editable === false 
    ? theme.colorTransparent?.get() || '#9CA3AF'
    : colors.input.text;
  
  // Handle focus changes
  const handleFocus = (event: any) => {
    setIsFocused(true);
    if (onFocusChange) onFocusChange(true);
    if (props.onFocus) props.onFocus(event);
  };
  
  const handleBlur = (event: any) => {
    setIsFocused(false);
    if (onFocusChange) onFocusChange(false);
    if (props.onBlur) props.onBlur(event);
  };
  
  // Animated styles
  const animatedLabelStyle = useAnimatedStyle(() => {
    return {
      position: 'absolute',
      left: leftIcon ? 40 : 16,
      top: adjustLabel ? 
        (16 + (-24 * animatedLabelValue.value)) : 
        (12 + (-20 * animatedLabelValue.value)),
      fontSize: 16 - (4 * animatedLabelValue.value),
      color: error ? colors.error : 
        animatedLabelValue.value > 0 ? 
          (isFocused ? colors.input.focusBorder : colors.input.placeholderText) : 
          colors.input.placeholderText,
      backgroundColor: animatedLabelValue.value > 0 ? 
        (theme.background?.get() || '#FFFFFF') : 'transparent',
      paddingHorizontal: 4 * animatedLabelValue.value,
      zIndex: 10,
    };
  });
  
  // Focus the input when the component is tapped
  const handleContainerPress = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };
  
  // Prepare input styles - flatten the array and provide default
  const inputStyles = StyleSheet.flatten([
    styles.input, 
    { color: textColor },
    leftIcon && { paddingLeft: 40 },
    rightIcon && { paddingRight: 40 },
    style // Style prop from component props
  ]) || {}; // Provide default empty style object
  
  return (
    <View style={[styles.container, containerStyle]}>
      <View 
        style={[
          styles.inputContainer, 
          { backgroundColor: colors.input.background },
          { borderColor: isFocused ? colors.input.focusBorder : colors.input.border },
          error && { borderColor: colors.error },
        ]} 
        onTouchStart={handleContainerPress}
      >
        {leftIcon && <View style={styles.leftIcon}>{leftIcon}</View>}
        
        <RNTextInput
          ref={inputRef}
          style={inputStyles}
          value={value}
          onFocus={handleFocus}
          onBlur={handleBlur}
          placeholderTextColor={colors.input.placeholderText}
          {...props}
        />
        
        {rightIcon && <View style={styles.rightIcon}>{rightIcon}</View>}
        
        <Animated.Text style={[animatedLabelStyle, labelStyle]}>
          {label}
        </Animated.Text>
      </View>
      
      {error && (
        <Text
          style={[styles.errorText, { color: colors.error }, errorStyle]}
          fontSize="$3"
          marginTop="$1"
        >
          {error}
        </Text>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    marginBottom: 16,
    width: '100%',
  },
  inputContainer: {
    borderWidth: 1,
    borderRadius: 8,
    height: 56,
    position: 'relative',
    justifyContent: 'center',
  },
  input: {
    height: 56,
    paddingHorizontal: 16,
    fontSize: 16,
    flex: 1,
  },
  label: {
    zIndex: 10,
  },
  errorText: {
    marginLeft: 4,
  },
  leftIcon: {
    position: 'absolute',
    left: 12,
    top: 16,
    zIndex: 2,
  },
  rightIcon: {
    position: 'absolute',
    right: 12,
    top: 16,
    zIndex: 2,
  },
}); ```

## File: ./components/dashboard/DashboardSection.tsx
```
import React, { ReactNode } from 'react';
import { Text, YStack, XStack, Button, Anchor, H4 } from 'tamagui';
import { SkeletonRow } from '../ui/Skeleton';
import { SectionError } from '../ui/ErrorBanner';

interface DashboardSectionProps<T> {
  title: string;
  data?: T[];
  isLoading: boolean;
  emptyMessage: string;
  seeAllRoute?: string;
  renderItem: (item: T) => ReactNode;
  skeletonCount?: number;
  error?: string;
  onRetry?(): void;
}

export default function DashboardSection<T>({ 
  title, 
  data, 
  isLoading, 
  emptyMessage,
  seeAllRoute,
  renderItem,
  skeletonCount = 2,
  error,
  onRetry
}: DashboardSectionProps<T>) {
  return (
    <YStack space="$2">
      {/* @ts-ignore // TODO: Investigate Tamagui prop type issue */}
      <XStack jc="space-between" ai="center" mb="$2">
        <H4>{title}</H4>
        {data && data.length > 0 && seeAllRoute && (
          <Button 
            chromeless 
            size="$2" 
            onPress={() => {
              console.log(`Navigate to: ${seeAllRoute}`);
            }}
          >
            See All
          </Button>
        )}
      </XStack>
      
      {isLoading ? (
        <SkeletonRow count={skeletonCount} />
      ) : error ? (
        <SectionError message={error} onRetry={onRetry} />
      ) : data && data.length === 0 ? (
        <Text color="$colorSecondary" fontSize="$3">{emptyMessage}</Text>
      ) : (
        <YStack space="$3">
          {data && data.slice(0, 3).map((item: any, index) => (
            <React.Fragment key={item.id ?? index}>
              {renderItem(item)}
            </React.Fragment>
          ))}
        </YStack>
      )}
    </YStack>
  );
} ```

## File: ./components/dashboard/GoalSummaryCard.tsx
```
import React from 'react';
import { Text, XStack, Card } from 'tamagui';
import ProgressRing from '../aether/ProgressRing';

interface Goal {
  id: string;
  title: string;
  progress: number;
  tasks?: {
    total: number;
    completed: number;
  };
}

interface GoalSummaryCardProps {
  goal: Goal;
  onPress: () => void;
}

export default function GoalSummaryCard({ goal, onPress }: GoalSummaryCardProps) {
  return (
    <Card 
      bordered
      elevate
      onPress={onPress} 
      pressStyle={{ opacity: 0.8 }}
      padding="$3"
    >
      // @ts-ignore // TODO: Investigate Tamagui prop type issue
      <XStack ai="center" space="$3">
        <ProgressRing
          progress={goal.progress}
          size={40}
          primaryColor="$primary"
        />
        <XStack flex={1} flexDirection="column">
          <Text fontSize="$4" fontWeight="500" color="$color">
            {goal.title}
          </Text>
          {goal.tasks && (
            <Text color="$colorSecondary" fontSize="$2">
              {goal.tasks.completed}/{goal.tasks.total} tasks completed
            </Text>
          )}
        </XStack>
      </XStack>
    </Card>
  );
} ```

## File: ./components/dashboard/HabitCheckItem.tsx
```
import React, { useState, useEffect } from 'react';
import { Text, XStack, Button, YStack } from 'tamagui';
import * as Haptics from 'expo-haptics';

interface Habit {
  id: string;
  title: string;
  streak: number;
  completedToday: boolean;
}

interface HabitCheckItemProps {
  habit: Habit;
  onToggle: (habitId: string, completed: boolean) => void;
}

export default function HabitCheckItem({ habit, onToggle }: HabitCheckItemProps) {
  const [checked, setChecked] = useState(habit.completedToday);
  
  // Update local state if the prop changes
  useEffect(() => {
    setChecked(habit.completedToday);
  }, [habit.completedToday]);
  
  const handleToggle = () => {
    const newValue = !checked;
    setChecked(newValue);
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    onToggle(habit.id, newValue);
  };
  
  return (
    <XStack 
      backgroundColor="$backgroundStrong"
      padding="$3"
      borderRadius="$4"
      // @ts-ignore // TODO: Investigate Tamagui prop type issue
      ai="center"
      // @ts-ignore // TODO: Investigate Tamagui prop type issue
      jc="space-between"
      space="$3"
    >
      <YStack flex={1}>
        <Text fontSize="$4" fontWeight="500" color="$color">
          {habit.title}
        </Text>
        
        {habit.streak > 0 && (
          // @ts-ignore // TODO: Investigate Tamagui prop type issue
          <Text color="$warning" fontSize="$2" mt="$1">
            🔥 {habit.streak} day streak
          </Text>
        )}
      </YStack>
      
      <Button
        size="$3"
        variant={checked ? undefined : 'outlined'}
        backgroundColor={checked ? '$success' : undefined}
        color={checked ? '$backgroundStrong' : '$primary'}
        borderColor={checked ? undefined : '$primary'}
        onPress={handleToggle}
        iconAfter={checked ? <Text>✓</Text> : undefined}
      >
        {checked ? "Done" : "Check-in"}
      </Button>
    </XStack>
  );
} ```

## File: ./components/dashboard/StateIndicator.tsx
```
import React from 'react';
// Use Tamagui components
import { Text, XStack, YStack, Card } from 'tamagui'; 
// Removed TouchableOpacity, View from react-native
// import { TouchableOpacity, View } from 'react-native';

interface State {
  id: string;
  name: string;
  currentValue: number | string;
  lastUpdated: string | null;
}

interface StateIndicatorProps {
  state: State;
  onPress: () => void;
}

export default function StateIndicator({ state, onPress }: StateIndicatorProps) {
  // Format the last updated time
  const formattedTime = state.lastUpdated 
    ? new Date(state.lastUpdated).toLocaleTimeString([], { 
        hour: '2-digit', 
        minute: '2-digit' 
      })
    : 'N/A';
  
  // Use Tamagui Card component
  return (
    <Card 
      onPress={onPress} 
      pressStyle={{ opacity: 0.8 }}
      padding="$3"
      // No explicit background, will use default Card background from theme
    >
      <YStack space="$1"> {/* Main container for text */}
        <Text fontSize="$3" color="$colorSecondary"> {/* Use tokens */}
          {state.name}
        </Text>
        
        // @ts-ignore // TODO: Investigate Tamagui prop type issue
        <XStack ai="baseline" space="$2"> {/* Align text by baseline, add space */}
          <Text fontSize="$5" fontWeight="600" color="$color"> {/* Use tokens */}
            {state.currentValue}
          </Text>
          <Text color="$colorSecondary" fontSize="$2"> {/* Use tokens */}
            {formattedTime}
          </Text>
        </XStack>
      </YStack>
    </Card>
  );
} ```

## File: ./components/dashboard/TaskItem.tsx
```
import React from 'react';
// Use Tamagui components
import { Text, XStack, YStack } from 'tamagui'; 
// Removed TouchableOpacity, View from react-native
// import { TouchableOpacity, View } from 'react-native'; 

interface Task {
  id: string;
  title: string;
  status: string;
  due?: string;
  priority?: number;
}

interface TaskItemProps {
  task: Task;
  onPress: () => void;
}

export default function TaskItem({ task, onPress }: TaskItemProps) {
  // Map priority to color
  const priorityColor = task.priority === 1 ? '$error' : 
                        task.priority === 2 ? '$warning' : 
                        '$success';
  
  // Format due date
  const formattedDate = task.due 
    ? new Date(task.due).toLocaleDateString(undefined, { 
        month: 'short', 
        day: 'numeric' 
      })
    : null;
  
  // Use YStack as the base pressable component
  return (
    <YStack 
      tag="pressable" // Make YStack pressable
      onPress={onPress} 
      backgroundColor="$backgroundStrong"
      padding="$3"
      borderRadius="$4"
      pressStyle={{ opacity: 0.7 }}
      space="$1" // Add space between XStack and Date Text
    >
      // @ts-ignore // TODO: Investigate Tamagui prop type issue
      <XStack ai="center"> {/* Use XStack for horizontal layout */}
        {/* Priority Dot using YStack */}
        // @ts-ignore // TODO: Investigate Tamagui prop type issue
        <YStack 
          w="$2" // Use size token for width
          h="$2" // Use size token for height
          borderRadius="$10" // Use a large radius token
          backgroundColor={priorityColor} 
          mr="$2" // Use space token for margin
        />
        <Text 
          fontSize="$4" // Use font size token
          fontWeight={task.priority === 1 ? '600' : '400'} // Keep fontWeight
          color="$color"
          flex={1} // Allow text to take remaining space
        >
          {task.title}
        </Text>
      </XStack>
      
      {formattedDate && (
        // Removed explicit margin, rely on outer YStack space
        <Text color="$colorSecondary" fontSize="$2">
          Due: {formattedDate}
        </Text>
      )}
    </YStack>
  );
} ```

## File: ./components/planner/GoalsList.tsx
```
import React from 'react';
import { StyleSheet, Pressable, ViewStyle, StyleProp } from 'react-native';
import { FlashList } from '@shopify/flash-list';
import { YStack, XStack, Text, View, Progress, ProgressIndicator } from 'tamagui';
import { useColors } from '@/utils/colors';
import EmptyOrSkeleton from '@/components/EmptyOrSkeleton';

// Goal interface - this should match your API schema
export interface Goal {
  id: string;
  title: string;
  description?: string;
  progress: number; // 0 to 1
  deadline?: string; // ISO date string
  userId: string;
  createdAt: string;
  updatedAt: string;
}

export interface GoalsListProps {
  /** List of goals to display */
  goals?: Goal[];
  /** Whether the data is loading */
  isLoading?: boolean;
  /** Called when a goal is pressed */
  onGoalPress?: (goal: Goal) => void;
  /** Called when the add button is pressed */
  onAddPress?: () => void;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}

/**
 * Component to render a goal card with progress bar
 */
function GoalCard({
  goal,
  onPress,
}: {
  goal: Goal;
  onPress?: (goal: Goal) => void;
}) {
  const colors = useColors();
  
  // Calculate remaining days if deadline is set
  const daysLeft = goal.deadline 
    ? Math.ceil((new Date(goal.deadline).getTime() - Date.now()) / (1000 * 60 * 60 * 24))
    : null;
  
  // Determine progress status color
  const getProgressColor = () => {
    if (goal.progress >= 1) return colors.status.success;
    if (daysLeft !== null && daysLeft < 3) return colors.status.error;
    if (daysLeft !== null && daysLeft < 7) return colors.status.warning;
    return colors.status.info;
  };
  
  const progressColor = getProgressColor();
  
  return (
    <Pressable
      onPress={() => onPress?.(goal)}
      style={({ pressed }) => [
        styles.card,
        {
          backgroundColor: colors.background.card,
          borderColor: colors.border.default,
          transform: [{ scale: pressed ? 0.98 : 1 }],
        },
      ]}
    >
      <YStack space="$2" padding="$4">
        <Text fontSize="$5" fontWeight="$2" color={colors.content.primary}>
          {goal.title}
        </Text>
        
        {goal.description && (
          <Text fontSize="$3" color={colors.content.secondary} numberOfLines={2}>
            {goal.description}
          </Text>
        )}
        
        <YStack space="$1" marginTop="$2">
          <XStack justifyContent="space-between" alignItems="center">
            <Text fontSize="$3" fontWeight="$2" color={colors.content.secondary}>
              Progress
            </Text>
            <Text fontSize="$3" color={colors.content.subtle}>
              {Math.round(goal.progress * 100)}%
            </Text>
          </XStack>
          
          <Progress value={goal.progress * 100} backgroundColor={colors.background.secondary}>
            <ProgressIndicator backgroundColor={progressColor} />
          </Progress>
        </YStack>
        
        {daysLeft !== null && (
          <XStack justifyContent="flex-end" marginTop="$1">
            <Text 
              fontSize="$2" 
              color={daysLeft < 0 ? colors.status.error : colors.content.subtle}
            >
              {daysLeft < 0 
                ? `Overdue by ${Math.abs(daysLeft)} days` 
                : daysLeft === 0 
                  ? "Due today" 
                  : `${daysLeft} days left`}
            </Text>
          </XStack>
        )}
      </YStack>
    </Pressable>
  );
}

/**
 * Component to display a list of goals with progress indicators
 */
export default function GoalsList({
  goals = [],
  isLoading = false,
  onGoalPress,
  onAddPress,
  style,
}: GoalsListProps) {
  const colors = useColors();
  
  return (
    <YStack flex={1} style={style}>
      <EmptyOrSkeleton
        isLoading={isLoading}
        isEmpty={goals.length === 0}
        skeletonCount={3}
        skeletonHeight={160}
        skeletonBorderRadius={12}
        title="No goals yet"
        message="Create a new goal to track your progress"
      >
        <FlashList
          data={goals}
          renderItem={({ item }) => (
            <GoalCard goal={item} onPress={onGoalPress} />
          )}
          estimatedItemSize={180}
          contentContainerStyle={styles.listContent}
          ItemSeparatorComponent={() => <View style={styles.separator} />}
        />
      </EmptyOrSkeleton>
      
      {onAddPress && (
        <Pressable
          onPress={onAddPress}
          style={({ pressed }) => [
            styles.addButton,
            {
              backgroundColor: colors.brand.primary,
              opacity: pressed ? 0.9 : 1,
              transform: [{ scale: pressed ? 0.97 : 1 }],
            }
          ]}
        >
          <Text fontSize="$4" fontWeight="$3" color="white">
            + Add Goal
          </Text>
        </Pressable>
      )}
    </YStack>
  );
}

const styles = StyleSheet.create({
  card: {
    borderRadius: 12,
    borderWidth: 1,
    overflow: 'hidden',
  },
  listContent: {
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  separator: {
    height: 12,
  },
  addButton: {
    position: 'absolute',
    bottom: 24,
    right: 24,
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 30,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 4,
  },
}); ```

## File: ./components/planner/HabitTracker.tsx
```
import React, { useState } from "react";
import { View, StyleSheet } from "react-native";
import { XStack, YStack, Text, Button, H4, Separator } from "tamagui";
import StreakCalendar from './StreakCalendar';
import { Plus, Check } from "@tamagui/lucide-icons";
import { format } from "date-fns";

interface Habit {
  id: string;
  name: string;
  description?: string;
  completedDates: string[]; // ISO date strings
}

interface HabitTrackerProps {
  habits: Habit[];
  onAddHabit?: () => void;
  onToggleHabit?: (habitId: string, date: string, completed: boolean) => void;
  onHabitPress?: (habit: Habit) => void;
}

export function HabitTracker({
  habits = [],
  onAddHabit,
  onToggleHabit,
  onHabitPress,
}: HabitTrackerProps) {
  const today = format(new Date(), "yyyy-MM-dd");

  const handleToggleHabit = (habit: Habit) => {
    if (!onToggleHabit) return;
    
    const isCompleted = habit.completedDates.includes(today);
    onToggleHabit(habit.id, today, !isCompleted);
  };

  return (
    <YStack space="$4">
      <XStack justifyContent="space-between" alignItems="center">
        <H4>Habits</H4>
        <Button 
          size="$2" 
          circular 
          icon={<Plus size={16} />} 
          onPress={onAddHabit}
        />
      </XStack>

      {habits.length === 0 ? (
        <YStack 
          p="$4"
          alignItems="center" 
          justifyContent="center" 
          backgroundColor="$gray2" 
          borderRadius="$4"
        >
          <Text color="$gray11" textAlign="center">
            No habits yet. Add your first habit to start tracking.
          </Text>
        </YStack>
      ) : (
        <YStack space="$3">
          {habits.map((habit, index) => (
            <YStack key={habit.id} space="$2">
              {index > 0 && <Separator />}
              <HabitItem 
                habit={habit} 
                onToggle={() => handleToggleHabit(habit)}
                onPress={() => onHabitPress?.(habit)} 
              />
            </YStack>
          ))}
        </YStack>
      )}
    </YStack>
  );
}

interface HabitItemProps {
  habit: Habit;
  onToggle: () => void;
  onPress: () => void;
}

function HabitItem({ habit, onToggle, onPress }: HabitItemProps) {
  const today = format(new Date(), "yyyy-MM-dd");
  const isCompletedToday = habit.completedDates.includes(today);

  return (
    <XStack 
      p="$3"
      borderRadius="$4" 
      backgroundColor="$gray2"
      justifyContent="space-between"
      alignItems="center"
      pressStyle={{ opacity: 0.8 }}
      onPress={onPress}
    >
      <YStack space="$1" flex={1}>
        <Text fontSize="$3" fontWeight="$5">
          {habit.name}
        </Text>
        {habit.description && (
          <Text fontSize="$2" color="$gray11">
            {habit.description}
          </Text>
        )}
        
        <YStack mt="$2">
          <StreakCalendar
            completedDates={habit.completedDates}
          />
        </YStack>
      </YStack>

      <Button
        size="$3"
        circular
        backgroundColor={isCompletedToday ? "$primary9" : "$gray4"}
        onPress={(e) => {
          e.stopPropagation();
          onToggle();
        }}
        pressStyle={{
          backgroundColor: isCompletedToday ? "$primary8" : "$gray5",
        }}
      >
        <Check 
          size={18} 
          color={isCompletedToday ? "$gray1" : "$gray11"} 
        />
      </Button>
    </XStack>
  );
} ```

## File: ./components/planner/HabitsList.tsx
```
import React, { useState } from 'react';
import { StyleSheet, Pressable, ViewStyle, StyleProp } from 'react-native';
import { YStack, XStack, Text, View, Checkbox } from 'tamagui';
import { useColors } from '@/utils/colors';
import EmptyOrSkeleton from '@/components/EmptyOrSkeleton';
import * as Haptics from 'expo-haptics';

// Habit interface - this should match your API schema
export interface Habit {
  id: string;
  title: string;
  description?: string;
  frequency: 'daily' | 'weekly' | 'monthly';
  completedToday: boolean;
  streak: number;
  userId: string;
  createdAt: string;
  updatedAt: string;
}

export interface HabitsListProps {
  /** List of habits to display */
  habits?: Habit[];
  /** Whether the data is loading */
  isLoading?: boolean;
  /** Called when a habit's completion status is toggled */
  onToggleHabit?: (habitId: string, completed: boolean) => Promise<void>;
  /** Called when a habit item is pressed */
  onHabitPress?: (habit: Habit) => void;
  /** Called when the add button is pressed */
  onAddPress?: () => void;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}

/**
 * Component to render a habit item with checkbox
 */
function HabitItem({
  habit,
  onToggle,
  onPress,
}: {
  habit: Habit;
  onToggle?: (habitId: string, completed: boolean) => Promise<void>;
  onPress?: (habit: Habit) => void;
}) {
  const colors = useColors();
  const [isChecked, setIsChecked] = useState(habit.completedToday);
  const [isUpdating, setIsUpdating] = useState(false);
  
  const handleToggle = async () => {
    if (isUpdating || !onToggle) return;
    
    // Optimistic update
    const newValue = !isChecked;
    setIsChecked(newValue);
    
    // Provide haptic feedback
    if (newValue) {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    } else {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    
    try {
      setIsUpdating(true);
      await onToggle(habit.id, newValue);
    } catch (error) {
      // Revert on error
      setIsChecked(!newValue);
      console.error('Failed to update habit:', error);
    } finally {
      setIsUpdating(false);
    }
  };
  
  // Get frequency text
  const getFrequencyText = () => {
    switch (habit.frequency) {
      case 'daily': return 'Daily';
      case 'weekly': return 'Weekly';
      case 'monthly': return 'Monthly';
      default: return '';
    }
  };
  
  return (
    <Pressable
      onPress={() => onPress?.(habit)}
      style={({ pressed }) => [
        styles.habitItem,
        {
          backgroundColor: colors.background.card,
          borderColor: colors.border.default,
          opacity: isUpdating ? 0.7 : 1,
          transform: [{ scale: pressed ? 0.98 : 1 }],
        },
      ]}
      disabled={isUpdating}
    >
      <XStack space="$3" flex={1} alignItems="center">
        <Checkbox
          checked={isChecked}
          onCheckedChange={handleToggle}
          disabled={isUpdating}
          borderColor={colors.border.default}
          backgroundColor={isChecked ? colors.status.success : undefined}
          opacity={isUpdating ? 0.5 : 1}
          size="$5"
        />
        
        <YStack flex={1} space="$1">
          <Text 
            fontSize="$4" 
            fontWeight="$2" 
            color={colors.content.primary}
            textDecorationLine={isChecked ? 'line-through' : 'none'}
            opacity={isChecked ? 0.8 : 1}
          >
            {habit.title}
          </Text>
          
          <XStack space="$3" alignItems="center">
            <Text fontSize="$2" color={colors.content.subtle}>
              {getFrequencyText()}
            </Text>
            
            {habit.streak > 0 && (
              <XStack space="$1" alignItems="center">
                <Text fontSize="$2" color={colors.status.success} fontWeight="$2">
                  {habit.streak} day streak 🔥
                </Text>
              </XStack>
            )}
          </XStack>
        </YStack>
      </XStack>
    </Pressable>
  );
}

/**
 * Component to display a list of habits with checkboxes
 */
export default function HabitsList({
  habits = [],
  isLoading = false,
  onToggleHabit,
  onHabitPress,
  onAddPress,
  style,
}: HabitsListProps) {
  const colors = useColors();
  
  return (
    <YStack flex={1} style={style}>
      <EmptyOrSkeleton
        isLoading={isLoading}
        isEmpty={habits.length === 0}
        skeletonCount={4}
        skeletonHeight={80}
        skeletonBorderRadius={12}
        title="No habits yet"
        message="Create a habit to track your daily progress"
      >
        <YStack space="$2" padding="$4">
          {habits.map((habit) => (
            <HabitItem
              key={habit.id}
              habit={habit}
              onToggle={onToggleHabit}
              onPress={onHabitPress}
            />
          ))}
        </YStack>
      </EmptyOrSkeleton>
      
      {onAddPress && (
        <Pressable
          onPress={onAddPress}
          style={({ pressed }) => [
            styles.addButton,
            {
              backgroundColor: colors.brand.primary,
              opacity: pressed ? 0.9 : 1,
              transform: [{ scale: pressed ? 0.97 : 1 }],
            }
          ]}
        >
          <Text fontSize="$4" fontWeight="$3" color="white">
            + Add Habit
          </Text>
        </Pressable>
      )}
    </YStack>
  );
}

const styles = StyleSheet.create({
  habitItem: {
    borderRadius: 12,
    borderWidth: 1,
    padding: 16,
    marginBottom: 8,
  },
  addButton: {
    position: 'absolute',
    bottom: 24,
    right: 24,
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 30,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 4,
  },
}); ```

## File: ./components/planner/StreakCalendar.tsx
```
import React, { useMemo } from 'react';
import { StyleSheet, ViewStyle, StyleProp } from 'react-native';
import { View, XStack, YStack, Text, Circle } from 'tamagui';
import { useColors } from '@/utils/colors';
import { format, startOfWeek, addDays, isSameDay, subWeeks, addWeeks } from 'date-fns';

export interface StreakCalendarProps {
  /** Array of dates (ISO strings) when the habit was completed */
  completedDates: string[];
  /** Number of weeks to display (default: 4) */
  weekCount?: number;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}

/**
 * Component that displays a habit completion calendar with dots for each day
 */
export default function StreakCalendar({
  completedDates = [],
  weekCount = 4,
  style,
}: StreakCalendarProps) {
  const today = new Date();

  const completedDatesObjects = useMemo(() => {
    return completedDates.map(dateStr => new Date(dateStr));
  }, [completedDates]);

  // Generate weeks from the current week backwards
  const weeks = useMemo(() => {
    const result = [];
    const day = startOfWeek(today, { weekStartsOn: 0 }); // Sunday as first day

    // Get current week
    const currentWeek = Array(7)
      .fill(null)
      .map((_, i) => {
        const date = addDays(day, i);
        return {
          date,
          completed: completedDatesObjects.some((d) => isSameDay(d, date)),
          isToday: isSameDay(date, today),
          isPast: date < today,
          isFuture: date > today,
        };
      });
    result.push(currentWeek);

    // Get previous weeks
    for (let i = 1; i < weekCount; i++) {
      const startDay = subWeeks(day, i);
      const week = Array(7)
        .fill(null)
        .map((_, j) => {
          const date = addDays(startDay, j);
          return {
            date,
            completed: completedDatesObjects.some((d) => isSameDay(d, date)),
            isToday: false,
            isPast: date < today,
            isFuture: date > today,
          };
        });
      result.push(week);
    }

    // Reverse so most recent week is at the bottom
    return result.reverse();
  }, [completedDatesObjects, weekCount, today]);

  const dayNames = useMemo(() => {
    const firstDayOfWeek = startOfWeek(new Date(), { weekStartsOn: 0 });
    return Array(7)
      .fill(null)
      .map((_, i) => {
        return format(addDays(firstDayOfWeek, i), "EEE").charAt(0);
      });
  }, []);

  return (
    <YStack space="$3" style={style}>
      <Text fontSize="$3" fontWeight="$3" color="$content.primary">
        Activity
      </Text>
      
      <XStack justifyContent="space-between">
        {dayNames.map((day, index) => (
          <Text key={index} color="$gray11" textAlign="center" fontSize="$1">
            {day}
          </Text>
        ))}
      </XStack>
      
      <YStack space="$3">
        {weeks.map((week, weekIndex) => (
          <XStack key={`week-${weekIndex}`} justifyContent="space-between">
            {week.map((day, dayIndex) => (
              <YStack key={`day-${weekIndex}-${dayIndex}`} alignItems="center" space="$1">
                <Text 
                  fontSize="$1" 
                  color={day.isToday ? "$brand.primary" : "$content.subtle"}
                  fontWeight={day.isToday ? '$3' : '$2'}
                >
                  {day.date.getDate()}
                </Text>
                
                {/* Day circle */}
                <DayCircle 
                  completed={day.completed}
                  isToday={day.isToday}
                  isPast={day.isPast}
                  isFuture={day.isFuture}
                />
              </YStack>
            ))}
          </XStack>
        ))}
      </YStack>
      
      {/* Legend */}
      <XStack space="$4" justifyContent="center" marginTop="$2">
        <XStack space="$1" alignItems="center">
          <View
            style={{
              width: 8,
              height: 8,
              borderRadius: 4,
              backgroundColor: "$gray6",
            }}
          />
          <Text fontSize="$2" color="$content.subtle">Not completed</Text>
        </XStack>
        
        <XStack space="$1" alignItems="center">
          <View
            style={{
              width: 8,
              height: 8,
              borderRadius: 4,
              backgroundColor: "$primary9",
            }}
          />
          <Text fontSize="$2" color="$content.subtle">Completed</Text>
        </XStack>
      </XStack>
    </YStack>
  );
}

function DayCircle({ 
  completed, 
  isToday, 
  isPast, 
  isFuture 
}: { 
  completed: boolean; 
  isToday: boolean;
  isPast: boolean;
  isFuture: boolean;
}) {
  let backgroundColor = completed 
    ? "$primary9" 
    : "transparent";
  
  // Future dates should be more faded
  if (isFuture) {
    backgroundColor = "transparent";
  }
  
  return (
    <View style={[
      styles.dayCircle,
      {
        backgroundColor,
        borderWidth: isToday ? 1 : 0,
        borderColor: "$primary9",
      }
    ]} />
  );
}

const styles = StyleSheet.create({
  dayCircle: {
    width: 32,
    height: 32,
    borderRadius: 16,
  },
}); ```

## File: ./components/rewards/ConfettiBurst.tsx
```
import React, { useEffect } from 'react';
import { StyleSheet, Dimensions } from 'react-native';
import { View } from 'tamagui';
import Animated, {
  useSharedValue,
  withDelay,
  withTiming,
  useAnimatedStyle,
  withSequence,
  runOnJS,
  Easing,
} from 'react-native-reanimated';
import { durations, easings } from '@/constants/motion';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

// Define confetti piece colors
const COLORS = [
  '#FF5252', // Red
  '#FFD740', // Amber
  '#64FFDA', // Teal
  '#448AFF', // Blue
  '#B388FF', // Deep Purple
  '#FF80AB', // Pink
  '#1DE9B6', // Green
  '#F48FB1', // Light Pink
];

// Number of confetti pieces
const CONFETTI_COUNT = 50;

// Confetti piece configuration
interface ConfettiPiece {
  id: number;
  x: number;
  y: number;
  size: number;
  color: string;
  rotation: number;
  delay: number;
  duration: number;
}

interface ConfettiBurstProps {
  /** Whether to show the confetti */
  isVisible: boolean;
  /** Called when animation completes */
  onComplete?: () => void;
  /** Number of confetti pieces to display (default: 50) */
  count?: number;
  /** Custom colors to use for confetti pieces */
  colors?: string[];
  /** Duration of the animation in ms (default: 2000) */
  duration?: number;
}

/**
 * A component that displays a burst of confetti animation
 */
export default function ConfettiBurst({
  isVisible,
  onComplete,
  count = CONFETTI_COUNT,
  colors = COLORS,
  duration = 2000,
}: ConfettiBurstProps) {
  // Create confetti pieces
  const pieces = React.useMemo(() => {
    const result: ConfettiPiece[] = [];
    
    for (let i = 0; i < count; i++) {
      result.push({
        id: i,
        x: Math.random() * SCREEN_WIDTH,
        y: -20, // Start above the screen
        size: Math.random() * 8 + 4, // Size between 4-12
        color: colors[Math.floor(Math.random() * colors.length)],
        rotation: Math.random() * 360,
        delay: Math.random() * 500, // Random delay up to 500ms
        duration: Math.random() * 1000 + 1500, // Duration between 1.5-2.5s
      });
    }
    
    return result;
  }, [count, colors]);
  
  // Trigger animation complete callback
  const animationComplete = () => {
    if (onComplete) {
      onComplete();
    }
  };
  
  return (
    <>
      {isVisible && (
        <View style={styles.container} pointerEvents="none">
          {pieces.map((piece) => (
            <ConfettiPiece
              key={piece.id}
              piece={piece}
              animationDuration={duration}
              onComplete={animationComplete}
            />
          ))}
        </View>
      )}
    </>
  );
}

// Individual confetti piece component
function ConfettiPiece({
  piece,
  animationDuration,
  onComplete,
}: {
  piece: ConfettiPiece;
  animationDuration: number;
  onComplete: () => void;
}) {
  const translateY = useSharedValue(piece.y);
  const translateX = useSharedValue(piece.x);
  const rotate = useSharedValue(piece.rotation);
  const opacity = useSharedValue(1);
  
  // Track if this is the last piece to complete
  const wasLastPiece = React.useRef(false);
  
  useEffect(() => {
    // Last piece will trigger onComplete
    if (piece.id === CONFETTI_COUNT - 1) {
      wasLastPiece.current = true;
    }
    
    // Start Y animation (falling down)
    translateY.value = withDelay(
      piece.delay,
      withTiming(
        SCREEN_HEIGHT + 50, // End below the screen
        {
          duration: piece.duration,
          easing: easings.accelerate,
        },
        () => {
          if (wasLastPiece.current) {
            runOnJS(onComplete)();
          }
        }
      )
    );
    
    // Swaying horizontal movement
    translateX.value = withDelay(
      piece.delay,
      withSequence(
        withTiming(piece.x - 50 + Math.random() * 100, {
          duration: piece.duration * 0.3,
          easing: easings.standard,
        }),
        withTiming(piece.x + 50 + Math.random() * 100, {
          duration: piece.duration * 0.3,
          easing: easings.standard,
        }),
        withTiming(piece.x - 25 + Math.random() * 50, {
          duration: piece.duration * 0.4,
          easing: easings.standard,
        })
      )
    );
    
    // Rotation animation
    rotate.value = withDelay(
      piece.delay,
      withTiming(piece.rotation + Math.random() * 720, {
        duration: piece.duration,
        easing: easings.standard,
      })
    );
    
    // Fade out toward the end
    opacity.value = withDelay(
      piece.delay + (piece.duration * 0.7),
      withTiming(0, {
        duration: piece.duration * 0.3,
        easing: easings.standard,
      })
    );
  }, []);
  
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: translateX.value },
        { translateY: translateY.value },
        { rotate: `${rotate.value}deg` },
      ],
      opacity: opacity.value,
    };
  });
  
  return (
    <Animated.View
      style={[
        {
          position: 'absolute',
          width: piece.size,
          height: piece.size * (Math.random() * 0.8 + 0.2), // Varying heights
          backgroundColor: piece.color,
          borderRadius: Math.random() > 0.5 ? piece.size / 2 : 0, // Some round, some square
        },
        animatedStyle,
      ]}
    />
  );
}

const styles = StyleSheet.create({
  container: {
    ...StyleSheet.absoluteFillObject,
    zIndex: 999,
    pointerEvents: 'none',
  },
}); ```

## File: ./components/settings/NotificationRow.tsx
```
import React, { ReactNode } from 'react';
import { StyleSheet, ViewStyle, StyleProp } from 'react-native';
import { XStack, Text, Switch, SwitchProps, YStack } from 'tamagui';
import { useColors } from '@/utils/colors';

export interface NotificationRowProps {
  /** Title of the notification setting */
  title: string;
  /** Optional description */
  description?: string;
  /** Whether the notification is turned on */
  enabled: boolean;
  /** Called when the switch is toggled */
  onToggle: (value: boolean) => void;
  /** Icon to display in the row */
  icon?: ReactNode;
  /** Whether the control is in loading state */
  isLoading?: boolean;
  /** Switch props */
  switchProps?: Omit<SwitchProps, 'checked' | 'onCheckedChange'>;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}

/**
 * A component for displaying a notification setting row with toggle switch
 */
export default function NotificationRow({
  title,
  description,
  enabled,
  onToggle,
  icon,
  isLoading,
  switchProps,
  style,
}: NotificationRowProps) {
  const colors = useColors();
  
  const handleToggle = (value: boolean) => {
    if (!isLoading) {
      onToggle(value);
    }
  };
  
  return (
    <XStack
      style={[styles.container, style]}
      alignItems="center"
      justifyContent="space-between"
      padding="$4"
      backgroundColor={colors.background.card}
      borderRadius="$4"
    >
      <XStack alignItems="center" space="$3" flex={1}>
        {icon && <XStack opacity={isLoading ? 0.5 : 1}>{icon}</XStack>}
        
        <YStack space="$1" flex={1} opacity={isLoading ? 0.5 : 1}>
          <Text
            fontSize="$4"
            fontWeight="$2"
            color={colors.content.primary}
          >
            {title}
          </Text>
          
          {description && (
            <Text
              fontSize="$3"
              color={colors.content.secondary}
            >
              {description}
            </Text>
          )}
        </YStack>
      </XStack>
      
      <Switch
        size="$2"
        checked={enabled}
        onCheckedChange={handleToggle}
        disabled={isLoading}
        {...switchProps}
      />
    </XStack>
  );
}

const styles = StyleSheet.create({
  container: {
    marginBottom: 12,
  },
}); ```

## File: ./components/settings/ThemePreview.tsx
```
import React from 'react';
import { StyleSheet, ViewStyle, StyleProp, Pressable } from 'react-native';
import { View, Stack, YStack, Text, XStack, Theme } from 'tamagui';
import { useTheme } from 'tamagui';
import { useColors } from '@/utils/colors';
import { Check } from '@tamagui/lucide-icons';

export interface ThemePreviewProps {
  /** The theme name to display */
  themeName: string;
  /** Whether this theme is currently selected */
  isSelected: boolean;
  /** Called when this theme is selected */
  onSelect: () => void;
  /** Whether to force dark mode for this preview */
  forceDark?: boolean;
  /** Whether to force light mode for this preview */
  forceLight?: boolean;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}

/**
 * A component that displays a preview of a theme with sample UI elements
 */
export default function ThemePreview({
  themeName,
  isSelected,
  onSelect,
  forceDark,
  forceLight,
  style,
}: ThemePreviewProps) {
  const currentTheme = useTheme();
  const previewTheme = forceDark ? 'dark' : forceLight ? 'light' : undefined;
  const colors = useColors();
  
  return (
    <Pressable 
      onPress={onSelect}
      style={({ pressed }) => [
        styles.container,
        {
          transform: [{ scale: pressed ? 0.97 : 1 }],
          borderColor: isSelected ? colors.border.focus : colors.border.default,
          borderWidth: isSelected ? 2 : 1,
        },
        style,
      ]}
    >
      <YStack space="$2">
        <Text
          fontSize="$4"
          fontWeight="$2"
          color={colors.content.primary}
          marginBottom="$1"
        >
          {themeName}
        </Text>
        
        <Theme name={previewTheme}>
          <YStack
            backgroundColor="$cardBackground"
            borderRadius="$3"
            padding="$2"
            space="$2"
          >
            {/* Header Preview */}
            <View 
              style={styles.header}
              backgroundColor="$primary"
            />
            
            {/* Content Preview */}
            <YStack space="$1">
              <View style={styles.textLine} backgroundColor="$color" opacity={0.9} />
              <View style={styles.textLine} backgroundColor="$color" opacity={0.7} width="80%" />
              <View style={styles.textLine} backgroundColor="$color" opacity={0.5} width="60%" />
            </YStack>
            
            {/* Button Preview */}
            <XStack space="$2">
              <View
                style={styles.button}
                backgroundColor="$primary"
              />
              <View
                style={styles.button}
                backgroundColor="$backgroundPress"
              />
            </XStack>
          </YStack>
        </Theme>
        
        {isSelected && (
          <View style={styles.checkContainer}>
            <XStack
              backgroundColor={colors.status.success}
              borderRadius={999}
              alignItems="center"
              justifyContent="center"
              width={24}
              height={24}
            >
              <Check color="white" size={16} />
            </XStack>
          </View>
        )}
      </YStack>
    </Pressable>
  );
}

const styles = StyleSheet.create({
  container: {
    borderRadius: 12,
    padding: 12,
    backgroundColor: 'transparent',
    overflow: 'hidden',
    position: 'relative',
  },
  header: {
    height: 24,
    borderRadius: 4,
  },
  textLine: {
    height: 8,
    borderRadius: 4,
  },
  button: {
    height: 20,
    flex: 1,
    borderRadius: 4,
  },
  checkContainer: {
    position: 'absolute',
    top: 8,
    right: 8,
  },
}); ```

## File: ./components/ui/AnimatedCountingText.tsx
```
import React, { useEffect, useRef } from 'react';
import { Animated, TextProps, StyleSheet } from 'react-native';
import { Text } from 'tamagui';

interface AnimatedCountingTextProps extends TextProps {
  value: number;
  duration?: number;
  formatValue?: (value: number) => string;
  prefix?: string;
  suffix?: string;
}

/**
 * Text component that animates counting up to a value
 * Useful for displaying points, counts, etc. with animation
 */
export function AnimatedCountingText({
  value,
  duration = 800,
  formatValue = (val) => Math.round(val).toString(),
  prefix = '',
  suffix = '',
  ...props
}: AnimatedCountingTextProps) {
  // Value to animate
  const animatedValue = useRef(new Animated.Value(0)).current;
  // Current displayed value for non-JS environments
  const [displayValue, setDisplayValue] = React.useState(formatValue(0));

  useEffect(() => {
    // Create a listener to update the displayed text during animation
    const listener = animatedValue.addListener(({ value: val }) => {
      setDisplayValue(formatValue(val));
    });

    // Animate to the new value
    Animated.timing(animatedValue, {
      toValue: value,
      duration,
      useNativeDriver: false,
    }).start();

    // Clean up listener on unmount or value change
    return () => {
      animatedValue.removeListener(listener);
    };
  }, [value, duration, formatValue, animatedValue]);

  return (
    <Text {...props}>
      {prefix}
      {displayValue}
      {suffix}
    </Text>
  );
}

/**
 * Specialized version for displaying points with a + prefix for changes
 */
export function PointsText({
  value,
  showPlus = false,
  ...props
}: AnimatedCountingTextProps & { showPlus?: boolean }) {
  const prefix = showPlus && value > 0 ? '+' : '';
  
  return (
    <AnimatedCountingText
      value={value}
      prefix={prefix}
      formatValue={(val) => Math.round(val).toLocaleString()}
      {...props}
    />
  );
} ```

## File: ./components/ui/Button.tsx
```
import { Text, styled, Button as TamaguiButton } from 'tamagui';

// Create a styled button with iOS-style appearance
export const Button = styled(TamaguiButton, {
  name: 'Button',
  backgroundColor: '$primary',
  borderRadius: '$3',
  paddingVertical: '$3',
  paddingHorizontal: '$4',
  
  // iOS button variants
  variants: {
    variant: {
      filled: {
        backgroundColor: '$primary',
        color: 'white',
      },
      outline: {
        backgroundColor: 'transparent',
        borderWidth: 1,
        borderColor: '$primary',
        color: '$primary',
      },
      text: {
        backgroundColor: 'transparent',
        color: '$primary',
        paddingVertical: '$2',
        paddingHorizontal: '$2',
      },
    },
    size: {
      small: {
        paddingVertical: '$2',
        paddingHorizontal: '$3',
        borderRadius: '$2',
      },
      medium: {
        paddingVertical: '$3',
        paddingHorizontal: '$4',
        borderRadius: '$3',
      },
      large: {
        paddingVertical: '$4',
        paddingHorizontal: '$5',
        borderRadius: '$4',
      },
    },
  } as const,
  
  // Default variant
  defaultVariants: {
    variant: 'filled',
    size: 'medium',
  } as const,
});

// Create a styled button for iOS-style secondary actions
export const SecondaryButton = styled(Button, {
  name: 'SecondaryButton',
  backgroundColor: 'transparent',
  color: '$primary',
  borderWidth: 0,
});

// Export a ButtonText component for consistent text styling
export const ButtonText = styled(Text, {
  name: 'ButtonText',
  fontSize: 16,
  fontWeight: '500',
  textAlign: 'center',
}); ```

## File: ./components/ui/ConfettiButton.tsx
```
import React, { useState } from 'react';
import { Button, ButtonProps, Spinner, Text } from 'tamagui';
import * as Haptics from 'expo-haptics';

interface ConfettiButtonProps extends ButtonProps {
  onPress: () => Promise<void> | void;
  loadingText?: string;
  isLoading?: boolean;
  successHaptic?: boolean;
}

/**
 * Button that shows loading state and plays haptic feedback on success
 * To be extended with confetti animation when rewards are claimed
 */
export function ConfettiButton({
  children,
  onPress,
  loadingText = 'Loading...',
  isLoading: controlledIsLoading,
  successHaptic = true,
  disabled,
  ...props
}: ConfettiButtonProps) {
  const [internalIsLoading, setInternalIsLoading] = useState(false);
  const isLoading = controlledIsLoading !== undefined ? controlledIsLoading : internalIsLoading;

  const handlePress = async () => {
    if (isLoading) return;
    
    try {
      setInternalIsLoading(true);
      
      // Wait for the onPress to complete
      await onPress();
      
      // Play success haptic
      if (successHaptic) {
        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      }
      
    } catch (error) {
      // Handle error if needed
      console.error('Error in ConfettiButton:', error);
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
    } finally {
      setInternalIsLoading(false);
    }
  };

  return (
    <Button
      {...props}
      onPress={handlePress}
      disabled={disabled || isLoading}
      opacity={isLoading ? 0.7 : 1}
    >
      {isLoading ? (
        <>
          <Spinner size="small" color="$colorTextPrimary" />
          <Text> {loadingText}</Text>
        </>
      ) : (
        children
      )}
    </Button>
  );
} ```

## File: ./components/ui/ErrorBanner.tsx
```
import React from 'react';
import { TouchableOpacity } from 'react-native';
import { YStack, Text, Stack, XStack, StackProps } from 'tamagui';
import * as Haptics from 'expo-haptics';

interface ErrorBannerProps extends StackProps {
  message: string;
  onRetry?: () => void;
  retryLabel?: string;
}

export function ErrorBanner({
  message,
  onRetry,
  retryLabel = 'Tap to retry',
  ...props
}: ErrorBannerProps) {
  const handleRetry = () => {
    if (onRetry) {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      onRetry();
    }
  };

  return (
    <Stack
      backgroundColor="$errorBackground"
      paddingVertical="$2"
      paddingHorizontal="$3"
      borderRadius="$2"
      {...props}
    >
      <XStack alignItems="center" justifyContent="space-between">
        <Text color="$errorText" fontSize={14} flex={1}>
          {message}
        </Text>
        {onRetry && (
          <TouchableOpacity onPress={handleRetry}>
            <Text color="$colorTextPrimary" fontSize={14} marginLeft="$2">
              {retryLabel}
            </Text>
          </TouchableOpacity>
        )}
      </XStack>
    </Stack>
  );
}

// Section-specific error with optional retry
export function SectionError({
  message,
  onRetry,
}: {
  message: string;
  onRetry?: () => void;
}) {
  return (
    <YStack space="$2">
      <Text color="$error" fontSize={14}>
        {message}
      </Text>
      {onRetry && (
        <TouchableOpacity onPress={onRetry}>
          <Text color="$primary" fontSize={14}>
            Tap to retry
          </Text>
        </TouchableOpacity>
      )}
    </YStack>
  );
} ```

## File: ./components/ui/FloatingActionButton.tsx
```
import React, { useState } from 'react';
import { StyleSheet, TouchableOpacity, View, Animated } from 'react-native';
import { Text, Theme, YStack, useTheme } from 'tamagui';
import * as Haptics from 'expo-haptics';
import { useRouter } from 'expo-router';

interface ActionItem {
  label: string;
  icon?: React.ReactNode;
  onPress: () => void;
}

interface FABProps {
  actions: ActionItem[];
  icon?: React.ReactNode;
  position?: 'bottomRight' | 'bottomLeft' | 'topRight' | 'topLeft';
  size?: number;
  color?: string;
}

export function FloatingActionButton({
  actions,
  icon = '+',
  position = 'bottomRight',
  size = 56,
  color,
}: FABProps) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useTheme();
  const actionButtonColor = color || theme.primary.val;
  
  // Animation values
  const animation = React.useRef(new Animated.Value(0)).current;
  
  const toggleMenu = () => {
    const toValue = isOpen ? 0 : 1;
    
    Animated.spring(animation, {
      toValue,
      friction: 5,
      useNativeDriver: true,
    }).start();
    
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    setIsOpen(!isOpen);
  };
  
  const getPosition = () => {
    switch (position) {
      case 'bottomRight':
        return { bottom: 20, right: 20 };
      case 'bottomLeft':
        return { bottom: 20, left: 20 };
      case 'topRight':
        return { top: 20, right: 20 };
      case 'topLeft':
        return { top: 20, left: 20 };
      default:
        return { bottom: 20, right: 20 };
    }
  };
  
  return (
    <View style={[styles.container, getPosition()]}>
      {isOpen && (
        <YStack space={8} marginBottom={8} alignItems={position.includes('Left') ? 'flex-start' : 'flex-end'}>
          {actions.map((action, index) => {
            const actionTranslation = animation.interpolate({
              inputRange: [0, 1],
              outputRange: [size, -10 - (index * (size + 10))],
            });
            
            return (
              <Animated.View
                key={`action-${index}`}
                style={{
                  transform: [{ translateY: actionTranslation }],
                  opacity: animation,
                  flexDirection: 'row',
                  alignItems: 'center',
                }}
              >
                {position.includes('Left') ? null : (
                  <View style={styles.actionLabel}>
                    <Text fontSize={14} color="$color">
                      {action.label}
                    </Text>
                  </View>
                )}
                
                <TouchableOpacity
                  style={[
                    styles.actionButton,
                    { width: size * 0.9, height: size * 0.9, backgroundColor: actionButtonColor }
                  ]}
                  onPress={() => {
                    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
                    toggleMenu();
                    action.onPress();
                  }}
                >
                  {action.icon || (
                    <Text color="white" fontSize={18}>
                      {action.label.charAt(0)}
                    </Text>
                  )}
                </TouchableOpacity>
                
                {position.includes('Left') ? (
                  <View style={styles.actionLabel}>
                    <Text fontSize={14} color="$color">
                      {action.label}
                    </Text>
                  </View>
                ) : null}
              </Animated.View>
            );
          })}
        </YStack>
      )}
      
      <TouchableOpacity
        style={[
          styles.fab,
          { width: size, height: size, backgroundColor: actionButtonColor }
        ]}
        onPress={toggleMenu}
      >
        <Animated.View
          style={{
            transform: [
              {
                rotate: animation.interpolate({
                  inputRange: [0, 1],
                  outputRange: ['0deg', '45deg'],
                }),
              },
            ],
          }}
        >
          {typeof icon === 'string' ? (
            <Text color="white" fontSize={24} fontWeight="bold">
              {icon}
            </Text>
          ) : (
            icon
          )}
        </Animated.View>
      </TouchableOpacity>
    </View>
  );
}

// Helper function to create quick navigation FAB for home screen
export function HomeActionButton() {
  // Get the router object using the hook
  const router = useRouter();
  
  return (
    <FloatingActionButton
      actions={[
        {
          label: 'New Task',
          // Use the router object from the hook
          onPress: () => router.push('/compose?type=task'),
        },
        {
          label: 'Track Habit',
          onPress: () => router.push('/compose?type=habit'),
        },
        {
          label: 'Record State',
          onPress: () => router.push('/compose?type=state'),
        },
      ]}
    />
  );
}

const styles = StyleSheet.create({
  container: {
    position: 'absolute',
    alignItems: 'center',
    zIndex: 999,
  },
  fab: {
    borderRadius: 28,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 3,
  },
  actionButton: {
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
  },
  actionLabel: {
    backgroundColor: 'rgba(250, 250, 250, 0.8)',
    borderRadius: 4,
    paddingHorizontal: 8,
    paddingVertical: 4,
    marginHorizontal: 8,
  },
});```

## File: ./components/ui/FrostedCard.tsx
```
import React, { ReactNode } from 'react';
import { BlurView } from 'expo-blur';
import { StyleSheet, View, useColorScheme } from 'react-native';
import { Card, CardProps, styled, YStack, useTheme } from 'tamagui';

interface FrostedCardProps extends CardProps {
  children: ReactNode;
  blurIntensity?: number;
  height?: number | string;
  tintMode?: 'light' | 'dark' | 'default';
  headerContent?: ReactNode;
}

/**
 * A card component with a frosted glass effect that adapts to light/dark mode
 */
export function FrostedCard({
  children,
  blurIntensity = 10,
  tintMode = 'default',
  height,
  headerContent,
  ...props
}: FrostedCardProps) {
  // Use React Native's useColorScheme for reliable dark mode detection
  const colorScheme = useColorScheme();
  
  // Determine tint based on theme and prop override
  const getTintEffect = () => {
    if (tintMode !== 'default') return tintMode;
    return colorScheme === 'dark' ? 'dark' : 'light';
  };
  
  return (
    <Card
      bordered
      overflow="hidden"
      height={height}
      {...props}
    >
      <BlurView
        style={StyleSheet.absoluteFill}
        intensity={blurIntensity}
        tint={getTintEffect()}
      />
      {headerContent && (
        <Card.Header padded>
          <YStack backgroundColor="transparent">
            {headerContent}
          </YStack>
        </Card.Header>
      )}
      
      <Card.Footer padded backgroundColor="transparent">
        {children}
      </Card.Footer>
    </Card>
  );
}

/**
 * Styled variants for common use cases
 */
export const CardWithTint = styled(Card, {
  variants: {
    tint: {
      primary: {
        backgroundColor: '$primary',
        opacity: 0.85,
      },
      secondary: {
        backgroundColor: '$secondary',
        opacity: 0.85,
      },
      success: {
        backgroundColor: '$success',
        opacity: 0.85,
      },
      warning: {
        backgroundColor: '$warning',
        opacity: 0.85,
      },
      error: {
        backgroundColor: '$error',
        opacity: 0.85,
      },
      glass: {
        backgroundColor: 'rgba(255, 255, 255, 0.15)',
        // Note: real glass effect requires BlurView as in FrostedCard
      },
    },
  },
}); ```

## File: ./components/ui/HabitToggleRow.tsx
```
import React, { useState, useEffect } from 'react';
import { TouchableOpacity, View } from 'react-native';
import { Checkbox, XStack, YStack, Text } from 'tamagui';
import * as Haptics from 'expo-haptics';

interface HabitToggleRowProps {
  habit: {
    id: string;
    name: string;
    streak?: number;
    completedToday?: boolean;
    frequency?: string;
  };
  onToggle?: (habitId: string, newValue: boolean) => Promise<void> | void;
  isUpdating?: boolean;
  showStreak?: boolean;
  showFrequency?: boolean;
  disabled?: boolean;
}

/**
 * A unified component for displaying and toggling habits
 * Used by both Dashboard's HabitCheckItem and Planner's HabitsList
 */
export function HabitToggleRow({
  habit,
  onToggle,
  isUpdating = false,
  showStreak = true,
  showFrequency = false,
  disabled = false,
}: HabitToggleRowProps) {
  const [checked, setChecked] = useState(habit.completedToday || false);

  // Sync with parent's state if it changes
  useEffect(() => {
    if (habit.completedToday !== undefined) {
      setChecked(habit.completedToday);
    }
  }, [habit.completedToday]);

  const handleToggle = async () => {
    if (disabled || isUpdating || !onToggle) return;

    // Optimistic update
    const newValue = !checked;
    setChecked(newValue);
    
    // Haptic feedback
    Haptics.selectionAsync();
    
    try {
      await onToggle(habit.id, newValue);
    } catch (error) {
      // Revert on error
      console.error('Error toggling habit:', error);
      setChecked(!newValue);
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
    }
  };

  return (
    <View style={{ opacity: isUpdating ? 0.5 : 1 }}>
      <XStack space={8} alignItems="center" paddingVertical={8}>
        <Checkbox 
          checked={checked}
          onPress={handleToggle}
          disabled={disabled || isUpdating}
          borderColor={checked ? '$success' : '$gray8'}
          backgroundColor={checked ? '$success' : 'transparent'}
        />
        
        <YStack flex={1}>
          <Text fontSize={16} fontWeight="500" color="$color">
            {habit.name}
          </Text>
          
          {showFrequency && habit.frequency && (
            <Text fontSize={12} color="$colorSecondary">
              {habit.frequency}
            </Text>
          )}
        </YStack>
        
        {showStreak && habit.streak && habit.streak > 0 && (
          <XStack space={4} alignItems="center">
            <Text fontSize={14} fontWeight="600" color="$warning">
              🔥 {habit.streak}
            </Text>
          </XStack>
        )}
      </XStack>
    </View>
  );
} ```

## File: ./components/ui/IconSymbol.ios.tsx
```
import { SymbolView, SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { StyleProp, ViewStyle } from 'react-native';

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = 'regular',
}: {
  name: SymbolViewProps['name'];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    />
  );
}
```

## File: ./components/ui/IconSymbol.tsx
```
// This file is a fallback for using MaterialIcons on Android and web.

import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { SymbolWeight } from 'expo-symbols';
import React from 'react';
import { OpaqueColorValue, StyleProp, TextStyle } from 'react-native';

// Add your SFSymbol to MaterialIcons mappings here.
const MAPPING = {
  // See MaterialIcons here: https://icons.expo.fyi
  // See SF Symbols in the SF Symbols app on Mac.
  'house.fill': 'home',
  'paperplane.fill': 'send',
  'chevron.left.forwardslash.chevron.right': 'code',
  'chevron.right': 'chevron-right',
} as Partial<
  Record<
    import('expo-symbols').SymbolViewProps['name'],
    React.ComponentProps<typeof MaterialIcons>['name']
  >
>;

export type IconSymbolName = keyof typeof MAPPING;

/**
 * An icon component that uses native SFSymbols on iOS, and MaterialIcons on Android and web. This ensures a consistent look across platforms, and optimal resource usage.
 *
 * Icon `name`s are based on SFSymbols and require manual mapping to MaterialIcons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<TextStyle>;
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}
```

## File: ./components/ui/Skeleton.tsx
```
import React from 'react';
import { Stack, StackProps, useTheme } from 'tamagui';
import { Animated, Easing } from 'react-native';
import { useEffect, useRef } from 'react';

interface SkeletonProps extends StackProps {
  width?: number | string;
  height?: number | string;
  borderRadius?: number;
  animated?: boolean;
}

export function Skeleton({
  width = '100%',
  height = 60,
  borderRadius = 8,
  animated = true,
  ...props
}: SkeletonProps) {
  const theme = useTheme();
  const opacity = useRef(new Animated.Value(0.3)).current;

  useEffect(() => {
    if (!animated) return;

    const pulseAnimation = Animated.sequence([
      Animated.timing(opacity, {
        toValue: 0.6,
        duration: 800,
        easing: Easing.ease,
        useNativeDriver: true,
      }),
      Animated.timing(opacity, {
        toValue: 0.3,
        duration: 800,
        easing: Easing.ease,
        useNativeDriver: true,
      }),
    ]);

    const loopAnimation = Animated.loop(pulseAnimation);
    loopAnimation.start();

    return () => {
      loopAnimation.stop();
    };
  }, [animated, opacity]);

  return (
    <Stack
      backgroundColor={theme.gray4?.val || "#e0e0e0"}
      width={width}
      height={height}
      borderRadius={borderRadius}
      opacity={opacity}
      {...props}
    />
  );
}

export function SkeletonText(props: SkeletonProps) {
  return <Skeleton height={18} {...props} />;
}

export function SkeletonRow({ count = 1 }: { count?: number }) {
  return (
    <Stack space="$2">
      {Array.from({ length: count }).map((_, index) => (
        <Skeleton key={index} />
      ))}
    </Stack>
  );
} ```

## File: ./components/ui/TabBarBackground.ios.tsx
```
import { useBottomTabBarHeight } from '@react-navigation/bottom-tabs';
import { BlurView } from 'expo-blur';
import { StyleSheet } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

export default function BlurTabBarBackground() {
  return (
    <BlurView
      // System chrome material automatically adapts to the system's theme
      // and matches the native tab bar appearance on iOS.
      tint="systemChromeMaterial"
      intensity={100}
      style={StyleSheet.absoluteFill}
    />
  );
}

export function useBottomTabOverflow() {
  const tabHeight = useBottomTabBarHeight();
  const { bottom } = useSafeAreaInsets();
  return tabHeight - bottom;
}
```

## File: ./components/ui/TabBarBackground.tsx
```
// This is a shim for web and Android where the tab bar is generally opaque.
export default undefined;

export function useBottomTabOverflow() {
  return 0;
}
```

## File: ./components/ui/iOS/Button.tsx
```
import { Button as TamaguiButton, Text, styled } from 'tamagui';
import { Pressable, StyleSheet, View } from 'react-native';
import { BlurView } from 'expo-blur';
import * as Haptics from 'expo-haptics';
import { GestureResponderEvent } from 'react-native';

type ButtonVariant = 'filled' | 'outline' | 'text';
type ButtonSize = 'small' | 'medium' | 'large';

// Create a styled button with iOS-style appearance
export const Button = styled(TamaguiButton, {
  name: 'iOSButton',
  backgroundColor: '$blue',
  borderRadius: '$3',
  height: 44,
  paddingHorizontal: 16,
  
  // iOS button variants
  variants: {
    variant: {
      filled: {
        backgroundColor: '$blue',
        color: '#fff',
      },
      outline: {
        backgroundColor: 'transparent',
        borderWidth: 1,
        borderColor: '$blue',
        color: '$blue',
      },
      text: {
        backgroundColor: 'transparent',
        color: '$blue',
        height: 'auto',
      },
    },
    size: {
      small: {
        height: 32,
        paddingHorizontal: 12,
        borderRadius: '$2',
      },
      medium: {
        height: 44,
        paddingHorizontal: 16,
        borderRadius: '$3',
      },
      large: {
        height: 52,
        paddingHorizontal: 20,
        borderRadius: '$4',
      },
    },
  } as const,
  
  // Default variant - properly typed
  defaultVariants: {
    variant: 'filled' as ButtonVariant,
    size: 'medium' as ButtonSize,
  },
});

// Create a button that plays haptic feedback on press
export function HapticButton(props: React.ComponentProps<typeof Button>) {
  const onPressWithHaptic = async (event: GestureResponderEvent) => {
    // Use impactAsync for light haptic feedback
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    // Call the original onPress handler if provided
    if (props.onPress) {
      props.onPress(event);
    }
  };

  return <Button {...props} onPress={onPressWithHaptic} />;
}

// Simple wrapper for button text
export function ButtonText(props: { children: React.ReactNode }) {
  return (
    <Text
      fontWeight="500"
      fontSize={16}
      textAlign="center"
      {...props}
    />
  );
} ```

## File: ./components/ui/iOS/NativeWindButton.tsx
```
import { Pressable, Text, type PressableProps } from 'react-native';

// iOS Button with NativeWind styling
interface ButtonProps extends PressableProps {
  variant?: 'filled' | 'outline' | 'text';
  size?: 'small' | 'medium' | 'large';
  label: string;
}

export function NWButton({
  variant = 'filled',
  size = 'medium',
  label,
  ...props
}: ButtonProps) {
  // Base classes for all buttons
  const baseClasses = 'items-center justify-center';
  
  // Variant-specific classes
  const variantClasses = {
    filled: 'bg-ios-blue',
    outline: 'bg-transparent border border-ios-blue',
    text: 'bg-transparent',
  };
  
  // Size-specific classes
  const sizeClasses = {
    small: 'py-2 px-3 rounded-ios-small',
    medium: 'py-3 px-4 rounded-ios-regular',
    large: 'py-4 px-6 rounded-ios-large',
  };
  
  // Text color classes
  const textColorClasses = {
    filled: 'text-white',
    outline: 'text-ios-blue',
    text: 'text-ios-blue',
  };
  
  return (
    <Pressable
      className={`${baseClasses} ${variantClasses[variant]} ${sizeClasses[size]}`}
      {...props}
    >
      <Text className={`font-ios-medium ${textColorClasses[variant]}`}>
        {label}
      </Text>
    </Pressable>
  );
} ```

## File: ./components/ui/nativewind-setup.tsx
```
import { useColorScheme } from 'react-native';
import { type PropsWithChildren, createContext, useContext, useEffect, useState } from 'react';

// Create a context to provide the current color scheme to NativeWind
export const ColorSchemeContext = createContext<'light' | 'dark' | null>(null);

// Helper hook to get the current color scheme
export function useNativeWindColorScheme() {
  const colorScheme = useContext(ColorSchemeContext);
  return colorScheme ?? 'light';
}

// Provider component that detects the device color scheme and provides it to components
export function NativeWindProvider({ children, theme }: PropsWithChildren & { theme: 'light' | 'dark' }) {
  // We now receive the theme from the parent provider
  const colorScheme = useColorScheme();
  // Note: This provider might become simpler if NativeWind v4 has direct theme support
  // For now, we pass the theme down via context.
  
  // Update when system theme changes
  // useEffect(() => {
  //   setCurrentScheme(colorScheme === 'dark' ? 'dark' : 'light');
  // }, [colorScheme]); // We might want to keep sync with system OR rely solely on Zustand state
  
  return (
    <ColorSchemeContext.Provider value={theme}>
      {children}
    </ColorSchemeContext.Provider>
  );
} ```

## File: ./constants/Colors.ts
```
/**
 * Below are the colors that are used in the app. The colors are defined in the light and dark mode.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */

const tintColorLight = '#0a7ea4';
const tintColorDark = '#fff';

export const Colors = {
  light: {
    text: '#11181C',
    background: '#fff',
    tint: tintColorLight,
    icon: '#687076',
    tabIconDefault: '#687076',
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: '#ECEDEE',
    background: '#151718',
    tint: tintColorDark,
    icon: '#9BA1A6',
    tabIconDefault: '#9BA1A6',
    tabIconSelected: tintColorDark,
  },
};
```

## File: ./constants/motion.ts
```
import { Easing } from 'react-native-reanimated';

/**
 * Standard animation durations (in milliseconds)
 */
export const durations = {
  /** Ultra-fast for micro-interactions */
  micro: 80,
  /** Tap/press feedback */
  tap: 120,
  /** Default animation speed for most UI transitions */
  standard: 200,
  /** For more noticeable animations */
  medium: 250,
  /** Modal entrances/exits, complex transitions */
  modal: 300,
  /** Full screen transitions */
  screen: 350,
  /** Extended animations for emphasis */
  long: 450,
};

/**
 * Standard easing curves
 */
export const easings = {
  /** Quick acceleration, gradual deceleration - for elements entering the screen */
  enter: Easing.bezier(0.25, 0.1, 0.25, 1.0),
  /** Gradual acceleration, quick deceleration - for elements exiting the screen */
  exit: Easing.bezier(0.25, 0.0, 0.2, 1.0),
  /** For transitions between UI states */
  standard: Easing.bezier(0.4, 0.0, 0.2, 1.0),
  /** Quick in, quick out - for emphasis */
  energetic: Easing.bezier(0.55, 0.0, 0.1, 1.0),
  /** Linear - consistent motion with no acceleration/deceleration */
  linear: Easing.linear,
  /** Slow start, fast finish */
  accelerate: Easing.in(Easing.quad),
  /** Fast start, slow finish */
  decelerate: Easing.out(Easing.quad),
  /** Fast start and end, slower in the middle */
  emphasize: Easing.inOut(Easing.quad),
};

/**
 * Animation presets for common UI patterns
 */
export const presets = {
  fadeIn: {
    duration: durations.standard,
    easing: easings.enter,
  },
  fadeOut: {
    duration: durations.standard,
    easing: easings.exit,
  },
  slideIn: {
    duration: durations.modal,
    easing: easings.enter,
  },
  slideOut: {
    duration: durations.modal,
    easing: easings.exit,
  },
  scaleIn: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  scaleOut: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  tapFeedback: {
    duration: durations.tap,
    easing: easings.emphasize,
  },
  skeleton: {
    duration: durations.long * 2,
    easing: easings.linear,
  },
};

/**
 * Animation values for specific components
 */
export const componentAnimations = {
  toast: {
    show: {
      duration: durations.modal,
      easing: easings.enter,
    },
    hide: {
      duration: durations.standard,
      easing: easings.exit,
    },
  },
  modal: {
    overlay: {
      show: {
        duration: durations.modal,
        easing: easings.standard,
      },
      hide: {
        duration: durations.modal,
        easing: easings.standard,
      },
    },
    content: {
      show: {
        duration: durations.modal,
        easing: easings.enter,
      },
      hide: {
        duration: durations.standard,
        easing: easings.exit,
      },
    },
  },
  button: {
    press: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
    release: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
  },
  navigation: {
    screen: {
      duration: durations.screen,
      easing: easings.standard,
    },
    tab: {
      duration: durations.standard,
      easing: easings.standard,
    },
  },
}; ```

## File: ./debug/toast-test.tsx
```
import React from 'react';
import { Button, YStack, XStack, Text, Theme } from 'tamagui';
import { useToast } from '@/providers/ToastProvider';
import { StatusBar } from 'expo-status-bar';
import { View } from 'react-native';

export default function ToastTestScreen() {
  const { showToast } = useToast();

  const testSuccessToast = () => {
    showToast({
      type: 'success',
      title: 'Success',
      message: 'This is a success toast message',
      duration: 3000,
    });
  };

  const testErrorToast = () => {
    showToast({
      type: 'error',
      title: 'Error',
      message: 'This is an error toast message',
      duration: 3000,
    });
  };

  const testInfoToast = () => {
    showToast({
      type: 'info',
      message: 'This is an info toast without a title',
      duration: 3000,
    });
  };

  return (
    <View style={{ flex: 1 }}>
      <StatusBar style="auto" />
      <YStack
        flex={1}
        padding={20}
        space={16}
        justifyContent="center"
        alignItems="center"
      >
        <Text fontSize={24} fontWeight="bold" marginBottom={20}>
          Toast Test Screen
        </Text>
        
        <Button 
          onPress={testSuccessToast} 
          backgroundColor="$green6" 
          size="$4"
        >
          Show Success Toast
        </Button>
        
        <Button 
          onPress={testErrorToast} 
          backgroundColor="$red6" 
          size="$4"
        >
          Show Error Toast
        </Button>
        
        <Button 
          onPress={testInfoToast} 
          backgroundColor="$blue6" 
          size="$4"
        >
          Show Info Toast
        </Button>
      </YStack>
    </View>
  );
} ```

## File: ./expo-env.d.ts
```
/// <reference types="expo/types" />

// NOTE: This file should not be edited and should be in your git ignore```

## File: ./global.d.ts
```
/// <reference types="nativewind/types" /> ```

## File: ./hooks/useColorScheme.ts
```
export { useColorScheme } from 'react-native';
```

## File: ./hooks/useColorScheme.web.ts
```
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}
```

## File: ./hooks/useOfflineSync.ts
```
import { useEffect, useCallback } from 'react';
import NetInfo from '@react-native-community/netinfo';
import { onlineManager } from '@tanstack/react-query';
import { saveOfflineMutation, syncOfflineMutations, getPendingItems, PendingItem, setupBackgroundSync } from '@/utils/offline-sync';
import { useState } from 'react';

/**
 * Hook to provide offline sync functionality
 */
export function useOfflineSync<T extends { id: string }>(entityType: string) {
  const [isOnline, setIsOnline] = useState(true);
  const [pendingItems, setPendingItems] = useState<PendingItem[]>([]);
  const [isSyncing, setIsSyncing] = useState(false);

  // Load pending items on mount
  useEffect(() => {
    loadPendingItems();
    
    // Set up network status listener
    const unsubscribe = NetInfo.addEventListener(state => {
      const online = state.isConnected !== false && state.isInternetReachable !== false;
      setIsOnline(online);
      
      // If going from offline to online, try to sync
      if (online) {
        syncItems();
      }
    });
    
    // Also set up background sync (network status changes outside this component)
    const unsubscribeBackground = setupBackgroundSync();
    
    return () => {
      unsubscribe();
      unsubscribeBackground();
    };
  }, [entityType]);

  // Load pending items from storage
  const loadPendingItems = useCallback(async () => {
    const items = await getPendingItems(entityType);
    setPendingItems(items);
  }, [entityType]);

  // Create an item (works offline)
  const createItem = useCallback(async (data: Omit<T, 'id'>): Promise<{ id: string, isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, create directly
        // In a real app, you'd use your API client (like supabase) here
        // const { data: newItem, error } = await supabase.from(entityType).insert(data).select();
        // if (error) throw error;
        // return { id: newItem.id, isOffline: false };
        
        // For demo purposes, simulate success
        return { id: `server-${Date.now()}`, isOffline: false };
      } else {
        // If offline, save to be synced later
        const tempId = await saveOfflineMutation('create', entityType, data);
        await loadPendingItems(); // Reload pending items
        return { id: tempId, isOffline: true };
      }
    } catch (error) {
      console.error('Error creating item:', error);
      // If API call fails, save offline
      const tempId = await saveOfflineMutation('create', entityType, data);
      await loadPendingItems(); // Reload pending items
      return { id: tempId, isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Update an item (works offline)
  const updateItem = useCallback(async (item: T): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, update directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).update(item).eq('id', item.id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('update', entityType, item);
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error updating item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('update', entityType, item);
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Delete an item (works offline)
  const deleteItem = useCallback(async (id: string): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, delete directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).delete().eq('id', id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('delete', entityType, { id });
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error deleting item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('delete', entityType, { id });
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Manually trigger sync
  const syncItems = useCallback(async (): Promise<boolean> => {
    if (isSyncing) return false;
    
    setIsSyncing(true);
    try {
      const success = await syncOfflineMutations();
      if (success) {
        await loadPendingItems(); // Reload pending items after successful sync
      }
      return success;
    } catch (error) {
      console.error('Error syncing items:', error);
      return false;
    } finally {
      setIsSyncing(false);
    }
  }, [isSyncing, loadPendingItems]);

  // Check if an item is pending sync
  const isItemPending = useCallback((id: string): boolean => {
    return pendingItems.some(item => item.id === id);
  }, [pendingItems]);

  return {
    isOnline,
    isSyncing,
    pendingItems,
    createItem,
    updateItem,
    deleteItem,
    syncItems,
    isItemPending,
  };
} ```

## File: ./hooks/useSkeleton.ts
```
import { useEffect } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withTiming,
  withSequence,
  withDelay,
  Easing,
} from 'react-native-reanimated';
import { durations, easings } from '@/constants/motion';

export interface SkeletonOptions {
  /**
   * Width of the gradient shimmer (as % of the component width)
   * @default 0.7
   */
  shimmerWidth?: number;
  /**
   * Base color of the skeleton component
   * @default '#E1E9EE'
   */
  baseColor?: string;
  /**
   * Highlight color for the shimmer effect
   * @default '#F2F8FC'
   */
  highlightColor?: string;
  /**
   * Duration for a complete shimmer cycle in ms
   * @default 2000
   */
  duration?: number;
  /**
   * Delay before starting animation in ms
   * @default 0
   */
  delay?: number;
  /**
   * Whether animation should start automatically
   * @default true
   */
  autoStart?: boolean;
}

/**
 * Hook to create skeleton loading animations with shimmer effect
 */
export function useSkeleton(options: SkeletonOptions = {}) {
  const {
    shimmerWidth = 0.7,
    baseColor = '#E1E9EE',
    highlightColor = '#F2F8FC',
    duration = durations.long * 2,
    delay = 0,
    autoStart = true,
  } = options;
  
  // Animation value to track shimmer position
  const translateX = useSharedValue(-1);
  
  // Start the animation
  useEffect(() => {
    if (autoStart) {
      translateX.value = withDelay(
        delay,
        withRepeat(
          withSequence(
            withTiming(-1, { duration: 0 }),
            withTiming(1, { 
              duration, 
              easing: easings.linear 
            }),
          ),
          -1, // Infinite repeat
        ),
      );
    }
  }, [translateX, duration, delay, autoStart]);
  
  // Generate the animated styles for the shimmer effect
  const shimmerStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateX: translateX.value * (1 + shimmerWidth) }],
    };
  });
  
  // Create styles for both container and shimmer
  const styles = StyleSheet.create({
    container: {
      backgroundColor: baseColor,
      overflow: 'hidden',
    },
    shimmer: {
      width: `${shimmerWidth * 100}%`,
      height: '100%',
      backgroundColor: highlightColor,
      position: 'absolute',
      top: 0,
      bottom: 0,
      opacity: 0.7,
    },
  });
  
  // Utility function to manually start the animation
  const startAnimation = () => {
    translateX.value = withDelay(
      delay,
      withRepeat(
        withSequence(
          withTiming(-1, { duration: 0 }),
          withTiming(1, { 
            duration, 
            easing: easings.linear 
          }),
        ),
        -1, // Infinite repeat
      ),
    );
  };
  
  // Utility function to stop the animation
  const stopAnimation = () => {
    translateX.value = withTiming(-1, { duration: 200 });
  };
  
  return {
    baseColor,
    shimmerStyle,
    styles,
    startAnimation,
    stopAnimation,
  };
} ```

## File: ./hooks/useThemeColor.ts
```
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}
```

## File: ./metro.config.js
```
const { getDefaultConfig } = require('expo/metro-config');
const { wrapWithReanimatedMetroConfig } = require('react-native-reanimated/metro-config');

// Get Expo's default Metro config
const config = getDefaultConfig(__dirname, { isCSSEnabled: true });

// Add .mjs extension support
config.resolver.sourceExts.push('mjs');

// Wrap with Reanimated's config for better error handling
module.exports = wrapWithReanimatedMetroConfig(config); ```

## File: ./modals/compose.tsx
```
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { Stack, useRouter } from 'expo-router';
import { Button } from '@/components/ui/iOS/Button';
import Animated, { 
  SlideInDown, 
  // SlideOutDown, // Not using exit animation with gesture
  useSharedValue, 
  useAnimatedStyle, 
  withTiming, 
  runOnJS 
} from 'react-native-reanimated';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';

const { height: SCREEN_HEIGHT } = Dimensions.get('window');
const DISMISS_THRESHOLD = SCREEN_HEIGHT * 0.25; // Swipe 25% down to dismiss

export default function ComposeModal() {
  const router = useRouter();

  // Reanimated shared value for tracking vertical translation
  const translateY = useSharedValue(0);
  const context = useSharedValue({ y: 0 });

  // Gesture handler for swipe down
  const gesture = Gesture.Pan()
    .onStart(() => {
      context.value = { y: translateY.value };
    })
    .onUpdate((event) => {
      translateY.value = Math.max(0, context.value.y + event.translationY); // Only allow downward swipe
    })
    .onEnd(() => {
      if (translateY.value > DISMISS_THRESHOLD) {
        // Animate out and navigate back
        translateY.value = withTiming(SCREEN_HEIGHT, { duration: 200 }, () => {
          runOnJS(router.back)();
        });
      } else {
        // Snap back to original position
        translateY.value = withTiming(0, { duration: 150 });
      }
    });

  // Animated style for the view
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateY: translateY.value }],
    };
  });

  return (
    // Wrap with GestureDetector
    <GestureDetector gesture={gesture}>
      {/* Apply animated style and entrance animation */}
      <Animated.View 
        style={[styles.container, animatedStyle]}
        entering={SlideInDown.duration(300)} 
      >
        {/* Optional: Add a small drag handle indicator */}
        <View style={styles.handleIndicator} />

        {/* Use Stack.Screen to configure the modal title */}
        <Stack.Screen 
          options={{
            title: 'Compose New',
            // Ensure header interaction doesn't conflict with gesture
            // headerLeft: () => <Button title="Close" onPress={() => router.back()} />
          }} 
        />
        <Text style={{ fontSize: 20, marginBottom: 20 }}>Swipe Down to Dismiss</Text>
        <Button onPress={() => router.back()}>Close Modal</Button>
      </Animated.View>
    </GestureDetector>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1, 
    alignItems: 'center', 
    justifyContent: 'center',
    backgroundColor: 'white', // Modals usually have solid background
    borderTopLeftRadius: 10, // Apply radius only to top corners for modal sheet look
    borderTopRightRadius: 10,
    // Add shadow for depth if desired
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -3 },
    shadowOpacity: 0.1,
    shadowRadius: 5,
    elevation: 5, // For Android shadow
  },
  handleIndicator: {
    width: 40,
    height: 5,
    backgroundColor: '#ccc',
    borderRadius: 2.5,
    position: 'absolute',
    top: 10,
    alignSelf: 'center',
  }
}); ```

## File: ./postcss.config.js
```
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}; ```

## File: ./providers/AppProvider.tsx
```
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { httpBatchLink } from '@trpc/client';
import { useEffect, useState, type ReactNode } from 'react';
import { Platform } from 'react-native';
import { TamaguiProvider } from 'tamagui';

import { NativeWindProvider } from '@/components/ui/nativewind-setup';
import config from '../tamagui.config';
import { trpc } from '@/utils/trpc';
import { useUiStore } from '@/stores/uiStore'; // Import store to get theme

/**
 * Complete app provider that integrates:
 * - tRPC
 * - React Query
 * - Tamagui
 * - NativeWind
 * - Additional providers can be added here
 */
export function AppProvider({ children }: { children: ReactNode }) {
  // Create Query Client
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 1000, // 5 seconds
        retry: Platform.OS === 'web' ? 3 : 1, // Less retries on mobile to save battery
      },
    },
  }));
  
  // Create tRPC client
  const [trpcClient] = useState(() => 
    trpc.createClient({
      links: [
        httpBatchLink({
          url: 'http://localhost:3000/api/trpc',
          fetch: (input, init) => {
            return fetch(input, {
              ...init,
              credentials: 'include',
            });
          },
        }),
      ],
    })
  );
  
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';
  
  // You could add NATS initialization here
  useEffect(() => {
    // Example: Initialize NATS for real-time updates
    // Note: This is commented out since we don't have a real NATS server to connect to
    /*
    try {
      const url = 'ws://localhost:4222';
      initNatsClient(url, queryClient)
        .then(conn => {
          console.log('NATS client initialized successfully');
          // Set up subscriptions to relevant topics
          subscribeWithCache('users.updates', ['users']);
          subscribeWithCache('messages.updates', ['messages']);
        })
        .catch(err => {
          console.error('Failed to initialize NATS client:', err);
        });
    } catch (error) {
      console.error('Error in NATS setup:', error);
    }
    
    // Cleanup on unmount
    return () => {
      closeNatsConnection().catch(err => {
        console.error('Error closing NATS connection:', err);
      });
    };
    */
  }, [queryClient]);
  
  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <NativeWindProvider theme={currentTheme}>
          <TamaguiProvider config={config}>
            {children}
          </TamaguiProvider>
        </NativeWindProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
} ```

## File: ./providers/ConfettiProvider.tsx
```
import { ReactNode, createContext, useCallback, useContext, useRef, useState } from 'react';
import { StyleSheet, Dimensions } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSequence,
  withDelay,
  runOnJS,
} from 'react-native-reanimated';
import { View } from 'tamagui';
import * as Haptics from 'expo-haptics';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');
const CONFETTI_COUNT = 50; // Number of confetti pieces
const COLORS = ['#ff4747', '#ffae47', '#fff347', '#47ff70', '#47d0ff', '#9147ff', '#ff47f3'];

interface ConfettiContextValue {
  showConfetti: () => void;
}

const ConfettiContext = createContext<ConfettiContextValue>({
  showConfetti: () => {},
});

export const useConfetti = () => useContext(ConfettiContext);

// Create a single confetti piece component
function ConfettiPiece({ 
  size, 
  color, 
  initialX, 
  initialY, 
  duration, 
  delay 
}: { 
  size: number, 
  color: string, 
  initialX: number, 
  initialY: number, 
  duration: number, 
  delay: number 
}) {
  const translateX = useSharedValue(initialX);
  const translateY = useSharedValue(initialY);
  const rotate = useSharedValue(0);
  const opacity = useSharedValue(1);

  // Create animation when component mounts
  useState(() => {
    // Random horizontal movement
    const targetX = initialX + (Math.random() * 2 - 1) * SCREEN_WIDTH * 0.5;
    
    // Fall down animation
    translateY.value = withDelay(
      delay,
      withTiming(SCREEN_HEIGHT + 100, { duration })
    );
    
    // Horizontal movement with some randomness
    translateX.value = withDelay(
      delay,
      withSequence(
        withTiming(targetX, { duration: duration * 0.4 }),
        withTiming(targetX + (Math.random() * 2 - 1) * 100, { duration: duration * 0.6 })
      )
    );
    
    // Rotation animation
    rotate.value = withDelay(
      delay,
      withTiming(Math.random() * 1080, { duration })
    );
    
    // Fade out toward the end
    opacity.value = withDelay(
      delay + duration * 0.7,
      withTiming(0, { duration: duration * 0.3 })
    );
  });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { rotate: `${rotate.value}deg` },
    ],
    opacity: opacity.value,
  }));

  return (
    <Animated.View
      style={[
        {
          position: 'absolute',
          width: size,
          height: size * (Math.random() * 0.8 + 0.2), // Varying heights
          backgroundColor: color,
          borderRadius: Math.random() > 0.5 ? size / 2 : 0, // Some round, some square
        },
        animatedStyle,
      ]}
    />
  );
}

export function ConfettiProvider({ children }: { children: ReactNode }) {
  const [isVisible, setIsVisible] = useState(false);
  const animationTimeout = useRef<NodeJS.Timeout | null>(null);
  
  // Generate confetti pieces data
  const generateConfettiData = useCallback(() => {
    const pieces = [];
    for (let i = 0; i < CONFETTI_COUNT; i++) {
      pieces.push({
        id: i,
        size: Math.random() * 8 + 4, // Size between 4-12
        color: COLORS[Math.floor(Math.random() * COLORS.length)],
        initialX: Math.random() * SCREEN_WIDTH,
        initialY: -20, // Start just above the screen
        duration: Math.random() * 1000 + 2000, // Duration between 2-3 seconds
        delay: Math.random() * 500, // Random delay up to 500ms
      });
    }
    return pieces;
  }, []);

  const [confettiPieces, setConfettiPieces] = useState(generateConfettiData());

  const showConfetti = useCallback(() => {
    // Trigger haptic feedback
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    
    // Clear any existing timeout
    if (animationTimeout.current) {
      clearTimeout(animationTimeout.current);
    }
    
    // Generate new confetti data and show
    setConfettiPieces(generateConfettiData());
    setIsVisible(true);
    
    // Hide confetti after animation completes
    animationTimeout.current = setTimeout(() => {
      setIsVisible(false);
    }, 3500); // Slightly longer than the max animation time to ensure all pieces are gone
  }, [generateConfettiData]);

  return (
    <ConfettiContext.Provider value={{ showConfetti }}>
      {children}
      {isVisible && (
        <View style={styles.confettiContainer} pointerEvents="none">
          {confettiPieces.map((piece) => (
            <ConfettiPiece
              key={piece.id}
              size={piece.size}
              color={piece.color}
              initialX={piece.initialX}
              initialY={piece.initialY}
              duration={piece.duration}
              delay={piece.delay}
            />
          ))}
        </View>
      )}
    </ConfettiContext.Provider>
  );
}

const styles = StyleSheet.create({
  confettiContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 9999,
    pointerEvents: 'none',
  },
}); ```

## File: ./providers/Providers.tsx
```
import { TRPCClientError } from '@trpc/client';
import { observable } from '@trpc/server/observable';
import { useState, useEffect, type ReactNode } from 'react';
import { TamaguiProvider } from 'tamagui';
import { QueryClientProvider } from '@tanstack/react-query';
import { persistQueryClient } from '@tanstack/react-query-persist-client';

import { NativeWindProvider } from '@/components/ui/nativewind-setup';
import { ToastProvider } from './ToastProvider';
import config from '../tamagui.config';
import { trpc } from '../utils/trpc';
import { useUiStore } from '@/stores/uiStore';
import { supabase } from '@/utils/supabase';
import { queryClient, persister, initializeNetworkMonitoring, resumeMutationsAndInvalidate } from '@/utils/query-client';

// Create a superjson transformer
// Note: In a real app, you'd use superjson when available
const transformer = {
  serialize: (obj: any) => JSON.stringify(obj),
  deserialize: (str: string) => JSON.parse(str),
};

// Set up persistence
persistQueryClient({
  queryClient,
  persister,
  maxAge: 1000 * 60 * 60 * 24, // 24 hours
  dehydrateOptions: {
    shouldDehydrateMutation: () => false,
  },
});

export function Providers({ children }: { children: ReactNode }) {
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';
  
  // Initialize network monitoring and query client persistence
  useEffect(() => {
    // Set up network monitoring
    const unsubscribeNetworkMonitoring = initializeNetworkMonitoring();
    
    // Try to resume any paused mutations immediately
    resumeMutationsAndInvalidate();
    
    return () => {
      unsubscribeNetworkMonitoring();
    };
  }, []);
  
  // Create tRPC client with Supabase auth integration
  const [trpcClient] = useState(() => 
    trpc.createClient({
      links: [
        // Link to handle auth token injection
        (runtime) => {
          return ({ op, next }) => {
            return observable((observer) => {
              // Get current session from Supabase
              const getSession = async () => {
                const { data } = await supabase.auth.getSession();
                return data.session;
              };
              
              Promise.resolve(getSession()).then(session => {
                // Safely handle headers, checking if op.input is an object
                let headers: Record<string, string> = {};
                if (typeof op.input === 'object' && op.input !== null && 'headers' in op.input && typeof op.input.headers === 'object') {
                  headers = { ...(op.input.headers as Record<string, string>) };
                }
                
                // Add authorization header if we have a session
                if (session?.access_token) {
                  headers['Authorization'] = `Bearer ${session.access_token}`;
                }

                // Construct input, merging potentially existing input object with new headers
                const input = typeof op.input === 'object' && op.input !== null 
                  ? { ...op.input, headers }
                  : { headers }; 

                // Proceed with the request
                next({ ...op, input })
                  .subscribe({
                    next: (value) => observer.next(value),
                    error: async (err) => {
                      // Check for unauthorized error (e.g., 401)
                      if (err instanceof TRPCClientError && err.data?.httpStatus === 401) {
                        console.log('Token expired or invalid, refreshing session...');
                        
                        try {
                          // Supabase will automatically refresh the session if needed
                          const { data, error } = await supabase.auth.refreshSession();
                          
                          if (error) throw error;
                          
                          if (data.session) {
                            console.log('Session refreshed successfully');
                            
                            // Retry the original request with the new token
                            const updatedHeaders = { 
                              ...headers, 
                              Authorization: `Bearer ${data.session.access_token}` 
                            };
                            const updatedInput = { ...input, headers: updatedHeaders };
                            next({ ...op, input: updatedInput }).subscribe(observer);
                          } else {
                            // No session after refresh, error out
                            observer.error(err);
                          }
                        } catch (refreshError) {
                          console.error('Session refresh failed:', refreshError);
                          observer.error(err); // Propagate original error
                        }
                      } else {
                        observer.error(err);
                      }
                    },
                    complete: () => observer.complete(),
                  });
              });

              return () => {
                // Cleanup logic if needed
              };
            });
          };
        },
        // REST API Link - modify URL to point to your Supabase function or other API
        (runtime) => {
          return ({ op, next }) => {
            return observable((observer) => {
              const { path, input, context } = op;
              
              // Provide base URL for API calls
              const baseUrl = process.env.EXPO_PUBLIC_API_URL || 'https://fjzzeprbdjwpxnhnltqm.supabase.co/rest/v1';
              const url = `${baseUrl}/${path.replace(/\./g, '/')}`;
              
              const fetchOptions: RequestInit = {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'apikey': process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY || '',
                },
                body: JSON.stringify(input),
              };
              
              // Execute fetch
              fetch(url, fetchOptions)
                .then(res => {
                  if (!res.ok) {
                    throw new Error(`HTTP error ${res.status}`);
                  }
                  return res.json();
                })
                .then(data => {
                  observer.next({ result: { data } });
                  observer.complete();
                })
                .catch(error => {
                  observer.error(error);
                });
              
              return () => {
                // Cancel fetch if needed
              };
            });
          };
        }
      ],
    })
  );
  
  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <TamaguiProvider config={config} defaultTheme={currentTheme}>
          <NativeWindProvider theme={currentTheme}>
            <ToastProvider>
              {children}
            </ToastProvider>
          </NativeWindProvider>
        </TamaguiProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
} ```

## File: ./providers/ToastProvider.tsx
```
import React, { createContext, useContext, useRef, useState, ReactNode, useCallback } from 'react';
import { View, StyleSheet, Dimensions } from 'react-native';
import { Text, Theme, YStack, useTheme, Button, XStack } from 'tamagui';
import Animated, { 
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSequence,
  Easing,
  runOnJS
} from 'react-native-reanimated';
import * as Haptics from 'expo-haptics';

const { width: SCREEN_WIDTH } = Dimensions.get('window');
const TOAST_PADDING = 16;
const TOAST_WIDTH = SCREEN_WIDTH - (TOAST_PADDING * 2);

type ToastType = 'success' | 'error' | 'info';

interface ToastOptions {
  type?: ToastType;
  duration?: number;
  message: string;
  title?: string;
}

interface ToastContextType {
  showToast: (options: ToastOptions) => void;
  hideToast: () => void;
}

const ToastContext = createContext<ToastContextType | undefined>(undefined);

export function useToast() {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within a ToastProvider');
  }
  return context;
}

export function ToastProvider({ children }: { children: ReactNode }) {
  const theme = useTheme();
  const [visible, setVisible] = useState(false);
  const [toastOptions, setToastOptions] = useState<ToastOptions>({ message: '' });
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  // Animation values
  const translateY = useSharedValue(-100);
  const opacity = useSharedValue(0);
  
  const clearToastTimeout = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
  };
  
  const hideToast = useCallback(() => {
    translateY.value = withTiming(-100, {
      duration: 300,
      easing: Easing.bezier(0.25, 0.1, 0.25, 1),
    });
    opacity.value = withTiming(0, {
      duration: 300,
      easing: Easing.bezier(0.25, 0.1, 0.25, 1),
    }, () => {
      runOnJS(setVisible)(false);
    });
    clearToastTimeout();
  }, [translateY, opacity]);

  const showToast = useCallback((options: ToastOptions) => {
    // Always clear any existing timeout
    clearToastTimeout();
    
    // Trigger haptic feedback based on toast type
    switch (options.type) {
      case 'success':
        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
        break;
      case 'error':
        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
        break;
      default:
        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    
    setToastOptions(options);
    setVisible(true);
    
    // Animate in
    translateY.value = -100;
    opacity.value = 0;
    
    translateY.value = withSequence(
      withTiming(20, { duration: 300, easing: Easing.out(Easing.cubic) }),
      withTiming(0, { duration: 150, easing: Easing.inOut(Easing.cubic) })
    );
    opacity.value = withTiming(1, { duration: 300 });
    
    // Auto-hide after duration
    const duration = options.duration || 3000;
    timeoutRef.current = setTimeout(hideToast, duration);
  }, [hideToast, translateY, opacity]);

  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateY: translateY.value }],
      opacity: opacity.value,
    };
  });
  
  // Get toast background color based on type
  const getToastBackgroundColor = () => {
    switch (toastOptions.type) {
      case 'success':
        return theme?.green6?.get() || '#22c55e'; // Default green if theme is undefined
      case 'error':
        return theme?.red6?.get() || '#ef4444'; // Default red if theme is undefined
      case 'info':
      default:
        return theme?.blue6?.get() || '#3b82f6'; // Default blue if theme is undefined
    }
  };
  
  // Get toast text color
  const getToastTextColor = () => {
    return theme?.color?.get() || '#ffffff';
  };

  return (
    <ToastContext.Provider value={{ showToast, hideToast }}>
      {children}
      {visible && (
        <Animated.View 
          style={[
            styles.toastContainer, 
            { backgroundColor: getToastBackgroundColor() },
            animatedStyle
          ]}
        >
          <YStack flex={1} paddingRight={10}>
            {toastOptions.title && (
              <Text fontSize={16} fontWeight="bold" color={getToastTextColor()}>
                {toastOptions.title}
              </Text>
            )}
            <Text fontSize={14} color={getToastTextColor()}>
              {toastOptions.message}
            </Text>
          </YStack>
          <Button
            size="$2"
            circular
            chromeless
            onPress={hideToast}
            icon={<Text color={getToastTextColor()} opacity={0.7}>×</Text>}
          />
        </Animated.View>
      )}
    </ToastContext.Provider>
  );
}

const styles = StyleSheet.create({
  toastContainer: {
    position: 'absolute',
    top: 50,
    width: TOAST_WIDTH,
    alignSelf: 'center',
    borderRadius: 8,
    padding: 12,
    flexDirection: 'row',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 5,
    zIndex: 1000,
  }
}); ```

## File: ./scripts/generate-all.js
```
const { execSync } = require('child_process');
const path = require('path');

/**
 * This script runs all code generation scripts in the correct order.
 * It ensures that:
 * 1. TRPC types are generated first (shared zod schemas)
 * 2. React Query hooks are generated from the TRPC router
 */
console.log('🚀 Running all code generators...');

try {
  console.log('\n📝 Generating TRPC shared types...');
  execSync('node ./scripts/generate-trpc-types.js', { stdio: 'inherit' });
  
  console.log('\n📝 Generating TRPC client hooks...');
  execSync('node ./scripts/generate-trpc-client.js', { stdio: 'inherit' });

  console.log('\n✅ All code generation complete!');
  console.log('\n🔍 Checking for TypeScript errors...');
  
  try {
    execSync('npx tsc --noEmit', { stdio: 'inherit' });
    console.log('✅ TypeScript validation successful!');
  } catch (error) {
    console.log('⚠️ TypeScript validation found some errors. Please fix them before continuing.');
  }

} catch (error) {
  console.error('\n❌ Generation failed:', error.message);
  process.exit(1);
} ```

## File: ./scripts/generate-trpc-client.js
```
const fs = require('fs');
const path = require('path');

/**
 * This script generates a TRPC client file with typed hooks for each procedure
 * in the AppRouter. This provides full type safety for the client code.
 */

// Configuration
const outputPath = path.join(__dirname, '../utils/generated-hooks.ts');
const routerPath = path.resolve(__dirname, '../server/src/router.ts');

const generateTRPCClient = () => {
  // First, let's read the router file to understand its structure
  const routerContent = fs.readFileSync(routerPath, 'utf-8');
  
  // Extract all the router imports
  const routerImportRegex = /import\s+{\s*(.*?)Router\s*}\s*from\s*['"](.+?)['"];/g;
  const routerImports = [];
  let match;
  
  while ((match = routerImportRegex.exec(routerContent)) !== null) {
    routerImports.push({
      name: match[1],
      path: match[2]
    });
  }
  
  // Extract the router registrations from appRouter
  const routerRegistrationRegex = /(\w+)\s*:\s*(\w+)Router,/g;
  const routerRegistrations = [];
  
  while ((match = routerRegistrationRegex.exec(routerContent)) !== null) {
    routerRegistrations.push({
      key: match[1],
      name: match[2]
    });
  }
  
  // Generate the type-safe hooks file
  const hookFileContent = `/**
 * GENERATED FILE - DO NOT EDIT
 * This file is automatically generated by the generate-trpc-client script.
 * To update this file, run: npm run generate-hooks
 */

import { trpc } from './trpc';
import { RouterInputs, RouterOutputs } from '../server/src/types/trpc-types';

/**
 * Type-safe hooks for TRPC procedures
 */

${routerRegistrations.map(router => {
  return `// ${router.key} hooks
export const use${capitalizeFirstLetter(router.key)} = {
  // Add strongly typed hooks here
};
`;
}).join('\n')}

// Example type usage
type GreetingOutput = RouterOutputs['greeting']['hello'];
`;

  // Write the generated file
  fs.writeFileSync(outputPath, hookFileContent);
  console.log(`✅ Generated TRPC client hooks at ${outputPath}`);
};

// Helper function to capitalize the first letter
function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

// Run the generator
generateTRPCClient(); ```

## File: ./scripts/generate-trpc-types.js
```
const fs = require('fs');
const path = require('path');

// Path to the generated types output file
const outputPath = path.join(__dirname, '../app/utils/api-types.ts');

const generateTypes = () => {
  // Define the content of the types file
  const typesContent = `/**
 * This file was auto-generated by the generate-trpc-types script.
 * Do not edit manually! Instead, run the script again.
 */

import type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from '../../server/src/router';

/**
 * Inference helper for inputs.
 *
 * @example type HelloInput = RouterInputs['example']['hello']
 */
export type RouterInputs = inferRouterInputs<AppRouter>;

/**
 * Inference helper for outputs.
 *
 * @example type HelloOutput = RouterOutputs['example']['hello']
 */
export type RouterOutputs = inferRouterOutputs<AppRouter>;
`;

  // Ensure directory exists
  const dir = path.dirname(outputPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  // Write the file
  fs.writeFileSync(outputPath, typesContent);
  console.log(`✅ Types generated at ${outputPath}`);
};

generateTypes(); ```

## File: ./scripts/reset-project.js
```
#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It deletes or moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example based on user input and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require("fs");
const path = require("path");
const readline = require("readline");

const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const exampleDir = "app-example";
const newAppDir = "app";
const exampleDirPath = path.join(root, exampleDir);

const indexContent = `import { Text, View } from "react-native";

export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}
`;

const layoutContent = `import { Stack } from "expo-router";

export default function RootLayout() {
  return <Stack />;
}
`;

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const moveDirectories = async (userInput) => {
  try {
    if (userInput === "y") {
      // Create the app-example directory
      await fs.promises.mkdir(exampleDirPath, { recursive: true });
      console.log(`📁 /${exampleDir} directory created.`);
    }

    // Move old directories to new app-example directory or delete them
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      if (fs.existsSync(oldDirPath)) {
        if (userInput === "y") {
          const newDirPath = path.join(root, exampleDir, dir);
          await fs.promises.rename(oldDirPath, newDirPath);
          console.log(`➡️ /${dir} moved to /${exampleDir}/${dir}.`);
        } else {
          await fs.promises.rm(oldDirPath, { recursive: true, force: true });
          console.log(`❌ /${dir} deleted.`);
        }
      } else {
        console.log(`➡️ /${dir} does not exist, skipping.`);
      }
    }

    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log("\n📁 New /app directory created.");

    // Create index.tsx
    const indexPath = path.join(newAppDirPath, "index.tsx");
    await fs.promises.writeFile(indexPath, indexContent);
    console.log("📄 app/index.tsx created.");

    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, "_layout.tsx");
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log("📄 app/_layout.tsx created.");

    console.log("\n✅ Project reset complete. Next steps:");
    console.log(
      `1. Run \`npx expo start\` to start a development server.\n2. Edit app/index.tsx to edit the main screen.${
        userInput === "y"
          ? `\n3. Delete the /${exampleDir} directory when you're done referencing it.`
          : ""
      }`
    );
  } catch (error) {
    console.error(`❌ Error during script execution: ${error.message}`);
  }
};

rl.question(
  "Do you want to move existing files to /app-example instead of deleting them? (Y/n): ",
  (answer) => {
    const userInput = answer.trim().toLowerCase() || "y";
    if (userInput === "y" || userInput === "n") {
      moveDirectories(userInput).finally(() => rl.close());
    } else {
      console.log("❌ Invalid input. Please enter 'Y' or 'N'.");
      rl.close();
    }
  }
);
```

## File: ./server/src/context.ts
```
import { createClient } from '@supabase/supabase-js';
import { TRPCError } from '@trpc/server';
import dotenv from 'dotenv';

// Load environment variables from ./server/.env
dotenv.config();

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

// Add checks to ensure variables are loaded
if (!supabaseUrl) {
    console.log('Attempting Supabase init. URL found: No'); // Keep log here
    throw new Error('Missing environment variable: SUPABASE_URL in server/.env');
}
if (!supabaseServiceKey) {
    throw new Error('Missing environment variable: SUPABASE_SERVICE_ROLE_KEY in server/.env');
}

console.log('Attempting Supabase init. URL found: Yes'); // Log success

// Initialize Supabase Admin client
export const supabaseAdmin = createClient(
  supabaseUrl,
  supabaseServiceKey,
  {
    auth: {
        autoRefreshToken: false,
        persistSession: false
    }
  }
);

// Context passed to all tRPC resolvers
export interface Context {
  supabaseAdmin: typeof supabaseAdmin;
  userId: string;
}

// Build context from incoming request
export async function createContext({ req }: { req: any }): Promise<Context> {
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: 'Missing Authorization header' });
  }
  const token = authHeader.split(' ')[1];
  if (!token) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: 'Invalid Authorization header' });
  }

  // Validate JWT and get user
  const { data, error } = await supabaseAdmin.auth.getUser(token);
  if (error || !data.user) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: error?.message || 'Invalid token' });
  }

  return {
    supabaseAdmin,
    userId: data.user.id,
  };
} ```

## File: ./server/src/index.ts
```
import express, { Request, Response } from 'express';
import cors from 'cors';
import { createExpressMiddleware } from '@trpc/server/adapters/express';
import { appRouter } from './router';
import { createContext } from './context';

const app = express();
const port = process.env.PORT || 3000;

// Enable CORS for client app
app.use(cors({
  origin: ['http://localhost:8081', 'http://localhost:19000', 'http://localhost:19006', 'exp://localhost:19000'],
  credentials: true,
}));

// Health check endpoint
app.get('/health', (_: Request, res: Response) => {
  res.status(200).json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Create tRPC middleware
app.use('/api/trpc', createExpressMiddleware({
  router: appRouter,
  createContext,
}));

// Start server
app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
  console.log(`tRPC API available at http://localhost:${port}/api/trpc`);
}); ```

## File: ./server/src/router.ts
```
import { initTRPC } from '@trpc/server';
import { z } from 'zod';
import { TRPCError } from '@trpc/server';
import { supabaseAdmin, Context } from './context';

// Initialize tRPC with Supabase context
const t = initTRPC.context<Context>().create();

// Public procedure (no auth required)
export const router = t.router;
export const publicProcedure = t.procedure;

// Protected procedures ensure user is authenticated
export const protectedProcedure = t.procedure.use(({ ctx, next }) => {
  if (!ctx.userId) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }
  return next({ ctx: { supabaseAdmin: ctx.supabaseAdmin, userId: ctx.userId } });
});

// Import individual routers
import { dashboardRouter } from './routers/dashboardRouter';
import { valueRouter } from './routers/valueRouter';
import { goalRouter } from './routers/goalRouter';
import { taskRouter } from './routers/taskRouter';
import { habitRouter } from './routers/habitRouter';
import { trackedStateRouter } from './routers/trackedStateRouter';
import { userRouter } from './routers/userRouter';
import { rewardsRouter } from './routers/rewardsRouter';

// Create the router with Supabase-backed procedures
export const appRouter = router({
  greeting: {
    hello: publicProcedure
      .input(z.object({ name: z.string().optional() }))
      .query(async ({ input }) => {
        return { greeting: `Hello ${input.name ?? 'world'}` };
      }),
    goodbye: publicProcedure
      .query(() => {
        return { greeting: 'Goodbye!' };
      }),
  },
  user: userRouter,
  dashboard: dashboardRouter,
  value: valueRouter,
  goal: goalRouter,
  task: taskRouter,
  habit: habitRouter,
  state: trackedStateRouter,
  rewards: rewardsRouter,
});

// Export type router type
export type AppRouter = typeof appRouter; ```

## File: ./server/src/routers/dashboardRouter.ts
```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';

export const dashboardRouter = router({
  getDashboardData: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Fetch recent habits
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select('*')
          .eq('user_id', ctx.userId)
          .order('created_at', { ascending: false })
          .limit(5);

        if (habitsError) throw habitsError;

        // Fetch recent goals
        const { data: goals, error: goalsError } = await ctx.supabaseAdmin
          .from('goals')
          .select('*')
          .eq('user_id', ctx.userId)
          .order('created_at', { ascending: false })
          .limit(5);

        if (goalsError) throw goalsError;

        // Fetch upcoming tasks
        const { data: tasks, error: tasksError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('*')
          .eq('user_id', ctx.userId)
          .order('due_date', { ascending: true })
          .limit(10);

        if (tasksError) throw tasksError;

        // Fetch user values
        const { data: values, error: valuesError } = await ctx.supabaseAdmin
          .from('values')
          .select('*')
          .eq('user_id', ctx.userId);

        if (valuesError) throw valuesError;

        // Fetch recent habit entries
        const { data: habitEntries, error: entriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('*, habits(name)')
          .in('habit_id', habits?.map(h => h.id) || [])
          .eq('user_id', ctx.userId)
          .order('entry_date', { ascending: false })
          .limit(20);

        if (entriesError) throw entriesError;

        return {
          habits,
          goals,
          tasks,
          values,
          habitEntries,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch dashboard data',
        });
      }
    }),
  
  getWeeklyProgress: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Calculate date range for the past week
        const today = new Date();
        const sevenDaysAgo = new Date();
        sevenDaysAgo.setDate(today.getDate() - 7);
        
        const todayStr = today.toISOString().split('T')[0];
        const sevenDaysAgoStr = sevenDaysAgo.toISOString().split('T')[0];
        
        // Get all habit entries for the past week
        const { data: habitEntries, error: entriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('*, habits(name, frequency)')
          .eq('user_id', ctx.userId)
          .gte('entry_date', sevenDaysAgoStr)
          .lte('entry_date', todayStr)
          .order('entry_date', { ascending: true });
          
        if (entriesError) throw entriesError;
        
        // Get completed tasks for the past week
        const { data: completedTasks, error: tasksError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('*')
          .eq('user_id', ctx.userId)
          .eq('status', 'completed')
          .gte('updated_at', sevenDaysAgo.toISOString())
          .lte('updated_at', today.toISOString());
          
        if (tasksError) throw tasksError;
        
        // Get total tasks count for completion rate
        const { count: totalTasks, error: countError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', ctx.userId);
          
        if (countError) throw countError;
        
        // Calculate habit streak for each habit
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select('*')
          .eq('user_id', ctx.userId);
          
        if (habitsError) throw habitsError;
        
        // Simple metric calculations
        const taskCompletionRate = totalTasks ? (completedTasks?.length || 0) / totalTasks : 0;
        const habitConsistency = habits?.length ? (habitEntries?.length || 0) / (habits.length * 7) : 0;
        
        return {
          habitEntries,
          completedTasks,
          metrics: {
            totalHabitEntries: habitEntries?.length || 0,
            completedTasksCount: completedTasks?.length || 0,
            taskCompletionRate,
            habitConsistency: Math.min(habitConsistency, 1), // Cap at 100%
          },
          dateRange: {
            start: sevenDaysAgoStr,
            end: todayStr,
          }
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch weekly progress',
        });
      }
    }),
}); ```

## File: ./server/src/routers/goalRouter.ts
```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';

export const goalRouter = router({
  getGoals: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select('*')
          .eq('user_id', ctx.userId)
          .order('created_at', { ascending: false });

        if (error) throw error;
        return goals;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals',
        });
      }
    }),

  getGoalById: protectedProcedure
    .input(z.object({
      id: z.string(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .select('*')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!goal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found',
          });
        }

        return goal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal',
        });
      }
    }),

  createGoal: protectedProcedure
    .input(z.object({
      title: z.string(),
      description: z.string().optional(),
      target_date: z.string().optional(),
      status: z.string().default('active'),
      value_id: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .insert({
            title: input.title,
            description: input.description,
            target_date: input.target_date,
            status: input.status,
            value_id: input.value_id,
            user_id: ctx.userId,
          })
          .select()
          .single();

        if (error) throw error;
        return goal;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal',
        });
      }
    }),

  updateGoal: protectedProcedure
    .input(z.object({
      id: z.string(),
      title: z.string().optional(),
      description: z.string().optional(),
      target_date: z.string().optional(),
      status: z.string().optional(),
      value_id: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // First check if the goal exists and belongs to user
        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to update it',
          });
        }

        // Update the goal
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({
            title: input.title,
            description: input.description,
            target_date: input.target_date,
            status: input.status,
            value_id: input.value_id,
          })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select()
          .single();

        if (error) throw error;
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal',
        });
      }
    }),

  deleteGoal: protectedProcedure
    .input(z.object({
      id: z.string(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check if the goal exists and belongs to user
        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to delete it',
          });
        }

        // Delete the goal
        const { error } = await ctx.supabaseAdmin
          .from('goals')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal',
        });
      }
    }),

  // ---- Stubs for client compatibility ----
  listActive: protectedProcedure
    .query(async ({ ctx }) => {
      // TODO: Implement actual logic - filter status = 'active'?
      // For now, return all goals like getGoals
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select('*')
          .eq('user_id', ctx.userId)
          .order('created_at', { ascending: false });
        if (error) throw error;
        console.log("[goalRouter.listActive] Stub called, returning all goals");
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals (in listActive stub)',
        });
      }
    }),
    
  // Note: Client calls state.getLatest, not goal.getLatest.
  // Adding stub here seems incorrect based on client calls.
  getLatest: protectedProcedure 
    .query(async ({ ctx }) => {
      console.log("[goalRouter.getLatest] STUB CALLED - LIKELY INCORRECT ROUTER");
      return [];
    }),
}); ```

## File: ./server/src/routers/habitRouter.ts
```
import { z } from "zod";
import { router, protectedProcedure } from "../router";
import { TRPCError } from "@trpc/server";

export const habitRouter = router({
  getHabits: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .select("*")
        .eq("user_id", ctx.userId)
        .order("created_at", { ascending: false });

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data || [];
    }),

  getHabitById: protectedProcedure
    .input(z.object({ id: z.string() }))
    .query(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .select("*")
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (error) throw new TRPCError({ 
        code: error.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: error.message 
      });
      return data;
    }),

  createHabit: protectedProcedure
    .input(
      z.object({
        name: z.string(),
        description: z.string().optional(),
        goal_frequency: z.number(),
        frequency_period: z.enum(["day", "week", "month"]),
        color: z.string().optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .insert({
          user_id: ctx.userId,
          name: input.name,
          description: input.description,
          goal_frequency: input.goal_frequency,
          frequency_period: input.frequency_period,
          color: input.color,
          streak: 0,
          best_streak: 0
        })
        .select()
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  updateHabit: protectedProcedure
    .input(
      z.object({
        id: z.string(),
        name: z.string().optional(),
        description: z.string().optional(),
        goal_frequency: z.number().optional(),
        frequency_period: z.enum(["day", "week", "month"]).optional(),
        color: z.string().optional(),
        streak: z.number().optional(),
        best_streak: z.number().optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      // First check if habit exists and belongs to user
      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      // Extract the id and update the remaining fields
      const { id, ...updateData } = input;

      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .update(updateData)
        .eq("id", id)
        .select()
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  deleteHabit: protectedProcedure
    .input(z.object({ id: z.string() }))
    .mutation(async ({ ctx, input }) => {
      // First check if habit exists and belongs to user
      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      // Delete all habit entries first (cascade delete would be better in the database)
      const { error: entriesError } = await ctx.supabaseAdmin
        .from("habit_entries")
        .delete()
        .eq("habit_id", input.id);

      if (entriesError) throw new TRPCError({ 
        code: "INTERNAL_SERVER_ERROR", 
        message: "Failed to delete habit entries" 
      });

      // Then delete the habit
      const { error } = await ctx.supabaseAdmin
        .from("habits")
        .delete()
        .eq("id", input.id);

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return { id: input.id };
    }),

  // Habit Entry procedures
  getHabitEntries: protectedProcedure
    .input(
      z.object({
        habitId: z.string(),
        startDate: z.string().optional(),
        endDate: z.string().optional(),
      })
    )
    .query(async ({ ctx, input }) => {
      // First verify the habit belongs to the user
      const { data: habit, error: habitError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", input.habitId)
        .eq("user_id", ctx.userId)
        .single();

      if (habitError) throw new TRPCError({ 
        code: habitError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      // Build query for habit entries
      let query = ctx.supabaseAdmin
        .from("habit_entries")
        .select("*")
        .eq("habit_id", input.habitId);

      // Add date range filters if provided
      if (input.startDate) {
        query = query.gte("date", input.startDate);
      }

      if (input.endDate) {
        query = query.lte("date", input.endDate);
      }

      const { data, error } = await query.order("date", { ascending: false });

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data || [];
    }),

  createHabitEntry: protectedProcedure
    .input(
      z.object({
        habitId: z.string(),
        date: z.string(),
        completed: z.boolean(),
        notes: z.string().optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      // First verify the habit belongs to the user
      const { data: habit, error: habitError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", input.habitId)
        .eq("user_id", ctx.userId)
        .single();

      if (habitError) throw new TRPCError({ 
        code: habitError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      // Insert or update the habit entry (upsert)
      const { data, error } = await ctx.supabaseAdmin
        .from("habit_entries")
        .upsert({
          habit_id: input.habitId,
          date: input.date,
          completed: input.completed,
          notes: input.notes
        })
        .select()
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      
      // Update streak if needed
      if (input.completed) {
        // Get current streak
        const { data: habitData } = await ctx.supabaseAdmin
          .from("habits")
          .select("streak, best_streak")
          .eq("id", input.habitId)
          .single();
          
        if (habitData) {
          const newStreak = (habitData.streak || 0) + 1;
          const bestStreak = Math.max(newStreak, habitData.best_streak || 0);
          
          await ctx.supabaseAdmin
            .from("habits")
            .update({ 
              streak: newStreak,
              best_streak: bestStreak
            })
            .eq("id", input.habitId);
        }
      }
      
      return data;
    }),

  updateHabitEntry: protectedProcedure
    .input(
      z.object({
        id: z.string(),
        completed: z.boolean().optional(),
        notes: z.string().optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      // First get the habit entry to check ownership
      const { data: entry, error: fetchError } = await ctx.supabaseAdmin
        .from("habit_entries")
        .select("habit_id")
        .eq("id", input.id)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit entry not found" 
      });

      // Verify the associated habit belongs to the user
      const { data: habit, error: habitError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", entry.habit_id)
        .eq("user_id", ctx.userId)
        .single();

      if (habitError) throw new TRPCError({ 
        code: "FORBIDDEN",
        message: "Access denied to this habit entry" 
      });

      // Extract the id and update the remaining fields
      const { id, ...updateData } = input;

      const { data, error } = await ctx.supabaseAdmin
        .from("habit_entries")
        .update(updateData)
        .eq("id", id)
        .select()
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      
      // Update streak if needed and if completed status changed
      if ("completed" in input) {
        // Get habit details
        const { data: habitData } = await ctx.supabaseAdmin
          .from("habits")
          .select("streak, best_streak")
          .eq("id", entry.habit_id)
          .single();
          
        if (habitData) {
          if (input.completed) {
            const newStreak = (habitData.streak || 0) + 1;
            const bestStreak = Math.max(newStreak, habitData.best_streak || 0);
            
            await ctx.supabaseAdmin
              .from("habits")
              .update({ 
                streak: newStreak,
                best_streak: bestStreak
              })
              .eq("id", entry.habit_id);
          } else {
            // Reset streak if habit marked as not completed
            await ctx.supabaseAdmin
              .from("habits")
              .update({ streak: 0 })
              .eq("id", entry.habit_id);
          }
        }
      }
      
      return data;
    }),

  deleteHabitEntry: protectedProcedure
    .input(z.object({ id: z.string() }))
    .mutation(async ({ ctx, input }) => {
      // First get the habit entry to check ownership
      const { data: entry, error: fetchError } = await ctx.supabaseAdmin
        .from("habit_entries")
        .select("habit_id")
        .eq("id", input.id)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit entry not found" 
      });

      // Verify the associated habit belongs to the user
      const { data: habit, error: habitError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", entry.habit_id)
        .eq("user_id", ctx.userId)
        .single();

      if (habitError) throw new TRPCError({ 
        code: "FORBIDDEN",
        message: "Access denied to this habit entry" 
      });

      // Delete the habit entry
      const { error } = await ctx.supabaseAdmin
        .from("habit_entries")
        .delete()
        .eq("id", input.id);

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      
      return { id: input.id };
    }),
}); ```

## File: ./server/src/routers/rewardsRouter.ts
```
import { TRPCError } from '@trpc/server';
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { supabaseAdmin } from '../context';

// Corrected relative path
import { claimLootInput, awardBadgeInput } from '../types/trpc-types';

export const rewardsRouter = router({
  // Get all rewards for current user
  getUserRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: rewards, error } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('*, rewards(*)')
          .eq('user_id', ctx.userId)
          .order('earned_at', { ascending: false });

        if (error) throw error;
        return rewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user rewards',
        });
      }
    }),

  // Get available rewards that can be earned
  getAvailableRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Get all rewards
        const { data: allRewards, error: rewardsError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .order('required_points', { ascending: true });

        if (rewardsError) throw rewardsError;

        // Get already earned rewards
        const { data: earnedRewards, error: earnedError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('reward_id')
          .eq('user_id', ctx.userId);

        if (earnedError) throw earnedError;

        // Filter out already earned one-time rewards
        const earnedIds = new Set((earnedRewards || []).map(er => er.reward_id));
        const availableRewards = allRewards?.filter(reward => 
          !earnedIds.has(reward.id) || reward.can_earn_multiple);

        return availableRewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch available rewards',
        });
      }
    }),

  // Get user points
  getUserPoints: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: userProfile, error } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (error) throw error;
        return {
          points: userProfile?.points || 0,
          lifetimePoints: userProfile?.lifetime_points || 0,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user points',
        });
      }
    }),

  // Earn a reward if eligible
  earnReward: protectedProcedure
    .input(claimLootInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get the reward details
        const { data: reward, error: rewardError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.lootId)
          .single();

        if (rewardError || !reward) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Reward not found',
          });
        }

        // Check if user has enough points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        if (userProfile.points < reward.required_points) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Not enough points to earn this reward',
          });
        }

        // If the reward is one-time, check if already earned
        if (!reward.can_earn_multiple) {
          const { data: existingReward, error: existingError } = await ctx.supabaseAdmin
            .from('user_rewards')
            .select('id')
            .eq('user_id', ctx.userId)
            .eq('reward_id', input.lootId)
            .single();

          if (existingReward) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'You have already earned this one-time reward',
            });
          }
        }

        // Begin transaction
        // 1. Deduct points from user
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: userProfile.points - reward.required_points,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // 2. Add reward to user's earned rewards
        const { data: userReward, error: insertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.lootId,
            earned_at: new Date().toISOString(),
            points_spent: reward.required_points,
          })
          .select()
          .single();

        if (insertError) {
          // Rollback points if adding reward failed
          await ctx.supabaseAdmin
            .from('profiles')
            .update({
              points: userProfile.points,
            })
            .eq('id', ctx.userId);

          throw insertError;
        }

        return {
          success: true,
          reward: userReward,
          remainingPoints: userProfile.points - reward.required_points,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to earn reward',
        });
      }
    }),

  // Award points to user (e.g., for completing habits, tasks)
  awardPoints: protectedProcedure
    .input(awardBadgeInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get current user points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        // Get badge details
        const { data: badge, error: badgeError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.badgeId)
          .eq('type', 'badge')
          .single();

        if (badgeError || !badge) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Badge not found',
          });
        }

        // Default points to award
        const pointsToAward = 10;
        const currentPoints = userProfile.points || 0;
        const lifetimePoints = userProfile.lifetime_points || 0;
        const newPoints = currentPoints + pointsToAward;
        const newLifetimePoints = lifetimePoints + pointsToAward;

        // Update user points
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: newPoints,
            lifetime_points: newLifetimePoints,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // Record the point transaction
        const { data: pointTransaction, error: transactionError } = await ctx.supabaseAdmin
          .from('point_transactions')
          .insert({
            user_id: ctx.userId,
            points: pointsToAward,
            reason: `Earned badge: ${badge.name}`,
            source_type: 'badge',
            source_id: input.badgeId,
          })
          .select()
          .single();

        if (transactionError) throw transactionError;

        // Add badge to user's earned rewards
        const { data: userBadge, error: badgeInsertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.badgeId,
            reward_type: 'badge',
            earned_at: new Date().toISOString(),
            points_spent: 0, // Badges don't cost points
          })
          .select()
          .single();

        if (badgeInsertError) throw badgeInsertError;

        return {
          success: true,
          previousPoints: currentPoints,
          newPoints,
          pointsAdded: pointsToAward,
          transaction: pointTransaction,
          badge: userBadge,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to award badge',
        });
      }
    }),

  // Get point transaction history
  getPointHistory: protectedProcedure
    .input(z.object({
      limit: z.number().optional().default(20),
      cursor: z.string().optional(), // for pagination
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('point_transactions')
          .select('*')
          .eq('user_id', ctx.userId)
          .order('created_at', { ascending: false })
          .limit(input.limit);
          
        // Handle cursor-based pagination
        if (input.cursor) {
          query = query.lt('created_at', input.cursor);
        }
        
        const { data: transactions, error } = await query;

        if (error) throw error;
        
        // Determine if there are more results
        const lastItem = transactions && transactions.length > 0 
          ? transactions[transactions.length - 1] 
          : null;
          
        return {
          items: transactions || [],
          nextCursor: lastItem?.created_at,
          hasMore: (transactions?.length || 0) === input.limit,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch point history',
        });
      }
    }),
}); ```

## File: ./server/src/routers/taskRouter.ts
```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';

export const taskRouter = router({
  getTasks: protectedProcedure
    .input(z.object({
      goalId: z.string().optional(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('tasks')
          .select('*')
          .eq('user_id', ctx.userId);
          
        if (input.goalId) {
          query = query.eq('goal_id', input.goalId);
        }
        
        const { data: tasks, error } = await query.order('created_at', { ascending: false });

        if (error) throw error;
        return tasks;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tasks',
        });
      }
    }),

  getTaskById: protectedProcedure
    .input(z.object({
      id: z.string(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select('*')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!task) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found',
          });
        }

        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch task',
        });
      }
    }),

  createTask: protectedProcedure
    .input(z.object({
      title: z.string(),
      description: z.string().optional(),
      due_date: z.string().optional(),
      status: z.string().default('pending'),
      priority: z.string().optional(),
      goal_id: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // If goal_id is provided, verify it belongs to user
        if (input.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', input.goal_id)
            .eq('user_id', ctx.userId)
            .single();
            
          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid goal ID or goal does not belong to user',
            });
          }
        }

        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .insert({
            title: input.title,
            description: input.description,
            due_date: input.due_date,
            status: input.status,
            priority: input.priority,
            goal_id: input.goal_id,
            user_id: ctx.userId,
          })
          .select()
          .single();

        if (error) throw error;
        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create task',
        });
      }
    }),

  updateTask: protectedProcedure
    .input(z.object({
      id: z.string(),
      title: z.string().optional(),
      description: z.string().optional(),
      due_date: z.string().optional(),
      status: z.string().optional(),
      priority: z.string().optional(),
      goal_id: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // First check if the task exists and belongs to user
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to update it',
          });
        }

        // If goal_id is provided, verify it belongs to user
        if (input.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', input.goal_id)
            .eq('user_id', ctx.userId)
            .single();
            
          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid goal ID or goal does not belong to user',
            });
          }
        }

        // Update the task
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({
            title: input.title,
            description: input.description,
            due_date: input.due_date,
            status: input.status,
            priority: input.priority,
            goal_id: input.goal_id,
          })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select()
          .single();

        if (error) throw error;
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update task',
        });
      }
    }),

  deleteTask: protectedProcedure
    .input(z.object({
      id: z.string(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check if the task exists and belongs to user
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to delete it',
          });
        }

        // Delete the task
        const { error } = await ctx.supabaseAdmin
          .from('tasks')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete task',
        });
      }
    }),

  updateTaskStatus: protectedProcedure
    .input(z.object({
      id: z.string(),
      status: z.string(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check if the task exists and belongs to user
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to update it',
          });
        }

        // Update just the status
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({
            status: input.status,
          })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select()
          .single();

        if (error) throw error;
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update task status',
        });
      }
    }),

  // ---- Stubs for client compatibility ----
  listToday: protectedProcedure
    .query(async ({ ctx }) => {
      // TODO: Implement actual logic - filter by due_date === today
      console.log("[taskRouter.listToday] Stub called");
      return []; // Return empty array for now
    }),

  listActive: protectedProcedure // Note: client calls task.listToday, not task.listActive
    .query(async ({ ctx }) => {
      // TODO: Implement actual logic - filter by status != completed?
      console.log("[taskRouter.listActive] Stub called");
      return []; // Return empty array for now
    }),
    
  // Note: client calls habit.toggleCompleted, not task.toggleCompleted
  // Adding stub here just in case, but likely not the right place
  toggleCompleted: protectedProcedure 
    .input(z.object({ id: z.string(), completed: z.boolean() }))
    .mutation(async ({ ctx, input }) => {
      console.log("[taskRouter.toggleCompleted] Stub called with:", input);
      // TODO: Implement actual logic if this belongs here
      return { id: input.id, completed: input.completed }; // Mock success
    }),
}); ```

## File: ./server/src/routers/trackedStateRouter.ts
```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';

export const trackedStateRouter = router({
  getTrackedStates: protectedProcedure
    .input(z.object({
      category: z.string().optional(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('tracked_states')
          .select('*')
          .eq('user_id', ctx.userId);
          
        if (input.category) {
          query = query.eq('category', input.category);
        }
        
        const { data: states, error } = await query.order('created_at', { ascending: false });

        if (error) throw error;
        return states;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tracked states',
        });
      }
    }),

  getTrackedStateById: protectedProcedure
    .input(z.object({
      id: z.string(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: state, error } = await ctx.supabaseAdmin
          .from('tracked_states')
          .select('*')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!state) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Tracked state not found',
          });
        }

        return state;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tracked state',
        });
      }
    }),

  createTrackedState: protectedProcedure
    .input(z.object({
      name: z.string(),
      category: z.string(),
      value: z.number(),
      unit: z.string().optional(),
      timestamp: z.string().optional(),
      notes: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: state, error } = await ctx.supabaseAdmin
          .from('tracked_states')
          .insert({
            name: input.name,
            category: input.category,
            value: input.value,
            unit: input.unit,
            timestamp: input.timestamp || new Date().toISOString(),
            notes: input.notes,
            user_id: ctx.userId,
          })
          .select()
          .single();

        if (error) throw error;
        return state;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create tracked state',
        });
      }
    }),

  updateTrackedState: protectedProcedure
    .input(z.object({
      id: z.string(),
      name: z.string().optional(),
      category: z.string().optional(),
      value: z.number().optional(),
      unit: z.string().optional(),
      timestamp: z.string().optional(),
      notes: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // First check if the tracked state exists and belongs to user
        const { data: existingState, error: fetchError } = await ctx.supabaseAdmin
          .from('tracked_states')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingState) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Tracked state not found or you do not have permission to update it',
          });
        }

        // Update the tracked state
        const { data: updatedState, error } = await ctx.supabaseAdmin
          .from('tracked_states')
          .update({
            name: input.name,
            category: input.category,
            value: input.value,
            unit: input.unit,
            timestamp: input.timestamp,
            notes: input.notes,
          })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select()
          .single();

        if (error) throw error;
        return updatedState;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update tracked state',
        });
      }
    }),

  deleteTrackedState: protectedProcedure
    .input(z.object({
      id: z.string(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check if the tracked state exists and belongs to user
        const { data: existingState, error: fetchError } = await ctx.supabaseAdmin
          .from('tracked_states')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingState) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Tracked state not found or you do not have permission to delete it',
          });
        }

        // Delete the tracked state
        const { error } = await ctx.supabaseAdmin
          .from('tracked_states')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete tracked state',
        });
      }
    }),

  getStateHistory: protectedProcedure
    .input(z.object({
      name: z.string(),
      category: z.string(),
      startDate: z.string().optional(),
      endDate: z.string().optional(),
      limit: z.number().optional(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('tracked_states')
          .select('*')
          .eq('user_id', ctx.userId)
          .eq('name', input.name)
          .eq('category', input.category);
          
        if (input.startDate) {
          query = query.gte('timestamp', input.startDate);
        }
        
        if (input.endDate) {
          query = query.lte('timestamp', input.endDate);
        }
        
        query = query.order('timestamp', { ascending: false });
        
        if (input.limit) {
          query = query.limit(input.limit);
        }
        
        const { data: history, error } = await query;

        if (error) throw error;
        return history;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch state history',
        });
      }
    }),

  // ---- Stubs for client compatibility ----
  getLatest: protectedProcedure
    .query(async ({ ctx }) => {
      // TODO: Implement actual logic - maybe get distinct names/categories and latest timestamp/value for each?
      // For now, return all states like getTrackedStates
      try {
        const { data: states, error } = await ctx.supabaseAdmin
          .from('tracked_states')
          .select('*')
          .eq('user_id', ctx.userId)
          .order('timestamp', { ascending: false }); // Order by timestamp to potentially get latest easily

        if (error) throw error;
        console.log("[trackedStateRouter.getLatest] Stub called, returning all states");
        // Maybe limit to first N distinct states here if needed later
        return states || []; 
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tracked states (in getLatest stub)',
        });
      }
    }),
}); ```

## File: ./server/src/routers/userRouter.ts
```
import { z } from 'zod';
import { router, protectedProcedure, publicProcedure } from '../router';
import { TRPCError } from '@trpc/server';

export const userRouter = router({
  getProfile: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('*')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  updateProfile: protectedProcedure
    .input(z.object({
      full_name: z.string().optional(),
      avatar_url: z.string().optional(),
      theme: z.string().optional(),
      time_zone: z.string().optional(),
      display_name: z.string().optional(),
      bio: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update(input)
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getUserSettings: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('*')
        .eq('user_id', ctx.userId)
        .single();
        
      if (error) {
        // If settings don't exist, create default settings
        if (error.code === 'PGRST116') {
          const { data: newSettings, error: createError } = await ctx.supabaseAdmin
            .from('user_settings')
            .insert({
              user_id: ctx.userId,
              notification_preferences: {
                email: true,
                push: true,
                task_reminders: true,
                goal_updates: true,
                habit_reminders: true
              },
              ui_preferences: {
                theme: 'system',
                compact_view: false,
                show_completed_tasks: true
              }
            })
            .select()
            .single();
            
          if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
          return newSettings;
        }
        
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      }
      
      return data;
    }),
    
  updateUserSettings: protectedProcedure
    .input(z.object({
      notification_preferences: z.object({
        email: z.boolean().optional(),
        push: z.boolean().optional(),
        task_reminders: z.boolean().optional(),
        goal_updates: z.boolean().optional(),
        habit_reminders: z.boolean().optional()
      }).optional(),
      ui_preferences: z.object({
        theme: z.string().optional(),
        compact_view: z.boolean().optional(),
        show_completed_tasks: z.boolean().optional()
      }).optional()
    }))
    .mutation(async ({ ctx, input }) => {
      // First check if settings exist
      const { data: existingSettings, error: fetchError } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('id')
        .eq('user_id', ctx.userId)
        .single();
        
      if (fetchError && fetchError.code === 'PGRST116') {
        // Create settings if they don't exist
        const defaultSettings = {
          user_id: ctx.userId,
          notification_preferences: {
            email: true,
            push: true,
            task_reminders: true,
            goal_updates: true,
            habit_reminders: true,
            ...input.notification_preferences
          },
          ui_preferences: {
            theme: 'system',
            compact_view: false,
            show_completed_tasks: true,
            ...input.ui_preferences
          }
        };
        
        const { data, error } = await ctx.supabaseAdmin
          .from('user_settings')
          .insert(defaultSettings)
          .select()
          .single();
          
        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        return data;
      } else if (fetchError) {
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: fetchError.message });
      }
      
      // Update existing settings
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .update(input)
        .eq('user_id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getOnboardingStatus: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('onboarding_completed')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { onboardingCompleted: data?.onboarding_completed || false };
    }),
    
  completeOnboarding: protectedProcedure
    .mutation(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update({ onboarding_completed: true })
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { success: true };
    }),
}); ```

## File: ./server/src/routers/valueRouter.ts
```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';

export const valueRouter = router({
  getValues: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: values, error } = await ctx.supabaseAdmin
          .from('values')
          .select('*')
          .eq('user_id', ctx.userId)
          .order('created_at', { ascending: false });

        if (error) throw error;
        return values;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch values',
        });
      }
    }),

  getValueById: protectedProcedure
    .input(z.object({
      id: z.string(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .select('*')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!value) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found',
          });
        }

        return value;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch value',
        });
      }
    }),

  createValue: protectedProcedure
    .input(z.object({
      name: z.string(),
      description: z.string().optional(),
      color: z.string().optional(),
      icon: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .insert({
            name: input.name,
            description: input.description,
            color: input.color,
            icon: input.icon,
            user_id: ctx.userId,
          })
          .select()
          .single();

        if (error) throw error;
        return value;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create value',
        });
      }
    }),

  updateValue: protectedProcedure
    .input(z.object({
      id: z.string(),
      name: z.string().optional(),
      description: z.string().optional(),
      color: z.string().optional(),
      icon: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // First check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to update it',
          });
        }

        // Update the value
        const { data: updatedValue, error } = await ctx.supabaseAdmin
          .from('values')
          .update({
            name: input.name,
            description: input.description,
            color: input.color,
            icon: input.icon,
          })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select()
          .single();

        if (error) throw error;
        return updatedValue;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update value',
        });
      }
    }),

  deleteValue: protectedProcedure
    .input(z.object({
      id: z.string(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to delete it',
          });
        }

        // Delete the value
        const { error } = await ctx.supabaseAdmin
          .from('values')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete value',
        });
      }
    }),
}); ```

## File: ./server/src/types/index.ts
```
export type ValueId = string;
export type GoalId = string;
export type TaskId = string;
export type HabitId = string;
export type BadgeId = string;

export interface Value {
  id: ValueId;
  name: string;
  description?: string;
  color: string; // tailwind color token (e.g. 'indigo-500')
  domainId?: string; // optional grouping
}

export interface Goal {
  id: GoalId;
  title: string;
  description?: string;
  valueIds: ValueId[];
  progress: number; // 0‒1
  keyResults: KeyResult[];
  targetDate?: string; // ISO
}

export interface KeyResult {
  id: string;
  title: string;
  progress: number; // 0‒1
}

export interface Task {
  id: TaskId;
  title: string;
  notes?: string;
  status: 'todo' | 'doing' | 'done' | 'blocked';
  due?: string; // ISO date
  priority?: 1 | 2 | 3;
  goalId?: GoalId;
  valueIds?: ValueId[];
}

export interface Habit {
  id: HabitId;
  title: string;
  cue?: string;
  routine?: string;
  reward?: string;
  valueIds: ValueId[];
  streak: number; // current consecutive days
  bestStreak: number;
  history: Record<string, boolean>; // ISO day → done?
}

export interface Principle {
  id: string;
  title: string;
  body: string;
  valueIds: ValueId[];
}

export interface TrackedStateDef {
  id: string;
  name: string;
  scale: '1-5' | 'low-high' | 'custom';
  customLabels?: string[];
  valueIds: ValueId[];
}

export interface Badge {
  id: BadgeId;
  title: string;
  icon: string; // Hero‑icons name or emoji
  earnedAt?: string; // ISO
  progress?: number; // 0‒1 for not‑yet
} ```

## File: ./server/src/types/trpc-types.ts
```
/*
  Aether – Shared tRPC Types
  ------------------------------------------------------------------
  Every Zod schema that powers a router lives here so both the server
  (routers) and the client (React Query hooks) reference a **single**
  source‑of‑truth.  Import these types everywhere else – **never** hand‑roll
  shapes again.
*/

import { z } from 'zod';
import { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from '../router';

/* ------------------------------------------------------------------
 *  Domain Models (DB row shapes) – keep in sync with Supabase tables
 * ----------------------------------------------------------------*/
export const UserProfile = z.object({
  id: z.string().uuid(),
  username: z.string().nullish(),
  avatar_url: z.string().url().nullish(),
  full_name: z.string().nullish(),
  bio: z.string().nullish(),
  time_zone: z.string().nullish(),
  onboarding_completed: z.boolean().default(false),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type UserProfile = z.infer<typeof UserProfile>;

export const NotificationPrefs = z.object({
  email: z.boolean().default(true),
  push: z.boolean().default(true),
  task_reminders: z.boolean().default(true),
  goal_updates: z.boolean().default(true),
  habit_reminders: z.boolean().default(true),
});

export const UiPrefs = z.object({
  theme: z.enum(['system', 'light', 'dark']).default('system'),
  compact_view: z.boolean().default(false),
  show_completed_tasks: z.boolean().default(true),
});

export const UserSettings = z.object({
  id: z.string().uuid().optional(),
  user_id: z.string().uuid(),
  notification_preferences: NotificationPrefs,
  ui_preferences: UiPrefs,
});
export type UserSettings = z.infer<typeof UserSettings>;

export const Value = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullish(),
  color: z.string().nullish(),
  icon: z.string().nullish(),
  created_at: z.string().datetime(),
});
export type Value = z.infer<typeof Value>;

export const Goal = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  description: z.string().nullish(),
  status: z.enum(['active', 'completed', 'archived']),
  target_date: z.string().datetime().nullish(),
  value_id: z.string().uuid().nullish(),
  created_at: z.string().datetime(),
});
export type Goal = z.infer<typeof Goal>;

export const Task = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  description: z.string().nullish(),
  status: z.enum(['pending', 'in_progress', 'completed', 'cancelled']),
  priority: z.enum(['low', 'medium', 'high']).nullish(),
  due_date: z.string().datetime().nullish(),
  goal_id: z.string().uuid().nullish(),
  created_at: z.string().datetime(),
});
export type Task = z.infer<typeof Task>;

export const Habit = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullish(),
  goal_frequency: z.number().positive(),
  frequency_period: z.enum(['day', 'week', 'month']),
  color: z.string().nullish(),
  streak: z.number().nonnegative(),
  best_streak: z.number().nonnegative(),
  created_at: z.string().datetime(),
});
export type Habit = z.infer<typeof Habit>;

export const TrackedState = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  name: z.string(),
  category: z.string(),
  current_value: z.union([z.number(), z.string()]),
  timestamp: z.string().datetime(),
});
export type TrackedState = z.infer<typeof TrackedState>;

/* ----------------------------- Rewards ---------------------------*/
export const Badge = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  name: z.string(),
  emoji: z.string().length(2).nullish(),
  description: z.string(),
  earned_at: z.string().datetime(),
});
export const Streak = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  habit_id: z.string().uuid(),
  length: z.number().positive(),
  best: z.number().positive(),
});
export const Loot = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  icon: z.string().nullish(),
  claimed: z.boolean().default(false),
});
export type Badge = z.infer<typeof Badge>;
export type Streak = z.infer<typeof Streak>;
export type Loot = z.infer<typeof Loot>;

/* ------------------------------------------------------------------
 *  Router‑level Schemas – inputs & outputs for every procedure
 * ----------------------------------------------------------------*/
export const greetingInput = z.object({ name: z.string().optional() });
export const greetingOutput = z.object({ greeting: z.string() });

// User
export const updateProfileInput = UserProfile.partial().omit({ id: true, created_at: true, updated_at: true });
export const updateSettingsInput = z.object({
  notification_preferences: NotificationPrefs.partial().optional(),
  ui_preferences: UiPrefs.partial().optional(),
});

// Values
export const createValueInput = Value.omit({ id: true, user_id: true, created_at: true });
export const updateValueInput = createValueInput.partial().extend({ id: z.string().uuid() });

// Goals
export const createGoalInput = Goal.omit({ id: true, user_id: true, created_at: true });
export const updateGoalInput = createGoalInput.partial().extend({ id: z.string().uuid() });

// Tasks
export const createTaskInput = Task.omit({ id: true, user_id: true, created_at: true });
export const updateTaskInput = createTaskInput.partial().extend({ id: z.string().uuid() });
export const updateTaskStatusInput = z.object({ id: z.string().uuid(), status: Task.shape.status });

// Habits
export const createHabitInput = Habit.omit({ id: true, user_id: true, created_at: true, streak: true, best_streak: true });
export const updateHabitInput = createHabitInput.partial().extend({ id: z.string().uuid() });

// Tracked States
export const createTrackedStateInput = TrackedState.omit({ id: true, user_id: true, timestamp: true });

// Rewards
export const claimLootInput = z.object({ lootId: z.string().uuid() });
export const awardBadgeInput = z.object({ badgeId: z.string().uuid() });

/* ------------------------------------------------------------------
 *  Aggregate Router Types – automatically inferred
 * ----------------------------------------------------------------*/
export type RouterInputs = inferRouterInputs<AppRouter>;
export type RouterOutputs = inferRouterOutputs<AppRouter>;

/*
  Usage (client‑side):

  const utils = trpc.useUtils();
  type TasksOutput = RouterOutputs['task']['getTasks'];
  type CreateTaskInput = RouterInputs['task']['createTask'];
*/ ```

## File: ./stores/uiStore.ts
```
import { create } from 'zustand';

interface UiState {
  isDarkMode: boolean;
  toggleTheme: () => void;
}

// Simple Zustand store for UI state (e.g., theme)
export const useUiStore = create<UiState>((set) => ({
  isDarkMode: false, // Default to light mode
  toggleTheme: () => set((state) => ({ isDarkMode: !state.isDarkMode })),
})); ```

## File: ./tailwind.config.js
```
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./app/**/*.{js,jsx,ts,tsx}",
    "./components/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {
      // iOS standard colors
      colors: {
        // iOS system colors
        'ios-blue': '#007AFF',
        'ios-dark-blue': '#0A84FF', // dark mode variant
        'ios-red': '#FF3B30',
        'ios-dark-red': '#FF453A', // dark mode variant
        'ios-green': '#34C759',
        'ios-dark-green': '#30D158', // dark mode variant
        'ios-orange': '#FF9500',
        'ios-dark-orange': '#FF9F0A', // dark mode variant
        'ios-purple': '#AF52DE',
        'ios-dark-purple': '#BF5AF2', // dark mode variant
        'ios-yellow': '#FFCC00',
        'ios-dark-yellow': '#FFD60A', // dark mode variant
        'ios-pink': '#FF2D55',
        'ios-dark-pink': '#FF375F', // dark mode variant
        'ios-indigo': '#5856D6',
        'ios-dark-indigo': '#5E5CE6', // dark mode variant
        
        // iOS gray palette
        'ios-gray': {
          1: '#8E8E93',
          2: '#AEAEB2',
          3: '#C7C7CC',
          4: '#D1D1D6',
          5: '#E5E5EA',
          6: '#F2F2F7',
        },
        'ios-dark-gray': {
          1: '#8E8E93',
          2: '#636366',
          3: '#48484A',
          4: '#3A3A3C',
          5: '#2C2C2E',
          6: '#1C1C1E',
        },
        
        // System background colors
        'ios-system': {
          DEFAULT: '#FFFFFF',
          secondary: '#F2F2F7',
          tertiary: '#FFFFFF',
        },
        'ios-dark-system': {
          DEFAULT: '#000000',
          secondary: '#1C1C1E',
          tertiary: '#2C2C2E',
        },
      },
      
      // iOS standard spacing
      spacing: {
        // Added standard iOS spacing if needed beyond Tailwind defaults
      },
      
      // iOS standard border radius
      borderRadius: {
        'ios-small': '4px',
        'ios-regular': '8px',
        'ios-large': '12px',
        'ios-xl': '16px',
      },
      
      // iOS system font weights
      fontWeight: {
        'ios-regular': '400',
        'ios-medium': '500', 
        'ios-semibold': '600',
        'ios-bold': '700',
      },
      
      // iOS shadows
      boxShadow: {
        'ios-small': '0 1px 2px rgba(0, 0, 0, 0.05)',
        'ios-medium': '0 2px 4px rgba(0, 0, 0, 0.1)',
        'ios-large': '0 4px 6px rgba(0, 0, 0, 0.1)',
      },
    },
  },
  plugins: [],
}; ```

## File: ./tamagui.config.ts
```
import { createTamagui, createTokens } from 'tamagui';

// --- 1. Define your Tokens ---
const tokens = createTokens({
  size: {
    // Using a consistent step (e.g., 4px)
    0: 0,
    1: 4, 
    2: 8, 
    3: 12,
    4: 16, 
    5: 20,
    6: 24,
    7: 28,
    8: 32,
    9: 36,
    10: 40,
    11: 44,
    12: 48, // Example: button height
    13: 52,
    14: 56, // Example: larger input height
    15: 60,
    16: 64,
    true: 16, // Default size
  },
  space: {
    // Often matches size for simplicity
    0: 0,
    1: 4,
    2: 8,
    3: 12,
    4: 16,
    5: 20,
    6: 24,
    7: 28,
    8: 32,
    9: 36,
    10: 40,
    11: 44,
    12: 48,
    13: 52,
    14: 56,
    15: 60,
    16: 64,
    true: 16, // Default space
  },
  radius: {
    0: 0,
    1: 4,
    2: 8,
    3: 10, // Small button radius
    4: 12, // Input/card radius
    5: 16, // Larger card radius
    6: 20,
    7: 24,
    8: 28,
    9: 32,
    10: 40,
    true: 12, // Default radius
  },
  zIndex: {
    0: 0,
    1: 100,
    2: 200,
    3: 300,
    4: 400,
    5: 500,
  },
  color: {
    // Light Theme Colors
    gray1: '#f9f9f9', // Lightest background
    gray2: '#f3f3f3', // Subtle background
    gray3: '#ededed', // UI element background
    gray4: '#e7e7e7', // Hovered UI element background
    gray5: '#dedede', // Active / Selected UI element background
    gray6: '#d7d7d7', // Subtle borders and separators (iOS: #D1D1D6)
    gray7: '#c7c7c7', // UI element border and focus rings (iOS: #C7C7CC)
    gray8: '#a7a7a7', // Hovered UI element border
    gray9: '#8f8f8f', // Solid backgrounds (iOS: #8E8E93)
    gray10: '#858585', // Hovered solid backgrounds
    gray11: '#6f6f6f', // Low-contrast text
    gray12: '#1f1f1f', // High-contrast text

    blue1: '#f0f9ff',
    blue2: '#e0f2fe',
    blue3: '#bae6fd',
    blue4: '#7dd3fc',
    blue5: '#38bdf8',
    blue6: '#0ea5e9',
    blue7: '#0284c7',
    blue8: '#0369a1',
    blue9: '#007AFF', // iOS primary blue
    blue10: '#065a94',
    blue11: '#074774',
    blue12: '#062640',

    // iOS standard colors
    red9: '#FF3B30', // iOS red
    green9: '#34C759', // iOS green
    yellow9: '#FFCC00', // iOS yellow
    orange9: '#FF9500', // iOS orange
    purple9: '#AF52DE', // iOS purple
    pink9: '#FF2D55', // iOS pink
    indigo9: '#5856D6', // iOS indigo

    // Dark Theme Colors
    gray1_dark: '#1C1C1E', // iOS dark background
    gray2_dark: '#2C2C2E', // iOS dark secondary background
    gray3_dark: '#3A3A3C', // iOS dark tertiary background
    gray4_dark: '#48484A',
    gray5_dark: '#545456',
    gray6_dark: '#636366', // iOS dark gray
    gray7_dark: '#8E8E93', // iOS gray
    gray8_dark: '#AEAEB2', // iOS gray2
    gray9_dark: '#C7C7CC', // iOS gray3
    gray10_dark: '#D1D1D6', // iOS gray4
    gray11_dark: '#E5E5EA', // iOS gray5
    gray12_dark: '#F2F2F7', // iOS gray6

    blue1_dark: '#052b4c',
    blue2_dark: '#06355f',
    blue3_dark: '#07467d',
    blue4_dark: '#085a9f',
    blue5_dark: '#0973c7',
    blue6_dark: '#098ff0',
    blue7_dark: '#1aa0ff',
    blue8_dark: '#3db3ff',
    blue9_dark: '#0A84FF', // iOS dark mode blue
    blue10_dark: '#83cfff',
    blue11_dark: '#a8ddff',
    blue12_dark: '#d1ecff',

    // Additional iOS dark mode colors
    red9_dark: '#FF453A', // iOS dark mode red
    green9_dark: '#30D158', // iOS dark mode green
    yellow9_dark: '#FFD60A', // iOS dark mode yellow
    orange9_dark: '#FF9F0A', // iOS dark mode orange
    purple9_dark: '#BF5AF2', // iOS dark mode purple
    pink9_dark: '#FF375F', // iOS dark mode pink
    indigo9_dark: '#5E5CE6', // iOS dark mode indigo

    // Common absolute colors
    white: '#FFFFFF',
    black: '#000000',
    transparent: 'transparent',
  },
  font: {
    body: 'System', // Default system font
    heading: 'System',
    mono: 'SpaceMono', // Custom font loaded in app
  },
  fontSize: {
    1: 12,
    2: 14,
    3: 15, // Common iOS body size
    4: 16,
    5: 18,
    6: 20, // Subtitle
    7: 24,
    8: 30, // Title
    9: 36,
    true: 15, // Default body size
  },
  lineHeight: {
    1: 16,
    2: 20,
    3: 22, // Body line height
    4: 24,
    5: 28,
    6: 32,
    true: 22,
  },
  fontWeight: {
    1: '400', // Regular
    2: '500', // Medium
    3: '600', // Semibold
    4: '700', // Bold
    true: '400',
  },
  letterSpacing: {
    1: 0,
    2: 0.2,
    3: 0.4,
    true: 0,
  },
  // Add font scale tokens for typography consistency
  fontScale: {
    // Heading sizes
    headingXl: 36, // Large title
    headingLg: 30, // Title
    headingMd: 24, // Subtitle
    headingSm: 20, // Section header
    
    // Body sizes
    bodyLg: 18, // Emphasized body text
    bodyMd: 16, // Standard body text
    bodySm: 14, // Secondary/hint text
    bodyXs: 12, // Small text (captions, labels)
  },
});

// --- 2. Define your Themes ---
const light = {
  background: tokens.color.white,
  backgroundHover: tokens.color.gray3,
  backgroundPress: tokens.color.gray4,
  backgroundFocus: tokens.color.gray4,
  backgroundStrong: tokens.color.gray2, // For cards
  backgroundTransparent: tokens.color.transparent,

  color: tokens.color.black, // High contrast text
  colorHover: tokens.color.gray11,
  colorPress: tokens.color.gray10,
  colorFocus: tokens.color.gray10,
  colorSecondary: tokens.color.gray11, // Lower contrast text
  colorTertiary: tokens.color.gray9,

  borderColor: tokens.color.gray6,
  borderColorHover: tokens.color.gray7,
  borderColorPress: tokens.color.gray8,
  borderColorFocus: tokens.color.blue9, // Accent focus border

  primary: tokens.color.blue9, // iOS blue
  primaryHover: tokens.color.blue10,
  primaryPress: tokens.color.blue8,
  primaryFocus: tokens.color.blue10,

  error: tokens.color.red9, // iOS red
  warning: tokens.color.yellow9, // iOS yellow
  success: tokens.color.green9, // iOS green
  info: tokens.color.blue9, // iOS blue

  // Card-specific backgrounds for different elevations
  cardBackground: tokens.color.white,
  cardBackgroundHover: tokens.color.gray2,
  cardBackgroundPress: tokens.color.gray3,
  
  // Input backgrounds
  inputBackground: tokens.color.gray1,
  inputBackgroundHover: tokens.color.white,
  inputBackgroundFocus: tokens.color.white,
};

const dark = {
  background: tokens.color.gray1_dark, // iOS dark background
  backgroundHover: tokens.color.gray3_dark,
  backgroundPress: tokens.color.gray4_dark,
  backgroundFocus: tokens.color.gray4_dark,
  backgroundStrong: tokens.color.gray2_dark,
  backgroundTransparent: tokens.color.transparent,

  color: tokens.color.white, // High contrast text
  colorHover: tokens.color.gray11_dark,
  colorPress: tokens.color.gray10_dark,
  colorFocus: tokens.color.gray10_dark,
  colorSecondary: tokens.color.gray11_dark,
  colorTertiary: tokens.color.gray9_dark,

  borderColor: tokens.color.gray6_dark,
  borderColorHover: tokens.color.gray7_dark,
  borderColorPress: tokens.color.gray8_dark,
  borderColorFocus: tokens.color.blue9_dark,

  primary: tokens.color.blue9_dark, // iOS dark mode blue
  primaryHover: tokens.color.blue10_dark,
  primaryPress: tokens.color.blue8_dark,
  primaryFocus: tokens.color.blue10_dark,

  error: tokens.color.red9_dark,
  warning: tokens.color.yellow9_dark,
  success: tokens.color.green9_dark,
  info: tokens.color.blue9_dark,

  // Card-specific backgrounds for different elevations
  cardBackground: tokens.color.gray2_dark,
  cardBackgroundHover: tokens.color.gray3_dark,
  cardBackgroundPress: tokens.color.gray4_dark,
  
  // Input backgrounds
  inputBackground: tokens.color.gray3_dark,
  inputBackgroundHover: tokens.color.gray2_dark,
  inputBackgroundFocus: tokens.color.gray2_dark,
};

// --- 3. Create the Config ---
const config = createTamagui({
  tokens,
  themes: {
    light,
    dark,
    // Component sub-themes
    light_Button: {
      background: tokens.color.blue9,
      backgroundHover: tokens.color.blue10,
      backgroundPress: tokens.color.blue8,
      color: tokens.color.white,
    },
    dark_Button: {
      background: tokens.color.blue9_dark,
      backgroundHover: tokens.color.blue10_dark,
      backgroundPress: tokens.color.blue8_dark,
      color: tokens.color.white,
    }
  },
  shorthands: {
    m: 'margin',
    mt: 'marginTop',
    mr: 'marginRight',
    mb: 'marginBottom',
    ml: 'marginLeft',
    mx: 'marginHorizontal',
    my: 'marginVertical',
    p: 'padding',
    pt: 'paddingTop',
    pr: 'paddingRight',
    pb: 'paddingBottom',
    pl: 'paddingLeft',
    px: 'paddingHorizontal',
    py: 'paddingVertical',
    bg: 'backgroundColor',
    br: 'borderRadius',
    bw: 'borderWidth',
    bc: 'borderColor',
    f: 'flex',
    fd: 'flexDirection',
    ai: 'alignItems',
    jc: 'justifyContent',
    w: 'width',
    h: 'height',
  },
  defaultTheme: 'light',
  shouldAddPrefersColorThemes: false,
  themeClassNameOnRoot: false,
  disableStrictSimpleProps: true,
  settings: {
    allowedStyleValues: 'somewhat-strict', // Allow both tokens and raw values
  },
  media: {
    xs: { maxWidth: 660 },
    sm: { maxWidth: 800 },
    md: { maxWidth: 1020 },
    lg: { maxWidth: 1280 },
    xl: { maxWidth: 1420 },
    xxl: { maxWidth: 1600 },
    gtXs: { minWidth: 660 + 1 },
    gtSm: { minWidth: 800 + 1 },
    gtMd: { minWidth: 1020 + 1 },
    gtLg: { minWidth: 1280 + 1 },
    short: { maxHeight: 820 },
    tall: { minHeight: 820 },
    hoverNone: { hover: 'none' },
    pointerCoarse: { pointer: 'coarse' },
  },
});

// --- 4. Type Augmentation ---
type AppConfig = typeof config;

declare module 'tamagui' {
  interface TamaguiCustomConfig extends AppConfig {}
}

export default config; ```

## File: ./utils/api-types.ts
```
/**
 * This file was auto-generated by the generate-trpc-types script.
 * Do not edit manually! Instead, run the script again.
 */

import type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from '../../server/src/router';

/**
 * Inference helper for inputs.
 *
 * @example type HelloInput = RouterInputs['example']['hello']
 */
export type RouterInputs = inferRouterInputs<AppRouter>;

/**
 * Inference helper for outputs.
 *
 * @example type HelloOutput = RouterOutputs['example']['hello']
 */
export type RouterOutputs = inferRouterOutputs<AppRouter>;
```

## File: ./utils/auth.ts
```
import { supabase } from './supabase';
import { router } from 'expo-router';

/**
 * Logs the user out and redirects to the login screen
 */
export async function logout() {
  try {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
    
    // Navigate to login screen
    router.replace('/auth/login');
  } catch (error) {
    console.error('Error signing out:', error);
    // Force navigation even if there was an error
    router.replace('/auth/login');
  }
}

/**
 * Gets the current user's profile data
 */
export async function getUserProfile() {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) return null;
    
    // If we have a user, get their profile from the profiles table
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', user.id)
      .single();
    
    if (error) {
      // If profile doesn't exist yet, return basic user info
      return {
        id: user.id,
        email: user.email,
        username: user.user_metadata?.username || 'User',
        created_at: user.created_at,
      };
    }
    
    return data;
  } catch (error) {
    console.error('Error getting user profile:', error);
    return null;
  }
} ```

## File: ./utils/colors.ts
```
import { useTheme } from 'tamagui';

/**
 * Semantic color tokens that map to theme variables
 */
export const semanticTokens = {
  // Background colors
  background: {
    /** Main app background */
    app: '$background',
    /** Card/surface background */
    card: '$backgroundHover',
    /** Secondary surface background */
    secondary: '$backgroundPress',
    /** Tertiary surface background */
    tertiary: '$backgroundStrong',
    /** Input background */
    input: '$backgroundTransparent',
  },
  
  // Foreground/content colors
  content: {
    /** Primary text */
    primary: '$color',
    /** Secondary/dimmed text */
    secondary: '$colorTransparent',
    /** Subtle text - least emphasis */
    subtle: '$colorTransparent2',
    /** Disabled text */
    disabled: '$colorTransparent3',
  },
  
  // Border colors
  border: {
    /** Default border */
    default: '$borderColor',
    /** Focused border */
    focus: '$borderColorFocus',
    /** Border for hover state */
    hover: '$borderColorHover',
  },
  
  // Status colors
  status: {
    /** Success indicators */
    success: '$green10',
    /** Error indicators */
    error: '$red10',
    /** Warning indicators */
    warning: '$yellow10',
    /** Information indicators */
    info: '$blue10',
  },
  
  // Brand colors (adjust to match your brand)
  brand: {
    /** Primary brand color */
    primary: '$blue10',
    /** Secondary brand color */
    secondary: '$purple10',
    /** Accent brand color */
    accent: '$green10',
  }
};

/**
 * Hook that provides access to theme-aware colors from the semantic tokens
 * @returns An object with semantic color tokens mapped to actual theme colors
 */
export function useColors() {
  const theme = useTheme();
  
  return {
    background: {
      app: theme?.background?.get() || '#FFFFFF',
      card: theme?.backgroundHover?.get() || '#F3F4F6',
      secondary: theme?.backgroundPress?.get() || '#E5E7EB',
      tertiary: theme?.backgroundStrong?.get() || '#D1D5DB',
      input: theme?.backgroundTransparent?.get() || '#FFFFFF',
    },
    content: {
      primary: theme?.color?.get() || '#111827',
      secondary: theme?.colorTransparent?.get() || '#4B5563',
      subtle: theme?.colorTransparent2?.get() || theme?.colorTransparent?.get() || '#6B7280',
      disabled: theme?.colorTransparent3?.get() || theme?.colorTransparent?.get() || '#9CA3AF',
    },
    border: {
      default: theme?.borderColor?.get() || '#E5E7EB',
      focus: theme?.borderColorFocus?.get() || '#93C5FD',
      hover: theme?.borderColorHover?.get() || '#BFDBFE',
    },
    status: {
      success: theme?.green10?.get() || '#10B981',
      error: theme?.red10?.get() || '#EF4444',
      warning: theme?.yellow10?.get() || '#F59E0B',
      info: theme?.blue10?.get() || '#3B82F6',
    },
    brand: {
      primary: theme?.blue10?.get() || '#3B82F6',
      secondary: theme?.purple10?.get() || '#8B5CF6',
      accent: theme?.green10?.get() || '#10B981',
    }
  };
}

/**
 * Helper function to handle opacity for colors
 * @param hex Hex color code
 * @param alpha Opacity (0-1)
 * @returns RGBA color string
 */
export function withOpacity(hex: string, alpha: number): string {
  // Extract RGB components from hex
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

/**
 * Palette with static color values for when theme context is not available
 * These should be used sparingly, prefer the useColors hook when possible
 */
export const palette = {
  // Main UI colors
  black: '#000000',
  white: '#FFFFFF',
  
  // Grays
  gray: {
    50: '#F9FAFB',
    100: '#F3F4F6',
    200: '#E5E7EB',
    300: '#D1D5DB',
    400: '#9CA3AF',
    500: '#6B7280',
    600: '#4B5563',
    700: '#374151',
    800: '#1F2937',
    900: '#111827',
  },
  
  // Blues
  blue: {
    50: '#EFF6FF',
    100: '#DBEAFE',
    200: '#BFDBFE',
    300: '#93C5FD',
    400: '#60A5FA',
    500: '#3B82F6',
    600: '#2563EB',
    700: '#1D4ED8',
    800: '#1E40AF',
    900: '#1E3A8A',
  },
  
  // Greens
  green: {
    50: '#ECFDF5',
    100: '#D1FAE5',
    200: '#A7F3D0',
    300: '#6EE7B7',
    400: '#34D399',
    500: '#10B981',
    600: '#059669',
    700: '#047857',
    800: '#065F46',
    900: '#064E3B',
  },
  
  // Reds
  red: {
    50: '#FEF2F2',
    100: '#FEE2E2',
    200: '#FECACA',
    300: '#FCA5A5',
    400: '#F87171',
    500: '#EF4444',
    600: '#DC2626',
    700: '#B91C1C',
    800: '#991B1B',
    900: '#7F1D1D',
  },
  
  // Yellows
  yellow: {
    50: '#FFFBEB',
    100: '#FEF3C7',
    200: '#FDE68A',
    300: '#FCD34D',
    400: '#FBBF24',
    500: '#F59E0B',
    600: '#D97706',
    700: '#B45309',
    800: '#92400E',
    900: '#78350F',
  },
  
  // Purples
  purple: {
    50: '#F5F3FF',
    100: '#EDE9FE',
    200: '#DDD6FE',
    300: '#C4B5FD',
    400: '#A78BFA',
    500: '#8B5CF6',
    600: '#7C3AED',
    700: '#6D28D9',
    800: '#5B21B6',
    900: '#4C1D95',
  },
}; ```

## File: ./utils/generated-hooks.ts
```
/**
 * GENERATED FILE - DO NOT EDIT
 * This file is automatically generated by the generate-trpc-client script.
 * To update this file, run: npm run generate-hooks
 */

import { trpc } from './trpc';
import { RouterInputs, RouterOutputs } from '../server/src/types/trpc-types';

/**
 * Type-safe hooks for TRPC procedures
 */

// user hooks
export const useUser = {
  // Add strongly typed hooks here
};

// dashboard hooks
export const useDashboard = {
  // Add strongly typed hooks here
};

// value hooks
export const useValue = {
  // Add strongly typed hooks here
};

// goal hooks
export const useGoal = {
  // Add strongly typed hooks here
};

// task hooks
export const useTask = {
  // Add strongly typed hooks here
};

// habit hooks
export const useHabit = {
  // Add strongly typed hooks here
};

// state hooks
export const useState = {
  // Add strongly typed hooks here
};

// rewards hooks
export const useRewards = {
  // Add strongly typed hooks here
};


// Example type usage
type GreetingOutput = RouterOutputs['greeting']['hello'];
```

## File: ./utils/haptics.ts
```
```

## File: ./utils/mock-api.ts
```
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

// Initialize tRPC for our mock API
const t = initTRPC.create();

// Export a procedure builder
const router = t.router;
const publicProcedure = t.procedure;

// Example router with some procedures
export const appRouter = router({
  greeting: {
    hello: publicProcedure
      .input(z.object({ name: z.string().optional() }))
      .query(({ input }) => {
        return {
          greeting: `Hello ${input.name ?? 'world'}`,
        };
      }),
    goodbye: publicProcedure
      .query(() => {
        return {
          greeting: 'Goodbye!',
        };
      }),
  },
  user: {
    get: publicProcedure
      .input(z.object({ id: z.string() }))
      .query(({ input }) => {
        return {
          id: input.id,
          name: 'Mock User',
        };
      }),
    list: publicProcedure
      .query(() => {
        return [
          { id: '1', name: 'Mock User 1' },
          { id: '2', name: 'Mock User 2' },
        ];
      }),
  },
  auth: {
    refreshToken: publicProcedure
      .input(z.object({ refreshToken: z.string() }))
      .mutation(async ({ input }) => {
        console.log('Mock API: refreshToken called with', input.refreshToken);
        // Simulate checking refresh token and issuing new ones
        await new Promise(resolve => setTimeout(resolve, 300));
        if (input.refreshToken === 'valid-refresh-token') { // Example valid token
          return {
            accessToken: `mock-access-${Date.now()}`,
            refreshToken: `mock-refresh-${Date.now()}`,
          };
        } else {
          // Throw error for invalid refresh token
          throw new Error('Invalid refresh token'); 
        }
      }),
    // Add login/logout mutations here later
  },
  item: {
    add: publicProcedure
      .input(z.object({ name: z.string() }))
      .mutation(async ({ input }) => {
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 500));
        // In a real backend, save to DB
        console.log('Mock API: Adding item', input);
        return {
          id: Math.random().toString(36).substring(7), // Generate random ID
          name: input.name,
          status: 'added'
        };
      }),
  },
});

// Export type router type
export type AppRouter = typeof appRouter; ```

## File: ./utils/nats-client.ts
```
import { QueryClient } from '@tanstack/react-query';
import { connect, type ConnectionOptions, type NatsConnection, StringCodec } from 'nats.ws';

// Codec for encoding/decoding NATS messages
const sc = StringCodec();

// Type for cache update handlers
type CacheUpdateHandler = (data: any) => void;

// Global handlers for different subjects
const handlers: Record<string, CacheUpdateHandler[]> = {};

// Connection state
let natsConnection: NatsConnection | null = null;
let queryClient: QueryClient | null = null;
let isConnecting = false;

/**
 * Initialize the NATS client and connect to the server
 */
export async function initNatsClient(
  url: string, 
  qc: QueryClient,
  options: Partial<ConnectionOptions> = {}
): Promise<NatsConnection> {
  if (natsConnection) {
    return natsConnection;
  }
  
  if (isConnecting) {
    throw new Error('NATS connection is already in progress');
  }
  
  isConnecting = true;
  
  try {
    // Set the query client for cache updates
    queryClient = qc;
    
    // Connect to NATS server
    natsConnection = await connect({
      servers: url,
      // Add required polyfills for React Native
      // These would need to be properly implemented in a real app
      ...options,
    });
    
    console.log('Connected to NATS server');
    
    // Setup ping interval to keep connection alive
    const pingInterval = setInterval(() => {
      if (natsConnection && !natsConnection.isClosed) {
        // Note: Using a custom ping mechanism instead of the built-in one
        try {
          const start = Date.now();
          // Simple ping using a request to a dummy subject
          natsConnection.request('_PING_', undefined, { timeout: 1000 })
            .then(() => {
              const latency = Date.now() - start;
              console.log(`NATS server latency: ${latency}ms`);
            })
            .catch((err: Error) => {
              console.error('NATS ping error:', err.message);
            });
        } catch (err) {
          const error = err as Error;
          console.error('NATS ping error:', error.message);
        }
      } else {
        clearInterval(pingInterval);
      }
    }, 30000);
    
    // Handle connection close
    natsConnection.closed().then(() => {
      console.log('NATS connection closed');
      natsConnection = null;
      clearInterval(pingInterval);
      // Could implement reconnection logic here
    });
    
    return natsConnection;
  } catch (error) {
    console.error('Failed to connect to NATS server:', error);
    isConnecting = false;
    throw error;
  }
}

/**
 * Subscribe to a NATS subject and update the React Query cache
 */
export async function subscribeWithCache(
  subject: string,
  queryKey: unknown[],
  updateType: 'invalidate' | 'setData' = 'invalidate'
): Promise<() => void> {
  if (!natsConnection) {
    throw new Error('NATS client not initialized');
  }
  
  if (!queryClient) {
    throw new Error('QueryClient not set');
  }
  
  // Create subscription
  const subscription = natsConnection.subscribe(subject);
  
  // Setup message handler
  (async () => {
    for await (const msg of subscription) {
      try {
        const data = JSON.parse(sc.decode(msg.data));
        
        if (updateType === 'invalidate') {
          // Invalidate the cache for this query key
          queryClient.invalidateQueries({ queryKey });
        } else {
          // Update the cache directly
          queryClient.setQueryData(queryKey, data);
        }
        
        // Call any custom handlers
        if (handlers[subject]) {
          handlers[subject].forEach(handler => handler(data));
        }
      } catch (error) {
        const err = error as Error;
        console.error(`Error handling message for ${subject}:`, err.message);
      }
    }
  })();
  
  // Return unsubscribe function
  return () => {
    subscription.unsubscribe();
  };
}

/**
 * Add a custom handler for a subject
 */
export function addSubjectHandler(subject: string, handler: CacheUpdateHandler): () => void {
  if (!handlers[subject]) {
    handlers[subject] = [];
  }
  
  handlers[subject].push(handler);
  
  // Return a function to remove the handler
  return () => {
    if (handlers[subject]) {
      handlers[subject] = handlers[subject].filter(h => h !== handler);
    }
  };
}

/**
 * Get the NATS connection
 */
export function getNatsConnection(): NatsConnection | null {
  return natsConnection;
}

/**
 * Close the NATS connection
 */
export async function closeNatsConnection(): Promise<void> {
  if (natsConnection) {
    await natsConnection.close();
    natsConnection = null;
  }
} ```

## File: ./utils/offline-mutations.ts
```
import AsyncStorage from '@react-native-async-storage/async-storage';
import {
  QueryClient,
  Mutation,
  MutationCache,
  onlineManager,
} from '@tanstack/react-query';
import {
  persistQueryClient,
  PersistQueryClientOptions,
} from '@tanstack/react-query-persist-client';
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister';
import { useNetInfo, type NetInfoSubscription } from '@react-native-community/netinfo';
import { useEffect, useRef } from 'react';
import NetInfo from '@react-native-community/netinfo';

// Create a persister for React Query (AsyncStorage-based)
export const asyncStoragePersister = createAsyncStoragePersister({
  storage: AsyncStorage,
});

/**
 * React Query persistence options for offline support
 */
export const reactQueryPersistOptions: Omit<PersistQueryClientOptions, 'queryClient'> = {
  persister: asyncStoragePersister,
  // Add custom serialization/deserialization if needed
  // We want to persist mutations especially for offline support
  buster: 'v1',
  dehydrateOptions: {
    shouldDehydrateMutation: () => true,
  },
};

/**
 * Hook to resume paused mutations when the device comes back online
 */
export function useResumeNetworkMutations(queryClient: QueryClient) {
  const netInfo = useNetInfo();
  const previousNetworkState = useRef(netInfo.isConnected);
  
  // Update React Query's online status manager
  useEffect(() => {
    onlineManager.setOnline(netInfo.isConnected === true);
  }, [netInfo.isConnected]);
  
  useEffect(() => {
    const isConnectedNow = netInfo.isConnected === true;
    const wasConnected = previousNetworkState.current === true;
    
    // If we just reconnected to the network
    if (isConnectedNow && !wasConnected) {
      console.log('Internet connection restored, resuming paused mutations');
      
      // Resume any paused mutations
      queryClient.resumePausedMutations().then(() => {
        // After resuming mutations, invalidate queries to refresh data
        queryClient.invalidateQueries();
      }).catch((error: Error) => {
        console.error('Error resuming mutations:', error.message);
      });
    }
    
    // Update our ref
    previousNetworkState.current = isConnectedNow;
  }, [netInfo.isConnected, queryClient]);
}

/**
 * Add a visual flag to offline-created items for UI feedback
 */
export function markItemAsOffline<T>(item: T): T & { isOffline: boolean } {
  return {
    ...item,
    isOffline: true,
  };
}

/**
 * Remove the offline flag from an item once it's synced
 */
export function markItemAsSynced<T extends { isOffline?: boolean }>(item: T): T {
  const result = { ...item };
  delete result.isOffline;
  return result;
}

/**
 * Get all pending mutations from the mutation cache
 */
export function getPendingMutations(mutationCache: MutationCache): Mutation[] {
  return mutationCache.getAll().filter((mutation: any) => 
    mutation?.state?.status === 'loading' || 
    (mutation?.state?.status === 'error' && mutation?.state?.isPaused)
  );
}

/**
 * Configure the query client for offline support and network state management
 */
export function configureQueryClientForOffline(queryClient: QueryClient): NetInfoSubscription {
  // Listen to network status changes and update onlineManager
  const unsubscribe = NetInfo.addEventListener(state => {
    onlineManager.setOnline(state.isConnected === true);
  });
  
  // When a mutation fails due to network error, pause it instead of failing
  queryClient.getMutationCache().config.onError = (error: unknown, _variables: unknown, _context: unknown, mutation: any) => {
    // Check if the error is a network error
    if (
      error instanceof Error && 
      (
        error.message.includes('network') || 
        error.message.includes('Network Error') ||
        error.message.includes('Failed to fetch')
      )
    ) {
      console.log('Network error detected, pausing mutation for later retry');
      
      // Pause the mutation instead of failing permanently
      mutation.state.isPaused = true;
    }
  };
  
  // Set up persistence
  persistQueryClient({
    queryClient,
    ...reactQueryPersistOptions,
  });

  // Return unsubscribe function for cleanup
  return unsubscribe;
} ```

## File: ./utils/offline-sync.ts
```
import AsyncStorage from '@react-native-async-storage/async-storage';
import NetInfo from '@react-native-community/netinfo';
import { queryClient } from './query-client';
import { supabase } from './supabase';

// Keys for offline data
const OFFLINE_MUTATIONS_KEY = 'aether-offline-mutations';
const PENDING_ITEMS_KEY = 'aether-pending-items';

// Types
export interface PendingItem {
  id: string;
  type: string;
  data: any;
  createdAt: number;
  isNotSynced: boolean;
}

interface OfflineMutation {
  id: string;
  type: 'create' | 'update' | 'delete';
  entity: string;
  data: any;
  timestamp: number;
}

/**
 * Save a mutation to be processed when back online
 */
export async function saveOfflineMutation(
  type: 'create' | 'update' | 'delete',
  entity: string,
  data: any
): Promise<string> {
  try {
    // Generate a temporary ID for new items
    const id = `temp-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
    
    // Create mutation object
    const mutation: OfflineMutation = {
      id,
      type,
      entity,
      data,
      timestamp: Date.now(),
    };
    
    // Get existing mutations
    const existingMutationsStr = await AsyncStorage.getItem(OFFLINE_MUTATIONS_KEY);
    const existingMutations: OfflineMutation[] = existingMutationsStr 
      ? JSON.parse(existingMutationsStr) 
      : [];
    
    // Add new mutation
    existingMutations.push(mutation);
    
    // Save mutations back to storage
    await AsyncStorage.setItem(OFFLINE_MUTATIONS_KEY, JSON.stringify(existingMutations));
    
    // Also add to pending items for UI
    if (type === 'create' || type === 'update') {
      await addToPendingItems(id, entity, data);
    }
    
    return id;
  } catch (error) {
    console.error('Error saving offline mutation:', error);
    throw error;
  }
}

/**
 * Add an item to the pending items list for UI display
 */
async function addToPendingItems(id: string, type: string, data: any): Promise<void> {
  try {
    const existingItemsStr = await AsyncStorage.getItem(PENDING_ITEMS_KEY);
    const existingItems: PendingItem[] = existingItemsStr 
      ? JSON.parse(existingItemsStr)
      : [];
    
    // Create a pending item
    const pendingItem: PendingItem = {
      id,
      type,
      data,
      createdAt: Date.now(),
      isNotSynced: true,
    };
    
    // Add to list
    existingItems.push(pendingItem);
    
    // Save back to storage
    await AsyncStorage.setItem(PENDING_ITEMS_KEY, JSON.stringify(existingItems));
  } catch (error) {
    console.error('Error adding to pending items:', error);
  }
}

/**
 * Get all pending items for a specific type
 */
export async function getPendingItems(type: string): Promise<PendingItem[]> {
  try {
    const itemsStr = await AsyncStorage.getItem(PENDING_ITEMS_KEY);
    if (!itemsStr) return [];
    
    const items: PendingItem[] = JSON.parse(itemsStr);
    return items.filter(item => item.type === type);
  } catch (error) {
    console.error('Error getting pending items:', error);
    return [];
  }
}

/**
 * Synchronize offline mutations with the server
 */
export async function syncOfflineMutations(): Promise<boolean> {
  try {
    // Check if we're online
    const netInfo = await NetInfo.fetch();
    if (!netInfo.isConnected || netInfo.isInternetReachable === false) {
      console.log('Not connected to the internet, skipping sync');
      return false;
    }
    
    // Get all pending mutations
    const mutationsStr = await AsyncStorage.getItem(OFFLINE_MUTATIONS_KEY);
    if (!mutationsStr) return true; // Nothing to sync
    
    const mutations: OfflineMutation[] = JSON.parse(mutationsStr);
    if (!mutations.length) return true; // Nothing to sync
    
    console.log(`Syncing ${mutations.length} offline mutations...`);
    
    // Process each mutation in order
    const results = await Promise.allSettled(
      mutations.map(async (mutation) => {
        try {
          switch (mutation.type) {
            case 'create':
              return await processMutation('create', mutation);
            case 'update':
              return await processMutation('update', mutation);
            case 'delete':
              return await processMutation('delete', mutation);
            default:
              console.error('Unknown mutation type:', mutation.type);
              return false;
          }
        } catch (error) {
          console.error('Error processing mutation:', error);
          return false;
        }
      })
    );
    
    // Check results
    const allSucceeded = results.every(
      result => result.status === 'fulfilled' && result.value === true
    );
    
    if (allSucceeded) {
      // Clear pending mutations if all succeeded
      await AsyncStorage.removeItem(OFFLINE_MUTATIONS_KEY);
      await AsyncStorage.removeItem(PENDING_ITEMS_KEY);
      
      // Invalidate queries to refresh data
      queryClient.invalidateQueries();
      
      return true;
    } else {
      // Some mutations failed, remove the successful ones
      const successfulMutationIndexes = results.map((result, index) => 
        result.status === 'fulfilled' && result.value === true ? index : -1
      ).filter(index => index !== -1);
      
      const remainingMutations = mutations.filter(
        (_, index) => !successfulMutationIndexes.includes(index)
      );
      
      // Save remaining mutations
      await AsyncStorage.setItem(
        OFFLINE_MUTATIONS_KEY, 
        JSON.stringify(remainingMutations)
      );
      
      // Refresh query data
      queryClient.invalidateQueries();
      
      return false;
    }
  } catch (error) {
    console.error('Error syncing offline mutations:', error);
    return false;
  }
}

/**
 * Process a single mutation against the server
 */
async function processMutation(
  type: 'create' | 'update' | 'delete',
  mutation: OfflineMutation
): Promise<boolean> {
  try {
    // Get the entity table name
    const table = mutation.entity;
    
    switch (type) {
      case 'create': {
        // For create, we remove any temp id and insert the record
        const { id, ...data } = mutation.data;
        const { data: responseData, error } = await supabase
          .from(table)
          .insert(data)
          .select();
          
        if (error) throw error;
        return true;
      }
      
      case 'update': {
        // For update, we update the record by ID
        const { id, ...data } = mutation.data;
        const { error } = await supabase
          .from(table)
          .update(data)
          .eq('id', id);
          
        if (error) throw error;
        return true;
      }
      
      case 'delete': {
        // For delete, we delete the record by ID
        const { error } = await supabase
          .from(table)
          .delete()
          .eq('id', mutation.data.id);
          
        if (error) throw error;
        return true;
      }
      
      default:
        return false;
    }
  } catch (error) {
    console.error('Error processing mutation:', error);
    return false;
  }
}

/**
 * Hook up background sync when app comes online
 */
export function setupBackgroundSync(): () => void {
  // Subscribe to network changes
  const unsubscribe = NetInfo.addEventListener(state => {
    // When we go from offline to online, sync mutations
    if (state.isConnected && state.isInternetReachable !== false) {
      syncOfflineMutations()
        .then(success => {
          console.log('Background sync completed:', success ? 'success' : 'with errors');
        })
        .catch(error => {
          console.error('Background sync failed:', error);
        });
    }
  });
  
  return unsubscribe;
} ```

## File: ./utils/query-client.ts
```
import { QueryClient } from '@tanstack/react-query';
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister';
import AsyncStorage from '@react-native-async-storage/async-storage';
import NetInfo from '@react-native-community/netinfo';
import { onlineManager } from '@tanstack/react-query';

// Create a client
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // Default stale time of 5 minutes
      staleTime: 1000 * 60 * 5,
      // When offline, keep data fresh for 24 hours (cacheTime was renamed to gcTime)
      gcTime: 1000 * 60 * 60 * 24,
      // Retry failed queries 3 times
      retry: 3,
      // Retry with exponential backoff
      retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
      // Don't refetch on window focus for mobile
      refetchOnWindowFocus: false,
      // Show stale data while fetching new data (renamed from keepPreviousData)
      placeholderData: 'keepPrevious',
    },
    mutations: {
      // Retry failed mutations 3 times
      retry: 3,
      // Enable offline mutations
      networkMode: 'offlineFirst',
    },
  },
});

// Create a persister
export const persister = createAsyncStoragePersister({
  storage: AsyncStorage,
  key: 'aether-query-cache-v1',
  // Only persist queries with a longer cacheTime
  throttleTime: 1000,
  // SerDe for serializing/deserializing the data
  serialize: data => JSON.stringify(data),
  deserialize: data => JSON.parse(data),
});

/**
 * Initialize network monitoring for the query client
 * Call this on app startup to enable online/offline detection
 */
export function initializeNetworkMonitoring(): () => void {
  // Subscribe to network status changes
  const unsubscribe = NetInfo.addEventListener(state => {
    onlineManager.setOnline(
      state.isConnected != null && 
      state.isConnected && 
      Boolean(state.isInternetReachable)
    );
  });

  // Initialize once at startup - check if online
  NetInfo.fetch().then(state => {
    onlineManager.setOnline(
      state.isConnected != null && 
      state.isConnected && 
      Boolean(state.isInternetReachable)
    );
  });

  return unsubscribe;
}

/**
 * Resume any paused mutations when the app comes back online
 * 
 * @returns A promise that resolves when mutations are resumed
 */
export async function resumeMutationsAndInvalidate(): Promise<void> {
  try {
    await queryClient.resumePausedMutations();
    queryClient.invalidateQueries();
  } catch (error) {
    console.error('Error resuming mutations:', error);
  }
} ```

## File: ./utils/settings.ts
```
import * as SecureStore from 'expo-secure-store';
import { Platform } from 'react-native';

// Settings keys
export const APP_SETTINGS_KEY = 'aether_app_settings';

// Default settings
const DEFAULT_SETTINGS = {
  enableNotifications: true,
  enableDarkMode: null, // null means "use system setting"
  enableOfflineMode: true,
  syncOnCellular: true,
  lastSyncTimestamp: null,
};

// Type for app settings
export type AppSettings = typeof DEFAULT_SETTINGS;

/**
 * Get app settings from secure storage
 */
export async function getSettings(): Promise<AppSettings> {
  try {
    const storedSettings = await SecureStore.getItemAsync(APP_SETTINGS_KEY);
    if (!storedSettings) return DEFAULT_SETTINGS;
    
    return { ...DEFAULT_SETTINGS, ...JSON.parse(storedSettings) };
  } catch (error) {
    console.error('Error getting settings:', error);
    return DEFAULT_SETTINGS;
  }
}

/**
 * Save app settings to secure storage
 */
export async function saveSettings(settings: Partial<AppSettings>): Promise<void> {
  try {
    const currentSettings = await getSettings();
    const newSettings = { ...currentSettings, ...settings };
    
    await SecureStore.setItemAsync(
      APP_SETTINGS_KEY, 
      JSON.stringify(newSettings)
    );
  } catch (error) {
    console.error('Error saving settings:', error);
  }
}

/**
 * Update a single setting
 */
export async function updateSetting<K extends keyof AppSettings>(
  key: K, 
  value: AppSettings[K]
): Promise<void> {
  await saveSettings({ [key]: value } as Partial<AppSettings>);
}

/**
 * Get app version
 */
export function getAppVersion(): string {
  // In a real app, you would use expo-constants to get the app version
  // import Constants from 'expo-constants';
  // return Constants.expoConfig.version;
  return '1.0.0';
}

/**
 * Get platform information
 */
export function getPlatformInfo(): string {
  return `${Platform.OS} ${Platform.Version}`;
} ```

## File: ./utils/supabase.ts
```
import 'react-native-url-polyfill/auto';
import { createClient } from '@supabase/supabase-js';
import * as SecureStore from 'expo-secure-store';

// SecureStore adapter for Supabase auth persistence
const ExpoSecureStoreAdapter = {
  getItem: (key: string) => {
    return SecureStore.getItemAsync(key);
  },
  setItem: (key: string, value: string) => {
    return SecureStore.setItemAsync(key, value);
  },
  removeItem: (key: string) => {
    return SecureStore.deleteItemAsync(key);
  },
};

// Get Supabase URL and anon key from environment variables
// In production, these should be set in app.config.js or via EAS secrets
const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL || '';
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY || '';

if (!supabaseUrl || !supabaseAnonKey) {
  console.warn(
    'Supabase URL or anon key not found. Make sure to set EXPO_PUBLIC_SUPABASE_URL and EXPO_PUBLIC_SUPABASE_ANON_KEY environment variables.'
  );
}

// Create Supabase client
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: ExpoSecureStoreAdapter,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
});

// Helper function to check if user is authenticated
export const isAuthenticated = async () => {
  const { data, error } = await supabase.auth.getSession();
  return !!data.session;
};

// Helper function to get current user
export const getCurrentUser = async () => {
  const { data, error } = await supabase.auth.getUser();
  if (error) {
    console.error('Error getting user:', error.message);
    return null;
  }
  return data.user;
}; ```

## File: ./utils/trpc.ts
```
import { createTRPCReact } from '@trpc/react-query';
import { type inferRouterInputs, type inferRouterOutputs } from '@trpc/server';

// Import the real AppRouter type from our server
import { type AppRouter } from '../server/src/router';

// Import types using the updated path
import { RouterInputs as TypedRouterInputs, RouterOutputs as TypedRouterOutputs } from '../server/src/types/trpc-types';

/**
 * tRPC React client
 * The client for consuming your tRPC API from React components
 */
export const trpc = createTRPCReact<AppRouter>();

/**
 * Inference helpers for input/output types
 * Use the pre-defined types from trpc-types.ts
 */
export type RouterInputs = TypedRouterInputs;
export type RouterOutputs = TypedRouterOutputs; ```

## File: ./app.json
```
{
  "expo": {
    "name": "AetherIphone",
    "slug": "AetherIphone",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "aether",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.tybed7.AetherIphone",
      "infoPlist": {
        "ITSAppUsesNonExemptEncryption": false
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.tybed7.AetherIphone"
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff"
        }
      ]
    ],
    "runtimeVersion": {
      "policy": "appVersion"
    },
    "updates": {
      "url": "https://u.expo.dev/d25504b5-1869-4dca-bfe0-9aaf6e86923b"
    },
    "experiments": {
      "typedRoutes": true
    },
    "extra": {
      "router": {
        "origin": false
      },
      "eas": {
        "projectId": "d25504b5-1869-4dca-bfe0-9aaf6e86923b"
      }
    }
  }
}
```

## File: ./eas.json
```
{
  "cli": {
    "version": ">= 16.3.2",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "distribution": "internal"
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}
```

## File: ./package.json
```
{
  "name": "aetheriphone",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "lint": "expo lint",
    "generate-types": "node ./scripts/generate-trpc-types.js",
    "generate-hooks": "node ./scripts/generate-trpc-client.js",
    "generate": "node ./scripts/generate-all.js",
    "dev": "npm run generate && expo start"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.2",
    "@react-native-async-storage/async-storage": "1.23.1",
    "@react-native-community/netinfo": "^11.4.1",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "@shopify/flash-list": "^1.8.0",
    "@supabase/supabase-js": "^2.49.4",
    "@tamagui/animations-react-native": "^1.126.1",
    "@tamagui/config": "^1.126.1",
    "@tamagui/core": "^1.126.1",
    "@tamagui/font-inter": "^1.126.1",
    "@tamagui/lucide-icons": "^1.126.1",
    "@tamagui/react-native-media-driver": "^1.126.1",
    "@tamagui/shorthands": "^1.126.1",
    "@tamagui/stacks": "^1.126.1",
    "@tamagui/themes": "^1.126.1",
    "@tanstack/query-async-storage-persister": "^5.74.4",
    "@tanstack/react-query": "^5.74.4",
    "@tanstack/react-query-persist-client": "^5.74.4",
    "@trpc/client": "^11.1.0",
    "@trpc/react-query": "^11.1.0",
    "@trpc/server": "^11.1.0",
    "date-fns": "^4.1.0",
    "expo": "~52.0.46",
    "expo-blur": "~14.0.3",
    "expo-constants": "~17.0.8",
    "expo-dev-client": "~5.0.20",
    "expo-font": "~13.0.4",
    "expo-haptics": "~14.0.1",
    "expo-linking": "~7.0.5",
    "expo-router": "~4.0.20",
    "expo-secure-store": "^14.0.1",
    "expo-splash-screen": "~0.29.24",
    "expo-status-bar": "~2.0.1",
    "expo-symbols": "~0.2.2",
    "expo-system-ui": "~4.0.9",
    "expo-web-browser": "~14.0.2",
    "nativewind": "^4.1.19",
    "nats.ws": "^1.30.3",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-native": "0.76.9",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-reanimated": "^3.17.4",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-svg": "15.8.0",
    "react-native-url-polyfill": "^2.0.0",
    "react-native-web": "~0.19.13",
    "react-native-webview": "13.12.5",
    "tamagui": "^1.126.1",
    "text-encoding": "^0.7.0",
    "zod": "^3.24.3",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@tamagui/babel-plugin": "^1.126.1",
    "@types/jest": "^29.5.12",
    "@types/react": "~18.3.12",
    "@types/react-test-renderer": "^18.3.0",
    "autoprefixer": "^10.4.21",
    "babel-plugin-transform-inline-environment-variables": "^0.4.4",
    "eslint": "^8.57.0",
    "eslint-config-expo": "~8.0.1",
    "jest": "^29.2.1",
    "jest-expo": "~52.0.6",
    "postcss": "^8.5.3",
    "react-test-renderer": "18.3.1",
    "supabase": "^2.22.4",
    "tailwindcss": "^3.4.17",
    "typescript": "^5.3.3"
  },
  "private": true
}
```

## File: ./server/package.json
```
{
  "name": "aether-server",
  "version": "1.0.0",
  "description": "Backend server for Aether app",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "dependencies": {
    "@supabase/supabase-js": "^2.49.4",
    "cors": "^2.8.5",
    "express": "^4.18.2",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/node": "^20.11.20",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.3.3"
  }
}
```

## File: ./server/tsconfig.json
```
{
  "compilerOptions": {
    "target": "es2019",
    "module": "commonjs",
    "lib": ["es2019", "esnext.asynciterable"],
    "outDir": "./dist",
    "rootDir": "../",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "sourceMap": true,
    "declaration": true
  },
  "include": ["src/**/*", "types/**/*"],
  "exclude": ["node_modules", "dist"]
}```

## File: ./tsconfig.json
```
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./*"
      ],
      "server/*": [
        "./server/*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts",
    "server/**/*.ts"
  ]
}
```

