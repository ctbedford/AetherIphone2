# Aether iPhone: Implementation Details for Migration Questions
Generated on Wed Apr 30 00:55:52 CDT 2025

\n\n# 1️⃣ tRPC Router Names & Procedure Signatures
\n## Router Definitions
\n\n## Router: dashboardRouter
**File:** server/src/routers/dashboardRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';

// Define fields for consistent selection - align with Zod schemas & table structure
const HABIT_FIELDS = 'id, user_id, name, description, habit_type, goal_quantity, goal_units, frequency_type, frequency_details, reminder_id, streak, best_streak, sort_order, created_at, updated_at'; // Added reminder_id
const GOAL_FIELDS = 'id, user_id, name, description, priority, status, target_date, sort_order, created_at, updated_at'; // Use target_date
const TASK_FIELDS = 'id, user_id, name, notes, status, priority, due_date, reminder_id, goal_id, sort_order, created_at, updated_at'; // Use due_date, reminder_id
const HABIT_ENTRY_FIELDS = 'id, habit_id, user_id, date, quantity_value, notes, created_at';
const TRACKED_STATE_DEF_FIELDS = 'id, user_id, name, description, data_type, unit, sort_order, active, notes, created_at, updated_at'; // Adjusted based on potential schema changes

export const dashboardRouter = router({
  getDashboardData: protectedProcedure
    .input(
      z.object({
        habitLimit: z.number().min(1).default(5),
        goalLimit: z.number().min(1).default(5),
        taskLimit: z.number().min(1).default(10)
      }).optional()
    )
    .query(async ({ ctx, input }) => {
      try {
        // Get limits from input or use defaults
        const habitLimit = input?.habitLimit || 5;
        const goalLimit = input?.goalLimit || 5;
        const taskLimit = input?.taskLimit || 10;

        // --- Fetch Habits ---
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
          .limit(habitLimit);
        if (habitsError) throw habitsError;

        // --- Fetch Goals ---
        const { data: goals, error: goalsError } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
          .limit(goalLimit);
        if (goalsError) throw goalsError;

        // --- Fetch Upcoming Tasks (focus on upcoming tasks and prioritize those due soon) ---
        const today = new Date();
        const twoWeeksFromNow = new Date();
        twoWeeksFromNow.setDate(today.getDate() + 14);
        
        // We want to fetch tasks that are:
        // 1. Not completed
        // 2. Due within the next two weeks, or overdue
        // 3. Either unassigned or associated with the dashboard goals
        const { data: tasks, error: tasksError } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .neq('status', 'completed') // Use correct enum value
          .or(`due_date.lte.${twoWeeksFromNow.toISOString()},due_date.is.null`)
          .order('due_date', { ascending: true, nullsFirst: false }) // Use 'due_date'
          .limit(taskLimit);
        if (tasksError) throw tasksError;

        // --- Fetch Active Tracked State Definitions ---
        const { data: trackedStateDefinitions, error: statesError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .eq('active', true)
          .order('sort_order', { ascending: true, nullsFirst: false }); // Correct: nullsFirst: false for nulls last
        if (statesError) throw statesError;
        
        // --- Fetch Latest State Entries for Active Definitions ---
        let latestEntriesMap: Record<string, { value: any; created_at: string }> = {};
        const stateDefIds = (trackedStateDefinitions || []).map(s => s.id);

        if (stateDefIds.length > 0) {
          // Use a CTE and ROW_NUMBER() to get the latest entry per state_id
          const { data: latestEntries, error: entriesError } = await ctx.supabaseAdmin.rpc(
            'get_latest_state_entries_for_user', 
            { p_user_id: ctx.userId, p_state_ids: stateDefIds }
          );

          if (entriesError) {
            console.error('Error fetching latest state entries:', entriesError);
            // Decide how to handle this - throw, or continue with empty/default values?
            // For now, log and continue, states will show default value
          } else {
            // Define expected type for entries from RPC
            type LatestEntry = { state_id: string; value: any; created_at: string };
            
            latestEntriesMap = (latestEntries as LatestEntry[] || []).reduce(
              (acc: Record<string, { value: any; created_at: string }>, entry: LatestEntry) => {
              acc[entry.state_id] = { value: entry.value, created_at: entry.created_at };
              return acc;
            }, {} as typeof latestEntriesMap);
          }
        }

        // --- Process Habits for 'completed' flag ---
        const todayStr = new Date().toISOString().split('T')[0];
        const habitIds = (habits || []).map(h => h.id);
        const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id') // Only need habit_id to check existence
          .eq('user_id', ctx.userId)
          .eq('date', todayStr) // Filter by date
          .in('habit_id', habitIds);
        if (todayEntriesError) throw todayEntriesError;

        const completedHabitIds = new Set((habitEntriesToday || []).map(e => e.habit_id));

        const formattedHabits = (habits || []).map(h => ({
          id: h.id,
          name: h.name, // Use name
          description: h.description, // Pass other potentially useful fields
          habit_type: h.habit_type,
          streak: h.streak,
          // Consider a habit completed if *any* entry exists for today
          completed: completedHabitIds.has(h.id)
        }));

        // --- Process Goals for 'progress' ---
        const goalIds = (goals || []).map(g => g.id);
        let tasksMap: Record<string, { total: number; completed: number }> = {};
        if (goalIds.length > 0) {
          const { data: allTasksForGoals, error: tasksError2 } = await ctx.supabaseAdmin
            .from('tasks')
            .select('goal_id, status')
            .eq('user_id', ctx.userId)
            .in('goal_id', goalIds);
          if (tasksError2) throw tasksError2;

          tasksMap = (allTasksForGoals || []).reduce<Record<string, { total: number; completed: number }>>((acc, task) => {
            if (task.goal_id) { // Ensure goal_id is not null
              const gid = task.goal_id;
              if (!acc[gid]) acc[gid] = { total: 0, completed: 0 };
              acc[gid].total++;
              if (task.status === 'completed') acc[gid].completed++;
            }
            return acc;
          }, {});
        }

        const formattedGoals = (goals || []).map((g) => {
          const { total = 0, completed: comp = 0 } = tasksMap[g.id] || {};
          // Calculate progress based on tasks, ignore goal.progress field for now
          const progress = total > 0 ? comp / total : 0;
          return {
            id: g.id,
            title: g.name, // Changed name to title to match frontend expectations
            status: g.status, // Pass status directly
            priority: g.priority, // Pass priority
            progress: Math.round(progress * 100) / 100, // Keep calculated progress
            tasks: { // Add tasks information expected by GoalSummaryCard
              total: total,
              completed: comp
            }
          };
        });

        // --- Format Tasks (Minimal formatting needed if TASK_FIELDS is correct) ---
        const formattedTasks = (tasks || []).map((t) => ({
          id: t.id,
          name: t.name,
          status: t.status,
          priority: t.priority,
          due_date: t.due_date, // Use due_date
          // Add other fields as needed by the dashboard UI
        }));

        // --- Format Tracked States with Latest Values ---
        const formattedTrackedStates = (trackedStateDefinitions || []).map((def) => {
          const latestEntry = latestEntriesMap[def.id];
          return {
            id: def.id,
            name: def.name,
            unit: def.unit, // Use 'unit' field
            currentValue: latestEntry ? latestEntry.value : null, // Default to null
            lastUpdated: latestEntry ? latestEntry.created_at : null,
          };
        });

        // Return formatted data including trackedStates
        return {
          habits: formattedHabits,
          goals: formattedGoals,
          tasks: tasks || [], // Ensure tasks is always an array
          trackedStates: formattedTrackedStates, // Use the newly formatted array
        };
      } catch (error: any) {
        console.error('Dashboard data fetch error:', error);
        
        // Handle specific error types with appropriate error codes
        if (error.code === '42P01') { // Table doesn't exist
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Database schema error',
          });
        }
        
        if (error.code === '23505') { // Unique violation
          throw new TRPCError({
            code: 'CONFLICT',
            message: 'Resource already exists',
          });
        }
        
        // Default error handling
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch dashboard data',
        });
      }
    }),
  
  getWeeklyProgress: protectedProcedure
    .input(z.object({
      daysToInclude: z.number().min(1).optional().default(7),
      includeRawData: z.boolean().optional().default(false),
    }).optional())
    .query(async ({ ctx, input }) => {
      try {
        // Calculate date range based on input or default to past week
        const daysToInclude = input?.daysToInclude || 7;
        const includeRawData = input?.includeRawData || false;
        
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(endDate.getDate() - (daysToInclude - 1));
        
        const todayStr = endDate.toISOString().split('T')[0];
        const startDateStr = startDate.toISOString().split('T')[0];
        
        // Generate array of all dates in the range for daily aggregation
        const dateRange: string[] = [];
        const tempDate = new Date(startDate);
        while (tempDate <= endDate) {
          dateRange.push(tempDate.toISOString().split('T')[0]);
          tempDate.setDate(tempDate.getDate() + 1);
        }
        
        // Fetch habits relevant to the date range (active during any part of the range)
        // Need to consider habits created *before* the end date and not archived *before* the start date
        const HABIT_FIELDS_FOR_PROGRESS = 'id, name, habit_type, frequency_type, frequency_details, created_at, streak, best_streak'; // Add streak fields
        const { data: relevantHabits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS_FOR_PROGRESS)
          .eq('user_id', ctx.userId)
          // Add logic here if needed to filter habits active within the date range
          // e.g., .lt('created_at', endDate.toISOString())
          //       .or(`archived_at.gte.${startDate.toISOString()},archived_at.is.null`)
          ;
        if (habitsError) throw habitsError;

        const relevantHabitIds = (relevantHabits || []).map(h => h.id);

        // Fetch habit entries within the date range for relevant habits
        const { data: habitEntries, error: entriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('id, habit_id, date, completed, quantity_value, notes')
          .eq('user_id', ctx.userId)
          .in('habit_id', relevantHabitIds.length > 0 ? relevantHabitIds : ['dummy-uuid']) // Filter by relevant habits
          .gte('date', startDate.toISOString().split('T')[0])
          .lte('date', endDate.toISOString().split('T')[0])
          .order('date', { ascending: true });
 
        if (entriesError) throw entriesError;

        // Get all tasks completed or due within the date range
        const { data: relevantTasks, error: tasksError } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .or(`due_date.gte.${startDateStr}.and.due_date.lte.${todayStr},status.eq.completed.and.updated_at.gte.${startDateStr}.and.updated_at.lte.${todayStr}`);

        if (tasksError) throw tasksError;
        
        // Get total tasks count for completion rate
        const { count: totalTasks, error: countError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', ctx.userId);
          
        if (countError) throw countError;
        
        // Get goal progress snapshots for the period
        const { data: goalSnapshots, error: goalSnapshotsError } = await ctx.supabaseAdmin
          .from('goal_progress_snapshots') // Assuming we have this table
          .select('goal_id, progress, created_at')
          .eq('user_id', ctx.userId)
          .gte('created_at', startDate.toISOString())
          .lte('created_at', endDate.toISOString())
          .order('created_at', { ascending: true });
          
        if (goalSnapshotsError) throw goalSnapshotsError;

        // -- AGGREGATE DATA BY DAY --
        
        // Create daily habit completion structure
        const habitsByDay: Record<string, { completed: number; total: number; entries: any[]; expected: number }> = {};
        dateRange.forEach(date => {
          habitsByDay[date] = { completed: 0, total: 0, entries: [], expected: 0 };
        });
        
        // Populate completed habits from entries (count existence, not completed flag)
        habitEntries?.forEach((entry: any) => {
          const dateStr = (entry.date as string).split('T')[0];
          if (habitsByDay[dateStr]) {
            // Only count one completion per habit per day
            if (!habitsByDay[dateStr].entries.some((e: any) => e.habit_id === entry.habit_id)) {
              habitsByDay[dateStr].completed++;
            }
            habitsByDay[dateStr].entries.push(entry);
          }
        });
        
        // Create daily task completion structure
        const tasksByDay: Record<string, { completed: number; entries: any[] }> = {};
        dateRange.forEach(date => {
          tasksByDay[date] = { completed: 0, entries: [] };
        });
        
        // Process completed tasks into daily stats
        relevantTasks?.forEach(task => {
          const completedDate = (task.updated_at as string).split('T')[0];
          if (tasksByDay[completedDate]) {
            tasksByDay[completedDate].completed++;
            tasksByDay[completedDate].entries.push(task);
          }
        });
        
        // Calculate expected habits per day based on frequency
        const isHabitExpected = (habit: any, date: string): boolean => {
          const dateObj = new Date(date + 'T00:00:00Z'); // Ensure UTC
          const dayOfWeek = dateObj.getUTCDay(); // 0 = Sunday, 6 = Saturday
          const dayOfMonth = dateObj.getUTCDate();
          const month = dateObj.getUTCMonth(); // 0 = January, 11 = December

          const habitCreatedDate = new Date(habit.created_at);
          if (dateObj < habitCreatedDate) {
            return false; // Cannot be expected before it was created
          }

          switch (habit.frequency_type) {
            case 'daily':
              return true;
            case 'specific_days':
              return Array.isArray(habit.frequency_details?.days) && habit.frequency_details.days.includes(dayOfWeek);
            // TODO: Add logic for 'weekly', 'monthly' etc. as needed
            default:
              return false;
          }
        };
        relevantHabits?.forEach(habit => {
          dateRange.forEach(date => {
            if (isHabitExpected(habit, date)) {
              habitsByDay[date].expected++;
            }
          });
        });
        
        // Format into daily progress reports
        const dailyProgress = dateRange.map(date => {
          const habitStats = habitsByDay[date];
          const taskStats = tasksByDay[date];
          
          const habitCompletionRate = habitStats.expected > 0 
            ? habitStats.completed / habitStats.expected 
            : 0;
            
          return {
            date,
            habits: {
              total: habitStats.total,
              completed: habitStats.completed,
              completionRate: habitCompletionRate,
              expected: habitStats.expected
            },
            tasks: {
              completed: taskStats.completed
            },
            // Optionally include raw entries if requested
            ...(includeRawData ? {
              habitEntries: habitStats.entries,
              completedTasks: taskStats.entries
            } : {})
          };
        });
        
        // Calculate overall metrics
        const totalHabitEntries = Object.values(habitsByDay).reduce(
          (sum, day) => sum + day.total, 0);
        const completedHabitEntries = Object.values(habitsByDay).reduce(
          (sum, day) => sum + day.completed, 0);
        const totalCompletedTasks = Object.values(tasksByDay).reduce(
          (sum, day) => sum + day.completed, 0);
          
        const taskCompletionRate = totalTasks ? totalCompletedTasks / totalTasks : 0;
        const habitConsistency = totalHabitEntries > 0 
          ? completedHabitEntries / totalHabitEntries 
          : 0;
          
        // Calculate habit streaks (could be moved to a separate helper function)
        const habitStreaks = (relevantHabits || []).map(habit => ({
          id: habit.id,
          name: habit.name,
          currentStreak: habit.streak || 0,
          bestStreak: habit.best_streak || 0
        }));
        
        // Prepare goal progress data
        const goalProgress: Record<string, { snapshots: any[]; startProgress?: number; endProgress?: number }> = {};
        
        (goalSnapshots || []).forEach(snapshot => {
          if (!goalProgress[snapshot.goal_id]) {
            goalProgress[snapshot.goal_id] = { snapshots: [] };
          }
          goalProgress[snapshot.goal_id].snapshots.push({
            progress: snapshot.progress,
            date: (snapshot.created_at as string).split('T')[0]
          });
        });
        
        // Calculate start and end progress for each goal
        Object.keys(goalProgress).forEach(goalId => {
          const snapshots = goalProgress[goalId].snapshots;
          if (snapshots.length > 0) {
            // Sort by date
            snapshots.sort((a, b) => a.date.localeCompare(b.date));
            goalProgress[goalId].startProgress = snapshots[0].progress;
            goalProgress[goalId].endProgress = snapshots[snapshots.length - 1].progress;
          }
        });
        
        return {
          dailyProgress,
          overallMetrics: {
            totalHabitEntries,
            completedHabitEntries,
            habitCompletionRate: habitConsistency,
            completedTasksCount: totalCompletedTasks,
            taskCompletionRate,
            // Trend indicators (compared to previous period)
            trends: {
              habitsImproving: true, // Placeholder - would compare to previous period
              tasksImproving: false // Placeholder - would compare to previous period
            }
          },
          habitStreaks,
          goalProgress: Object.entries(goalProgress).map(([goalId, data]) => ({
            goalId,
            progressChange: (data.endProgress || 0) - (data.startProgress || 0),
            currentProgress: data.endProgress || 0
          })),
          dateRange: {
            start: startDateStr,
            end: todayStr,
            days: dateRange
          }
        };
      } catch (error: any) {
        console.error('Weekly progress fetch error:', error);
        
        // Handle specific error types with appropriate error codes
        if (error.code === '42P01') { // Table doesn't exist
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Database schema error',
          });
        }
        
        if (error.code === '22P02') { // Invalid text representation
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Invalid input format',
          });
        }
        
        // Default error handling
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch weekly progress',
        });
      }
    }),
}); ```
\n\n## Router: habitRouter
**File:** server/src/routers/habitRouter.ts
\n```
import { z } from "zod";
import { router, protectedProcedure } from "../router";
import { TRPCError } from "@trpc/server";
import {
  createHabitInput,
  updateHabitInput,
  createHabitEntryInput,
  updateHabitEntryInput,
} from '../types/trpc-types';
import {
  differenceInCalendarDays,
  parseISO,
  format
} from 'date-fns'; // Need date-fns

const HABIT_FIELDS =
  'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, sort_order, streak, best_streak, created_at, updated_at';

const HABIT_ENTRY_FIELDS =
  'id, user_id, habit_id, date, completed, quantity_value, notes, created_at';

async function calculateAndUpdateStreak(habitId: string, userId: string, supabase: any): Promise<{ currentStreak: number, bestStreak: number }> {
  try {
    // Fetch all entries for the habit, ordered by date descending
    const { data: entries, error: entriesError } = await supabase
      .from('habit_entries')
      .select('date, completed') // Only need date and completed status
      .eq('habit_id', habitId)
      .eq('user_id', userId)
      .order('date', { ascending: false });

    if (entriesError) {
      console.error(`Streak Calc Error: Failed to fetch entries for habit ${habitId}:`, entriesError);
      return { currentStreak: 0, bestStreak: 0 }; // Return 0 if entries can't be fetched
    }

    if (!entries || entries.length === 0) {
      // No entries, reset streak
      const { error: updateErr } = await supabase
        .from('habits')
        .update({ streak: 0 })
        .eq('id', habitId);
      if (updateErr) console.error(`Streak Calc Error: Failed to reset streak for habit ${habitId}`, updateErr);
      // Fetch best streak to return it accurately even if current is 0
      const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
      return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 };
    }

    let currentStreak = 0;
    const today = new Date();
    let expectedDate = today; // Start checking from today
    const todayStr = format(today, 'yyyy-MM-dd');
    const todayEntry = entries.find((e: any) => e.date === todayStr);

    // Determine starting point for streak check
    if (todayEntry?.completed) {
      currentStreak = 1;
      expectedDate = new Date(today.setDate(today.getDate() - 1)); // Start checking from yesterday
    } else {
      const yesterday = new Date(); // Need a fresh date object
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayStr = format(yesterday, 'yyyy-MM-dd');
      const yesterdayEntry = entries.find((e: any) => e.date === yesterdayStr);
      if (yesterdayEntry?.completed) {
        currentStreak = 1;
        expectedDate = new Date(yesterday.setDate(yesterday.getDate() - 1)); // Start checking from day before yesterday
      } else {
        currentStreak = 0;
        // No need to loop if streak is already 0 based on today/yesterday
      }
    }

    // Only loop if there's a potential streak > 0
    if (currentStreak > 0) {
      // Find index of the entry *before* the expectedDate (since we check backwards)
      let startIndex = entries.findIndex((e: any) => e.date === format(expectedDate, 'yyyy-MM-dd'));
      // If expected date wasn't found (e.g., yesterday was the start), adjust index
      if (startIndex === -1) {
        // Start from the entry after the one that established the initial streak (today or yesterday)
        const initialStreakDateStr = todayEntry?.completed ? todayStr : (format(new Date(new Date().setDate(new Date().getDate() - 1)), 'yyyy-MM-dd'));
        const initialEntryIndex = entries.findIndex((e: any) => e.date === initialStreakDateStr);
        startIndex = initialEntryIndex !== -1 ? initialEntryIndex + 1 : 0;
      }

      for (let i = startIndex; i < entries.length; i++) {
        const entry = entries[i];
        const entryDate = parseISO(entry.date);
        const expectedDateStr = format(expectedDate, 'yyyy-MM-dd');

        if (entry.date === expectedDateStr) {
          if (entry.completed) {
            currentStreak++;
            expectedDate.setDate(expectedDate.getDate() - 1); // Move to check previous day
          } else {
            break; // Streak broken by uncompleted entry
          }
        } else {
          // Check if the date difference breaks the streak (allowing for gaps)
          const previousDate = i > 0 ? parseISO(entries[i - 1].date) : parseISO(entries[0].date);
          const dateDiff = differenceInCalendarDays(previousDate, entryDate);

          if (dateDiff > 1) {
            break; // Gap too large, streak broken
          }

          // If gap is 1 day, but this entry wasn't completed, streak is broken
          if (!entry.completed) {
            break;
          }

          // If gap is 1 day and completed, it doesn't continue the *current* consecutive sequence
          // but doesn't necessarily break it either (e.g., completed Mon, Wed - streak is 1 from Wed).
          // For simplicity, we break the loop here, assuming the *consecutive* streak from today/yesterday is what matters.
          // A more complex implementation could find the *longest* streak ending recently.
          break;
        }
      }
    }

    // Fetch current best_streak
    const { data: habitData, error: habitFetchError } = await supabase
      .from('habits')
      .select('best_streak')
      .eq('id', habitId)
      .single();

    if (habitFetchError) {
      console.error(`Streak Calc Error: Failed to fetch habit ${habitId} for best_streak:`, habitFetchError);
      // Fallback best streak if fetch fails
      const bestStreakFallback = Math.max(currentStreak, 0); 
      const { error: updateError } = await supabase
        .from('habits')
        .update({ streak: currentStreak, best_streak: bestStreakFallback })
        .eq('id', habitId);
      if (updateError) console.error(`Streak Calc Error: Failed to update streak (fallback) for habit ${habitId}:`, updateError);
      console.log(`Streak Updated (Fallback Best) for habit ${habitId}: Current=${currentStreak}, Best=${bestStreakFallback}`);
      return { currentStreak, bestStreak: bestStreakFallback };
    }

    const bestStreak = Math.max(currentStreak, habitData?.best_streak || 0);

    // Update the habit record
    const { error: updateError } = await supabase
      .from('habits')
      .update({ streak: currentStreak, best_streak: bestStreak })
      .eq('id', habitId);

    if (updateError) {
      console.error(`Streak Calc Error: Failed to update streak for habit ${habitId}:`, updateError);
    }

    console.log(`Streak Updated for habit ${habitId}: Current=${currentStreak}, Best=${bestStreak}`);
    return { currentStreak, bestStreak };

  } catch (error) {
    console.error(`Unexpected error calculating streak for habit ${habitId}:`, error);
    // Attempt to fetch best streak even on error
    const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
    return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 }; // Return 0 current streak on error
  }
}

export const habitRouter = router({
  getHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (habitsError) throw habitsError;
        if (!habits) return [];

        const todayStr = new Date().toISOString().split('T')[0];

        const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id')
          .eq('user_id', ctx.userId)
          .eq('date', todayStr)
          .in('habit_id', habits.map(h => h.id));

        if (todayEntriesError) throw todayEntriesError;

        const completedMap = (habitEntriesToday || []).reduce<Record<string, boolean>>((acc, entry) => {
          acc[entry.habit_id] = true;
          return acc;
        }, {});

        const formattedHabits = habits.map(h => ({
          ...h,
          completedToday: !!completedMap[h.id]
        }));

        return formattedHabits;
      } catch (error: any) {
        throw new TRPCError({ 
          code: 'INTERNAL_SERVER_ERROR', 
          message: error.message || 'Failed to fetch habits'
        });
      }
    }),

  getHabitById: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .select(HABIT_FIELDS)
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (error) throw new TRPCError({ 
        code: error.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: error.message 
      });
      return data;
    }),

  createHabit: protectedProcedure
    .input(createHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .insert({
          ...input,
          user_id: ctx.userId,
          streak: 0,
          best_streak: 0
        })
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  updateHabit: protectedProcedure
    .input(updateHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { id, ...updateData } = input;

      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .update(updateData)
        .eq("id", id)
        .eq('user_id', ctx.userId)
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  deleteHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { error } = await ctx.supabaseAdmin
        .from("habits")
        .delete()
        .eq("id", input.id);

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return { id: input.id };
    }),

  listArchivedHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        return habits || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived habits',
        });
      }
    }),

  archiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to archive habit' });
      }
    }),

  unarchiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to unarchive habit' });
      }
    }),

  getHabitEntries: protectedProcedure
    .input(z.object({
      habitId: z.string().uuid(),
      startDate: z.string().optional(), 
      endDate: z.string().optional(),   
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { error: habitError } = await ctx.supabaseAdmin
          .from("habits")
          .select("id")
          .eq("id", input.habitId)
          .eq("user_id", ctx.userId)
          .single();

        if (habitError) {
          if (habitError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: habitError.message });
        }

        let query = ctx.supabaseAdmin
          .from('habit_entries')
          .select(HABIT_ENTRY_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('habit_id', input.habitId);

        if (input.startDate) query = query.gte('date', input.startDate);
        if (input.endDate) query = query.lte('date', input.endDate);

        const { data, error: entriesError } = await query.order('date', { ascending: false });

        if (entriesError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: entriesError.message });
        return data || [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to fetch habit entries' });
      }
    }),

  getHabitEntriesForHabit: protectedProcedure
    .input(z.object({ habitId: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      // TODO: Implement logic to fetch habit entries for a specific habit
      console.log(`Fetching entries for habit: ${input.habitId}, user: ${ctx.userId}`);
      // Example fetch:
      // const { data, error } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select(HABIT_ENTRY_FIELDS)
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .order('date', { ascending: false });
      // if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      // return data || [];
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),

  createHabitEntry: protectedProcedure
    .input(createHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .insert({ ...input, user_id: ctx.userId })
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });

        // Update streak after successful insert
        if (data) {
          await calculateAndUpdateStreak(input.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create habit entry',
        });
      }
    }),

  updateHabitEntry: protectedProcedure
    .input(updateHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: habitEntry, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) throw new TRPCError({ 
          code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
          message: "Habit entry not found or access denied" 
        });

        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId) // Ensure ownership
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });

        // Update streak after successful update
        if (data) {
          await calculateAndUpdateStreak(data.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update habit entry',
        });
      }
    }),

  deleteHabitEntry: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Fetch habitId *before* deleting the entry
        const { data: entryToDelete, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id') // Fetch habit_id
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !entryToDelete) {
          throw new TRPCError({ 
            code: fetchError?.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Habit entry not found or access denied.' 
          });
        }

        const { habit_id: habitIdForStreak } = entryToDelete; // Store before delete

        // Perform delete
        const { error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId); // Ensure user owns the entry being deleted

        if (error) throw error; // Throw if delete fails

        // Update streak *after* successful delete
        if (habitIdForStreak) { // Check if we got the habitId
          await calculateAndUpdateStreak(habitIdForStreak, ctx.userId, ctx.supabaseAdmin);
        }

        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete habit entry',
        });
      }
    }),

  toggleHabitEntry: protectedProcedure
    .input(z.object({ habitId: z.string().uuid(), date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/) }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Implement logic to find if entry exists for habitId/date/userId.
      // If exists, delete it.
      // If not exists, create it (need default values for boolean/quantity type).
      // Call calculateAndUpdateStreak after create/delete.
      console.log(`Toggling habit entry for habit: ${input.habitId}, date: ${input.date}`);
      // Example logic:
      // const { data: existingEntry, error: findError } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select('id')
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .eq('date', input.date)
      //   .maybeSingle();
      // if (findError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: findError.message });

      // if (existingEntry) {
      //   // Delete existing
      //   const { error: deleteError } = await ctx.supabaseAdmin.from('habit_entries').delete().eq('id', existingEntry.id);
      //   if (deleteError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: deleteError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'deleted', habitId: input.habitId, date: input.date };
      // } else {
      //   // Create new
      //   // Need to know habit type to set default 'completed' or 'quantity_value'
      //   const { data: newEntry, error: createError } = await ctx.supabaseAdmin
      //     .from('habit_entries')
      //     .insert({ habit_id: input.habitId, user_id: ctx.userId, date: input.date, completed: true /* or quantity_value: default */ })
      //     .select(HABIT_ENTRY_FIELDS)
      //     .single();
      //   if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'created', entry: newEntry };
      // }
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),
});```
\n\n## Router: reminderRouter
**File:** server/src/routers/reminderRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createReminderInput,
  updateReminderInput,
  GetRemindersForEntityInput,
  DeleteReminderInput,
} from '../types/trpc-types';

// Define fields for consistent selection
const REMINDER_FIELDS = 'id, user_id, related_entity_type, related_entity_id, reminder_time, message, is_active, created_at, updated_at';

export const reminderRouter = router({
  // Get all active reminders for the user (might need refinement later)
  getActiveReminders: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('is_active', true)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch active reminders',
        });
      }
    }),

  // Get reminders linked to a specific entity
  getRemindersForEntity: protectedProcedure
    .input(GetRemindersForEntityInput)
    .query(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('related_entity_type', input.related_entity_type)
          .eq('related_entity_id', input.related_entity_id)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch reminders for entity',
        });
      }
    }),

  createReminder: protectedProcedure
    .input(createReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // TODO: Potentially validate that related_entity_id exists and belongs to user?
        // This requires knowing the related_entity_type and querying the correct table.
        // For now, assume valid input.
        const { data: reminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return reminder;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create reminder',
        });
      }
    }),

  updateReminder: protectedProcedure
    .input(updateReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { data: updatedReminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return updatedReminder;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update reminder',
        });
      }
    }),

  deleteReminder: protectedProcedure
    .input(DeleteReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('reminders')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete reminder',
        });
      }
    }),
});
```
\n\n## Router: principleRouter
**File:** server/src/routers/principleRouter.ts
\n```
// server/src/routers/principleRouter.ts
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createPrincipleInput, updatePrincipleInput } from '../types/trpc-types'; // These now expect 'title' and 'body'

// Define fields for consistent selection, using 'title' and 'body'
const PRINCIPLE_FIELDS = 'id, user_id, title, body, sort_order, created_at, updated_at';

export const principleRouter = router({
  getPrinciples: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: principles, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principles || []; // Return empty array if null
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principles',
        });
      }
    }),

  getPrincipleById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) {
           if (error.code === 'PGRST116') { // Handle not found specifically
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found' });
           }
           throw error; // Rethrow other errors
        }
        // No need for !principle check if .single() is used and error isn't PGRST116

        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principle',
        });
      }
    }),

  createPrinciple: protectedProcedure
    .input(createPrincipleInput) // This Zod schema now expects 'title' and 'body'
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .insert({
            ...input, // Spread validated input, already contains 'title' and 'body'
            user_id: ctx.userId,
          })
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create principle',
        });
      }
    }),

  updatePrinciple: protectedProcedure
    .input(updatePrincipleInput) // This Zod schema now expects 'title' and 'body' (optional)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
           if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to update it' });
           }
           throw fetchError;
        }

        // Update
        const { data: updatedPrinciple, error } = await ctx.supabaseAdmin
          .from('principles')
          .update(updateData) // updateData contains validated 'title'/'body' if provided
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return updatedPrinciple;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update principle',
        });
      }
    }),

  deletePrinciple: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
            if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to delete it' });
           }
           throw fetchError;
        }

        // Delete
        const { error } = await ctx.supabaseAdmin
          .from('principles')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete principle',
        });
      }
    }),
});```
\n\n## Router: rewardsRouter
**File:** server/src/routers/rewardsRouter.ts
\n```
import { TRPCError } from '@trpc/server';
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { supabaseAdmin } from '../context';

// Corrected relative path
import { claimLootInput, awardBadgeInput } from '../types/trpc-types';

export const rewardsRouter = router({
  // Get all rewards for current user
  getUserRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Select specific fields aligned with our Zod types
        const { data: rewards, error } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('id, user_id, reward_id, earned_at, rewards(id, name, description, emoji, image_url, required_points, type)')
          .eq('user_id', ctx.userId)
          .order('earned_at', { ascending: false });

        if (error) throw error;
        return rewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user rewards',
        });
      }
    }),

  // Get available rewards that can be earned
  getAvailableRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Get all rewards with specific fields
        const { data: allRewards, error: rewardsError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('id, name, description, emoji, image_url, required_points, type, can_earn_multiple')
          .order('required_points', { ascending: true });

        if (rewardsError) throw rewardsError;

        // Get already earned rewards
        const { data: earnedRewards, error: earnedError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('reward_id')
          .eq('user_id', ctx.userId);

        if (earnedError) throw earnedError;

        // Filter out already earned one-time rewards
        const earnedIds = new Set((earnedRewards || []).map(er => er.reward_id));
        const availableRewards = allRewards?.filter(reward => 
          !earnedIds.has(reward.id) || reward.can_earn_multiple);

        return availableRewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch available rewards',
        });
      }
    }),

  // Get user points
  getUserPoints: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: userProfile, error } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (error) throw error;
        return {
          points: userProfile?.points || 0,
          lifetimePoints: userProfile?.lifetime_points || 0,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user points',
        });
      }
    }),

  // Earn a reward if eligible
  earnReward: protectedProcedure
    .input(claimLootInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get the reward details
        const { data: reward, error: rewardError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.rewardId)
          .single();

        if (rewardError || !reward) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Reward not found',
          });
        }

        // Check if user has enough points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        if (userProfile.points < reward.required_points) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Not enough points to earn this reward',
          });
        }

        // If the reward is one-time, check if already earned
        if (!reward.can_earn_multiple) {
          const { data: existingReward, error: existingError } = await ctx.supabaseAdmin
            .from('user_rewards')
            .select('id')
            .eq('user_id', ctx.userId)
            .eq('reward_id', input.rewardId)
            .single();

          if (existingReward) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'You have already earned this one-time reward',
            });
          }
        }

        // Begin transaction
        // 1. Deduct points from user
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: userProfile.points - reward.required_points,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // 2. Add reward to user's earned rewards
        const { data: userReward, error: insertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.rewardId,
            earned_at: new Date().toISOString(),
            points_spent: reward.required_points,
          })
          .select()
          .single();

        if (insertError) {
          // Rollback points if adding reward failed
          await ctx.supabaseAdmin
            .from('profiles')
            .update({
              points: userProfile.points,
            })
            .eq('id', ctx.userId);

          throw insertError;
        }

        return {
          success: true,
          reward: userReward,
          remainingPoints: userProfile.points - reward.required_points,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to earn reward',
        });
      }
    }),

  // Award points to user (e.g., for completing habits, tasks)
  awardPoints: protectedProcedure
    .input(awardBadgeInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get current user points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        // Get badge details
        const { data: badge, error: badgeError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.badgeId)
          .eq('type', 'badge')
          .single();

        if (badgeError || !badge) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Badge not found',
          });
        }

        // Default points to award
        const pointsToAward = 10;
        const currentPoints = userProfile.points || 0;
        const lifetimePoints = userProfile.lifetime_points || 0;
        const newPoints = currentPoints + pointsToAward;
        const newLifetimePoints = lifetimePoints + pointsToAward;

        // Update user points
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: newPoints,
            lifetime_points: newLifetimePoints,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // Record the point transaction
        const { data: pointTransaction, error: transactionError } = await ctx.supabaseAdmin
          .from('point_transactions')
          .insert({
            user_id: ctx.userId,
            points: pointsToAward,
            reason: `Earned badge: ${badge.name}`,
            source_type: 'badge',
            source_id: input.badgeId,
          })
          .select()
          .single();

        if (transactionError) throw transactionError;

        // Add badge to user's earned rewards
        const { data: userBadge, error: badgeInsertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.badgeId,
            reward_type: 'badge',
            earned_at: new Date().toISOString(),
            points_spent: 0, // Badges don't cost points
          })
          .select()
          .single();

        if (badgeInsertError) throw badgeInsertError;

        return {
          success: true,
          previousPoints: currentPoints,
          newPoints,
          pointsAdded: pointsToAward,
          transaction: pointTransaction,
          badge: userBadge,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to award badge',
        });
      }
    }),

  // Get point transaction history
  getPointHistory: protectedProcedure
    .input(z.object({
      limit: z.number().optional().default(20),
      cursor: z.string().optional(), // for pagination
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('point_transactions')
          .select('*')
          .eq('user_id', ctx.userId)
          .order('created_at', { ascending: false })
          .limit(input.limit);
          
        // Handle cursor-based pagination
        if (input.cursor) {
          query = query.lt('created_at', input.cursor);
        }
        
        const { data: transactions, error } = await query;

        if (error) throw error;
        
        // Determine if there are more results
        const lastItem = transactions && transactions.length > 0 
          ? transactions[transactions.length - 1] 
          : null;
          
        return {
          items: transactions || [],
          nextCursor: lastItem?.created_at,
          hasMore: (transactions?.length || 0) === input.limit,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch point history',
        });
      }
    }),
}); ```
\n\n## Router: taskRouter
**File:** server/src/routers/taskRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createTaskInput,
  updateTaskInput,
  updateTaskStatusInput,
  TaskStatusEnum, // Import the enum
  TaskPriorityEnum,
} from '../types/trpc-types';

// Define fields for selection consistency
const TASK_FIELDS =
  'id, user_id, title, notes, status, priority, due_date, goal_id, parent_task_id, recurrence_rule, recurrence_end_date, archived_at, sort_order, created_at, updated_at'; // Corrected: 'priority' instead of 'priority_enum' if that's the actual column name after migration
const GOAL_FIELDS = 'id, user_id, title, description, progress, target_date, archived_at, sort_order, created_at, updated_at';


// --- Helper function to update goal progress ---
async function updateGoalProgress(goalId: string, userId: string, supabase: any) {
  try {
    // 1. Fetch all non-archived tasks for the goal
    const { data: tasks, error: tasksError } = await supabase
      .from('tasks')
      .select('id, status') // Only need id and status
      .eq('goal_id', goalId)
      .eq('user_id', userId)
      .is('archived_at', null); // Exclude archived tasks

    if (tasksError) {
      console.error(`Error fetching tasks for goal ${goalId} during progress update:`, tasksError);
      // Decide how to handle this - maybe just log and skip update?
      return; // Exit if tasks can't be fetched
    }

    const totalTasks = tasks?.length || 0;
    const completedTasks = tasks?.filter((t: { status: string }) => t.status === TaskStatusEnum.enum.done).length || 0;

    // 2. Calculate progress (avoid division by zero)
    const newProgress = totalTasks > 0 ? completedTasks / totalTasks : 0;
    // Ensure progress is between 0 and 1, rounded to avoid floating point issues
    const clampedProgress = Math.round(Math.min(1, Math.max(0, newProgress)) * 100) / 100;

    // 3. Update the goal record
    const { error: updateError } = await supabase
      .from('goals')
      .update({ progress: clampedProgress })
      .eq('id', goalId)
      .eq('user_id', userId); // Ensure user owns the goal

    if (updateError) {
      console.error(`Error updating progress for goal ${goalId}:`, updateError);
      // Log error but don't necessarily throw, task toggle was successful
    } else {
        console.log(`Updated progress for goal ${goalId} to ${clampedProgress}`);
    }

  } catch (err) {
    console.error(`Unexpected error during goal progress update for goal ${goalId}:`, err);
    // Log unexpected errors
  }
}

export const taskRouter = router({
  getTasks: protectedProcedure // Gets non-archived tasks
    .input(z.object({
      goalId: z.string().uuid().optional(),
      // TODO: Add filters for status, priority, dates etc.?
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null); // Filter out archived

        if (input.goalId) {
          query = query.eq('goal_id', input.goalId);
        }

        // TODO: Add complex priority enum sorting? (e.g. high > medium > low)
        const { data: tasks, error } = await query
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('due_date', { ascending: true, nullsFirst: false }) // Order by due date (nulls last)
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tasks',
        });
      }
    }),

  getTaskById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(), // Use uuid validation
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!task) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found',
          });
        }

        // TODO: Parse with Task schema?
        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch task',
        });
      }
    }),

  createTask: protectedProcedure
    .input(createTaskInput) // Use imported input type
    .mutation(async ({ ctx, input }) => {
      try {
        // Verify goal_id if provided
        if (input.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', input.goal_id)
            .eq('user_id', ctx.userId) // Ensure goal belongs to user
            .is('archived_at', null) // Ensure goal is not archived
            .single();

          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived goal ID',
            });
          }
        }

        // Verify parent_task_id if provided
        if (input.parent_task_id) {
          const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
            .from('tasks')
            .select('id')
            .eq('id', input.parent_task_id)
            .eq('user_id', ctx.userId) // Ensure parent belongs to user
            .is('archived_at', null) // Ensure parent is not archived
            .single();

          if (parentError || !parentTask) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived parent task ID',
            });
          }
        }

        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .insert({
            ...input, // Spread validated input (includes new fields like parent_task_id, recurrence etc)
            user_id: ctx.userId,
            // Ensure due_date is used if present in input
            due_date: input.due_date ?? null, // Use correct field name
          })
          .select(TASK_FIELDS)
          .single();

        if (error) {
           // Handle specific errors like FK violations?
           console.error("Create task error:", error);
           throw error;
        }
        // TODO: Parse with Task schema?
        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create task',
        });
      }
    }),

  updateTask: protectedProcedure
    .input(updateTaskInput) // Use imported input type
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input; // Separate id from update payload

        // Check ownership
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id, parent_task_id') // Select parent_task_id for cycle check
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to update it',
          });
        }

        // Verify goal_id if being updated
        if (updateData.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', updateData.goal_id)
            .eq('user_id', ctx.userId)
            .is('archived_at', null)
            .single();

          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived goal ID',
            });
          }
        }
        // Handle setting goal_id to null
        if (updateData.goal_id === null) {
          updateData.goal_id = null;
        }

        // Verify parent_task_id if being updated
        if (updateData.parent_task_id) {
           // Basic cycle check
           if (updateData.parent_task_id === id) {
             throw new TRPCError({
               code: 'BAD_REQUEST',
               message: 'Task cannot be its own parent',
             });
           }
          const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
            .from('tasks')
            .select('id')
            .eq('id', updateData.parent_task_id)
            .eq('user_id', ctx.userId)
            .is('archived_at', null)
            .single();

          if (parentError || !parentTask) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived parent task ID',
            });
          }
          // TODO: Add deeper cycle detection if needed (check if new parent is a descendant)
        }
         // Handle setting parent_task_id to null
        if (updateData.parent_task_id === null) {
          updateData.parent_task_id = null;
        }

        // Ensure correct field name for due date if provided
        const payload: Record<string, any> = { ...updateData };
        if ('due_date' in payload) {
          payload.due_date = payload.due_date ?? null;
        }

        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update(payload) // Pass validated update data
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
             // Handle specific errors like FK violations?
           console.error("Update task error:", error);
           throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update task',
        });
      }
    }),

  deleteTask: protectedProcedure
    .input(z.object({
      id: z.string().uuid(), // Use uuid validation
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to delete it',
          });
        }

        // Delete the task (consider implications for subtasks - maybe archive instead?)
        // For now, direct delete.
        const { error } = await ctx.supabaseAdmin
          .from('tasks')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete task',
        });
      }
    }),

  // ---- Archive/Unarchive ----
  listArchivedTasks: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: tasks, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null) // Filter for archived tasks
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived tasks',
        });
      }
    }),

  archiveTask: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Consider archiving subtasks recursively?
      try {
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Task not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive task',
        });
      }
    }),

  unarchiveTask: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
       // TODO: Consider check if parent is archived?
      try {
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Task not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive task',
        });
      }
    }),

  // ---- Status Update ----
  updateTaskStatus: protectedProcedure
    .input(updateTaskStatusInput) // Uses { id: string().uuid(), status: TaskStatusEnum }
    .mutation(async ({ ctx, input }) => {
       try {
         // Check ownership first
         const { data: existing, error: fetchErr } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

         if (fetchErr || !existing) {
           throw new TRPCError({ code: 'NOT_FOUND', message: 'Task not found or permission denied.' });
         }

         // Perform update
         const { data: updatedTask, error: updateErr } = await ctx.supabaseAdmin
           .from('tasks')
           .update({ status: input.status })
           .eq('id', input.id)
           .select(TASK_FIELDS)
           .single();

         if (updateErr) throw updateErr;
         // TODO: Parse with Task schema?
         return updatedTask;
       } catch (error: any) {
         if (error instanceof TRPCError) throw error;
         throw new TRPCError({
           code: 'INTERNAL_SERVER_ERROR',
           message: error.message || 'Failed to update task status',
         });
       }
    }),

  // ---- Refactored Stubs ----
  listToday: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const todayStart = new Date();
        todayStart.setHours(0, 0, 0, 0);
        const todayEnd = new Date();
        todayEnd.setHours(23, 59, 59, 999);

        const { data: tasks, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .gte('due_date', todayStart.toISOString())
          .lte('due_date', todayEnd.toISOString())
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('due_date', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list tasks for today' });
      }
    }),

  listUpcoming: protectedProcedure
    .query(async ({ ctx }) => {
       try {
         const tomorrowStart = new Date();
         tomorrowStart.setDate(tomorrowStart.getDate() + 1);
         tomorrowStart.setHours(0, 0, 0, 0);

         const { data: tasks, error } = await ctx.supabaseAdmin
           .from('tasks')
           .select(TASK_FIELDS)
           .eq('user_id', ctx.userId)
           .is('archived_at', null)
           .gte('due_date', tomorrowStart.toISOString()) // Due date is tomorrow or later
           .order('due_date', { ascending: true, nullsFirst: false })
           .order('sort_order', { ascending: true, nullsFirst: false })
           .order('created_at', { ascending: false });

         if (error) throw error;
         // TODO: Parse with Task schema?
         return tasks || [];
       } catch (error: any) {
         throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list upcoming tasks' });
       }
    }),

 listOverdue: protectedProcedure
    .query(async ({ ctx }) => {
       try {
         const todayStart = new Date();
         todayStart.setHours(0, 0, 0, 0);

         const { data: tasks, error } = await ctx.supabaseAdmin
           .from('tasks')
           .select(TASK_FIELDS)
           .eq('user_id', ctx.userId)
           .is('archived_at', null)
           .lt('due_date', todayStart.toISOString()) // Due date is before today
           .not('status', 'in', `('${TaskStatusEnum.enum.done}')`) // Exclude completed tasks
           .order('due_date', { ascending: true, nullsFirst: false })
           .order('sort_order', { ascending: true, nullsFirst: false })
           .order('created_at', { ascending: false });

         if (error) throw error;
         // TODO: Parse with Task schema?
         return tasks || [];
       } catch (error: any) {
         throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list overdue tasks' });
       }
    }),

  toggleTask: protectedProcedure // Toggles between 'todo' and 'done'
    .input(z.object({
      taskId: z.string().uuid(),
      completed: z.boolean().optional() // Optional for backward compatibility
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // 1. Fetch the current task, including goal_id
        const { data: currentTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id, status, goal_id, title') // <-- Include goal_id and title
          .eq('id', input.taskId)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !currentTask) {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Task not found or permission denied.' });
        }

        // 2. Determine the new status
        let newStatus;
        if (input.completed !== undefined) {
          // If completed was explicitly provided, use it
          newStatus = input.completed ? TaskStatusEnum.enum.done : TaskStatusEnum.enum.todo;
        } else {
          // Otherwise toggle the current status
          newStatus = currentTask.status === TaskStatusEnum.enum.done
            ? TaskStatusEnum.enum.todo
            : TaskStatusEnum.enum.done;
        }

        // 3. Update the task status
        const { data: updatedTask, error: updateError } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ status: newStatus })
          .eq('id', input.taskId)
          .select(TASK_FIELDS) // Return the full updated task
          .single();

        if (updateError) throw updateError;

        // 4. *** NEW: Update goal progress if applicable ***
        if (currentTask.goal_id) {
           // Call the helper function asynchronously - no need to await here
           // unless the UI needs the updated goal immediately (unlikely for a toggle)
          updateGoalProgress(currentTask.goal_id, ctx.userId, ctx.supabaseAdmin);
        }

        // 5. Return the updated task
        return updatedTask;

      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        console.error("Error in toggleTask:", error); // Log unexpected errors
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to toggle task status',
        });
      }
    }),

  // --- Obsolete Stubs (keep or remove based on client usage) ---
  /*
  getTasksByGoal: protectedProcedure ... // Covered by getTasks with goalId filter
  getTodaysTasks: protectedProcedure ... // Replaced by listToday
  getUpcomingTasks: protectedProcedure ... // Replaced by listUpcoming
  updateTaskStatus_OLD: protectedProcedure ... // Replaced by updateTaskStatus and toggleTask
  */

});```
\n\n## Router: valueRouter
**File:** server/src/routers/valueRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createValueInput, updateValueInput } from '../types/trpc-types';

export const valueRouter = router({
  getValues: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: values, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return values;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch values',
        });
      }
    }),

  getValueById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!value) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found',
          });
        }

        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch value',
        });
      }
    }),

  createValue: protectedProcedure
    .input(createValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create value',
        });
      }
    }),

  updateValue: protectedProcedure
    .input(updateValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // First check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to update it',
          });
        }

        // Update the value
        const { data: updatedValue, error } = await ctx.supabaseAdmin
          .from('values')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return updatedValue;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update value',
        });
      }
    }),

  deleteValue: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to delete it',
          });
        }

        // Delete the value
        const { error } = await ctx.supabaseAdmin
          .from('values')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete value',
        });
      }
    }),
});```
\n\n## Router: goalRouter
**File:** server/src/routers/goalRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createGoalInput, updateGoalInput } from '../types/trpc-types';

const GOAL_FIELDS = 'id, user_id, title, description, progress, target_date, archived_at, sort_order, created_at, updated_at';

export const goalRouter = router({
  getGoals: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;

        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals',
        });
      }
    }),

  getGoalById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!goal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found',
          });
        }

        return goal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal',
        });
      }
    }),

  createGoal: protectedProcedure
    .input(createGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return goal;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal',
        });
      }
    }),

  updateGoal: protectedProcedure
    .input(updateGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to update it',
          });
        }

        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal',
        });
      }
    }),

  deleteGoal: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to delete it',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goals')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal',
        });
      }
    }),

  listActive: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals (in listActive stub)',
        });
      }
    }),

  listArchived: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived goals',
        });
      }
    }),

  archiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') { 
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive goal',
        });
      }
    }),

  unarchiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive goal',
        });
      }
    }),
});```
\n\n## Router: goalProgressNoteRouter
**File:** server/src/routers/goalProgressNoteRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createGoalProgressNoteInput,
  updateGoalProgressNoteInput,
  GetGoalProgressNotesInput,
  DeleteGoalProgressNoteInput,
} from '../types/trpc-types';

// Define fields for consistent selection
const GOAL_PROGRESS_NOTE_FIELDS = 'id, goal_id, user_id, note, created_at';

export const goalProgressNoteRouter = router({
  // Get all notes for a specific goal
  getNotesForGoal: protectedProcedure
    .input(GetGoalProgressNotesInput)
    .query(async ({ ctx, input }) => {
      try {
        // First, ensure the goal exists and belongs to the user
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        // Fetch the notes for that goal
        const { data, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .eq('user_id', ctx.userId) // Redundant check, but good practice
          .eq('goal_id', input.goal_id)
          .order('created_at', { ascending: false }); // Newest first

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal progress notes',
        });
      }
    }),

  createNote: protectedProcedure
    .input(createGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Ensure the goal exists and belongs to the user before adding a note
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        const { data: note, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return note;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal progress note',
        });
      }
    }),

  updateNote: protectedProcedure
    .input(updateGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership of the note
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { data: updatedNote, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return updatedNote;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal progress note',
        });
      }
    }),

  deleteNote: protectedProcedure
    .input(DeleteGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal progress note',
        });
      }
    }),
});
```
\n\n## Router: trackedStateRouter
**File:** server/src/routers/trackedStateRouter.ts
\n```
// File: server/src/routers/trackedStateRouter.ts

import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  // Ensure all necessary input types from trpc-types are imported
  createTrackedStateDefInput,
  updateTrackedStateDefInput,
  GetTrackedStateDefByIdInput,
  DeleteTrackedStateDefInput,
  CreateStateEntryInput,      // <--- Import for createEntry
  updateStateEntryInput,      // <--- Import for updateEntry
  GetStateEntriesInput,       // <--- Import for getEntries
  DeleteStateEntryInput       // <--- Import for deleteEntry
} from '../types/trpc-types';

// Use correct field names from database.types.ts & trpc-types.ts
const TRACKED_STATE_DEF_FIELDS = 'id, user_id, name, description, scale, custom_labels, unit, icon, target_min_value, target_max_value, created_at, updated_at, active, priority';
const STATE_ENTRY_FIELDS = 'id, user_id, definition_id, value_numeric, value_text, entry_timestamp, notes';

export const trackedStateRouter = router({
  getDefinitions: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('active', true)
          .order('priority', { ascending: true, nullsFirst: false }) // Corrected: nullsFirst
          .order('created_at', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tracked state definitions',
        });
      }
    }),

  getDefinitionById: protectedProcedure
    .input(GetTrackedStateDefByIdInput) // Use correct Zod schema
    .query(async ({ ctx, input }) => {
       try {
        const { data: definition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS)
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Tracked state definition not found.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return definition;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tracked state definition',
        });
      }
    }),

  createDefinition: protectedProcedure
    .input(createTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { data: definition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .insert({
            ...input, // input is now correctly typed
            user_id: ctx.userId,
          })
          .select(TRACKED_STATE_DEF_FIELDS)
          .single();

        if (error) throw error;
        return definition;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create tracked state definition',
        });
      }
    }),

  updateDefinition: protectedProcedure
    .input(updateTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { id, ...updateData } = input; // input is now correctly typed

        const { error: fetchError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Definition not found or access denied.',
          });
        }

        const { data: updatedDefinition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(TRACKED_STATE_DEF_FIELDS)
          .single();

        if (error) throw error;
        return updatedDefinition;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update tracked state definition',
        });
      }
    }),

  deleteDefinition: protectedProcedure
    .input(DeleteTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Definition not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .delete()
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id }; // input.id is now correctly typed
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete tracked state definition',
        });
      }
    }),

  // --- State Entry Procedures ---

  getEntries: protectedProcedure
    .input(GetStateEntriesInput) // <<<--- ADDED .input() BINDING
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('state_entries')
          .select(STATE_ENTRY_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('definition_id', input.tracked_state_def_id); // input is now typed

        if (input.startDate) { // input is now typed
          query = query.gte('entry_timestamp', input.startDate);
        }
        if (input.endDate) { // input is now typed
          query = query.lte('entry_timestamp', input.endDate);
        }

        query = query.order('entry_timestamp', { ascending: false });

        if (input.limit) { // input is now typed
          query = query.limit(input.limit);
        }

        const { data: entries, error } = await query;

        if (error) throw error;
        return entries ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch state entries',
        });
      }
    }),

  createEntry: protectedProcedure
    .input(CreateStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
      try {
        // Check definition ownership (already implemented correctly)
        const { error: defError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', input.tracked_state_def_id) // input is now typed
          .eq('user_id', ctx.userId)
          .single();

        if (defError) {
          throw new TRPCError({
            code: defError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Tracked state definition not found or invalid.',
          });
        }

        // Insert typed data
        const { data: entry, error } = await ctx.supabaseAdmin
          .from('state_entries')
          .insert({
            user_id: ctx.userId,
            definition_id: input.tracked_state_def_id, // input is now typed
            value_numeric: input.value_numeric,     // input is now typed
            value_text: input.value_text,         // input is now typed
            entry_timestamp: input.entry_timestamp || new Date().toISOString(), // input is now typed
            notes: input.notes,                 // input is now typed
          })
          .select(STATE_ENTRY_FIELDS)
          .single();

        if (error) throw error;
        return entry;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create state entry',
        });
      }
    }),

  updateEntry: protectedProcedure
    .input(updateStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input; // input is now typed

        // Check ownership (already implemented correctly)
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('state_entries')
          .select('id')
          .eq('id', id) // Use id from destructured input
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Entry not found or access denied.',
          });
        }

        // updateData is now correctly typed from the input schema
        const { data: updatedEntry, error } = await ctx.supabaseAdmin
          .from('state_entries')
          .update(updateData)
          .eq('id', id) // Use id from destructured input
          .eq('user_id', ctx.userId)
          .select(STATE_ENTRY_FIELDS)
          .single();

        if (error) throw error;
        return updatedEntry;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update state entry',
        });
      }
    }),

  deleteEntry: protectedProcedure
    .input(DeleteStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
       try {
        // Check ownership (already implemented correctly)
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('state_entries')
          .select('id')
          .eq('id', input.id) // input is now typed
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Entry not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('state_entries')
          .delete()
          .eq('id', input.id) // input is now typed
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id }; // input is now typed
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete state entry',
        });
      }
    }),
});```
\n\n## Router: userRouter
**File:** server/src/routers/userRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure, publicProcedure } from '../router';
import { TRPCError } from '@trpc/server';

export const userRouter = router({
  getProfile: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('id, username, avatar_url, full_name, bio, time_zone, onboarding_completed, created_at, updated_at')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  updateProfile: protectedProcedure
    .input(z.object({
      full_name: z.string().optional(),
      avatar_url: z.string().optional(),
      theme: z.string().optional(),
      time_zone: z.string().optional(),
      display_name: z.string().optional(),
      bio: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update(input)
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getUserSettings: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('id, user_id, notification_preferences, ui_preferences')
        .eq('user_id', ctx.userId)
        .single();
        
      if (error) {
        // If settings don't exist, create default settings
        if (error.code === 'PGRST116') {
          const { data: newSettings, error: createError } = await ctx.supabaseAdmin
            .from('user_settings')
            .insert({
              user_id: ctx.userId,
              notification_preferences: {
                email: true,
                push: true,
                task_reminders: true,
                goal_updates: true,
                habit_reminders: true
              },
              ui_preferences: {
                theme: 'system',
                compact_view: false,
                show_completed_tasks: true
              }
            })
            .select()
            .single();
            
          if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
          return newSettings;
        }
        
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      }
      
      return data;
    }),
    
  updateUserSettings: protectedProcedure
    .input(z.object({
      notification_preferences: z.object({
        email: z.boolean().optional(),
        push: z.boolean().optional(),
        task_reminders: z.boolean().optional(),
        goal_updates: z.boolean().optional(),
        habit_reminders: z.boolean().optional()
      }).optional(),
      ui_preferences: z.object({
        theme: z.string().optional(),
        compact_view: z.boolean().optional(),
        show_completed_tasks: z.boolean().optional()
      }).optional()
    }))
    .mutation(async ({ ctx, input }) => {
      // First check if settings exist
      const { data: existingSettings, error: fetchError } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('id')
        .eq('user_id', ctx.userId)
        .single();
        
      if (fetchError && fetchError.code === 'PGRST116') {
        // Create settings if they don't exist
        const defaultSettings = {
          user_id: ctx.userId,
          notification_preferences: {
            email: true,
            push: true,
            task_reminders: true,
            goal_updates: true,
            habit_reminders: true,
            ...input.notification_preferences
          },
          ui_preferences: {
            theme: 'system',
            compact_view: false,
            show_completed_tasks: true,
            ...input.ui_preferences
          }
        };
        
        const { data, error } = await ctx.supabaseAdmin
          .from('user_settings')
          .insert(defaultSettings)
          .select()
          .single();
          
        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        return data;
      } else if (fetchError) {
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: fetchError.message });
      }
      
      // Update existing settings
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .update(input)
        .eq('user_id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getOnboardingStatus: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('id, onboarding_completed')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { onboardingCompleted: data?.onboarding_completed || false };
    }),
    
  completeOnboarding: protectedProcedure
    .mutation(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update({ onboarding_completed: true })
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { success: true };
    }),
}); ```
\n## Router Import/Export Structure
\n\n## Main App Router
**File not found:** server/src/routers/index.ts
\n\n## Dashboard Router
**File:** server/src/routers/dashboardRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';

// Define fields for consistent selection - align with Zod schemas & table structure
const HABIT_FIELDS = 'id, user_id, name, description, habit_type, goal_quantity, goal_units, frequency_type, frequency_details, reminder_id, streak, best_streak, sort_order, created_at, updated_at'; // Added reminder_id
const GOAL_FIELDS = 'id, user_id, name, description, priority, status, target_date, sort_order, created_at, updated_at'; // Use target_date
const TASK_FIELDS = 'id, user_id, name, notes, status, priority, due_date, reminder_id, goal_id, sort_order, created_at, updated_at'; // Use due_date, reminder_id
const HABIT_ENTRY_FIELDS = 'id, habit_id, user_id, date, quantity_value, notes, created_at';
const TRACKED_STATE_DEF_FIELDS = 'id, user_id, name, description, data_type, unit, sort_order, active, notes, created_at, updated_at'; // Adjusted based on potential schema changes

export const dashboardRouter = router({
  getDashboardData: protectedProcedure
    .input(
      z.object({
        habitLimit: z.number().min(1).default(5),
        goalLimit: z.number().min(1).default(5),
        taskLimit: z.number().min(1).default(10)
      }).optional()
    )
    .query(async ({ ctx, input }) => {
      try {
        // Get limits from input or use defaults
        const habitLimit = input?.habitLimit || 5;
        const goalLimit = input?.goalLimit || 5;
        const taskLimit = input?.taskLimit || 10;

        // --- Fetch Habits ---
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
          .limit(habitLimit);
        if (habitsError) throw habitsError;

        // --- Fetch Goals ---
        const { data: goals, error: goalsError } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
          .limit(goalLimit);
        if (goalsError) throw goalsError;

        // --- Fetch Upcoming Tasks (focus on upcoming tasks and prioritize those due soon) ---
        const today = new Date();
        const twoWeeksFromNow = new Date();
        twoWeeksFromNow.setDate(today.getDate() + 14);
        
        // We want to fetch tasks that are:
        // 1. Not completed
        // 2. Due within the next two weeks, or overdue
        // 3. Either unassigned or associated with the dashboard goals
        const { data: tasks, error: tasksError } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .neq('status', 'completed') // Use correct enum value
          .or(`due_date.lte.${twoWeeksFromNow.toISOString()},due_date.is.null`)
          .order('due_date', { ascending: true, nullsFirst: false }) // Use 'due_date'
          .limit(taskLimit);
        if (tasksError) throw tasksError;

        // --- Fetch Active Tracked State Definitions ---
        const { data: trackedStateDefinitions, error: statesError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .eq('active', true)
          .order('sort_order', { ascending: true, nullsFirst: false }); // Correct: nullsFirst: false for nulls last
        if (statesError) throw statesError;
        
        // --- Fetch Latest State Entries for Active Definitions ---
        let latestEntriesMap: Record<string, { value: any; created_at: string }> = {};
        const stateDefIds = (trackedStateDefinitions || []).map(s => s.id);

        if (stateDefIds.length > 0) {
          // Use a CTE and ROW_NUMBER() to get the latest entry per state_id
          const { data: latestEntries, error: entriesError } = await ctx.supabaseAdmin.rpc(
            'get_latest_state_entries_for_user', 
            { p_user_id: ctx.userId, p_state_ids: stateDefIds }
          );

          if (entriesError) {
            console.error('Error fetching latest state entries:', entriesError);
            // Decide how to handle this - throw, or continue with empty/default values?
            // For now, log and continue, states will show default value
          } else {
            // Define expected type for entries from RPC
            type LatestEntry = { state_id: string; value: any; created_at: string };
            
            latestEntriesMap = (latestEntries as LatestEntry[] || []).reduce(
              (acc: Record<string, { value: any; created_at: string }>, entry: LatestEntry) => {
              acc[entry.state_id] = { value: entry.value, created_at: entry.created_at };
              return acc;
            }, {} as typeof latestEntriesMap);
          }
        }

        // --- Process Habits for 'completed' flag ---
        const todayStr = new Date().toISOString().split('T')[0];
        const habitIds = (habits || []).map(h => h.id);
        const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id') // Only need habit_id to check existence
          .eq('user_id', ctx.userId)
          .eq('date', todayStr) // Filter by date
          .in('habit_id', habitIds);
        if (todayEntriesError) throw todayEntriesError;

        const completedHabitIds = new Set((habitEntriesToday || []).map(e => e.habit_id));

        const formattedHabits = (habits || []).map(h => ({
          id: h.id,
          name: h.name, // Use name
          description: h.description, // Pass other potentially useful fields
          habit_type: h.habit_type,
          streak: h.streak,
          // Consider a habit completed if *any* entry exists for today
          completed: completedHabitIds.has(h.id)
        }));

        // --- Process Goals for 'progress' ---
        const goalIds = (goals || []).map(g => g.id);
        let tasksMap: Record<string, { total: number; completed: number }> = {};
        if (goalIds.length > 0) {
          const { data: allTasksForGoals, error: tasksError2 } = await ctx.supabaseAdmin
            .from('tasks')
            .select('goal_id, status')
            .eq('user_id', ctx.userId)
            .in('goal_id', goalIds);
          if (tasksError2) throw tasksError2;

          tasksMap = (allTasksForGoals || []).reduce<Record<string, { total: number; completed: number }>>((acc, task) => {
            if (task.goal_id) { // Ensure goal_id is not null
              const gid = task.goal_id;
              if (!acc[gid]) acc[gid] = { total: 0, completed: 0 };
              acc[gid].total++;
              if (task.status === 'completed') acc[gid].completed++;
            }
            return acc;
          }, {});
        }

        const formattedGoals = (goals || []).map((g) => {
          const { total = 0, completed: comp = 0 } = tasksMap[g.id] || {};
          // Calculate progress based on tasks, ignore goal.progress field for now
          const progress = total > 0 ? comp / total : 0;
          return {
            id: g.id,
            title: g.name, // Changed name to title to match frontend expectations
            status: g.status, // Pass status directly
            priority: g.priority, // Pass priority
            progress: Math.round(progress * 100) / 100, // Keep calculated progress
            tasks: { // Add tasks information expected by GoalSummaryCard
              total: total,
              completed: comp
            }
          };
        });

        // --- Format Tasks (Minimal formatting needed if TASK_FIELDS is correct) ---
        const formattedTasks = (tasks || []).map((t) => ({
          id: t.id,
          name: t.name,
          status: t.status,
          priority: t.priority,
          due_date: t.due_date, // Use due_date
          // Add other fields as needed by the dashboard UI
        }));

        // --- Format Tracked States with Latest Values ---
        const formattedTrackedStates = (trackedStateDefinitions || []).map((def) => {
          const latestEntry = latestEntriesMap[def.id];
          return {
            id: def.id,
            name: def.name,
            unit: def.unit, // Use 'unit' field
            currentValue: latestEntry ? latestEntry.value : null, // Default to null
            lastUpdated: latestEntry ? latestEntry.created_at : null,
          };
        });

        // Return formatted data including trackedStates
        return {
          habits: formattedHabits,
          goals: formattedGoals,
          tasks: tasks || [], // Ensure tasks is always an array
          trackedStates: formattedTrackedStates, // Use the newly formatted array
        };
      } catch (error: any) {
        console.error('Dashboard data fetch error:', error);
        
        // Handle specific error types with appropriate error codes
        if (error.code === '42P01') { // Table doesn't exist
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Database schema error',
          });
        }
        
        if (error.code === '23505') { // Unique violation
          throw new TRPCError({
            code: 'CONFLICT',
            message: 'Resource already exists',
          });
        }
        
        // Default error handling
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch dashboard data',
        });
      }
    }),
  
  getWeeklyProgress: protectedProcedure
    .input(z.object({
      daysToInclude: z.number().min(1).optional().default(7),
      includeRawData: z.boolean().optional().default(false),
    }).optional())
    .query(async ({ ctx, input }) => {
      try {
        // Calculate date range based on input or default to past week
        const daysToInclude = input?.daysToInclude || 7;
        const includeRawData = input?.includeRawData || false;
        
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(endDate.getDate() - (daysToInclude - 1));
        
        const todayStr = endDate.toISOString().split('T')[0];
        const startDateStr = startDate.toISOString().split('T')[0];
        
        // Generate array of all dates in the range for daily aggregation
        const dateRange: string[] = [];
        const tempDate = new Date(startDate);
        while (tempDate <= endDate) {
          dateRange.push(tempDate.toISOString().split('T')[0]);
          tempDate.setDate(tempDate.getDate() + 1);
        }
        
        // Fetch habits relevant to the date range (active during any part of the range)
        // Need to consider habits created *before* the end date and not archived *before* the start date
        const HABIT_FIELDS_FOR_PROGRESS = 'id, name, habit_type, frequency_type, frequency_details, created_at, streak, best_streak'; // Add streak fields
        const { data: relevantHabits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS_FOR_PROGRESS)
          .eq('user_id', ctx.userId)
          // Add logic here if needed to filter habits active within the date range
          // e.g., .lt('created_at', endDate.toISOString())
          //       .or(`archived_at.gte.${startDate.toISOString()},archived_at.is.null`)
          ;
        if (habitsError) throw habitsError;

        const relevantHabitIds = (relevantHabits || []).map(h => h.id);

        // Fetch habit entries within the date range for relevant habits
        const { data: habitEntries, error: entriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('id, habit_id, date, completed, quantity_value, notes')
          .eq('user_id', ctx.userId)
          .in('habit_id', relevantHabitIds.length > 0 ? relevantHabitIds : ['dummy-uuid']) // Filter by relevant habits
          .gte('date', startDate.toISOString().split('T')[0])
          .lte('date', endDate.toISOString().split('T')[0])
          .order('date', { ascending: true });
 
        if (entriesError) throw entriesError;

        // Get all tasks completed or due within the date range
        const { data: relevantTasks, error: tasksError } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .or(`due_date.gte.${startDateStr}.and.due_date.lte.${todayStr},status.eq.completed.and.updated_at.gte.${startDateStr}.and.updated_at.lte.${todayStr}`);

        if (tasksError) throw tasksError;
        
        // Get total tasks count for completion rate
        const { count: totalTasks, error: countError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', ctx.userId);
          
        if (countError) throw countError;
        
        // Get goal progress snapshots for the period
        const { data: goalSnapshots, error: goalSnapshotsError } = await ctx.supabaseAdmin
          .from('goal_progress_snapshots') // Assuming we have this table
          .select('goal_id, progress, created_at')
          .eq('user_id', ctx.userId)
          .gte('created_at', startDate.toISOString())
          .lte('created_at', endDate.toISOString())
          .order('created_at', { ascending: true });
          
        if (goalSnapshotsError) throw goalSnapshotsError;

        // -- AGGREGATE DATA BY DAY --
        
        // Create daily habit completion structure
        const habitsByDay: Record<string, { completed: number; total: number; entries: any[]; expected: number }> = {};
        dateRange.forEach(date => {
          habitsByDay[date] = { completed: 0, total: 0, entries: [], expected: 0 };
        });
        
        // Populate completed habits from entries (count existence, not completed flag)
        habitEntries?.forEach((entry: any) => {
          const dateStr = (entry.date as string).split('T')[0];
          if (habitsByDay[dateStr]) {
            // Only count one completion per habit per day
            if (!habitsByDay[dateStr].entries.some((e: any) => e.habit_id === entry.habit_id)) {
              habitsByDay[dateStr].completed++;
            }
            habitsByDay[dateStr].entries.push(entry);
          }
        });
        
        // Create daily task completion structure
        const tasksByDay: Record<string, { completed: number; entries: any[] }> = {};
        dateRange.forEach(date => {
          tasksByDay[date] = { completed: 0, entries: [] };
        });
        
        // Process completed tasks into daily stats
        relevantTasks?.forEach(task => {
          const completedDate = (task.updated_at as string).split('T')[0];
          if (tasksByDay[completedDate]) {
            tasksByDay[completedDate].completed++;
            tasksByDay[completedDate].entries.push(task);
          }
        });
        
        // Calculate expected habits per day based on frequency
        const isHabitExpected = (habit: any, date: string): boolean => {
          const dateObj = new Date(date + 'T00:00:00Z'); // Ensure UTC
          const dayOfWeek = dateObj.getUTCDay(); // 0 = Sunday, 6 = Saturday
          const dayOfMonth = dateObj.getUTCDate();
          const month = dateObj.getUTCMonth(); // 0 = January, 11 = December

          const habitCreatedDate = new Date(habit.created_at);
          if (dateObj < habitCreatedDate) {
            return false; // Cannot be expected before it was created
          }

          switch (habit.frequency_type) {
            case 'daily':
              return true;
            case 'specific_days':
              return Array.isArray(habit.frequency_details?.days) && habit.frequency_details.days.includes(dayOfWeek);
            // TODO: Add logic for 'weekly', 'monthly' etc. as needed
            default:
              return false;
          }
        };
        relevantHabits?.forEach(habit => {
          dateRange.forEach(date => {
            if (isHabitExpected(habit, date)) {
              habitsByDay[date].expected++;
            }
          });
        });
        
        // Format into daily progress reports
        const dailyProgress = dateRange.map(date => {
          const habitStats = habitsByDay[date];
          const taskStats = tasksByDay[date];
          
          const habitCompletionRate = habitStats.expected > 0 
            ? habitStats.completed / habitStats.expected 
            : 0;
            
          return {
            date,
            habits: {
              total: habitStats.total,
              completed: habitStats.completed,
              completionRate: habitCompletionRate,
              expected: habitStats.expected
            },
            tasks: {
              completed: taskStats.completed
            },
            // Optionally include raw entries if requested
            ...(includeRawData ? {
              habitEntries: habitStats.entries,
              completedTasks: taskStats.entries
            } : {})
          };
        });
        
        // Calculate overall metrics
        const totalHabitEntries = Object.values(habitsByDay).reduce(
          (sum, day) => sum + day.total, 0);
        const completedHabitEntries = Object.values(habitsByDay).reduce(
          (sum, day) => sum + day.completed, 0);
        const totalCompletedTasks = Object.values(tasksByDay).reduce(
          (sum, day) => sum + day.completed, 0);
          
        const taskCompletionRate = totalTasks ? totalCompletedTasks / totalTasks : 0;
        const habitConsistency = totalHabitEntries > 0 
          ? completedHabitEntries / totalHabitEntries 
          : 0;
          
        // Calculate habit streaks (could be moved to a separate helper function)
        const habitStreaks = (relevantHabits || []).map(habit => ({
          id: habit.id,
          name: habit.name,
          currentStreak: habit.streak || 0,
          bestStreak: habit.best_streak || 0
        }));
        
        // Prepare goal progress data
        const goalProgress: Record<string, { snapshots: any[]; startProgress?: number; endProgress?: number }> = {};
        
        (goalSnapshots || []).forEach(snapshot => {
          if (!goalProgress[snapshot.goal_id]) {
            goalProgress[snapshot.goal_id] = { snapshots: [] };
          }
          goalProgress[snapshot.goal_id].snapshots.push({
            progress: snapshot.progress,
            date: (snapshot.created_at as string).split('T')[0]
          });
        });
        
        // Calculate start and end progress for each goal
        Object.keys(goalProgress).forEach(goalId => {
          const snapshots = goalProgress[goalId].snapshots;
          if (snapshots.length > 0) {
            // Sort by date
            snapshots.sort((a, b) => a.date.localeCompare(b.date));
            goalProgress[goalId].startProgress = snapshots[0].progress;
            goalProgress[goalId].endProgress = snapshots[snapshots.length - 1].progress;
          }
        });
        
        return {
          dailyProgress,
          overallMetrics: {
            totalHabitEntries,
            completedHabitEntries,
            habitCompletionRate: habitConsistency,
            completedTasksCount: totalCompletedTasks,
            taskCompletionRate,
            // Trend indicators (compared to previous period)
            trends: {
              habitsImproving: true, // Placeholder - would compare to previous period
              tasksImproving: false // Placeholder - would compare to previous period
            }
          },
          habitStreaks,
          goalProgress: Object.entries(goalProgress).map(([goalId, data]) => ({
            goalId,
            progressChange: (data.endProgress || 0) - (data.startProgress || 0),
            currentProgress: data.endProgress || 0
          })),
          dateRange: {
            start: startDateStr,
            end: todayStr,
            days: dateRange
          }
        };
      } catch (error: any) {
        console.error('Weekly progress fetch error:', error);
        
        // Handle specific error types with appropriate error codes
        if (error.code === '42P01') { // Table doesn't exist
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Database schema error',
          });
        }
        
        if (error.code === '22P02') { // Invalid text representation
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Invalid input format',
          });
        }
        
        // Default error handling
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch weekly progress',
        });
      }
    }),
}); ```
\n\n## goal Router
**File:** server/src/routers/goalRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createGoalInput, updateGoalInput } from '../types/trpc-types';

const GOAL_FIELDS = 'id, user_id, title, description, progress, target_date, archived_at, sort_order, created_at, updated_at';

export const goalRouter = router({
  getGoals: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;

        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals',
        });
      }
    }),

  getGoalById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!goal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found',
          });
        }

        return goal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal',
        });
      }
    }),

  createGoal: protectedProcedure
    .input(createGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return goal;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal',
        });
      }
    }),

  updateGoal: protectedProcedure
    .input(updateGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to update it',
          });
        }

        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal',
        });
      }
    }),

  deleteGoal: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to delete it',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goals')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal',
        });
      }
    }),

  listActive: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals (in listActive stub)',
        });
      }
    }),

  listArchived: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived goals',
        });
      }
    }),

  archiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') { 
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive goal',
        });
      }
    }),

  unarchiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive goal',
        });
      }
    }),
});```
\n\n## task Router
**File:** server/src/routers/taskRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createTaskInput,
  updateTaskInput,
  updateTaskStatusInput,
  TaskStatusEnum, // Import the enum
  TaskPriorityEnum,
} from '../types/trpc-types';

// Define fields for selection consistency
const TASK_FIELDS =
  'id, user_id, title, notes, status, priority, due_date, goal_id, parent_task_id, recurrence_rule, recurrence_end_date, archived_at, sort_order, created_at, updated_at'; // Corrected: 'priority' instead of 'priority_enum' if that's the actual column name after migration
const GOAL_FIELDS = 'id, user_id, title, description, progress, target_date, archived_at, sort_order, created_at, updated_at';


// --- Helper function to update goal progress ---
async function updateGoalProgress(goalId: string, userId: string, supabase: any) {
  try {
    // 1. Fetch all non-archived tasks for the goal
    const { data: tasks, error: tasksError } = await supabase
      .from('tasks')
      .select('id, status') // Only need id and status
      .eq('goal_id', goalId)
      .eq('user_id', userId)
      .is('archived_at', null); // Exclude archived tasks

    if (tasksError) {
      console.error(`Error fetching tasks for goal ${goalId} during progress update:`, tasksError);
      // Decide how to handle this - maybe just log and skip update?
      return; // Exit if tasks can't be fetched
    }

    const totalTasks = tasks?.length || 0;
    const completedTasks = tasks?.filter((t: { status: string }) => t.status === TaskStatusEnum.enum.done).length || 0;

    // 2. Calculate progress (avoid division by zero)
    const newProgress = totalTasks > 0 ? completedTasks / totalTasks : 0;
    // Ensure progress is between 0 and 1, rounded to avoid floating point issues
    const clampedProgress = Math.round(Math.min(1, Math.max(0, newProgress)) * 100) / 100;

    // 3. Update the goal record
    const { error: updateError } = await supabase
      .from('goals')
      .update({ progress: clampedProgress })
      .eq('id', goalId)
      .eq('user_id', userId); // Ensure user owns the goal

    if (updateError) {
      console.error(`Error updating progress for goal ${goalId}:`, updateError);
      // Log error but don't necessarily throw, task toggle was successful
    } else {
        console.log(`Updated progress for goal ${goalId} to ${clampedProgress}`);
    }

  } catch (err) {
    console.error(`Unexpected error during goal progress update for goal ${goalId}:`, err);
    // Log unexpected errors
  }
}

export const taskRouter = router({
  getTasks: protectedProcedure // Gets non-archived tasks
    .input(z.object({
      goalId: z.string().uuid().optional(),
      // TODO: Add filters for status, priority, dates etc.?
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null); // Filter out archived

        if (input.goalId) {
          query = query.eq('goal_id', input.goalId);
        }

        // TODO: Add complex priority enum sorting? (e.g. high > medium > low)
        const { data: tasks, error } = await query
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('due_date', { ascending: true, nullsFirst: false }) // Order by due date (nulls last)
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tasks',
        });
      }
    }),

  getTaskById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(), // Use uuid validation
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!task) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found',
          });
        }

        // TODO: Parse with Task schema?
        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch task',
        });
      }
    }),

  createTask: protectedProcedure
    .input(createTaskInput) // Use imported input type
    .mutation(async ({ ctx, input }) => {
      try {
        // Verify goal_id if provided
        if (input.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', input.goal_id)
            .eq('user_id', ctx.userId) // Ensure goal belongs to user
            .is('archived_at', null) // Ensure goal is not archived
            .single();

          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived goal ID',
            });
          }
        }

        // Verify parent_task_id if provided
        if (input.parent_task_id) {
          const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
            .from('tasks')
            .select('id')
            .eq('id', input.parent_task_id)
            .eq('user_id', ctx.userId) // Ensure parent belongs to user
            .is('archived_at', null) // Ensure parent is not archived
            .single();

          if (parentError || !parentTask) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived parent task ID',
            });
          }
        }

        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .insert({
            ...input, // Spread validated input (includes new fields like parent_task_id, recurrence etc)
            user_id: ctx.userId,
            // Ensure due_date is used if present in input
            due_date: input.due_date ?? null, // Use correct field name
          })
          .select(TASK_FIELDS)
          .single();

        if (error) {
           // Handle specific errors like FK violations?
           console.error("Create task error:", error);
           throw error;
        }
        // TODO: Parse with Task schema?
        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create task',
        });
      }
    }),

  updateTask: protectedProcedure
    .input(updateTaskInput) // Use imported input type
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input; // Separate id from update payload

        // Check ownership
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id, parent_task_id') // Select parent_task_id for cycle check
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to update it',
          });
        }

        // Verify goal_id if being updated
        if (updateData.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', updateData.goal_id)
            .eq('user_id', ctx.userId)
            .is('archived_at', null)
            .single();

          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived goal ID',
            });
          }
        }
        // Handle setting goal_id to null
        if (updateData.goal_id === null) {
          updateData.goal_id = null;
        }

        // Verify parent_task_id if being updated
        if (updateData.parent_task_id) {
           // Basic cycle check
           if (updateData.parent_task_id === id) {
             throw new TRPCError({
               code: 'BAD_REQUEST',
               message: 'Task cannot be its own parent',
             });
           }
          const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
            .from('tasks')
            .select('id')
            .eq('id', updateData.parent_task_id)
            .eq('user_id', ctx.userId)
            .is('archived_at', null)
            .single();

          if (parentError || !parentTask) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived parent task ID',
            });
          }
          // TODO: Add deeper cycle detection if needed (check if new parent is a descendant)
        }
         // Handle setting parent_task_id to null
        if (updateData.parent_task_id === null) {
          updateData.parent_task_id = null;
        }

        // Ensure correct field name for due date if provided
        const payload: Record<string, any> = { ...updateData };
        if ('due_date' in payload) {
          payload.due_date = payload.due_date ?? null;
        }

        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update(payload) // Pass validated update data
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
             // Handle specific errors like FK violations?
           console.error("Update task error:", error);
           throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update task',
        });
      }
    }),

  deleteTask: protectedProcedure
    .input(z.object({
      id: z.string().uuid(), // Use uuid validation
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to delete it',
          });
        }

        // Delete the task (consider implications for subtasks - maybe archive instead?)
        // For now, direct delete.
        const { error } = await ctx.supabaseAdmin
          .from('tasks')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete task',
        });
      }
    }),

  // ---- Archive/Unarchive ----
  listArchivedTasks: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: tasks, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null) // Filter for archived tasks
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived tasks',
        });
      }
    }),

  archiveTask: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Consider archiving subtasks recursively?
      try {
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Task not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive task',
        });
      }
    }),

  unarchiveTask: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
       // TODO: Consider check if parent is archived?
      try {
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Task not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive task',
        });
      }
    }),

  // ---- Status Update ----
  updateTaskStatus: protectedProcedure
    .input(updateTaskStatusInput) // Uses { id: string().uuid(), status: TaskStatusEnum }
    .mutation(async ({ ctx, input }) => {
       try {
         // Check ownership first
         const { data: existing, error: fetchErr } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

         if (fetchErr || !existing) {
           throw new TRPCError({ code: 'NOT_FOUND', message: 'Task not found or permission denied.' });
         }

         // Perform update
         const { data: updatedTask, error: updateErr } = await ctx.supabaseAdmin
           .from('tasks')
           .update({ status: input.status })
           .eq('id', input.id)
           .select(TASK_FIELDS)
           .single();

         if (updateErr) throw updateErr;
         // TODO: Parse with Task schema?
         return updatedTask;
       } catch (error: any) {
         if (error instanceof TRPCError) throw error;
         throw new TRPCError({
           code: 'INTERNAL_SERVER_ERROR',
           message: error.message || 'Failed to update task status',
         });
       }
    }),

  // ---- Refactored Stubs ----
  listToday: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const todayStart = new Date();
        todayStart.setHours(0, 0, 0, 0);
        const todayEnd = new Date();
        todayEnd.setHours(23, 59, 59, 999);

        const { data: tasks, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .gte('due_date', todayStart.toISOString())
          .lte('due_date', todayEnd.toISOString())
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('due_date', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list tasks for today' });
      }
    }),

  listUpcoming: protectedProcedure
    .query(async ({ ctx }) => {
       try {
         const tomorrowStart = new Date();
         tomorrowStart.setDate(tomorrowStart.getDate() + 1);
         tomorrowStart.setHours(0, 0, 0, 0);

         const { data: tasks, error } = await ctx.supabaseAdmin
           .from('tasks')
           .select(TASK_FIELDS)
           .eq('user_id', ctx.userId)
           .is('archived_at', null)
           .gte('due_date', tomorrowStart.toISOString()) // Due date is tomorrow or later
           .order('due_date', { ascending: true, nullsFirst: false })
           .order('sort_order', { ascending: true, nullsFirst: false })
           .order('created_at', { ascending: false });

         if (error) throw error;
         // TODO: Parse with Task schema?
         return tasks || [];
       } catch (error: any) {
         throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list upcoming tasks' });
       }
    }),

 listOverdue: protectedProcedure
    .query(async ({ ctx }) => {
       try {
         const todayStart = new Date();
         todayStart.setHours(0, 0, 0, 0);

         const { data: tasks, error } = await ctx.supabaseAdmin
           .from('tasks')
           .select(TASK_FIELDS)
           .eq('user_id', ctx.userId)
           .is('archived_at', null)
           .lt('due_date', todayStart.toISOString()) // Due date is before today
           .not('status', 'in', `('${TaskStatusEnum.enum.done}')`) // Exclude completed tasks
           .order('due_date', { ascending: true, nullsFirst: false })
           .order('sort_order', { ascending: true, nullsFirst: false })
           .order('created_at', { ascending: false });

         if (error) throw error;
         // TODO: Parse with Task schema?
         return tasks || [];
       } catch (error: any) {
         throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list overdue tasks' });
       }
    }),

  toggleTask: protectedProcedure // Toggles between 'todo' and 'done'
    .input(z.object({
      taskId: z.string().uuid(),
      completed: z.boolean().optional() // Optional for backward compatibility
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // 1. Fetch the current task, including goal_id
        const { data: currentTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id, status, goal_id, title') // <-- Include goal_id and title
          .eq('id', input.taskId)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !currentTask) {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Task not found or permission denied.' });
        }

        // 2. Determine the new status
        let newStatus;
        if (input.completed !== undefined) {
          // If completed was explicitly provided, use it
          newStatus = input.completed ? TaskStatusEnum.enum.done : TaskStatusEnum.enum.todo;
        } else {
          // Otherwise toggle the current status
          newStatus = currentTask.status === TaskStatusEnum.enum.done
            ? TaskStatusEnum.enum.todo
            : TaskStatusEnum.enum.done;
        }

        // 3. Update the task status
        const { data: updatedTask, error: updateError } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ status: newStatus })
          .eq('id', input.taskId)
          .select(TASK_FIELDS) // Return the full updated task
          .single();

        if (updateError) throw updateError;

        // 4. *** NEW: Update goal progress if applicable ***
        if (currentTask.goal_id) {
           // Call the helper function asynchronously - no need to await here
           // unless the UI needs the updated goal immediately (unlikely for a toggle)
          updateGoalProgress(currentTask.goal_id, ctx.userId, ctx.supabaseAdmin);
        }

        // 5. Return the updated task
        return updatedTask;

      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        console.error("Error in toggleTask:", error); // Log unexpected errors
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to toggle task status',
        });
      }
    }),

  // --- Obsolete Stubs (keep or remove based on client usage) ---
  /*
  getTasksByGoal: protectedProcedure ... // Covered by getTasks with goalId filter
  getTodaysTasks: protectedProcedure ... // Replaced by listToday
  getUpcomingTasks: protectedProcedure ... // Replaced by listUpcoming
  updateTaskStatus_OLD: protectedProcedure ... // Replaced by updateTaskStatus and toggleTask
  */

});```
\n\n## habit Router
**File:** server/src/routers/habitRouter.ts
\n```
import { z } from "zod";
import { router, protectedProcedure } from "../router";
import { TRPCError } from "@trpc/server";
import {
  createHabitInput,
  updateHabitInput,
  createHabitEntryInput,
  updateHabitEntryInput,
} from '../types/trpc-types';
import {
  differenceInCalendarDays,
  parseISO,
  format
} from 'date-fns'; // Need date-fns

const HABIT_FIELDS =
  'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, sort_order, streak, best_streak, created_at, updated_at';

const HABIT_ENTRY_FIELDS =
  'id, user_id, habit_id, date, completed, quantity_value, notes, created_at';

async function calculateAndUpdateStreak(habitId: string, userId: string, supabase: any): Promise<{ currentStreak: number, bestStreak: number }> {
  try {
    // Fetch all entries for the habit, ordered by date descending
    const { data: entries, error: entriesError } = await supabase
      .from('habit_entries')
      .select('date, completed') // Only need date and completed status
      .eq('habit_id', habitId)
      .eq('user_id', userId)
      .order('date', { ascending: false });

    if (entriesError) {
      console.error(`Streak Calc Error: Failed to fetch entries for habit ${habitId}:`, entriesError);
      return { currentStreak: 0, bestStreak: 0 }; // Return 0 if entries can't be fetched
    }

    if (!entries || entries.length === 0) {
      // No entries, reset streak
      const { error: updateErr } = await supabase
        .from('habits')
        .update({ streak: 0 })
        .eq('id', habitId);
      if (updateErr) console.error(`Streak Calc Error: Failed to reset streak for habit ${habitId}`, updateErr);
      // Fetch best streak to return it accurately even if current is 0
      const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
      return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 };
    }

    let currentStreak = 0;
    const today = new Date();
    let expectedDate = today; // Start checking from today
    const todayStr = format(today, 'yyyy-MM-dd');
    const todayEntry = entries.find((e: any) => e.date === todayStr);

    // Determine starting point for streak check
    if (todayEntry?.completed) {
      currentStreak = 1;
      expectedDate = new Date(today.setDate(today.getDate() - 1)); // Start checking from yesterday
    } else {
      const yesterday = new Date(); // Need a fresh date object
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayStr = format(yesterday, 'yyyy-MM-dd');
      const yesterdayEntry = entries.find((e: any) => e.date === yesterdayStr);
      if (yesterdayEntry?.completed) {
        currentStreak = 1;
        expectedDate = new Date(yesterday.setDate(yesterday.getDate() - 1)); // Start checking from day before yesterday
      } else {
        currentStreak = 0;
        // No need to loop if streak is already 0 based on today/yesterday
      }
    }

    // Only loop if there's a potential streak > 0
    if (currentStreak > 0) {
      // Find index of the entry *before* the expectedDate (since we check backwards)
      let startIndex = entries.findIndex((e: any) => e.date === format(expectedDate, 'yyyy-MM-dd'));
      // If expected date wasn't found (e.g., yesterday was the start), adjust index
      if (startIndex === -1) {
        // Start from the entry after the one that established the initial streak (today or yesterday)
        const initialStreakDateStr = todayEntry?.completed ? todayStr : (format(new Date(new Date().setDate(new Date().getDate() - 1)), 'yyyy-MM-dd'));
        const initialEntryIndex = entries.findIndex((e: any) => e.date === initialStreakDateStr);
        startIndex = initialEntryIndex !== -1 ? initialEntryIndex + 1 : 0;
      }

      for (let i = startIndex; i < entries.length; i++) {
        const entry = entries[i];
        const entryDate = parseISO(entry.date);
        const expectedDateStr = format(expectedDate, 'yyyy-MM-dd');

        if (entry.date === expectedDateStr) {
          if (entry.completed) {
            currentStreak++;
            expectedDate.setDate(expectedDate.getDate() - 1); // Move to check previous day
          } else {
            break; // Streak broken by uncompleted entry
          }
        } else {
          // Check if the date difference breaks the streak (allowing for gaps)
          const previousDate = i > 0 ? parseISO(entries[i - 1].date) : parseISO(entries[0].date);
          const dateDiff = differenceInCalendarDays(previousDate, entryDate);

          if (dateDiff > 1) {
            break; // Gap too large, streak broken
          }

          // If gap is 1 day, but this entry wasn't completed, streak is broken
          if (!entry.completed) {
            break;
          }

          // If gap is 1 day and completed, it doesn't continue the *current* consecutive sequence
          // but doesn't necessarily break it either (e.g., completed Mon, Wed - streak is 1 from Wed).
          // For simplicity, we break the loop here, assuming the *consecutive* streak from today/yesterday is what matters.
          // A more complex implementation could find the *longest* streak ending recently.
          break;
        }
      }
    }

    // Fetch current best_streak
    const { data: habitData, error: habitFetchError } = await supabase
      .from('habits')
      .select('best_streak')
      .eq('id', habitId)
      .single();

    if (habitFetchError) {
      console.error(`Streak Calc Error: Failed to fetch habit ${habitId} for best_streak:`, habitFetchError);
      // Fallback best streak if fetch fails
      const bestStreakFallback = Math.max(currentStreak, 0); 
      const { error: updateError } = await supabase
        .from('habits')
        .update({ streak: currentStreak, best_streak: bestStreakFallback })
        .eq('id', habitId);
      if (updateError) console.error(`Streak Calc Error: Failed to update streak (fallback) for habit ${habitId}:`, updateError);
      console.log(`Streak Updated (Fallback Best) for habit ${habitId}: Current=${currentStreak}, Best=${bestStreakFallback}`);
      return { currentStreak, bestStreak: bestStreakFallback };
    }

    const bestStreak = Math.max(currentStreak, habitData?.best_streak || 0);

    // Update the habit record
    const { error: updateError } = await supabase
      .from('habits')
      .update({ streak: currentStreak, best_streak: bestStreak })
      .eq('id', habitId);

    if (updateError) {
      console.error(`Streak Calc Error: Failed to update streak for habit ${habitId}:`, updateError);
    }

    console.log(`Streak Updated for habit ${habitId}: Current=${currentStreak}, Best=${bestStreak}`);
    return { currentStreak, bestStreak };

  } catch (error) {
    console.error(`Unexpected error calculating streak for habit ${habitId}:`, error);
    // Attempt to fetch best streak even on error
    const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
    return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 }; // Return 0 current streak on error
  }
}

export const habitRouter = router({
  getHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (habitsError) throw habitsError;
        if (!habits) return [];

        const todayStr = new Date().toISOString().split('T')[0];

        const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id')
          .eq('user_id', ctx.userId)
          .eq('date', todayStr)
          .in('habit_id', habits.map(h => h.id));

        if (todayEntriesError) throw todayEntriesError;

        const completedMap = (habitEntriesToday || []).reduce<Record<string, boolean>>((acc, entry) => {
          acc[entry.habit_id] = true;
          return acc;
        }, {});

        const formattedHabits = habits.map(h => ({
          ...h,
          completedToday: !!completedMap[h.id]
        }));

        return formattedHabits;
      } catch (error: any) {
        throw new TRPCError({ 
          code: 'INTERNAL_SERVER_ERROR', 
          message: error.message || 'Failed to fetch habits'
        });
      }
    }),

  getHabitById: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .select(HABIT_FIELDS)
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (error) throw new TRPCError({ 
        code: error.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: error.message 
      });
      return data;
    }),

  createHabit: protectedProcedure
    .input(createHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .insert({
          ...input,
          user_id: ctx.userId,
          streak: 0,
          best_streak: 0
        })
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  updateHabit: protectedProcedure
    .input(updateHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { id, ...updateData } = input;

      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .update(updateData)
        .eq("id", id)
        .eq('user_id', ctx.userId)
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  deleteHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { error } = await ctx.supabaseAdmin
        .from("habits")
        .delete()
        .eq("id", input.id);

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return { id: input.id };
    }),

  listArchivedHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        return habits || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived habits',
        });
      }
    }),

  archiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to archive habit' });
      }
    }),

  unarchiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to unarchive habit' });
      }
    }),

  getHabitEntries: protectedProcedure
    .input(z.object({
      habitId: z.string().uuid(),
      startDate: z.string().optional(), 
      endDate: z.string().optional(),   
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { error: habitError } = await ctx.supabaseAdmin
          .from("habits")
          .select("id")
          .eq("id", input.habitId)
          .eq("user_id", ctx.userId)
          .single();

        if (habitError) {
          if (habitError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: habitError.message });
        }

        let query = ctx.supabaseAdmin
          .from('habit_entries')
          .select(HABIT_ENTRY_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('habit_id', input.habitId);

        if (input.startDate) query = query.gte('date', input.startDate);
        if (input.endDate) query = query.lte('date', input.endDate);

        const { data, error: entriesError } = await query.order('date', { ascending: false });

        if (entriesError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: entriesError.message });
        return data || [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to fetch habit entries' });
      }
    }),

  getHabitEntriesForHabit: protectedProcedure
    .input(z.object({ habitId: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      // TODO: Implement logic to fetch habit entries for a specific habit
      console.log(`Fetching entries for habit: ${input.habitId}, user: ${ctx.userId}`);
      // Example fetch:
      // const { data, error } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select(HABIT_ENTRY_FIELDS)
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .order('date', { ascending: false });
      // if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      // return data || [];
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),

  createHabitEntry: protectedProcedure
    .input(createHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .insert({ ...input, user_id: ctx.userId })
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });

        // Update streak after successful insert
        if (data) {
          await calculateAndUpdateStreak(input.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create habit entry',
        });
      }
    }),

  updateHabitEntry: protectedProcedure
    .input(updateHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: habitEntry, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) throw new TRPCError({ 
          code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
          message: "Habit entry not found or access denied" 
        });

        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId) // Ensure ownership
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });

        // Update streak after successful update
        if (data) {
          await calculateAndUpdateStreak(data.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update habit entry',
        });
      }
    }),

  deleteHabitEntry: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Fetch habitId *before* deleting the entry
        const { data: entryToDelete, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id') // Fetch habit_id
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !entryToDelete) {
          throw new TRPCError({ 
            code: fetchError?.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Habit entry not found or access denied.' 
          });
        }

        const { habit_id: habitIdForStreak } = entryToDelete; // Store before delete

        // Perform delete
        const { error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId); // Ensure user owns the entry being deleted

        if (error) throw error; // Throw if delete fails

        // Update streak *after* successful delete
        if (habitIdForStreak) { // Check if we got the habitId
          await calculateAndUpdateStreak(habitIdForStreak, ctx.userId, ctx.supabaseAdmin);
        }

        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete habit entry',
        });
      }
    }),

  toggleHabitEntry: protectedProcedure
    .input(z.object({ habitId: z.string().uuid(), date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/) }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Implement logic to find if entry exists for habitId/date/userId.
      // If exists, delete it.
      // If not exists, create it (need default values for boolean/quantity type).
      // Call calculateAndUpdateStreak after create/delete.
      console.log(`Toggling habit entry for habit: ${input.habitId}, date: ${input.date}`);
      // Example logic:
      // const { data: existingEntry, error: findError } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select('id')
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .eq('date', input.date)
      //   .maybeSingle();
      // if (findError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: findError.message });

      // if (existingEntry) {
      //   // Delete existing
      //   const { error: deleteError } = await ctx.supabaseAdmin.from('habit_entries').delete().eq('id', existingEntry.id);
      //   if (deleteError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: deleteError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'deleted', habitId: input.habitId, date: input.date };
      // } else {
      //   // Create new
      //   // Need to know habit type to set default 'completed' or 'quantity_value'
      //   const { data: newEntry, error: createError } = await ctx.supabaseAdmin
      //     .from('habit_entries')
      //     .insert({ habit_id: input.habitId, user_id: ctx.userId, date: input.date, completed: true /* or quantity_value: default */ })
      //     .select(HABIT_ENTRY_FIELDS)
      //     .single();
      //   if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'created', entry: newEntry };
      // }
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),
});```
\n\n## profile Router
**File not found:** server/src/routers/profileRouter.ts
\n\n## principle Router
**File:** server/src/routers/principleRouter.ts
\n```
// server/src/routers/principleRouter.ts
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createPrincipleInput, updatePrincipleInput } from '../types/trpc-types'; // These now expect 'title' and 'body'

// Define fields for consistent selection, using 'title' and 'body'
const PRINCIPLE_FIELDS = 'id, user_id, title, body, sort_order, created_at, updated_at';

export const principleRouter = router({
  getPrinciples: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: principles, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principles || []; // Return empty array if null
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principles',
        });
      }
    }),

  getPrincipleById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) {
           if (error.code === 'PGRST116') { // Handle not found specifically
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found' });
           }
           throw error; // Rethrow other errors
        }
        // No need for !principle check if .single() is used and error isn't PGRST116

        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principle',
        });
      }
    }),

  createPrinciple: protectedProcedure
    .input(createPrincipleInput) // This Zod schema now expects 'title' and 'body'
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .insert({
            ...input, // Spread validated input, already contains 'title' and 'body'
            user_id: ctx.userId,
          })
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create principle',
        });
      }
    }),

  updatePrinciple: protectedProcedure
    .input(updatePrincipleInput) // This Zod schema now expects 'title' and 'body' (optional)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
           if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to update it' });
           }
           throw fetchError;
        }

        // Update
        const { data: updatedPrinciple, error } = await ctx.supabaseAdmin
          .from('principles')
          .update(updateData) // updateData contains validated 'title'/'body' if provided
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return updatedPrinciple;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update principle',
        });
      }
    }),

  deletePrinciple: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
            if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to delete it' });
           }
           throw fetchError;
        }

        // Delete
        const { error } = await ctx.supabaseAdmin
          .from('principles')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete principle',
        });
      }
    }),
});```
\n\n## reward Router
**File not found:** server/src/routers/rewardRouter.ts
\n\n# 2️⃣ Points Economy Endpoint
\n## Reward System Implementation
\n\n## Reward Router
**File not found:** server/src/routers/rewardRouter.ts
\n\n## Points/Rewards Handler: habitRouter.ts
**File:** server/src/routers/habitRouter.ts
\n```
import { z } from "zod";
import { router, protectedProcedure } from "../router";
import { TRPCError } from "@trpc/server";
import {
  createHabitInput,
  updateHabitInput,
  createHabitEntryInput,
  updateHabitEntryInput,
} from '../types/trpc-types';
import {
  differenceInCalendarDays,
  parseISO,
  format
} from 'date-fns'; // Need date-fns

const HABIT_FIELDS =
  'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, sort_order, streak, best_streak, created_at, updated_at';

const HABIT_ENTRY_FIELDS =
  'id, user_id, habit_id, date, completed, quantity_value, notes, created_at';

async function calculateAndUpdateStreak(habitId: string, userId: string, supabase: any): Promise<{ currentStreak: number, bestStreak: number }> {
  try {
    // Fetch all entries for the habit, ordered by date descending
    const { data: entries, error: entriesError } = await supabase
      .from('habit_entries')
      .select('date, completed') // Only need date and completed status
      .eq('habit_id', habitId)
      .eq('user_id', userId)
      .order('date', { ascending: false });

    if (entriesError) {
      console.error(`Streak Calc Error: Failed to fetch entries for habit ${habitId}:`, entriesError);
      return { currentStreak: 0, bestStreak: 0 }; // Return 0 if entries can't be fetched
    }

    if (!entries || entries.length === 0) {
      // No entries, reset streak
      const { error: updateErr } = await supabase
        .from('habits')
        .update({ streak: 0 })
        .eq('id', habitId);
      if (updateErr) console.error(`Streak Calc Error: Failed to reset streak for habit ${habitId}`, updateErr);
      // Fetch best streak to return it accurately even if current is 0
      const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
      return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 };
    }

    let currentStreak = 0;
    const today = new Date();
    let expectedDate = today; // Start checking from today
    const todayStr = format(today, 'yyyy-MM-dd');
    const todayEntry = entries.find((e: any) => e.date === todayStr);

    // Determine starting point for streak check
    if (todayEntry?.completed) {
      currentStreak = 1;
      expectedDate = new Date(today.setDate(today.getDate() - 1)); // Start checking from yesterday
    } else {
      const yesterday = new Date(); // Need a fresh date object
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayStr = format(yesterday, 'yyyy-MM-dd');
      const yesterdayEntry = entries.find((e: any) => e.date === yesterdayStr);
      if (yesterdayEntry?.completed) {
        currentStreak = 1;
        expectedDate = new Date(yesterday.setDate(yesterday.getDate() - 1)); // Start checking from day before yesterday
      } else {
        currentStreak = 0;
        // No need to loop if streak is already 0 based on today/yesterday
      }
    }

    // Only loop if there's a potential streak > 0
    if (currentStreak > 0) {
      // Find index of the entry *before* the expectedDate (since we check backwards)
      let startIndex = entries.findIndex((e: any) => e.date === format(expectedDate, 'yyyy-MM-dd'));
      // If expected date wasn't found (e.g., yesterday was the start), adjust index
      if (startIndex === -1) {
        // Start from the entry after the one that established the initial streak (today or yesterday)
        const initialStreakDateStr = todayEntry?.completed ? todayStr : (format(new Date(new Date().setDate(new Date().getDate() - 1)), 'yyyy-MM-dd'));
        const initialEntryIndex = entries.findIndex((e: any) => e.date === initialStreakDateStr);
        startIndex = initialEntryIndex !== -1 ? initialEntryIndex + 1 : 0;
      }

      for (let i = startIndex; i < entries.length; i++) {
        const entry = entries[i];
        const entryDate = parseISO(entry.date);
        const expectedDateStr = format(expectedDate, 'yyyy-MM-dd');

        if (entry.date === expectedDateStr) {
          if (entry.completed) {
            currentStreak++;
            expectedDate.setDate(expectedDate.getDate() - 1); // Move to check previous day
          } else {
            break; // Streak broken by uncompleted entry
          }
        } else {
          // Check if the date difference breaks the streak (allowing for gaps)
          const previousDate = i > 0 ? parseISO(entries[i - 1].date) : parseISO(entries[0].date);
          const dateDiff = differenceInCalendarDays(previousDate, entryDate);

          if (dateDiff > 1) {
            break; // Gap too large, streak broken
          }

          // If gap is 1 day, but this entry wasn't completed, streak is broken
          if (!entry.completed) {
            break;
          }

          // If gap is 1 day and completed, it doesn't continue the *current* consecutive sequence
          // but doesn't necessarily break it either (e.g., completed Mon, Wed - streak is 1 from Wed).
          // For simplicity, we break the loop here, assuming the *consecutive* streak from today/yesterday is what matters.
          // A more complex implementation could find the *longest* streak ending recently.
          break;
        }
      }
    }

    // Fetch current best_streak
    const { data: habitData, error: habitFetchError } = await supabase
      .from('habits')
      .select('best_streak')
      .eq('id', habitId)
      .single();

    if (habitFetchError) {
      console.error(`Streak Calc Error: Failed to fetch habit ${habitId} for best_streak:`, habitFetchError);
      // Fallback best streak if fetch fails
      const bestStreakFallback = Math.max(currentStreak, 0); 
      const { error: updateError } = await supabase
        .from('habits')
        .update({ streak: currentStreak, best_streak: bestStreakFallback })
        .eq('id', habitId);
      if (updateError) console.error(`Streak Calc Error: Failed to update streak (fallback) for habit ${habitId}:`, updateError);
      console.log(`Streak Updated (Fallback Best) for habit ${habitId}: Current=${currentStreak}, Best=${bestStreakFallback}`);
      return { currentStreak, bestStreak: bestStreakFallback };
    }

    const bestStreak = Math.max(currentStreak, habitData?.best_streak || 0);

    // Update the habit record
    const { error: updateError } = await supabase
      .from('habits')
      .update({ streak: currentStreak, best_streak: bestStreak })
      .eq('id', habitId);

    if (updateError) {
      console.error(`Streak Calc Error: Failed to update streak for habit ${habitId}:`, updateError);
    }

    console.log(`Streak Updated for habit ${habitId}: Current=${currentStreak}, Best=${bestStreak}`);
    return { currentStreak, bestStreak };

  } catch (error) {
    console.error(`Unexpected error calculating streak for habit ${habitId}:`, error);
    // Attempt to fetch best streak even on error
    const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
    return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 }; // Return 0 current streak on error
  }
}

export const habitRouter = router({
  getHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (habitsError) throw habitsError;
        if (!habits) return [];

        const todayStr = new Date().toISOString().split('T')[0];

        const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id')
          .eq('user_id', ctx.userId)
          .eq('date', todayStr)
          .in('habit_id', habits.map(h => h.id));

        if (todayEntriesError) throw todayEntriesError;

        const completedMap = (habitEntriesToday || []).reduce<Record<string, boolean>>((acc, entry) => {
          acc[entry.habit_id] = true;
          return acc;
        }, {});

        const formattedHabits = habits.map(h => ({
          ...h,
          completedToday: !!completedMap[h.id]
        }));

        return formattedHabits;
      } catch (error: any) {
        throw new TRPCError({ 
          code: 'INTERNAL_SERVER_ERROR', 
          message: error.message || 'Failed to fetch habits'
        });
      }
    }),

  getHabitById: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .select(HABIT_FIELDS)
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (error) throw new TRPCError({ 
        code: error.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: error.message 
      });
      return data;
    }),

  createHabit: protectedProcedure
    .input(createHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .insert({
          ...input,
          user_id: ctx.userId,
          streak: 0,
          best_streak: 0
        })
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  updateHabit: protectedProcedure
    .input(updateHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { id, ...updateData } = input;

      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .update(updateData)
        .eq("id", id)
        .eq('user_id', ctx.userId)
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  deleteHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { error } = await ctx.supabaseAdmin
        .from("habits")
        .delete()
        .eq("id", input.id);

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return { id: input.id };
    }),

  listArchivedHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        return habits || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived habits',
        });
      }
    }),

  archiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to archive habit' });
      }
    }),

  unarchiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to unarchive habit' });
      }
    }),

  getHabitEntries: protectedProcedure
    .input(z.object({
      habitId: z.string().uuid(),
      startDate: z.string().optional(), 
      endDate: z.string().optional(),   
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { error: habitError } = await ctx.supabaseAdmin
          .from("habits")
          .select("id")
          .eq("id", input.habitId)
          .eq("user_id", ctx.userId)
          .single();

        if (habitError) {
          if (habitError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: habitError.message });
        }

        let query = ctx.supabaseAdmin
          .from('habit_entries')
          .select(HABIT_ENTRY_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('habit_id', input.habitId);

        if (input.startDate) query = query.gte('date', input.startDate);
        if (input.endDate) query = query.lte('date', input.endDate);

        const { data, error: entriesError } = await query.order('date', { ascending: false });

        if (entriesError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: entriesError.message });
        return data || [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to fetch habit entries' });
      }
    }),

  getHabitEntriesForHabit: protectedProcedure
    .input(z.object({ habitId: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      // TODO: Implement logic to fetch habit entries for a specific habit
      console.log(`Fetching entries for habit: ${input.habitId}, user: ${ctx.userId}`);
      // Example fetch:
      // const { data, error } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select(HABIT_ENTRY_FIELDS)
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .order('date', { ascending: false });
      // if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      // return data || [];
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),

  createHabitEntry: protectedProcedure
    .input(createHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .insert({ ...input, user_id: ctx.userId })
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });

        // Update streak after successful insert
        if (data) {
          await calculateAndUpdateStreak(input.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create habit entry',
        });
      }
    }),

  updateHabitEntry: protectedProcedure
    .input(updateHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: habitEntry, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) throw new TRPCError({ 
          code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
          message: "Habit entry not found or access denied" 
        });

        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId) // Ensure ownership
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });

        // Update streak after successful update
        if (data) {
          await calculateAndUpdateStreak(data.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update habit entry',
        });
      }
    }),

  deleteHabitEntry: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Fetch habitId *before* deleting the entry
        const { data: entryToDelete, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id') // Fetch habit_id
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !entryToDelete) {
          throw new TRPCError({ 
            code: fetchError?.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Habit entry not found or access denied.' 
          });
        }

        const { habit_id: habitIdForStreak } = entryToDelete; // Store before delete

        // Perform delete
        const { error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId); // Ensure user owns the entry being deleted

        if (error) throw error; // Throw if delete fails

        // Update streak *after* successful delete
        if (habitIdForStreak) { // Check if we got the habitId
          await calculateAndUpdateStreak(habitIdForStreak, ctx.userId, ctx.supabaseAdmin);
        }

        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete habit entry',
        });
      }
    }),

  toggleHabitEntry: protectedProcedure
    .input(z.object({ habitId: z.string().uuid(), date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/) }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Implement logic to find if entry exists for habitId/date/userId.
      // If exists, delete it.
      // If not exists, create it (need default values for boolean/quantity type).
      // Call calculateAndUpdateStreak after create/delete.
      console.log(`Toggling habit entry for habit: ${input.habitId}, date: ${input.date}`);
      // Example logic:
      // const { data: existingEntry, error: findError } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select('id')
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .eq('date', input.date)
      //   .maybeSingle();
      // if (findError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: findError.message });

      // if (existingEntry) {
      //   // Delete existing
      //   const { error: deleteError } = await ctx.supabaseAdmin.from('habit_entries').delete().eq('id', existingEntry.id);
      //   if (deleteError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: deleteError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'deleted', habitId: input.habitId, date: input.date };
      // } else {
      //   // Create new
      //   // Need to know habit type to set default 'completed' or 'quantity_value'
      //   const { data: newEntry, error: createError } = await ctx.supabaseAdmin
      //     .from('habit_entries')
      //     .insert({ habit_id: input.habitId, user_id: ctx.userId, date: input.date, completed: true /* or quantity_value: default */ })
      //     .select(HABIT_ENTRY_FIELDS)
      //     .single();
      //   if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'created', entry: newEntry };
      // }
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),
});```
\n\n## Points/Rewards Handler: rewardsRouter.ts
**File:** server/src/routers/rewardsRouter.ts
\n```
import { TRPCError } from '@trpc/server';
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { supabaseAdmin } from '../context';

// Corrected relative path
import { claimLootInput, awardBadgeInput } from '../types/trpc-types';

export const rewardsRouter = router({
  // Get all rewards for current user
  getUserRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Select specific fields aligned with our Zod types
        const { data: rewards, error } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('id, user_id, reward_id, earned_at, rewards(id, name, description, emoji, image_url, required_points, type)')
          .eq('user_id', ctx.userId)
          .order('earned_at', { ascending: false });

        if (error) throw error;
        return rewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user rewards',
        });
      }
    }),

  // Get available rewards that can be earned
  getAvailableRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Get all rewards with specific fields
        const { data: allRewards, error: rewardsError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('id, name, description, emoji, image_url, required_points, type, can_earn_multiple')
          .order('required_points', { ascending: true });

        if (rewardsError) throw rewardsError;

        // Get already earned rewards
        const { data: earnedRewards, error: earnedError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('reward_id')
          .eq('user_id', ctx.userId);

        if (earnedError) throw earnedError;

        // Filter out already earned one-time rewards
        const earnedIds = new Set((earnedRewards || []).map(er => er.reward_id));
        const availableRewards = allRewards?.filter(reward => 
          !earnedIds.has(reward.id) || reward.can_earn_multiple);

        return availableRewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch available rewards',
        });
      }
    }),

  // Get user points
  getUserPoints: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: userProfile, error } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (error) throw error;
        return {
          points: userProfile?.points || 0,
          lifetimePoints: userProfile?.lifetime_points || 0,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user points',
        });
      }
    }),

  // Earn a reward if eligible
  earnReward: protectedProcedure
    .input(claimLootInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get the reward details
        const { data: reward, error: rewardError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.rewardId)
          .single();

        if (rewardError || !reward) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Reward not found',
          });
        }

        // Check if user has enough points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        if (userProfile.points < reward.required_points) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Not enough points to earn this reward',
          });
        }

        // If the reward is one-time, check if already earned
        if (!reward.can_earn_multiple) {
          const { data: existingReward, error: existingError } = await ctx.supabaseAdmin
            .from('user_rewards')
            .select('id')
            .eq('user_id', ctx.userId)
            .eq('reward_id', input.rewardId)
            .single();

          if (existingReward) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'You have already earned this one-time reward',
            });
          }
        }

        // Begin transaction
        // 1. Deduct points from user
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: userProfile.points - reward.required_points,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // 2. Add reward to user's earned rewards
        const { data: userReward, error: insertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.rewardId,
            earned_at: new Date().toISOString(),
            points_spent: reward.required_points,
          })
          .select()
          .single();

        if (insertError) {
          // Rollback points if adding reward failed
          await ctx.supabaseAdmin
            .from('profiles')
            .update({
              points: userProfile.points,
            })
            .eq('id', ctx.userId);

          throw insertError;
        }

        return {
          success: true,
          reward: userReward,
          remainingPoints: userProfile.points - reward.required_points,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to earn reward',
        });
      }
    }),

  // Award points to user (e.g., for completing habits, tasks)
  awardPoints: protectedProcedure
    .input(awardBadgeInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get current user points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        // Get badge details
        const { data: badge, error: badgeError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.badgeId)
          .eq('type', 'badge')
          .single();

        if (badgeError || !badge) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Badge not found',
          });
        }

        // Default points to award
        const pointsToAward = 10;
        const currentPoints = userProfile.points || 0;
        const lifetimePoints = userProfile.lifetime_points || 0;
        const newPoints = currentPoints + pointsToAward;
        const newLifetimePoints = lifetimePoints + pointsToAward;

        // Update user points
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: newPoints,
            lifetime_points: newLifetimePoints,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // Record the point transaction
        const { data: pointTransaction, error: transactionError } = await ctx.supabaseAdmin
          .from('point_transactions')
          .insert({
            user_id: ctx.userId,
            points: pointsToAward,
            reason: `Earned badge: ${badge.name}`,
            source_type: 'badge',
            source_id: input.badgeId,
          })
          .select()
          .single();

        if (transactionError) throw transactionError;

        // Add badge to user's earned rewards
        const { data: userBadge, error: badgeInsertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.badgeId,
            reward_type: 'badge',
            earned_at: new Date().toISOString(),
            points_spent: 0, // Badges don't cost points
          })
          .select()
          .single();

        if (badgeInsertError) throw badgeInsertError;

        return {
          success: true,
          previousPoints: currentPoints,
          newPoints,
          pointsAdded: pointsToAward,
          transaction: pointTransaction,
          badge: userBadge,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to award badge',
        });
      }
    }),

  // Get point transaction history
  getPointHistory: protectedProcedure
    .input(z.object({
      limit: z.number().optional().default(20),
      cursor: z.string().optional(), // for pagination
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('point_transactions')
          .select('*')
          .eq('user_id', ctx.userId)
          .order('created_at', { ascending: false })
          .limit(input.limit);
          
        // Handle cursor-based pagination
        if (input.cursor) {
          query = query.lt('created_at', input.cursor);
        }
        
        const { data: transactions, error } = await query;

        if (error) throw error;
        
        // Determine if there are more results
        const lastItem = transactions && transactions.length > 0 
          ? transactions[transactions.length - 1] 
          : null;
          
        return {
          items: transactions || [],
          nextCursor: lastItem?.created_at,
          hasMore: (transactions?.length || 0) === input.limit,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch point history',
        });
      }
    }),
}); ```
\n\n## Points/Rewards Handler: trpc-types.ts
**File:** server/src/types/trpc-types.ts
\n```
// server/src/types/trpc-types.ts
/*
  Aether – Shared tRPC Types
  ------------------------------------------------------------------
  Every Zod schema that powers a router lives here so both the server
  (routers) and the client (React Query hooks) reference a **single**
  source‑of‑truth.  Import these types everywhere else – **never** hand‑roll
  shapes again.
*/

import { z } from 'zod';
import { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from '../router';

/* ------------------------------------------------------------------
 * Enums (keep in sync with DB enums)
 * ----------------------------------------------------------------*/
export const TaskStatusEnum = z.enum(['todo', 'doing', 'done', 'blocked', 'pending']);
export const TaskPriorityEnum = z.enum(['low', 'medium', 'high']);
export const RewardTypeEnum = z.enum(['badge', 'achievement', 'item', 'discount']);
export const HabitTypeEnum = z.enum(['boolean', 'quantity']);
export const HabitFrequencyPeriodEnum = z.enum(['day', 'week', 'month']);

/* ------------------------------------------------------------------
 * Domain Models (DB row shapes) – keep in sync with Supabase tables
 * ----------------------------------------------------------------*/
export const UserProfile = z.object({
  id: z.string().uuid(),
  username: z.string().nullish(),
  avatar_url: z.string().url().nullish(),
  full_name: z.string().nullish(),
  bio: z.string().nullish(),
  points: z.number().int().nonnegative().default(0),
  time_zone: z.string().nullish(),
  onboarding_completed: z.boolean().default(false),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type UserProfile = z.infer<typeof UserProfile>;

export const NotificationPrefs = z.object({
  email: z.boolean().default(true),
  push: z.boolean().default(true),
  task_reminders: z.boolean().default(true),
  goal_updates: z.boolean().default(true),
  habit_reminders: z.boolean().default(true),
});

export const UiPrefs = z.object({
  theme: z.enum(['system', 'light', 'dark']).default('system'),
  compact_view: z.boolean().default(false),
  show_completed_tasks: z.boolean().default(true),
  first_day_of_week: z.number().int().min(0).max(6).default(0),
});

export const UserSettings = z.object({
  id: z.string().uuid().optional(),
  user_id: z.string().uuid(),
  notification_preferences: NotificationPrefs,
  ui_preferences: UiPrefs,
});
export type UserSettings = z.infer<typeof UserSettings>;

export const Value = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), 
  description: z.string().nullish(),
  color: z.string().nullish(),
  icon: z.string().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type Value = z.infer<typeof Value>;

export const Principle = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), // <<< Changed from 'name' to 'title'
  body: z.string(), // <<< Renamed from description for clarity, matching migration
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type Principle = z.infer<typeof Principle>;

export const Goal = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  description: z.string().nullish(),
  progress: z.number().nullish(),
  target_date: z.string().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime().nullish(),
  updated_at: z.string().datetime().nullish(),
});
export type Goal = z.infer<typeof Goal>;

export const Task = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  notes: z.string().nullish(),
  status: TaskStatusEnum.default('todo'),
  priority_enum: TaskPriorityEnum.nullish(), // <<< Renamed from priority
  due_date: z.string().datetime().nullish(),
  goal_id: z.string().uuid().nullish(),
  parent_task_id: z.string().uuid().nullish(),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Task = z.infer<typeof Task>;

export const Habit = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  cue: z.string().nullish(),
  routine: z.string().nullish(),
  reward: z.string().nullish(),
  streak: z.number().nonnegative().default(0),
  best_streak: z.number().nonnegative().default(0),
  habit_type: HabitTypeEnum.default('boolean'),
  goal_quantity: z.number().int().nullish(),
  goal_unit: z.string().nullish(),
  frequency_period: HabitFrequencyPeriodEnum.default('day'),
  goal_frequency: z.number().int().positive().default(1),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(), // <<< Added sort_order
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Habit = z.infer<typeof Habit>;

export const HabitEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  habit_id: z.string().uuid(),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be in YYYY-MM-DD format"),
  completed: z.boolean().default(false),
  quantity_value: z.number().int().nullish(),
  notes: z.string().nullish(),
  created_at: z.string().datetime(),
});
export type HabitEntry = z.infer<typeof HabitEntry>;

export const TrackedStateDef = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  name: z.string(),
  // category: z.string(), // Category seems removed/replaced in DB schema by scale/custom_labels
  scale: z.enum(['1-5', 'low-high', 'custom']), // <<< Added scale
  custom_labels: z.array(z.string()).nullish(), // <<< Added custom_labels
  unit: z.string().nullish(), // Keep unit if still used alongside scale
  icon: z.string().nullish(), // Keep icon if still used
  target_min_value: z.number().nullish(), // <<< Added
  target_max_value: z.number().nullish(), // <<< Added
  active: z.boolean().default(true), // <<< Added active
  priority: z.number().int().default(1), // <<< Added priority
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type TrackedStateDef = z.infer<typeof TrackedStateDef>;

export const StateEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  definition_id: z.string().uuid(), // <<< Renamed from tracked_state_def_id for consistency? check DB
  value_numeric: z.number().optional().nullable(),
  value_text: z.string().optional().nullable(),
  entry_timestamp: z.string().datetime({ message: "Invalid datetime string. Must be UTC ISO 8601" }).optional(),
  notes: z.string().optional().nullable(), // <<< Added notes
});
export type StateEntry = z.infer<typeof StateEntry>;

export const Reward = z.object({
  id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullish(),
  type: RewardTypeEnum,
  required_points: z.number().int().nonnegative().default(0),
  can_earn_multiple: z.boolean().default(false),
  image_url: z.string().url().nullish(),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Reward = z.infer<typeof Reward>;

export const UserReward = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  reward_id: z.string().uuid(),
  reward_type: z.string().nullish(), // From DB schema
  earned_at: z.string().datetime(),
  points_spent: z.number().int().nonnegative().default(0),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type UserReward = z.infer<typeof UserReward>;

export const PointTransaction = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  points: z.number().int(),
  reason: z.string(),
  source_type: z.string(),
  source_id: z.string().uuid().nullish(),
  created_at: z.string().datetime(),
});
export type PointTransaction = z.infer<typeof PointTransaction>;

export const BadgeDefinition = z.object({
  id: z.string(), // From DB: text primary key
  title: z.string(),
  description: z.string().nullish(),
  icon: z.string(),
});
export type BadgeDefinition = z.infer<typeof BadgeDefinition>;

export const UserBadge = z.object({
  // Note: user_badges might be merged into user_rewards with type='badge'
  user_id: z.string().uuid(),
  badge_id: z.string(), // Matches badge_definitions.id (text)
  earned_at: z.string().datetime(),
  progress: z.number().nullish(), // From DB schema
});
export type UserBadge = z.infer<typeof UserBadge>;

export const Reminder = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
  reminder_time: z.string().datetime(),
  is_active: z.boolean().default(true),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Reminder = z.infer<typeof Reminder>;

export const GoalProgressNote = z.object({
  id: z.string().uuid(),
  goal_id: z.string().uuid(),
  user_id: z.string().uuid(),
  note: z.string(),
  created_at: z.string().datetime(),
});
export type GoalProgressNote = z.infer<typeof GoalProgressNote>;

/* ------------------------------------------------------------------
 * Router‑level Schemas – inputs & outputs for every procedure
 * ----------------------------------------------------------------*/
export const greetingInput = z.object({ name: z.string().optional() });
export const greetingOutput = z.object({ greeting: z.string() });

// User
export const updateProfileInput = UserProfile.partial().omit({ id: true, created_at: true, updated_at: true });
export const updateSettingsInput = z.object({
  notification_preferences: NotificationPrefs.partial().optional(),
  ui_preferences: UiPrefs.partial().optional(),
});

// Values
export const createValueInput = Value.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateValueInput = createValueInput.partial().extend({ id: z.string().uuid() });

// Principles
// Uses 'title' and 'body' from the updated Principle schema
export const createPrincipleInput = Principle.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updatePrincipleInput = createPrincipleInput.partial().extend({ id: z.string().uuid() });

// Goals
export const createGoalInput = Goal.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateGoalInput = createGoalInput.partial().extend({ id: z.string().uuid() });

// Tasks
export const createTaskInput = Task.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateTaskInput = createTaskInput.partial().extend({ id: z.string().uuid() });
export const updateTaskStatusInput = z.object({ id: z.string().uuid(), status: TaskStatusEnum });

// Habits
export const createHabitInput = Habit.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateHabitInput = createHabitInput.partial().extend({ id: z.string().uuid() });

// Habit Entries
export const createHabitEntryInput = HabitEntry.omit({ id: true, user_id: true, created_at: true });
export const updateHabitEntryInput = createHabitEntryInput.partial().extend({ id: z.string().uuid() });

// Tracked State Definitions
export const createTrackedStateDefInput = TrackedStateDef.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateTrackedStateDefInput = createTrackedStateDefInput.partial().extend({ id: z.string().uuid() });
export const GetTrackedStateDefByIdInput = z.object({ id: z.string().uuid() });
export const DeleteTrackedStateDefInput = z.object({ id: z.string().uuid() });

// State Entries
export const CreateStateEntryInput = StateEntry.omit({ id: true, user_id: true })
.extend({
  tracked_state_def_id: z.string().uuid(), // Ensure this is required
  // Values are optional in base schema
});
export const updateStateEntryInput = CreateStateEntryInput.partial().extend({ id: z.string().uuid() });
export const GetStateEntriesInput = z.object({
  tracked_state_def_id: z.string().uuid(), // Renamed from definition_id to match DB? Check usage.
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  limit: z.number().int().positive().optional(),
});
export const DeleteStateEntryInput = z.object({ id: z.string().uuid() });

// Rewards (Assuming rewards definitions are managed elsewhere)
// No create/update for Reward definitions needed via API?
export const claimLootInput = z.object({
  rewardId: z.string().uuid(), // Use rewardId to match router
});

// Badges
export const awardBadgeInput = z.object({
  badgeId: z.string(), // Matches text ID in badge_definitions
  description: z.string().optional(), // Example custom field if needed
});

// Reminders
export const createReminderInput = Reminder.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateReminderInput = createReminderInput.partial().extend({ id: z.string().uuid() });
export const GetRemindersForEntityInput = z.object({
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
});
export const DeleteReminderInput = z.object({ id: z.string().uuid() });

// Goal Progress Notes
export const createGoalProgressNoteInput = GoalProgressNote.omit({ id: true, user_id: true, created_at: true });
export const updateGoalProgressNoteInput = createGoalProgressNoteInput.partial().extend({ id: z.string().uuid() });
export const GetGoalProgressNotesInput = z.object({ goal_id: z.string().uuid() });
export const DeleteGoalProgressNoteInput = z.object({ id: z.string().uuid() });

/* ------------------------------------------------------------------
 * Aggregate Router Types – automatically inferred
 * ----------------------------------------------------------------*/
export type RouterInputs = inferRouterInputs<AppRouter>;
export type RouterOutputs = inferRouterOutputs<AppRouter>;

/*
  Usage (client‑side):

  const utils = trpc.useUtils();
  type TasksOutput = RouterOutputs['task']['getTasks'];
  type CreateTaskInput = RouterInputs['task']['createTask'];
*/```
\n\n## Points/Rewards Handler: index.ts
**File:** server/src/types/index.ts
\n```
export type ValueId = string;
export type GoalId = string;
export type TaskId = string;
export type HabitId = string;
export type BadgeId = string;

export interface Value {
  id: ValueId;
  name: string;
  description?: string;
  color: string; // tailwind color token (e.g. 'indigo-500')
  domainId?: string; // optional grouping
}

export interface Goal {
  id: GoalId;
  title: string;
  description?: string;
  valueIds: ValueId[];
  progress: number; // 0‒1
  keyResults: KeyResult[];
  targetDate?: string; // ISO
}

export interface KeyResult {
  id: string;
  title: string;
  progress: number; // 0‒1
}

export interface Task {
  id: TaskId;
  title: string;
  notes?: string;
  status: 'todo' | 'doing' | 'done' | 'blocked';
  due?: string; // ISO date
  priority?: 1 | 2 | 3;
  goalId?: GoalId;
  valueIds?: ValueId[];
}

export interface Habit {
  id: HabitId;
  title: string;
  cue?: string;
  routine?: string;
  reward?: string;
  valueIds: ValueId[];
  streak: number; // current consecutive days
  bestStreak: number;
  history: Record<string, boolean>; // ISO day → done?
}

export interface Principle {
  id: string;
  title: string;
  body: string;
  valueIds: ValueId[];
}

export interface TrackedStateDef {
  id: string;
  name: string;
  scale: '1-5' | 'low-high' | 'custom';
  customLabels?: string[];
  valueIds: ValueId[];
}

export interface Badge {
  id: BadgeId;
  title: string;
  icon: string; // Hero‑icons name or emoji
  earnedAt?: string; // ISO
  progress?: number; // 0‒1 for not‑yet
} ```
\n\n## Points/Rewards Handler: router.ts
**File:** server/src/router.ts
\n```
import { initTRPC } from '@trpc/server';
import { z } from 'zod';
import { TRPCError } from '@trpc/server';
import { supabaseAdmin, Context } from './context';

// Initialize tRPC with Supabase context
const t = initTRPC.context<Context>().create();

// Public procedure (no auth required)
export const router = t.router;
export const publicProcedure = t.procedure;

// Protected procedures ensure user is authenticated
export const protectedProcedure = t.procedure.use(({ ctx, next }) => {
  if (!ctx.userId) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }
  return next({ ctx: { supabaseAdmin: ctx.supabaseAdmin, userId: ctx.userId } });
});

// Import individual routers
import { dashboardRouter } from './routers/dashboardRouter';
import { valueRouter } from './routers/valueRouter';
import { principleRouter } from './routers/principleRouter';
import { goalRouter } from './routers/goalRouter';
import { taskRouter } from './routers/taskRouter';
import { habitRouter } from './routers/habitRouter';
import { trackedStateRouter } from './routers/trackedStateRouter';
import { userRouter } from './routers/userRouter';
import { rewardsRouter } from './routers/rewardsRouter';
import { reminderRouter } from './routers/reminderRouter';
import { goalProgressNoteRouter } from './routers/goalProgressNoteRouter';

// Create the router with Supabase-backed procedures
export const appRouter = router({
  greeting: {
    hello: publicProcedure
      .input(z.object({ name: z.string().optional() }))
      .query(async ({ input }) => {
        return { greeting: `Hello ${input.name ?? 'world'}` };
      }),
    goodbye: publicProcedure
      .query(() => {
        return { greeting: 'Goodbye!' };
      }),
  },
  user: userRouter,
  dashboard: dashboardRouter,
  value: valueRouter,
  principle: principleRouter,
  goal: goalRouter,
  task: taskRouter,
  habit: habitRouter,
  state: trackedStateRouter,
  rewards: rewardsRouter,
  reminder: reminderRouter,
  goalProgressNote: goalProgressNoteRouter,
});

// Export type router type
export type AppRouter = typeof appRouter; ```
\n\n# 3️⃣ Realtime Strategy
\n## Supabase Realtime Implementation
\n\n## Realtime Channel: compose.tsx
**File:** ./app/compose.tsx
\n```
// app/compose.tsx
import React from 'react';
import { ScrollView } from 'react-native'; // Using RN ScrollView directly
import { Stack, useRouter, useLocalSearchParams } from 'expo-router';
import { YStack, XStack, Form, Input, Label, TextArea, Button, Switch, Paragraph, Spinner } from 'tamagui';
import { useForm, Controller, ControllerRenderProps, FieldValues } from 'react-hook-form'; // Import ControllerRenderProps
import { zodResolver } from '@hookform/resolvers/zod';
import { useToastController } from '@tamagui/toast'; // Assuming ToastProvider is set up

import { trpc, type RouterInputs } from '@/utils/trpc'; // Assuming inputs are exported like this
import { haptics } from '@/utils/haptics'; // Assuming haptics helper exists

// Assuming your Zod schemas are exported like this. Adjust if necessary.
type CreateValueInput = RouterInputs['value']['createValue'];
type CreateStateInput = RouterInputs['state']['createDefinition'];

// 1️⃣ Define tagged types for discriminated union
type CreateValueInputTagged = CreateValueInput & { __type: 'value' };
type CreateStateInputTagged = CreateStateInput & { __type: 'state' };
type FormValues = CreateValueInputTagged | CreateStateInputTagged;

export default function ComposeModal() {
  const router = useRouter();
  const params = useLocalSearchParams<{ type: string }>();
  const type = params.type === 'value' || params.type === 'state' ? params.type : undefined;
  const toast = useToastController();
  const utils = trpc.useUtils();

  const isValue = type === 'value';

  // 2️⃣ Define stricter default values using tagged types
  const defaultValueValues: CreateValueInputTagged = {
    __type: 'value',
    title: '', // Use 'title' instead of 'name' - Patch #4
    description: ''
  };
  const defaultStateValues: CreateStateInputTagged = {
    __type: 'state',
    name: '',
    scale: '1-5',
    description: '',
    active: true,
    priority: 50
  };

  // --- Separate useMutation hooks ---
  const createValueMutation = trpc.value.createValue.useMutation({
    onSuccess: (data) => handleSuccess(data),
    onError: (error) => handleError(error),
  });
  const createStateDefMutation = trpc.state.createDefinition.useMutation({
    onSuccess: (data) => handleSuccess(data),
    onError: (error) => handleError(error),
  });

  // --- Form setup ---
  const { control, handleSubmit, formState: { errors }, reset } = useForm<FormValues>({
    // Note: ZodResolver might need specific configuration if schemas differ vastly
    // or consider not using it if relying solely on backend validation for this dynamic form.
    // Use the new stricter default value constants
    defaultValues: isValue ? defaultValueValues : defaultStateValues,
  });

  // Reset form if the type changes dynamically
  React.useEffect(() => {
    // Use the new stricter default value constants for reset
    reset(isValue ? defaultValueValues : defaultStateValues);
  }, [isValue, reset]);

  // --- Shared success/error handlers ---
  const handleSuccess = (data: any) => {
      toast.show('Created successfully!', { native: true });
      haptics.success();
      if (isValue) {
        utils.value.getValues.invalidate();
      } else {
        utils.state.getDefinitions.invalidate();
      }
      if (router.canGoBack()) {
        router.dismiss(); // Apply patch #5 - Use dismiss for modals
      } else {
        router.replace('/(tabs)/compass');
      }
  }

  const handleError = (error: any) => {
       toast.show(`Error: ${error.message}`, { type: 'error', native: true });
       haptics.error();
  }

  // --- Corrected onSubmit ---
  const onSubmit = (formData: FormValues) => {
    // 3️⃣ Use discriminant (__type) for type safety, remove casts
    if (formData.__type === 'value') {
      createValueMutation.mutate(formData);
    } else { // formData.__type === 'state'
      createStateDefMutation.mutate(formData);
    }
  };

  // Handle invalid type parameter gracefully
  if (!type) {
    return (
        <YStack flex={1} justifyContent="center" alignItems="center" padding="$4">
            <Paragraph color="$error">Invalid type specified.</Paragraph> {/* Use $error */}
            <Button onPress={() => router.back()} marginTop="$4">Go Back</Button>
        </YStack>
    );
  }

  // Determine current mutation state for button
  const isPending = isValue ? createValueMutation.isPending : createStateDefMutation.isPending;

  return (
    <ScrollView contentContainerStyle={{ flexGrow: 1 }}>
      <Form onSubmit={handleSubmit(onSubmit)} flex={1} padding="$4" space="$4" backgroundColor="$background">
        <Stack.Screen options={{ title: isValue ? 'Add Principle' : 'Define State' }} />

        {/* Conditionally render form fields */}
        {isValue ? (
          <>
            {/* --- Fields for Principle/Value --- */}
            <YStack space="$2">
              <Label htmlFor="title">Title</Label> {/* Patch #4: name -> title */}
              <Controller
                name="title" /* Patch #4: name -> title */
                control={control}
                rules={{ required: 'Title is required' }} /* Patch #4 */
                render={({ field }) => ( /* Use inferred types from FormValues */
                  <Input
                    id="title"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value}
                    placeholder="Principle Title"
                  />
                )}
              />
              {/* Use $error token */}
              {errors.title && <Paragraph color="$error">{errors.title?.message}</Paragraph>}
            </YStack>

            <YStack space="$2">
              <Label htmlFor="description">Description (Optional)</Label>
              <Controller
                name="description"
                control={control}
                render={({ field }) => ( // Use inferred types
                  <TextArea
                    id="description"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value ?? ''}
                    placeholder="Describe the principle..."
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && <Paragraph color="$error">{errors.description?.message}</Paragraph>}
            </YStack>
          </>
        ) : (
          <>
            {/* --- Fields for State Definition --- */}
            <YStack space="$2">
              <Label htmlFor="name">State Name</Label>
              <Controller
                name="name"
                control={control}
                rules={{ required: 'Name is required' }}
                render={({ field }) => ( // Use inferred types // Explicit type
                  <Input
                    id="name"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value}
                    placeholder="e.g., Energy Level, Mood" />
                )}
              />
              {errors.name && <Paragraph color="$error">{errors.name?.message}</Paragraph>}
            </YStack>

             <YStack space="$2">
               <Label htmlFor="scale">Scale</Label>
               <Controller
                 name="scale"
                 control={control}
                 rules={{ required: 'Scale is required' }}
                 render={({ field }) => ( // Use inferred types
                   <>
                    <Paragraph>Scale Selector Placeholder (Selected: {field.value})</Paragraph>
                    <XStack space="$2">
                      {/* Removed invalid theme prop */}
                      <Button size="$2" onPress={() => field.onChange('1-5')} theme={field.value === '1-5' ? 'active' : undefined}>1-5</Button>
                      <Button size="$2" onPress={() => field.onChange('1-10')} theme={field.value === '1-10' ? 'active' : undefined}>1-10</Button>
                    </XStack>
                   </>
                 )}
               />
                {errors.scale && <Paragraph color="$error">{errors.scale?.message}</Paragraph>}
             </YStack>

             <YStack space="$2">
              <Label htmlFor="description">Description (Optional)</Label>
              <Controller
                name="description"
                control={control}
                render={({ field }) => ( // Use inferred types
                  <TextArea
                    id="description"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value ?? ''}
                    placeholder="Describe when/how to track this state..."
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && <Paragraph color="$error">{errors.description?.message}</Paragraph>}
            </YStack>

            <XStack space="$4" alignItems="center">
               <Label htmlFor="active" flex={1}>Active</Label>
               <Controller
                 name="active"
                 control={control}
                 render={({ field }: { field: ControllerRenderProps<FieldValues, 'active'> }) => ( // Explicit type
                    <Switch
                      id="active"
                      checked={!!field.value} // Use checked
                      onCheckedChange={field.onChange} // Use onCheckedChange
                      size="$3"
                    >
                        <Switch.Thumb animation="quick" />
                    </Switch>
                 )}
               />
            </XStack>
          </>
        )}

        {/* Removed invalid theme prop */}
        <Form.Trigger asChild disabled={isPending}>
          <Button icon={isPending ? <Spinner /> : undefined}>
            {isPending ? 'Saving...' : 'Save'}
          </Button>
        </Form.Trigger>
      </Form>
    </ScrollView>
  );
}```
\n\n## Realtime Channel: index.tsx
**File:** ./app/(tabs)/home/index.tsx
\n```
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/home/index.tsx
import React, { useCallback, useMemo } from 'react';
import { YStack, H1, Text, XStack, Button, ScrollView, Spinner } from 'tamagui';
import { SafeAreaView, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc, RouterOutputs } from '@/utils/trpc';
import DashboardSection from '@/components/dashboard/DashboardSection';
import GoalSummaryCard from '@/components/dashboard/GoalSummaryCard';
import HabitCheckItem from '@/components/dashboard/HabitCheckItem';
import TaskItem from '@/components/dashboard/TaskItem';
import StateIndicator from '@/components/dashboard/StateIndicator';
import DailyProgressBanner from '@/components/dashboard/DailyProgressBanner'; // Import Banner
import EmptyOrSkeleton from '@/components/ui/EmptyOrSkeleton';
import { SkeletonCard, SkeletonRow } from '@/components/ui/Skeleton';
import { useSkeleton } from '@/hooks/useSkeleton';
import { useColorScheme } from '@/hooks/useColorScheme';
import { useToastController } from '@tamagui/toast';
import { BlurView } from 'expo-blur';
import { Plus } from '@tamagui/lucide-icons';
import LottieView from 'lottie-react-native';
import SwipeableRow from '@/components/ui/SwipeableRow'; // Import SwipeableRow

// Types inferred from tRPC Router
type RouterOutput = RouterOutputs['dashboard']['getDashboardData'];
// --- Define types for the STRUCTURE AFTER mapping in useMemo ---
export type DashboardGoal = {
  id: string;
  title: string;
  progress: number;
  tasks: { completed: number; total: number };
  // Include other relevant fields if needed by GoalSummaryCard
  status?: string | null; 
  priority?: number | null;
};
export type DashboardHabit = {
  id: string;
  name: string;
  description?: string | null;
  completed: boolean; // Mapped from completedToday
  streak: number;
  last_entry_id?: string; // Mapped from habit.last_entry_id (null -> undefined)
  habit_type?: string | null;
};
export type DashboardTask = {
  id: string;
  name: string;
  status: string | null; // Allow null
  due_date?: Date | string | null;
  // Include other relevant fields if needed by TaskItem
};
export type DashboardState = {
  id: string;
  name: string | null;
  unit: string | null;
  currentValue: number | string | null;
  lastUpdated: string | null;
  lastEntry: { value: number | null; created_at: Date | string } | null; // Explicitly include lastEntry
};
// --- End mapped type definitions ---

export default function HomeScreen() {
  const colorScheme = useColorScheme();
  const toast = useToastController();
  const utils = trpc.useUtils(); // Get tRPC utils for mutations
  
  // Define types using RouterOutputs for clarity and safety
  // type DashboardGoal = RouterOutputs['dashboard']['getDashboardData']['goals'][number];
  // type DashboardHabit = RouterOutputs['dashboard']['getDashboardData']['habits'][number];
  // type DashboardTask = RouterOutputs['dashboard']['getDashboardData']['tasks'][number];

  // Use tRPC hooks to fetch data - Types are inferred but can be explicitly used
  const { 
    data: dashboardData, 
    isLoading, 
    error, 
    refetch,
    isRefetching 
  } = trpc.dashboard.getDashboardData.useQuery();

  // Define the habit entry mutation hook
  const createHabitEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: () => {
      refetch(); // Refresh data after successful mutation
      // Optional: Add success toast
      // toast.show('Habit updated!', { type: 'success' });
    },
    onError: (error) => {
      // Handle tRPC client error
      toast.show(error.message || 'Failed to update habit', { type: 'error' });
    }
  });

  // Handle errors
  React.useEffect(() => {
    if (error) {
      toast.show(error.message || 'Failed to load dashboard data', { type: 'error' });
    }
  }, [error, toast]);

  // Set up pull-to-refresh
  const onRefresh = useCallback(() => {
    refetch();
  }, [refetch]);

  // Custom skeleton states from your hooks
  const { isLoading: skeletonsLoading, count: skeletonCount = 3 } = {
    isLoading,
    count: 3 // Number of skeleton items to show
  };
  
  // Generate skeleton UI based on loading state
  const renderSkeletons = () => {
    return Array.from({ length: skeletonCount }).map((_, index) => (
      <SkeletonCard key={`skeleton-${index}`} />
    ));
  };

  // Get current date and greeting
  const greeting = getGreeting();
  const currentDate = new Date().toLocaleDateString('en-US', { 
    weekday: 'long', 
    month: 'long', 
    day: 'numeric' 
  });

  const dashboardDataMemo = useMemo(() => {
    // Fix: Add check to ensure dashboardData exists before accessing properties
    if (!dashboardData) {
      return null; // Or return default structure: { goals: [], habits: [], tasks: [], trackedStates: [] }
    }

    // Map and filter data, ensuring structure matches exported types
    return {
      // Filter goals to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      goals: (dashboardData.goals ?? [])
        .filter((goal): goal is typeof goal & { id: string } => !!goal?.id)
        .map((goal) => ({
        // Map to DashboardGoal structure
        id: goal.id, 
        title: goal.title ?? 'Untitled Goal', // Provide default for title
        progress: goal.progress ?? 0, 
        tasks: goal.tasks ?? { completed: 0, total: 0 }, 
        status: goal.status,
        priority: goal.priority,
      })),
      // Filter habits to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      habits: (dashboardData.habits ?? [])
        .filter((habit): habit is typeof habit & { id: string } => !!habit?.id)
        .map((habit) => ({
        // Map to DashboardHabit structure
        id: habit.id, 
        name: habit.name ?? 'Unnamed Habit', // Provide default for name
        description: habit.description,
        completed: habit.completedToday ?? false, // Map completedToday to completed
        streak: habit.streak ?? 0, 
        last_entry_id: habit.last_entry_id ?? undefined, // Map null to undefined
        habit_type: habit.habit_type,
      })),
      // Filter tasks to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      tasks: (dashboardData.tasks ?? [])
        .filter((task): task is typeof task & { id: string } => !!task?.id)
        .map((task) => ({
        // Map to DashboardTask structure
        id: task.id,
        name: task.name ?? 'Untitled Task', // Provide default name
        status: task.status,
        due_date: task.due_date,
      })),
      // Map trackedStates, ensuring lastEntry is preserved
      // Fix: Use nullish coalescing and optional chaining
      trackedStates: (dashboardData.trackedStates ?? [])
        .filter((state): state is typeof state & { id: string } => !!state?.id)
        .map((trackedState) => ({
        // Map to DashboardState structure
        id: trackedState.id,
        name: trackedState.name,
        unit: trackedState.unit,
        currentValue: trackedState.currentValue,
        lastUpdated: trackedState.lastUpdated,
        // Ensure lastEntry structure matches definition or is null
        lastEntry: trackedState.lastEntry ?? null, 
      })),
    };
  }, [dashboardData]);

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <ScrollView 
        showsVerticalScrollIndicator={false}
        contentContainerStyle={{ paddingBottom: 100 }}
        refreshControl={
          <RefreshControl
            refreshing={isRefetching}
            onRefresh={onRefresh}
            tintColor="transparent" // Hide default spinner
            colors={['transparent']} // Hide default spinner (Android)
            progressBackgroundColor="transparent" // Hide default bg (Android)
            refreshingComponent={
              <LottieView
                source={require('@/assets/refresh-sheikah.json')} // ASSUMES this file exists
                autoPlay
                loop
                style={{ width: 48, height: 48, alignSelf: 'center' }} // Center the animation
              />
            }
          />
        }
      >
        <YStack space="$4" paddingHorizontal="$4">
          {/* Header */}
          <YStack space="$1">
            <H1>{greeting}</H1>
            <Text color="$gray10">{currentDate}</Text>
          </YStack>

          {/* Daily Progress Banner */}
          <DailyProgressBanner 
            // tasksCompleted={...} 
            // totalTasks={...} 
            // habitsChecked={...} 
            // totalHabits={...} 
          />

          {/* Goals Section */}
          <DashboardSection 
            title="Goals"
            onSeeAll={() => router.push('/planner')}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load goals"
              />
            ) : !dashboardDataMemo?.goals || dashboardDataMemo.goals.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No goals yet"
                actionText="Create a goal"
                onAction={() => router.push('/planner/add-goal')}
              />
            ) : (
              <YStack space="$3">
                {dashboardDataMemo.goals.slice(0, 3).map((goal) => (
                  <SwipeableRow
                    key={goal.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.goal.delete.mutate({ id: goal.id })
                      console.log('Attempting to delete goal:', goal.id); // Placeholder
                      // utils.goal.delete.mutate({ id: goal.id });
                    }}
                  >
                    <GoalSummaryCard
                      goal={goal}
                      onPress={() => router.push(`/planner/goal/${goal.id}`)}
                    />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>

          {/* Today's Habits */}
          <DashboardSection 
            title="Today's Habits"
            onSeeAll={() => router.push('/planner?tab=habits')}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load habits"
              />
            ) : !dashboardDataMemo?.habits || dashboardDataMemo.habits.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No habits for today"
                actionText="Create a habit"
                onAction={() => router.push('/planner/add-habit')}
              />
            ) : (
              <YStack space="$2">
                {dashboardDataMemo.habits.slice(0, 4).map((habit) => (
                  <SwipeableRow
                    key={habit.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.habit.delete.mutate({ id: habit.id })
                      console.log('Attempting to delete habit:', habit.id); // Placeholder
                      // utils.habit.delete.mutate({ id: habit.id });
                    }}
                  >
                    <HabitCheckItem habit={habit} />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>

          {/* Today's State */}
          <DashboardSection
            title="Today's State"
            // TODO: Add navigation to a dedicated state tracking screen
            onSeeAll={() => console.log('Navigate to State Tracking screen')}
          >
            {isLoading ? (
              renderSkeletons() // Use generic skeletons or specific state skeletons
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load state"
              />
            ) : !dashboardDataMemo?.trackedStates || dashboardDataMemo.trackedStates.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No states being tracked"
                actionText="Track a state"
                // TODO: Navigate to state definition creation screen
                onAction={() => console.log('Navigate to Add State screen')}
              />
            ) : (
              <XStack space="$3" flexWrap="wrap"> 
                {dashboardDataMemo.trackedStates.map((stateData) => (
                  <StateIndicator
                    key={stateData.id}
                    state={stateData} // Pass the whole state object which includes lastEntry
                    lastEntry={stateData.lastEntry} // Pass lastEntry explicitly
                    // TODO: Handle interaction - e.g., navigate to state detail/entry screen
                    onPress={() => console.log('State pressed:', stateData.id)}
                  />
                ))}
              </XStack>
            )}
          </DashboardSection>

          {/* Upcoming Tasks */}
          <DashboardSection 
            title="Upcoming Tasks"
            onSeeAll={() => {/* Navigate to tasks list */}}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load tasks"
              />
            ) : !dashboardDataMemo?.tasks || dashboardDataMemo.tasks.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No upcoming tasks"
                actionText="Create a task"
                onAction={() => {/* Navigate to create task */}}
              />
            ) : (
              <YStack space="$2">
                {dashboardDataMemo.tasks.slice(0, 5).map((task) => (
                  <SwipeableRow
                    key={task.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.task.delete.mutate({ id: task.id })
                      console.log('Attempting to delete task:', task.id); // Placeholder
                      // utils.task.delete.mutate({ id: task.id });
                    }}
                  >
                    <TaskItem
                      task={{
                        // Explicitly pass props matching DashboardTask type
                        id: task.id, // Ensure id is passed
                        name: task.name, // Already defaulted in map
                        status: task.status, // Pass status
                        due_date: task.due_date, // Pass due_date
                      }}
                      isLast={false} // Adjust if needed for styling
                      onPress={() => console.log('Task Item Pressed:', task.id)}
                    />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>
        </YStack>
      </ScrollView>
      <QuickAddFAB />
    </SafeAreaView>
  );
}

// Helper function for greeting
function getGreeting() {
  const hour = new Date().getHours();
  if (hour < 12) return 'Good Morning';
  if (hour < 18) return 'Good Afternoon';
  return 'Good evening';
}

// Quick Add FAB Component
function QuickAddFAB() {
  return (
    <BlurView intensity={40} tint="default" style={{ position:'absolute', bottom:24, right:24, borderRadius:32, overflow: 'hidden' }}>
      <Button
        circular
        size="$5"
        backgroundColor="$accent"
        icon={Plus}
        elevate
        shadowColor="$shadowColor"
        shadowRadius={5}
        shadowOffset={{ width: 0, height: 2 }}
        pressStyle={{ scale: 0.95, opacity: 0.9 }}
        onPress={() => {
          router.push('/planner/add-task');
        }}
      />
    </BlurView>
  );
}
```
\n\n## Realtime Channel: index.tsx
**File:** ./app/(tabs)/planner/index.tsx
\n```
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/planner/index.tsx
import React, { useState, Suspense } from 'react';
import { YStack, XStack, Text, Tabs, Button, Spinner, Card, ScrollView } from 'tamagui';
import { SafeAreaView, FlatList, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { RouterOutputs } from '@/utils/api-types';
import { SectionError } from '@/components/ui/ErrorBanner';


interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'goals',
    title: 'Goals',
    icon: <Ionicons name="trophy-outline" size={18} color="currentColor" />
  },
  {
    key: 'habits',
    title: 'Habits',
    icon: <Ionicons name="repeat-outline" size={18} color="currentColor" />
  },
  {
    key: 'calendar',
    title: 'Calendar',
    icon: <Ionicons name="calendar-outline" size={18} color="currentColor" />
  }
];

export default function PlannerScreen() {
  const [activeTab, setActiveTab] = useState<string>('goals');
  const colorScheme = useColorScheme();
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Planner</Text>
          <Button
            size="$3"
            circular
            onPress={() => {/* Handle new item */}}
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>
        
        {/* Tabs */}
        <Tabs
          defaultValue="goals"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List 
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {tab.icon}
                  <Text>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>
          
          {/* Tab Content */}
          <Tabs.Content value="goals" flex={1}>
            <ScrollView>
              <GoalsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="habits" flex={1}>
            <ScrollView>
              <HabitsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="calendar" flex={1}>
            <ScrollView>
              <CalendarTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Goals Tab
function GoalsTab() {
  // Fetch goals using tRPC
  const { data: goals, isLoading, error, refetch } = trpc.goal.getGoals.useQuery();
  
  // Define the inferred type for a single goal
  type PlannerGoal = RouterOutputs['goal']['getGoals'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load goals" 
      />
    );
  }
  
  if (!goals || goals.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No goals yet" 
        actionText="Create a goal" 
        onAction={() => router.push('/planner/add-goal')} 
      />
    );
  }
  
  return (
    <YStack space="$4">
      {goals.map((goal: PlannerGoal) => (
        <Button 
          key={goal.id} 
          height="$12" 
          justifyContent="flex-start" 
          paddingHorizontal="$3"
          onPress={() => router.push({ pathname: '/planner/goal/[id]', params: { id: goal.id } })}
        >
          <YStack>
            <Text fontWeight="bold">{goal.title}</Text>
            <Text fontSize="$2" color="$gray10">
              {goal.dueDate ? new Date(goal.dueDate).toLocaleDateString() : 'No due date'}
            </Text>
          </YStack>
        </Button>
      ))}
    </YStack>
  );
}

// Habits Tab
function HabitsTab() {
  // Fetch habits using tRPC
  const { data: habits, isLoading, error, refetch } = trpc.habit.getHabits.useQuery();
  
  // Define the inferred type for a single habit
  type PlannerHabit = RouterOutputs['habit']['getHabits'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={isLoading} count={3} type="row" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load habits" 
      />
    );
  }
  
  if (!habits || habits.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No habits yet" 
        actionText="Create a habit" 
        onAction={() => router.push('/planner/add-habit')} 
      />
    );
  }
  
  return (
    <YStack space="$3">
      {habits.map((habit: PlannerHabit) => (
        <XStack 
          key={habit.id} 
          justifyContent="space-between" 
          alignItems="center" 
          paddingVertical="$3" 
          paddingHorizontal="$3" 
          borderBottomWidth={1} 
          borderColor="$gray5"
          pressStyle={{ opacity: 0.7 }}
          tag="pressable"
          onPress={() => router.push({ pathname: '/planner/habit/[id]', params: { id: habit.id } })}
        >
          <Text>{habit.title}</Text>
          <Button
            size="$2"
            circular
            backgroundColor={habit.completed ? '$green9' : '$gray9'}
            onPress={() => {
              // Use today's date for the habit entry
              const today = new Date().toISOString().split('T')[0];
              
              // Create a mutation to toggle habit completion
              const toggleHabit = trpc.habit.createHabitEntry.useMutation({
                onSuccess: () => {
                  refetch(); // Refresh data after toggling
                },
                onError: (error) => {
                  // Show error message
                  console.error('Failed to toggle habit:', error.message);
                }
              });
              
              // Toggle the habit completion status
              toggleHabit.mutate({
                habitId: habit.id,
                completed: !habit.completed,
                date: today
              });
            }}
            icon={<Ionicons name="checkmark" size={18} color="white" />}
          />
        </XStack>
      ))}
    </YStack>
  );
}

// Calendar Tab
function CalendarTab() {
  return (
    <YStack alignItems="center" justifyContent="center" padding="$8">
      <Text fontSize="$5" textAlign="center">
        Calendar integration coming soon
      </Text>
      <Text marginTop="$2" color="$gray10" textAlign="center">
        This tab will display task and habit schedules in a calendar view
      </Text>
    </YStack>
  );
}
```
\n\n## Realtime Channel: index.tsx
**File:** ./app/(tabs)/rewards/index.tsx
\n```
// Rewards screen with grid/list toggle and claim functionality
import React, { useState, useCallback } from 'react';
import { YStack, XStack, Text, Button, ScrollView, Card, Checkbox, useTheme, H1 } from 'tamagui';
import { SafeAreaView, View, FlatList, ImageBackground, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { RouterOutputs } from '@/utils/trpc'; // Import RouterOutputs
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton'; // Import helper component

// Define inferred type for rewards
type RewardItem = RouterOutputs['rewards']['getAvailableRewards'][number];

enum ViewMode {
  Grid = 'grid',
  List = 'list'
}

export default function RewardsScreen() {
  const [viewMode, setViewMode] = useState<ViewMode>(ViewMode.Grid);
  const colorScheme = useColorScheme();
  const theme = useTheme();

  // Define fallback colors
  const blue2 = theme?.blue2?.val ?? '#eff6ff';
  const blue5 = theme?.blue5?.val ?? '#60a5fa';
  const blue10 = theme?.blue10?.val ?? '#1e40af';
  const blue11 = theme?.blue11?.val ?? '#1e3a8a';
  const green9 = theme?.green9?.val ?? '#16a34a';

  // Fetch available rewards from tRPC
  const { 
    data: rewards, 
    isLoading, 
    error, 
    refetch 
  } = trpc.rewards.getAvailableRewards.useQuery();

  // Mutation for claiming rewards
  const claimMutation = trpc.rewards.earnReward.useMutation({
    onSuccess: (data) => {
      console.log('Reward claimed successfully:', data);
      // Maybe show confetti?
      Alert.alert('Reward Claimed!', `You spent ${data.reward.points_spent} points. Remaining: ${data.remainingPoints}`);
      refetch(); // Refetch the list of available rewards
    },
    onError: (err) => {
      console.error('Failed to claim reward:', err);
      Alert.alert('Claim Failed', err.message || 'Could not claim reward.');
    }
  });
  
  const handleClaimReward = useCallback((rewardId: string) => {
    if (claimMutation.isPending) return; // Prevent double-clicks
    
    Alert.alert(
      'Confirm Claim',
      'Are you sure you want to spend points on this reward?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Claim', 
          onPress: () => {
            claimMutation.mutate({ rewardId });
          },
          style: 'default'
        }
      ]
    );
  }, [claimMutation]);
  
  const renderItem = ({ item }: { item: RewardItem }) => { // Use inferred type
    // Assuming backend field is image_url, map to imagePath
    const imagePath = item.image_url; 
    // All items from getAvailableRewards are considered claimable (not yet claimed)
    const claimed = false; 
    // Map required_points to pointCost
    const pointCost = item.required_points;

    if (viewMode === ViewMode.Grid) {
      return (
        <Card
          size="$4"
          bordered
          width={160}
          height={200}
          margin="$2"
          overflow="hidden"
          elevation="$2"
          opacity={claimed ? 0.7 : 1}
        >
          <ImageBackground
            source={{ uri: imagePath }}
            style={{ width: '100%', height: 100 }}
          >
            <View style={{ 
              position: 'absolute', 
              top: 5, 
              right: 5, 
              backgroundColor: blue5,
              borderRadius: 10,
              padding: 4
            }}>
              <Text color="white" fontSize="$2" fontWeight="bold">
                {pointCost} pts
              </Text>
            </View>
          </ImageBackground>
          
          <YStack padding="$2" flex={1} justifyContent="space-between">
            <Text fontSize="$4" fontWeight="bold" numberOfLines={1}>
              {item.name}
            </Text>
            
            <Button
              size="$2"
              themeInverse={claimed}
              backgroundColor={claimed ? undefined : blue10}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </YStack>
        </Card>
      );
    } else {
      return (
        <Card
          bordered
          margin="$2"
          padding="$3"
          opacity={claimed ? 0.7 : 1}
        >
          <XStack space="$3" alignItems="center">
            {imagePath && (
              <View style={{ 
                width: 60, 
                height: 60, 
                borderRadius: 8, 
                overflow: 'hidden',
                backgroundColor: theme.gray3.val
              }}>
                <ImageBackground
                  source={{ uri: imagePath }}
                  style={{ width: '100%', height: '100%' }}
                />
              </View>
            )}
            
            <YStack flex={1} space="$1">
              <Text fontSize="$5" fontWeight="bold">{item.name}</Text>
              <Text fontSize="$3" color="$gray11" numberOfLines={2}>{item.description}</Text>
              <Text fontSize="$3" color={blue10} fontWeight="500">{pointCost} points</Text>
            </YStack>
            
            <Button
              size="$3"
              backgroundColor={claimed ? undefined : blue10}
              themeInverse={claimed}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </XStack>
        </Card>
      );
    }
  };
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        <YStack space="$4">
          {/* Header */}
          <XStack justifyContent="space-between" alignItems="center">
            <H1>Rewards</H1>
            
            <XStack space="$2">
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.Grid ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.Grid)}
              >
                <Ionicons 
                  name="grid-outline" 
                  size={22} 
                  color={viewMode === ViewMode.Grid ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
              
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.List ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.List)}
              >
                <Ionicons 
                  name="list-outline" 
                  size={22} 
                  color={viewMode === ViewMode.List ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
            </XStack>
          </XStack>
          
          {/* Stats */}
          <Card padding="$3" backgroundColor={blue2}>
            <XStack justifyContent="space-between" alignItems="center">
              <Text fontSize="$5" fontWeight="bold" color={blue11}>Your Points</Text>
              <Text fontSize="$6" fontWeight="bold" color={blue10}>275</Text>
            </XStack>
          </Card>
        </YStack>
        
        {/* Content Area */} 
        <EmptyOrSkeleton 
          isLoading={isLoading}
          isEmpty={!isLoading && !error && (!rewards || rewards.length === 0)}
          isError={!!error}
          text={error ? error.message : 'No rewards available yet.'} // Use text for error OR empty msg
          onRetry={refetch}
          type={viewMode === ViewMode.Grid ? 'card' : 'row'}
          count={viewMode === ViewMode.Grid ? 6 : 3}
        >
          <FlatList
            key={viewMode} // Change key based on viewMode to force re-render
            data={rewards}
            renderItem={renderItem}
            keyExtractor={(item, index) =>
              `${item?.id ?? `tmp-${index}`}-${viewMode}`   // fall back to index if ID is missing
            }
            
            // Optional: Log corrupt data in development
            onLayout={() => {
              if (__DEV__) {
                const missing = (rewards ?? []).filter(r => !r?.id);
                if (missing.length) console.warn('Rewards missing id:', missing);
              }
            }}
            numColumns={viewMode === ViewMode.Grid ? 2 : 1}
            contentContainerStyle={{ paddingBottom: 50 }} // Add padding at the bottom
            // Optional Optimizations (Patch #6)
            initialNumToRender={8}
            removeClippedSubviews={true} // Note: Can have visual glitches on iOS sometimes
          />
        </EmptyOrSkeleton>

      </YStack>
    </SafeAreaView>
  );
}
```
\n\n## Realtime Channel: _layout.tsx
**File:** ./app/_layout.tsx
\n```
// app/_layout.tsx
import '../tamagui.config'; // Import config first!

import React, { useCallback, useEffect, useState, ReactNode, createContext, useContext } from 'react';
import { Slot, SplashScreen, useRouter, useSegments } from 'expo-router';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { StatusBar } from 'expo-status-bar';
import { View, ActivityIndicator, Platform } from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { useFonts } from 'expo-font';
import { useColorScheme } from 'react-native';
import { TamaguiProvider, Theme } from 'tamagui'; // Consolidate Tamagui imports
// tamagui config is already imported at the top of the file
import type { ThemeName } from '@tamagui/core'; // Ensure ThemeName is imported from @tamagui/core
import * as SecureStore from 'expo-secure-store'; // Import SecureStore

import { supabase } from '@/utils/supabase';

import type { Session } from '@supabase/supabase-js';

// Prevent the splash screen from auto-hiding
SplashScreen.preventAutoHideAsync();

/* ------------------------------------------------------------------ */
/*  1. Simple Auth-aware context                                       */
/* ------------------------------------------------------------------ */
interface AuthCtx {
  session: Session | null;
  isLoading: boolean;
}
export const AuthContext = React.createContext<AuthCtx>({
  session: null,
  isLoading: true,
});
export const useAuth = () => React.useContext(AuthContext);

/* ------------------------------------------------------------------ */
/*  2. The actual Provider                                             */
/* ------------------------------------------------------------------ */
function AuthProvider({ children }: { children: ReactNode }) {
  const [session, setSession] = useState<Session | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Initial session check
  useEffect(() => {
    supabase.auth.getSession().then(({ data }) => {
      setSession(data.session ?? null);
      setIsLoading(false);
      console.log('Initial session check:', data.session ? 'Session found' : 'No session');
    }).catch(error => {
        console.error("Error getting initial session:", error);
        setIsLoading(false);
    });

    // Subscribe to auth changes (login / logout / token refresh)
    const { data: authListener } = supabase.auth.onAuthStateChange(
      (_event, newSession) => {
        console.log('Auth state changed:', _event, newSession ? 'New session' : 'No session');
        setSession(newSession ?? null);
        // If the event is SIGNED_IN or TOKEN_REFRESHED, loading might briefly be true again
        // depending on how you handle redirects, but usually setting session is enough.
        // If SIGNED_OUT, ensure loading is false.
        if (_event === 'SIGNED_OUT') {
          setIsLoading(false);
        }
      },
    );

    return () => {
      authListener?.subscription.unsubscribe();
    };
  }, []);

  return (
    <AuthContext.Provider value={{ session, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
}

/* ------------------------------------------------------------------ */
/*  3. Enforce splash-screen logic & route guarding                    */
/* ------------------------------------------------------------------ */
function Root() {
  const { session, isLoading } = useAuth();
  const router = useRouter();
  const segments = useSegments(); // e.g., ["(tabs)", "home"] or ["(auth)", "login"]

  /* Load Fonts ----------------------------------------------------- */
  const [fontsLoaded, fontError] = useFonts({
    // Ensure font names match those used in tamagui.config.ts
    Inter: require('@tamagui/font-inter/otf/Inter-Medium.otf'),
    InterBold: require('@tamagui/font-inter/otf/Inter-Bold.otf'),
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
  });

  /* Handle Font Loading & Errors ----------------------------------- */
  useEffect(() => {
    if (fontError) {
      console.error("Font loading error:", fontError);
      // Decide how to handle font errors - maybe show an error message?
      // For now, we still need to hide splash eventually.
      SplashScreen.hideAsync();
    }
  }, [fontError]);

  /* Redirect Logic ------------------------------------------------- */
  useEffect(() => {
    // Wait until auth state is confirmed AND fonts are potentially loaded
    if (isLoading || !fontsLoaded && !fontError) return;

    const inAuthGroup = segments[0] === '(auth)';

    console.log(`Auth State: isLoading=${isLoading}, session=${!!session}, inAuthGroup=${inAuthGroup}, segments=${segments.join('/')}`);

    if (!session && !inAuthGroup) {
      console.log('Redirecting to login...');
      router.replace('/(auth)/login');
    } else if (session && inAuthGroup) {
      console.log('Redirecting to home...');
      router.replace('/(tabs)/home');
    } else {
        console.log('No redirect needed.');
    }
  }, [isLoading, session, segments, router, fontsLoaded, fontError]);

  /* Hide splash only when fonts loaded/error AND auth check done ---- */
  useEffect(() => {
    if ((fontsLoaded || fontError) && !isLoading) {
        console.log('Hiding SplashScreen...');
      SplashScreen.hideAsync();
    }
  }, [fontsLoaded, fontError, isLoading]);

  /* Show loading indicator until ready ----------------------------- */
  if (!fontsLoaded && !fontError || isLoading) {
    // Optionally, return the Splash Screen component itself or a custom loading view
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#1C1C1E' /* Approx dark bg */ }}>
        <ActivityIndicator size="large" color="#FFFFFF" />
      </View>
    );
  }

  // Once loaded and auth checked, render the content based on route
  return (
    <>
      <StatusBar style={Platform.OS === 'ios' ? 'light' : 'auto'} />
      <Slot />
    </>
  );
}

/* ------------------------------------------------------------------ */
/*  4. Wrap everything with SafeArea, Providers, etc.                  */
/* ------------------------------------------------------------------ */
import { ToastProvider, Toast, useToastState, ToastViewport } from '@tamagui/toast';
import { CheckCircle, AlertCircle, AlertTriangle, Info } from '@tamagui/lucide-icons';
import { YStack, XStack } from 'tamagui';
import { ThemeProvider, DarkTheme, DefaultTheme } from '@react-navigation/native';

const ACCENT_COLOR_KEY = 'userAccentColor';
const DEFAULT_ACCENT = 'blue'; // Set your default accent color theme name here

// Context to provide accent update function down the tree
const AccentContext = createContext({
  setAccent: (color: string) => {},
});
export const useAccent = () => useContext(AccentContext);

function RootLayoutNav() {
  const colorScheme = useColorScheme();
  const themeMode = colorScheme === 'dark' ? 'dark' : 'light';

  return (
    <ToastProvider swipeDirection="horizontal" duration={6000}>
      <Slot />
      <CurrentToast />
      <ToastViewport name="DefaultViewport" top={40} left={0} right={0} /> 
    </ToastProvider>
  );
}

function CurrentToast() {
  const currentToast = useToastState();

  if (!currentToast || currentToast.isHandledNatively) {
    return null;
  }

  const toastType = currentToast.customData?.type || 'info'; // Default to 'info'
  let themeName = 'toast_info'; // Default theme
  let IconComponent = Info;

  switch (toastType) {
    case 'success':
      themeName = 'toast_success';
      IconComponent = CheckCircle;
      break;
    case 'error':
      themeName = 'toast_error';
      IconComponent = AlertCircle;
      break;
    case 'warning':
      themeName = 'toast_warning';
      IconComponent = AlertTriangle;
      break;
  }

  return (
    <Theme name={themeName as ThemeName}> {/* Cast themeName to ThemeName */}
      <Toast
        key={currentToast.id}
        duration={currentToast.duration}
        enterStyle={{ opacity: 0, scale: 0.5, y: -25 }}
        exitStyle={{ opacity: 0, scale: 0.95, y: -10 }} // Adjusted exit style slightly
        y={0}
        opacity={1}
        scale={1}
        animation="bouncy" // Apply bouncy animation
        viewportName={currentToast.viewportName ?? 'DefaultViewport'}
        backgroundColor="$background" // Use background from the wrapped theme
        padding="$3"
        borderRadius="$4"
        marginHorizontal="$4"
        elevate
        shadowColor="$shadowColor"
      >
        <YStack space="$1">
          <XStack space="$2" alignItems="center">
            <IconComponent size={18} color="$color" /> {/* Use color from the wrapped theme */}
            <Toast.Title color="$color">{currentToast.title}</Toast.Title> {/* Use color from the wrapped theme */}
          </XStack>
          {!!currentToast.message && (
            <Toast.Description color="$color"> {/* Use color from the wrapped theme */}
              {currentToast.message}
            </Toast.Description>
          )}
        </YStack>
      </Toast>
    </Theme>
  );
}

function Providers({ children }: { children: React.ReactNode }) {
  const colorScheme = useColorScheme();
  const [accentColor, setAccentColor] = useState(DEFAULT_ACCENT);

  // Load accent color on mount
  useEffect(() => {
    const loadAccent = async () => {
      try {
        const savedAccent = await SecureStore.getItemAsync(ACCENT_COLOR_KEY);
        if (savedAccent) {
          setAccentColor(savedAccent);
        }
      } catch (error) {
        console.error('Failed to load accent color:', error);
      }
    };
    loadAccent();
  }, []);

  // Function to update and save accent color
  const handleSetAccent = useCallback(async (newColor: string) => {
    try {
      await SecureStore.setItemAsync(ACCENT_COLOR_KEY, newColor);
      setAccentColor(newColor);
    } catch (error) {
      console.error('Failed to save accent color:', error);
    }
  }, []);

  return (
    <AccentContext.Provider value={{ setAccent: handleSetAccent }}>
      <Theme name={accentColor as ThemeName}> {/* Cast accentColor to ThemeName */}
        {children}
      </Theme>
    </AccentContext.Provider>
  );
}

export default function RootLayout() {
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        {/* Core Providers (Tamagui, QueryClient, tRPC) */}
        <Providers>
          {/* Auth Provider manages session state */}
          <AuthProvider>
            {/* Root handles splash, font loading, and redirects */}
            <RootLayoutNav />
          </AuthProvider>
        </Providers>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}
```
\n\n## Realtime Channel: AppProvider.tsx
**File:** ./providers/AppProvider.tsx
\n```
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { httpBatchLink } from '@trpc/client';
import { useEffect, useState, type ReactNode } from 'react';
import { Platform } from 'react-native';
import { TamaguiProvider } from 'tamagui';

import { NativeWindProvider } from '@/components/ui/nativewind-setup';
import config from '../tamagui.config';
import { trpc } from '@/utils/trpc';
import { useUiStore } from '@/stores/uiStore'; // Import store to get theme

/**
 * Complete app provider that integrates:
 * - tRPC
 * - React Query
 * - Tamagui
 * - NativeWind
 * - Additional providers can be added here
 */
export function AppProvider({ children }: { children: ReactNode }) {
  // Create Query Client
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 1000, // 5 seconds
        retry: Platform.OS === 'web' ? 3 : 1, // Less retries on mobile to save battery
      },
    },
  }));
  
  // Create tRPC client
  const [trpcClient] = useState(() => 
    trpc.createClient({
      links: [
        httpBatchLink({
          url: 'http://localhost:3000/api/trpc',
          fetch: (input, init) => {
            return fetch(input, {
              ...init,
              credentials: 'include',
            });
          },
        }),
      ],
    })
  );
  
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';
  
  // You could add NATS initialization here
  useEffect(() => {
    // Example: Initialize NATS for real-time updates
    // Note: This is commented out since we don't have a real NATS server to connect to
    /*
    try {
      const url = 'ws://localhost:4222';
      initNatsClient(url, queryClient)
        .then(conn => {
          console.log('NATS client initialized successfully');
          // Set up subscriptions to relevant topics
          subscribeWithCache('users.updates', ['users']);
          subscribeWithCache('messages.updates', ['messages']);
        })
        .catch(err => {
          console.error('Failed to initialize NATS client:', err);
        });
    } catch (error) {
      console.error('Error in NATS setup:', error);
    }
    
    // Cleanup on unmount
    return () => {
      closeNatsConnection().catch(err => {
        console.error('Error closing NATS connection:', err);
      });
    };
    */
  }, [queryClient]);
  
  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <NativeWindProvider theme={currentTheme}>
          <TamaguiProvider config={config}>
            {children}
          </TamaguiProvider>
        </NativeWindProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
} ```
\n\n## Realtime Channel: Providers.tsx
**File:** ./providers/Providers.tsx
\n```
// providers/Providers.tsx
import '../tamagui.config'; // Ensure Tamagui config is loaded first!
import { getConfig } from '@tamagui/core';
console.log('Effective Tamagui config keys:', Object.keys(getConfig() ?? {}));
import { QueryClientProvider } from '@tanstack/react-query';
import { persistQueryClient } from '@tanstack/react-query-persist-client';
import { TamaguiProvider, type TamaguiProviderProps } from 'tamagui';
import { ToastProvider, ToastViewport } from '@tamagui/toast'; // Import from Tamagui Toast
import React, { useEffect, useState, type ReactNode } from 'react';
import { Platform } from 'react-native'; // Import Platform

import config from '../tamagui.config'; // Import your config
import { trpc } from '../utils/trpc'; // Your tRPC hook setup
import { queryClient, persister, initializeNetworkMonitoring, resumeMutationsAndInvalidate } from '@/utils/query-client';
import { useUiStore } from '@/stores/uiStore';
import { supabase } from '@/utils/supabase'; // Needed for auth link
import { createTRPCClient, httpBatchLink, TRPCLink, TRPCClientError } from '@trpc/client'; // Import TRPC Client utils
import { observable } from '@trpc/server/observable';
import type { AppRouter } from '../server/src/router'; // Adjust path if needed
import type { Session } from '@supabase/supabase-js';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

// Setup query client persistence
persistQueryClient({
  queryClient,
  persister,
  maxAge: 1000 * 60 * 60 * 24, // 24 hours
  dehydrateOptions: {
    shouldDehydrateMutation: () => false, // Usually don't dehydrate mutations
  },
});

// New component for the viewport using safe area
const CurrentToastViewport = () => {
  const { top, bottom, left, right } = useSafeAreaInsets();
  return (
    <>
      {/* Adjust positioning based on your desired toast location */}
      <ToastViewport
        name="global_top"
        flexDirection="column" // Stack new toasts below older ones
        top={top + 10} // Add padding below status bar
        left={left + 10} // Add padding from sides
        right={right + 10}
      />
      <ToastViewport
        name="global_bottom"
        flexDirection="column-reverse"
        bottom={bottom + 10}
        left={left + 10}
        right={right + 10}
      />
    </>
  );
};

// Extract tRPC links setup
function getTRPCLinks(getSession: () => Promise<Session | null>): TRPCLink<AppRouter>[] {
  const apiBaseUrl = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api/trpc'; // Default to localhost
  console.log('Using tRPC API URL:', apiBaseUrl);

  return [
    // Link to handle auth token injection and refresh
    (runtime) => {
      return ({ op, next }) => {
        return observable((observer) => {
          getSession().then(session => {
            const headers = (op.context?.headers || {}) as Record<string, string>;
            if (session?.access_token) {
              headers['Authorization'] = `Bearer ${session.access_token}`;
            }

            // Proceed with the request, ensuring context is passed correctly
            next({ ...op, context: { ...op.context, headers } })
              .subscribe({
                next: (value) => observer.next(value),
                error: async (err) => {
                  if (err instanceof TRPCClientError && err.data?.httpStatus === 401) {
                    console.log('tRPC: Token expired or invalid, attempting refresh...');
                    try {
                      // Supabase handles refresh internally if needed when getSession is called
                      const { data, error: refreshError } = await supabase.auth.refreshSession();
                      if (refreshError) throw refreshError;

                      if (data.session) {
                        console.log('tRPC: Session refreshed successfully, retrying request.');
                        const refreshedHeaders = { ...headers, Authorization: `Bearer ${data.session.access_token}` };
                        // Retry with new headers in context
                        next({ ...op, context: { ...op.context, headers: refreshedHeaders } }).subscribe(observer);
                      } else {
                        console.error('tRPC: Session refresh failed, no session returned.');
                        observer.error(err); // Propagate original error if no new session
                        // Optionally trigger logout here
                        supabase.auth.signOut();
                      }
                    } catch (refreshCatchError) {
                      console.error('tRPC: Session refresh catch error:', refreshCatchError);
                      observer.error(err); // Propagate original error
                      supabase.auth.signOut();
                    }
                  } else {
                    observer.error(err); // Propagate non-auth errors
                  }
                },
                complete: () => observer.complete(),
              });
          }).catch(err => {
             console.error('tRPC: Error getting session for headers:', err);
             observer.error(new TRPCClientError('Failed to get session')); // Use TRPCClientError
          });

          // Return cleanup function if needed
          return () => {};
        });
      };
    },
    // The terminating HTTP link
    httpBatchLink({
      url: apiBaseUrl,
       headers() {
         // Headers are injected by the middleware link above
         return {};
       },
      // Add superjson transformer here if you use one
      // transformer: superjson,
    }),
  ];
}

export function Providers({ children }: { children: ReactNode }) {
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';

  // Initialize network monitoring and query client persistence
  useEffect(() => {
    const unsubscribeNetworkMonitoring = initializeNetworkMonitoring();
    resumeMutationsAndInvalidate(); // Try resuming mutations on app load
    return () => {
      unsubscribeNetworkMonitoring();
    };
  }, []);

  // Memoize tRPC client creation
  const [trpcClient] = useState(() =>
    trpc.createClient({
      links: getTRPCLinks(async () => { // Pass session getter to links setup
        const { data } = await supabase.auth.getSession();
        return data.session;
      }),
    })
  );

  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <TamaguiProvider
            config={config}
            defaultTheme={currentTheme}
            // disableInjectCSS // May not be needed depending on setup
        >
          {/* Use Tamagui's ToastProvider */}
          <ToastProvider
            // burntOptions={{ from: 'top' }} // Disabled until native module 'Burnt' is installed
            swipeDirection="horizontal"
            duration={4000}
            native={[]}
          >
            {children}
            {/* Add the safe-area aware ToastViewport */}
            <CurrentToastViewport />
          </ToastProvider>
        </TamaguiProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
}```
\n\n## Realtime Channel: compose.tsx
**File:** ./modals/compose.tsx
\n```
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { Stack, useRouter } from 'expo-router';
import { Button } from '@/components/ui/iOS/Button';
import Animated, { 
  SlideInDown, 
  // SlideOutDown, // Not using exit animation with gesture
  useSharedValue, 
  useAnimatedStyle, 
  withTiming, 
  runOnJS 
} from 'react-native-reanimated';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';

const { height: SCREEN_HEIGHT } = Dimensions.get('window');
const DISMISS_THRESHOLD = SCREEN_HEIGHT * 0.25; // Swipe 25% down to dismiss

export default function ComposeModal() {
  const router = useRouter();

  // Reanimated shared value for tracking vertical translation
  const translateY = useSharedValue(0);
  const context = useSharedValue({ y: 0 });

  // Gesture handler for swipe down
  const gesture = Gesture.Pan()
    .onStart(() => {
      context.value = { y: translateY.value };
    })
    .onUpdate((event) => {
      translateY.value = Math.max(0, context.value.y + event.translationY); // Only allow downward swipe
    })
    .onEnd(() => {
      if (translateY.value > DISMISS_THRESHOLD) {
        // Animate out and navigate back
        translateY.value = withTiming(SCREEN_HEIGHT, { duration: 200 }, () => {
          runOnJS(router.back)();
        });
      } else {
        // Snap back to original position
        translateY.value = withTiming(0, { duration: 150 });
      }
    });

  // Animated style for the view
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateY: translateY.value }],
    };
  });

  return (
    // Wrap with GestureDetector
    <GestureDetector gesture={gesture}>
      {/* Apply animated style and entrance animation */}
      <Animated.View 
        style={[styles.container, animatedStyle]}
        entering={SlideInDown.duration(300)} 
      >
        {/* Optional: Add a small drag handle indicator */}
        <View style={styles.handleIndicator} />

        {/* Use Stack.Screen to configure the modal title */}
        <Stack.Screen 
          options={{
            title: 'Compose New',
            // Ensure header interaction doesn't conflict with gesture
            // headerLeft: () => <Button title="Close" onPress={() => router.back()} />
          }} 
        />
        <Text style={{ fontSize: 20, marginBottom: 20 }}>Swipe Down to Dismiss</Text>
        <Button onPress={() => router.back()}>Close Modal</Button>
      </Animated.View>
    </GestureDetector>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1, 
    alignItems: 'center', 
    justifyContent: 'center',
    backgroundColor: 'white', // Modals usually have solid background
    borderTopLeftRadius: 10, // Apply radius only to top corners for modal sheet look
    borderTopRightRadius: 10,
    // Add shadow for depth if desired
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -3 },
    shadowOpacity: 0.1,
    shadowRadius: 5,
    elevation: 5, // For Android shadow
  },
  handleIndicator: {
    width: 40,
    height: 5,
    backgroundColor: '#ccc',
    borderRadius: 2.5,
    position: 'absolute',
    top: 10,
    alignSelf: 'center',
  }
}); ```
\n\n## Realtime Channel: habitRouter.ts
**File:** ./server/src/routers/habitRouter.ts
\n```
import { z } from "zod";
import { router, protectedProcedure } from "../router";
import { TRPCError } from "@trpc/server";
import {
  createHabitInput,
  updateHabitInput,
  createHabitEntryInput,
  updateHabitEntryInput,
} from '../types/trpc-types';
import {
  differenceInCalendarDays,
  parseISO,
  format
} from 'date-fns'; // Need date-fns

const HABIT_FIELDS =
  'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, sort_order, streak, best_streak, created_at, updated_at';

const HABIT_ENTRY_FIELDS =
  'id, user_id, habit_id, date, completed, quantity_value, notes, created_at';

async function calculateAndUpdateStreak(habitId: string, userId: string, supabase: any): Promise<{ currentStreak: number, bestStreak: number }> {
  try {
    // Fetch all entries for the habit, ordered by date descending
    const { data: entries, error: entriesError } = await supabase
      .from('habit_entries')
      .select('date, completed') // Only need date and completed status
      .eq('habit_id', habitId)
      .eq('user_id', userId)
      .order('date', { ascending: false });

    if (entriesError) {
      console.error(`Streak Calc Error: Failed to fetch entries for habit ${habitId}:`, entriesError);
      return { currentStreak: 0, bestStreak: 0 }; // Return 0 if entries can't be fetched
    }

    if (!entries || entries.length === 0) {
      // No entries, reset streak
      const { error: updateErr } = await supabase
        .from('habits')
        .update({ streak: 0 })
        .eq('id', habitId);
      if (updateErr) console.error(`Streak Calc Error: Failed to reset streak for habit ${habitId}`, updateErr);
      // Fetch best streak to return it accurately even if current is 0
      const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
      return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 };
    }

    let currentStreak = 0;
    const today = new Date();
    let expectedDate = today; // Start checking from today
    const todayStr = format(today, 'yyyy-MM-dd');
    const todayEntry = entries.find((e: any) => e.date === todayStr);

    // Determine starting point for streak check
    if (todayEntry?.completed) {
      currentStreak = 1;
      expectedDate = new Date(today.setDate(today.getDate() - 1)); // Start checking from yesterday
    } else {
      const yesterday = new Date(); // Need a fresh date object
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayStr = format(yesterday, 'yyyy-MM-dd');
      const yesterdayEntry = entries.find((e: any) => e.date === yesterdayStr);
      if (yesterdayEntry?.completed) {
        currentStreak = 1;
        expectedDate = new Date(yesterday.setDate(yesterday.getDate() - 1)); // Start checking from day before yesterday
      } else {
        currentStreak = 0;
        // No need to loop if streak is already 0 based on today/yesterday
      }
    }

    // Only loop if there's a potential streak > 0
    if (currentStreak > 0) {
      // Find index of the entry *before* the expectedDate (since we check backwards)
      let startIndex = entries.findIndex((e: any) => e.date === format(expectedDate, 'yyyy-MM-dd'));
      // If expected date wasn't found (e.g., yesterday was the start), adjust index
      if (startIndex === -1) {
        // Start from the entry after the one that established the initial streak (today or yesterday)
        const initialStreakDateStr = todayEntry?.completed ? todayStr : (format(new Date(new Date().setDate(new Date().getDate() - 1)), 'yyyy-MM-dd'));
        const initialEntryIndex = entries.findIndex((e: any) => e.date === initialStreakDateStr);
        startIndex = initialEntryIndex !== -1 ? initialEntryIndex + 1 : 0;
      }

      for (let i = startIndex; i < entries.length; i++) {
        const entry = entries[i];
        const entryDate = parseISO(entry.date);
        const expectedDateStr = format(expectedDate, 'yyyy-MM-dd');

        if (entry.date === expectedDateStr) {
          if (entry.completed) {
            currentStreak++;
            expectedDate.setDate(expectedDate.getDate() - 1); // Move to check previous day
          } else {
            break; // Streak broken by uncompleted entry
          }
        } else {
          // Check if the date difference breaks the streak (allowing for gaps)
          const previousDate = i > 0 ? parseISO(entries[i - 1].date) : parseISO(entries[0].date);
          const dateDiff = differenceInCalendarDays(previousDate, entryDate);

          if (dateDiff > 1) {
            break; // Gap too large, streak broken
          }

          // If gap is 1 day, but this entry wasn't completed, streak is broken
          if (!entry.completed) {
            break;
          }

          // If gap is 1 day and completed, it doesn't continue the *current* consecutive sequence
          // but doesn't necessarily break it either (e.g., completed Mon, Wed - streak is 1 from Wed).
          // For simplicity, we break the loop here, assuming the *consecutive* streak from today/yesterday is what matters.
          // A more complex implementation could find the *longest* streak ending recently.
          break;
        }
      }
    }

    // Fetch current best_streak
    const { data: habitData, error: habitFetchError } = await supabase
      .from('habits')
      .select('best_streak')
      .eq('id', habitId)
      .single();

    if (habitFetchError) {
      console.error(`Streak Calc Error: Failed to fetch habit ${habitId} for best_streak:`, habitFetchError);
      // Fallback best streak if fetch fails
      const bestStreakFallback = Math.max(currentStreak, 0); 
      const { error: updateError } = await supabase
        .from('habits')
        .update({ streak: currentStreak, best_streak: bestStreakFallback })
        .eq('id', habitId);
      if (updateError) console.error(`Streak Calc Error: Failed to update streak (fallback) for habit ${habitId}:`, updateError);
      console.log(`Streak Updated (Fallback Best) for habit ${habitId}: Current=${currentStreak}, Best=${bestStreakFallback}`);
      return { currentStreak, bestStreak: bestStreakFallback };
    }

    const bestStreak = Math.max(currentStreak, habitData?.best_streak || 0);

    // Update the habit record
    const { error: updateError } = await supabase
      .from('habits')
      .update({ streak: currentStreak, best_streak: bestStreak })
      .eq('id', habitId);

    if (updateError) {
      console.error(`Streak Calc Error: Failed to update streak for habit ${habitId}:`, updateError);
    }

    console.log(`Streak Updated for habit ${habitId}: Current=${currentStreak}, Best=${bestStreak}`);
    return { currentStreak, bestStreak };

  } catch (error) {
    console.error(`Unexpected error calculating streak for habit ${habitId}:`, error);
    // Attempt to fetch best streak even on error
    const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
    return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 }; // Return 0 current streak on error
  }
}

export const habitRouter = router({
  getHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (habitsError) throw habitsError;
        if (!habits) return [];

        const todayStr = new Date().toISOString().split('T')[0];

        const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id')
          .eq('user_id', ctx.userId)
          .eq('date', todayStr)
          .in('habit_id', habits.map(h => h.id));

        if (todayEntriesError) throw todayEntriesError;

        const completedMap = (habitEntriesToday || []).reduce<Record<string, boolean>>((acc, entry) => {
          acc[entry.habit_id] = true;
          return acc;
        }, {});

        const formattedHabits = habits.map(h => ({
          ...h,
          completedToday: !!completedMap[h.id]
        }));

        return formattedHabits;
      } catch (error: any) {
        throw new TRPCError({ 
          code: 'INTERNAL_SERVER_ERROR', 
          message: error.message || 'Failed to fetch habits'
        });
      }
    }),

  getHabitById: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .select(HABIT_FIELDS)
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (error) throw new TRPCError({ 
        code: error.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: error.message 
      });
      return data;
    }),

  createHabit: protectedProcedure
    .input(createHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .insert({
          ...input,
          user_id: ctx.userId,
          streak: 0,
          best_streak: 0
        })
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  updateHabit: protectedProcedure
    .input(updateHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { id, ...updateData } = input;

      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .update(updateData)
        .eq("id", id)
        .eq('user_id', ctx.userId)
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  deleteHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { error } = await ctx.supabaseAdmin
        .from("habits")
        .delete()
        .eq("id", input.id);

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return { id: input.id };
    }),

  listArchivedHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        return habits || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived habits',
        });
      }
    }),

  archiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to archive habit' });
      }
    }),

  unarchiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to unarchive habit' });
      }
    }),

  getHabitEntries: protectedProcedure
    .input(z.object({
      habitId: z.string().uuid(),
      startDate: z.string().optional(), 
      endDate: z.string().optional(),   
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { error: habitError } = await ctx.supabaseAdmin
          .from("habits")
          .select("id")
          .eq("id", input.habitId)
          .eq("user_id", ctx.userId)
          .single();

        if (habitError) {
          if (habitError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: habitError.message });
        }

        let query = ctx.supabaseAdmin
          .from('habit_entries')
          .select(HABIT_ENTRY_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('habit_id', input.habitId);

        if (input.startDate) query = query.gte('date', input.startDate);
        if (input.endDate) query = query.lte('date', input.endDate);

        const { data, error: entriesError } = await query.order('date', { ascending: false });

        if (entriesError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: entriesError.message });
        return data || [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to fetch habit entries' });
      }
    }),

  getHabitEntriesForHabit: protectedProcedure
    .input(z.object({ habitId: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      // TODO: Implement logic to fetch habit entries for a specific habit
      console.log(`Fetching entries for habit: ${input.habitId}, user: ${ctx.userId}`);
      // Example fetch:
      // const { data, error } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select(HABIT_ENTRY_FIELDS)
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .order('date', { ascending: false });
      // if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      // return data || [];
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),

  createHabitEntry: protectedProcedure
    .input(createHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .insert({ ...input, user_id: ctx.userId })
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });

        // Update streak after successful insert
        if (data) {
          await calculateAndUpdateStreak(input.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create habit entry',
        });
      }
    }),

  updateHabitEntry: protectedProcedure
    .input(updateHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: habitEntry, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) throw new TRPCError({ 
          code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
          message: "Habit entry not found or access denied" 
        });

        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId) // Ensure ownership
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });

        // Update streak after successful update
        if (data) {
          await calculateAndUpdateStreak(data.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update habit entry',
        });
      }
    }),

  deleteHabitEntry: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Fetch habitId *before* deleting the entry
        const { data: entryToDelete, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id') // Fetch habit_id
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !entryToDelete) {
          throw new TRPCError({ 
            code: fetchError?.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Habit entry not found or access denied.' 
          });
        }

        const { habit_id: habitIdForStreak } = entryToDelete; // Store before delete

        // Perform delete
        const { error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId); // Ensure user owns the entry being deleted

        if (error) throw error; // Throw if delete fails

        // Update streak *after* successful delete
        if (habitIdForStreak) { // Check if we got the habitId
          await calculateAndUpdateStreak(habitIdForStreak, ctx.userId, ctx.supabaseAdmin);
        }

        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete habit entry',
        });
      }
    }),

  toggleHabitEntry: protectedProcedure
    .input(z.object({ habitId: z.string().uuid(), date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/) }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Implement logic to find if entry exists for habitId/date/userId.
      // If exists, delete it.
      // If not exists, create it (need default values for boolean/quantity type).
      // Call calculateAndUpdateStreak after create/delete.
      console.log(`Toggling habit entry for habit: ${input.habitId}, date: ${input.date}`);
      // Example logic:
      // const { data: existingEntry, error: findError } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select('id')
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .eq('date', input.date)
      //   .maybeSingle();
      // if (findError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: findError.message });

      // if (existingEntry) {
      //   // Delete existing
      //   const { error: deleteError } = await ctx.supabaseAdmin.from('habit_entries').delete().eq('id', existingEntry.id);
      //   if (deleteError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: deleteError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'deleted', habitId: input.habitId, date: input.date };
      // } else {
      //   // Create new
      //   // Need to know habit type to set default 'completed' or 'quantity_value'
      //   const { data: newEntry, error: createError } = await ctx.supabaseAdmin
      //     .from('habit_entries')
      //     .insert({ habit_id: input.habitId, user_id: ctx.userId, date: input.date, completed: true /* or quantity_value: default */ })
      //     .select(HABIT_ENTRY_FIELDS)
      //     .single();
      //   if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'created', entry: newEntry };
      // }
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),
});```
\n\n## Realtime Channel: reminderRouter.ts
**File:** ./server/src/routers/reminderRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createReminderInput,
  updateReminderInput,
  GetRemindersForEntityInput,
  DeleteReminderInput,
} from '../types/trpc-types';

// Define fields for consistent selection
const REMINDER_FIELDS = 'id, user_id, related_entity_type, related_entity_id, reminder_time, message, is_active, created_at, updated_at';

export const reminderRouter = router({
  // Get all active reminders for the user (might need refinement later)
  getActiveReminders: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('is_active', true)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch active reminders',
        });
      }
    }),

  // Get reminders linked to a specific entity
  getRemindersForEntity: protectedProcedure
    .input(GetRemindersForEntityInput)
    .query(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('related_entity_type', input.related_entity_type)
          .eq('related_entity_id', input.related_entity_id)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch reminders for entity',
        });
      }
    }),

  createReminder: protectedProcedure
    .input(createReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // TODO: Potentially validate that related_entity_id exists and belongs to user?
        // This requires knowing the related_entity_type and querying the correct table.
        // For now, assume valid input.
        const { data: reminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return reminder;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create reminder',
        });
      }
    }),

  updateReminder: protectedProcedure
    .input(updateReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { data: updatedReminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return updatedReminder;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update reminder',
        });
      }
    }),

  deleteReminder: protectedProcedure
    .input(DeleteReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('reminders')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete reminder',
        });
      }
    }),
});
```
\n\n## Realtime Channel: principleRouter.ts
**File:** ./server/src/routers/principleRouter.ts
\n```
// server/src/routers/principleRouter.ts
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createPrincipleInput, updatePrincipleInput } from '../types/trpc-types'; // These now expect 'title' and 'body'

// Define fields for consistent selection, using 'title' and 'body'
const PRINCIPLE_FIELDS = 'id, user_id, title, body, sort_order, created_at, updated_at';

export const principleRouter = router({
  getPrinciples: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: principles, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principles || []; // Return empty array if null
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principles',
        });
      }
    }),

  getPrincipleById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) {
           if (error.code === 'PGRST116') { // Handle not found specifically
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found' });
           }
           throw error; // Rethrow other errors
        }
        // No need for !principle check if .single() is used and error isn't PGRST116

        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principle',
        });
      }
    }),

  createPrinciple: protectedProcedure
    .input(createPrincipleInput) // This Zod schema now expects 'title' and 'body'
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .insert({
            ...input, // Spread validated input, already contains 'title' and 'body'
            user_id: ctx.userId,
          })
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create principle',
        });
      }
    }),

  updatePrinciple: protectedProcedure
    .input(updatePrincipleInput) // This Zod schema now expects 'title' and 'body' (optional)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
           if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to update it' });
           }
           throw fetchError;
        }

        // Update
        const { data: updatedPrinciple, error } = await ctx.supabaseAdmin
          .from('principles')
          .update(updateData) // updateData contains validated 'title'/'body' if provided
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return updatedPrinciple;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update principle',
        });
      }
    }),

  deletePrinciple: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
            if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to delete it' });
           }
           throw fetchError;
        }

        // Delete
        const { error } = await ctx.supabaseAdmin
          .from('principles')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete principle',
        });
      }
    }),
});```
\n\n## Realtime Channel: rewardsRouter.ts
**File:** ./server/src/routers/rewardsRouter.ts
\n```
import { TRPCError } from '@trpc/server';
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { supabaseAdmin } from '../context';

// Corrected relative path
import { claimLootInput, awardBadgeInput } from '../types/trpc-types';

export const rewardsRouter = router({
  // Get all rewards for current user
  getUserRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Select specific fields aligned with our Zod types
        const { data: rewards, error } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('id, user_id, reward_id, earned_at, rewards(id, name, description, emoji, image_url, required_points, type)')
          .eq('user_id', ctx.userId)
          .order('earned_at', { ascending: false });

        if (error) throw error;
        return rewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user rewards',
        });
      }
    }),

  // Get available rewards that can be earned
  getAvailableRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Get all rewards with specific fields
        const { data: allRewards, error: rewardsError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('id, name, description, emoji, image_url, required_points, type, can_earn_multiple')
          .order('required_points', { ascending: true });

        if (rewardsError) throw rewardsError;

        // Get already earned rewards
        const { data: earnedRewards, error: earnedError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('reward_id')
          .eq('user_id', ctx.userId);

        if (earnedError) throw earnedError;

        // Filter out already earned one-time rewards
        const earnedIds = new Set((earnedRewards || []).map(er => er.reward_id));
        const availableRewards = allRewards?.filter(reward => 
          !earnedIds.has(reward.id) || reward.can_earn_multiple);

        return availableRewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch available rewards',
        });
      }
    }),

  // Get user points
  getUserPoints: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: userProfile, error } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (error) throw error;
        return {
          points: userProfile?.points || 0,
          lifetimePoints: userProfile?.lifetime_points || 0,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user points',
        });
      }
    }),

  // Earn a reward if eligible
  earnReward: protectedProcedure
    .input(claimLootInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get the reward details
        const { data: reward, error: rewardError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.rewardId)
          .single();

        if (rewardError || !reward) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Reward not found',
          });
        }

        // Check if user has enough points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        if (userProfile.points < reward.required_points) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Not enough points to earn this reward',
          });
        }

        // If the reward is one-time, check if already earned
        if (!reward.can_earn_multiple) {
          const { data: existingReward, error: existingError } = await ctx.supabaseAdmin
            .from('user_rewards')
            .select('id')
            .eq('user_id', ctx.userId)
            .eq('reward_id', input.rewardId)
            .single();

          if (existingReward) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'You have already earned this one-time reward',
            });
          }
        }

        // Begin transaction
        // 1. Deduct points from user
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: userProfile.points - reward.required_points,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // 2. Add reward to user's earned rewards
        const { data: userReward, error: insertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.rewardId,
            earned_at: new Date().toISOString(),
            points_spent: reward.required_points,
          })
          .select()
          .single();

        if (insertError) {
          // Rollback points if adding reward failed
          await ctx.supabaseAdmin
            .from('profiles')
            .update({
              points: userProfile.points,
            })
            .eq('id', ctx.userId);

          throw insertError;
        }

        return {
          success: true,
          reward: userReward,
          remainingPoints: userProfile.points - reward.required_points,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to earn reward',
        });
      }
    }),

  // Award points to user (e.g., for completing habits, tasks)
  awardPoints: protectedProcedure
    .input(awardBadgeInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get current user points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        // Get badge details
        const { data: badge, error: badgeError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.badgeId)
          .eq('type', 'badge')
          .single();

        if (badgeError || !badge) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Badge not found',
          });
        }

        // Default points to award
        const pointsToAward = 10;
        const currentPoints = userProfile.points || 0;
        const lifetimePoints = userProfile.lifetime_points || 0;
        const newPoints = currentPoints + pointsToAward;
        const newLifetimePoints = lifetimePoints + pointsToAward;

        // Update user points
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: newPoints,
            lifetime_points: newLifetimePoints,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // Record the point transaction
        const { data: pointTransaction, error: transactionError } = await ctx.supabaseAdmin
          .from('point_transactions')
          .insert({
            user_id: ctx.userId,
            points: pointsToAward,
            reason: `Earned badge: ${badge.name}`,
            source_type: 'badge',
            source_id: input.badgeId,
          })
          .select()
          .single();

        if (transactionError) throw transactionError;

        // Add badge to user's earned rewards
        const { data: userBadge, error: badgeInsertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.badgeId,
            reward_type: 'badge',
            earned_at: new Date().toISOString(),
            points_spent: 0, // Badges don't cost points
          })
          .select()
          .single();

        if (badgeInsertError) throw badgeInsertError;

        return {
          success: true,
          previousPoints: currentPoints,
          newPoints,
          pointsAdded: pointsToAward,
          transaction: pointTransaction,
          badge: userBadge,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to award badge',
        });
      }
    }),

  // Get point transaction history
  getPointHistory: protectedProcedure
    .input(z.object({
      limit: z.number().optional().default(20),
      cursor: z.string().optional(), // for pagination
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('point_transactions')
          .select('*')
          .eq('user_id', ctx.userId)
          .order('created_at', { ascending: false })
          .limit(input.limit);
          
        // Handle cursor-based pagination
        if (input.cursor) {
          query = query.lt('created_at', input.cursor);
        }
        
        const { data: transactions, error } = await query;

        if (error) throw error;
        
        // Determine if there are more results
        const lastItem = transactions && transactions.length > 0 
          ? transactions[transactions.length - 1] 
          : null;
          
        return {
          items: transactions || [],
          nextCursor: lastItem?.created_at,
          hasMore: (transactions?.length || 0) === input.limit,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch point history',
        });
      }
    }),
}); ```
\n\n## Realtime Channel: taskRouter.ts
**File:** ./server/src/routers/taskRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createTaskInput,
  updateTaskInput,
  updateTaskStatusInput,
  TaskStatusEnum, // Import the enum
  TaskPriorityEnum,
} from '../types/trpc-types';

// Define fields for selection consistency
const TASK_FIELDS =
  'id, user_id, title, notes, status, priority, due_date, goal_id, parent_task_id, recurrence_rule, recurrence_end_date, archived_at, sort_order, created_at, updated_at'; // Corrected: 'priority' instead of 'priority_enum' if that's the actual column name after migration
const GOAL_FIELDS = 'id, user_id, title, description, progress, target_date, archived_at, sort_order, created_at, updated_at';


// --- Helper function to update goal progress ---
async function updateGoalProgress(goalId: string, userId: string, supabase: any) {
  try {
    // 1. Fetch all non-archived tasks for the goal
    const { data: tasks, error: tasksError } = await supabase
      .from('tasks')
      .select('id, status') // Only need id and status
      .eq('goal_id', goalId)
      .eq('user_id', userId)
      .is('archived_at', null); // Exclude archived tasks

    if (tasksError) {
      console.error(`Error fetching tasks for goal ${goalId} during progress update:`, tasksError);
      // Decide how to handle this - maybe just log and skip update?
      return; // Exit if tasks can't be fetched
    }

    const totalTasks = tasks?.length || 0;
    const completedTasks = tasks?.filter((t: { status: string }) => t.status === TaskStatusEnum.enum.done).length || 0;

    // 2. Calculate progress (avoid division by zero)
    const newProgress = totalTasks > 0 ? completedTasks / totalTasks : 0;
    // Ensure progress is between 0 and 1, rounded to avoid floating point issues
    const clampedProgress = Math.round(Math.min(1, Math.max(0, newProgress)) * 100) / 100;

    // 3. Update the goal record
    const { error: updateError } = await supabase
      .from('goals')
      .update({ progress: clampedProgress })
      .eq('id', goalId)
      .eq('user_id', userId); // Ensure user owns the goal

    if (updateError) {
      console.error(`Error updating progress for goal ${goalId}:`, updateError);
      // Log error but don't necessarily throw, task toggle was successful
    } else {
        console.log(`Updated progress for goal ${goalId} to ${clampedProgress}`);
    }

  } catch (err) {
    console.error(`Unexpected error during goal progress update for goal ${goalId}:`, err);
    // Log unexpected errors
  }
}

export const taskRouter = router({
  getTasks: protectedProcedure // Gets non-archived tasks
    .input(z.object({
      goalId: z.string().uuid().optional(),
      // TODO: Add filters for status, priority, dates etc.?
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null); // Filter out archived

        if (input.goalId) {
          query = query.eq('goal_id', input.goalId);
        }

        // TODO: Add complex priority enum sorting? (e.g. high > medium > low)
        const { data: tasks, error } = await query
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('due_date', { ascending: true, nullsFirst: false }) // Order by due date (nulls last)
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tasks',
        });
      }
    }),

  getTaskById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(), // Use uuid validation
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!task) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found',
          });
        }

        // TODO: Parse with Task schema?
        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch task',
        });
      }
    }),

  createTask: protectedProcedure
    .input(createTaskInput) // Use imported input type
    .mutation(async ({ ctx, input }) => {
      try {
        // Verify goal_id if provided
        if (input.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', input.goal_id)
            .eq('user_id', ctx.userId) // Ensure goal belongs to user
            .is('archived_at', null) // Ensure goal is not archived
            .single();

          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived goal ID',
            });
          }
        }

        // Verify parent_task_id if provided
        if (input.parent_task_id) {
          const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
            .from('tasks')
            .select('id')
            .eq('id', input.parent_task_id)
            .eq('user_id', ctx.userId) // Ensure parent belongs to user
            .is('archived_at', null) // Ensure parent is not archived
            .single();

          if (parentError || !parentTask) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived parent task ID',
            });
          }
        }

        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .insert({
            ...input, // Spread validated input (includes new fields like parent_task_id, recurrence etc)
            user_id: ctx.userId,
            // Ensure due_date is used if present in input
            due_date: input.due_date ?? null, // Use correct field name
          })
          .select(TASK_FIELDS)
          .single();

        if (error) {
           // Handle specific errors like FK violations?
           console.error("Create task error:", error);
           throw error;
        }
        // TODO: Parse with Task schema?
        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create task',
        });
      }
    }),

  updateTask: protectedProcedure
    .input(updateTaskInput) // Use imported input type
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input; // Separate id from update payload

        // Check ownership
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id, parent_task_id') // Select parent_task_id for cycle check
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to update it',
          });
        }

        // Verify goal_id if being updated
        if (updateData.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', updateData.goal_id)
            .eq('user_id', ctx.userId)
            .is('archived_at', null)
            .single();

          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived goal ID',
            });
          }
        }
        // Handle setting goal_id to null
        if (updateData.goal_id === null) {
          updateData.goal_id = null;
        }

        // Verify parent_task_id if being updated
        if (updateData.parent_task_id) {
           // Basic cycle check
           if (updateData.parent_task_id === id) {
             throw new TRPCError({
               code: 'BAD_REQUEST',
               message: 'Task cannot be its own parent',
             });
           }
          const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
            .from('tasks')
            .select('id')
            .eq('id', updateData.parent_task_id)
            .eq('user_id', ctx.userId)
            .is('archived_at', null)
            .single();

          if (parentError || !parentTask) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived parent task ID',
            });
          }
          // TODO: Add deeper cycle detection if needed (check if new parent is a descendant)
        }
         // Handle setting parent_task_id to null
        if (updateData.parent_task_id === null) {
          updateData.parent_task_id = null;
        }

        // Ensure correct field name for due date if provided
        const payload: Record<string, any> = { ...updateData };
        if ('due_date' in payload) {
          payload.due_date = payload.due_date ?? null;
        }

        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update(payload) // Pass validated update data
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
             // Handle specific errors like FK violations?
           console.error("Update task error:", error);
           throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update task',
        });
      }
    }),

  deleteTask: protectedProcedure
    .input(z.object({
      id: z.string().uuid(), // Use uuid validation
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to delete it',
          });
        }

        // Delete the task (consider implications for subtasks - maybe archive instead?)
        // For now, direct delete.
        const { error } = await ctx.supabaseAdmin
          .from('tasks')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete task',
        });
      }
    }),

  // ---- Archive/Unarchive ----
  listArchivedTasks: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: tasks, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null) // Filter for archived tasks
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived tasks',
        });
      }
    }),

  archiveTask: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Consider archiving subtasks recursively?
      try {
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Task not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive task',
        });
      }
    }),

  unarchiveTask: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
       // TODO: Consider check if parent is archived?
      try {
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Task not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive task',
        });
      }
    }),

  // ---- Status Update ----
  updateTaskStatus: protectedProcedure
    .input(updateTaskStatusInput) // Uses { id: string().uuid(), status: TaskStatusEnum }
    .mutation(async ({ ctx, input }) => {
       try {
         // Check ownership first
         const { data: existing, error: fetchErr } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

         if (fetchErr || !existing) {
           throw new TRPCError({ code: 'NOT_FOUND', message: 'Task not found or permission denied.' });
         }

         // Perform update
         const { data: updatedTask, error: updateErr } = await ctx.supabaseAdmin
           .from('tasks')
           .update({ status: input.status })
           .eq('id', input.id)
           .select(TASK_FIELDS)
           .single();

         if (updateErr) throw updateErr;
         // TODO: Parse with Task schema?
         return updatedTask;
       } catch (error: any) {
         if (error instanceof TRPCError) throw error;
         throw new TRPCError({
           code: 'INTERNAL_SERVER_ERROR',
           message: error.message || 'Failed to update task status',
         });
       }
    }),

  // ---- Refactored Stubs ----
  listToday: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const todayStart = new Date();
        todayStart.setHours(0, 0, 0, 0);
        const todayEnd = new Date();
        todayEnd.setHours(23, 59, 59, 999);

        const { data: tasks, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .gte('due_date', todayStart.toISOString())
          .lte('due_date', todayEnd.toISOString())
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('due_date', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list tasks for today' });
      }
    }),

  listUpcoming: protectedProcedure
    .query(async ({ ctx }) => {
       try {
         const tomorrowStart = new Date();
         tomorrowStart.setDate(tomorrowStart.getDate() + 1);
         tomorrowStart.setHours(0, 0, 0, 0);

         const { data: tasks, error } = await ctx.supabaseAdmin
           .from('tasks')
           .select(TASK_FIELDS)
           .eq('user_id', ctx.userId)
           .is('archived_at', null)
           .gte('due_date', tomorrowStart.toISOString()) // Due date is tomorrow or later
           .order('due_date', { ascending: true, nullsFirst: false })
           .order('sort_order', { ascending: true, nullsFirst: false })
           .order('created_at', { ascending: false });

         if (error) throw error;
         // TODO: Parse with Task schema?
         return tasks || [];
       } catch (error: any) {
         throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list upcoming tasks' });
       }
    }),

 listOverdue: protectedProcedure
    .query(async ({ ctx }) => {
       try {
         const todayStart = new Date();
         todayStart.setHours(0, 0, 0, 0);

         const { data: tasks, error } = await ctx.supabaseAdmin
           .from('tasks')
           .select(TASK_FIELDS)
           .eq('user_id', ctx.userId)
           .is('archived_at', null)
           .lt('due_date', todayStart.toISOString()) // Due date is before today
           .not('status', 'in', `('${TaskStatusEnum.enum.done}')`) // Exclude completed tasks
           .order('due_date', { ascending: true, nullsFirst: false })
           .order('sort_order', { ascending: true, nullsFirst: false })
           .order('created_at', { ascending: false });

         if (error) throw error;
         // TODO: Parse with Task schema?
         return tasks || [];
       } catch (error: any) {
         throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list overdue tasks' });
       }
    }),

  toggleTask: protectedProcedure // Toggles between 'todo' and 'done'
    .input(z.object({
      taskId: z.string().uuid(),
      completed: z.boolean().optional() // Optional for backward compatibility
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // 1. Fetch the current task, including goal_id
        const { data: currentTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id, status, goal_id, title') // <-- Include goal_id and title
          .eq('id', input.taskId)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !currentTask) {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Task not found or permission denied.' });
        }

        // 2. Determine the new status
        let newStatus;
        if (input.completed !== undefined) {
          // If completed was explicitly provided, use it
          newStatus = input.completed ? TaskStatusEnum.enum.done : TaskStatusEnum.enum.todo;
        } else {
          // Otherwise toggle the current status
          newStatus = currentTask.status === TaskStatusEnum.enum.done
            ? TaskStatusEnum.enum.todo
            : TaskStatusEnum.enum.done;
        }

        // 3. Update the task status
        const { data: updatedTask, error: updateError } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ status: newStatus })
          .eq('id', input.taskId)
          .select(TASK_FIELDS) // Return the full updated task
          .single();

        if (updateError) throw updateError;

        // 4. *** NEW: Update goal progress if applicable ***
        if (currentTask.goal_id) {
           // Call the helper function asynchronously - no need to await here
           // unless the UI needs the updated goal immediately (unlikely for a toggle)
          updateGoalProgress(currentTask.goal_id, ctx.userId, ctx.supabaseAdmin);
        }

        // 5. Return the updated task
        return updatedTask;

      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        console.error("Error in toggleTask:", error); // Log unexpected errors
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to toggle task status',
        });
      }
    }),

  // --- Obsolete Stubs (keep or remove based on client usage) ---
  /*
  getTasksByGoal: protectedProcedure ... // Covered by getTasks with goalId filter
  getTodaysTasks: protectedProcedure ... // Replaced by listToday
  getUpcomingTasks: protectedProcedure ... // Replaced by listUpcoming
  updateTaskStatus_OLD: protectedProcedure ... // Replaced by updateTaskStatus and toggleTask
  */

});```
\n\n## Realtime Channel: valueRouter.ts
**File:** ./server/src/routers/valueRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createValueInput, updateValueInput } from '../types/trpc-types';

export const valueRouter = router({
  getValues: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: values, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return values;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch values',
        });
      }
    }),

  getValueById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!value) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found',
          });
        }

        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch value',
        });
      }
    }),

  createValue: protectedProcedure
    .input(createValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create value',
        });
      }
    }),

  updateValue: protectedProcedure
    .input(updateValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // First check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to update it',
          });
        }

        // Update the value
        const { data: updatedValue, error } = await ctx.supabaseAdmin
          .from('values')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return updatedValue;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update value',
        });
      }
    }),

  deleteValue: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to delete it',
          });
        }

        // Delete the value
        const { error } = await ctx.supabaseAdmin
          .from('values')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete value',
        });
      }
    }),
});```
\n\n## Realtime Channel: goalRouter.ts
**File:** ./server/src/routers/goalRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createGoalInput, updateGoalInput } from '../types/trpc-types';

const GOAL_FIELDS = 'id, user_id, title, description, progress, target_date, archived_at, sort_order, created_at, updated_at';

export const goalRouter = router({
  getGoals: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;

        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals',
        });
      }
    }),

  getGoalById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!goal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found',
          });
        }

        return goal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal',
        });
      }
    }),

  createGoal: protectedProcedure
    .input(createGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return goal;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal',
        });
      }
    }),

  updateGoal: protectedProcedure
    .input(updateGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to update it',
          });
        }

        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal',
        });
      }
    }),

  deleteGoal: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to delete it',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goals')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal',
        });
      }
    }),

  listActive: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals (in listActive stub)',
        });
      }
    }),

  listArchived: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived goals',
        });
      }
    }),

  archiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') { 
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive goal',
        });
      }
    }),

  unarchiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive goal',
        });
      }
    }),
});```
\n\n## Realtime Channel: goalProgressNoteRouter.ts
**File:** ./server/src/routers/goalProgressNoteRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createGoalProgressNoteInput,
  updateGoalProgressNoteInput,
  GetGoalProgressNotesInput,
  DeleteGoalProgressNoteInput,
} from '../types/trpc-types';

// Define fields for consistent selection
const GOAL_PROGRESS_NOTE_FIELDS = 'id, goal_id, user_id, note, created_at';

export const goalProgressNoteRouter = router({
  // Get all notes for a specific goal
  getNotesForGoal: protectedProcedure
    .input(GetGoalProgressNotesInput)
    .query(async ({ ctx, input }) => {
      try {
        // First, ensure the goal exists and belongs to the user
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        // Fetch the notes for that goal
        const { data, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .eq('user_id', ctx.userId) // Redundant check, but good practice
          .eq('goal_id', input.goal_id)
          .order('created_at', { ascending: false }); // Newest first

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal progress notes',
        });
      }
    }),

  createNote: protectedProcedure
    .input(createGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Ensure the goal exists and belongs to the user before adding a note
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        const { data: note, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return note;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal progress note',
        });
      }
    }),

  updateNote: protectedProcedure
    .input(updateGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership of the note
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { data: updatedNote, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return updatedNote;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal progress note',
        });
      }
    }),

  deleteNote: protectedProcedure
    .input(DeleteGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal progress note',
        });
      }
    }),
});
```
\n\n## Realtime Channel: trackedStateRouter.ts
**File:** ./server/src/routers/trackedStateRouter.ts
\n```
// File: server/src/routers/trackedStateRouter.ts

import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  // Ensure all necessary input types from trpc-types are imported
  createTrackedStateDefInput,
  updateTrackedStateDefInput,
  GetTrackedStateDefByIdInput,
  DeleteTrackedStateDefInput,
  CreateStateEntryInput,      // <--- Import for createEntry
  updateStateEntryInput,      // <--- Import for updateEntry
  GetStateEntriesInput,       // <--- Import for getEntries
  DeleteStateEntryInput       // <--- Import for deleteEntry
} from '../types/trpc-types';

// Use correct field names from database.types.ts & trpc-types.ts
const TRACKED_STATE_DEF_FIELDS = 'id, user_id, name, description, scale, custom_labels, unit, icon, target_min_value, target_max_value, created_at, updated_at, active, priority';
const STATE_ENTRY_FIELDS = 'id, user_id, definition_id, value_numeric, value_text, entry_timestamp, notes';

export const trackedStateRouter = router({
  getDefinitions: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('active', true)
          .order('priority', { ascending: true, nullsFirst: false }) // Corrected: nullsFirst
          .order('created_at', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tracked state definitions',
        });
      }
    }),

  getDefinitionById: protectedProcedure
    .input(GetTrackedStateDefByIdInput) // Use correct Zod schema
    .query(async ({ ctx, input }) => {
       try {
        const { data: definition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS)
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Tracked state definition not found.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return definition;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tracked state definition',
        });
      }
    }),

  createDefinition: protectedProcedure
    .input(createTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { data: definition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .insert({
            ...input, // input is now correctly typed
            user_id: ctx.userId,
          })
          .select(TRACKED_STATE_DEF_FIELDS)
          .single();

        if (error) throw error;
        return definition;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create tracked state definition',
        });
      }
    }),

  updateDefinition: protectedProcedure
    .input(updateTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { id, ...updateData } = input; // input is now correctly typed

        const { error: fetchError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Definition not found or access denied.',
          });
        }

        const { data: updatedDefinition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(TRACKED_STATE_DEF_FIELDS)
          .single();

        if (error) throw error;
        return updatedDefinition;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update tracked state definition',
        });
      }
    }),

  deleteDefinition: protectedProcedure
    .input(DeleteTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Definition not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .delete()
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id }; // input.id is now correctly typed
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete tracked state definition',
        });
      }
    }),

  // --- State Entry Procedures ---

  getEntries: protectedProcedure
    .input(GetStateEntriesInput) // <<<--- ADDED .input() BINDING
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('state_entries')
          .select(STATE_ENTRY_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('definition_id', input.tracked_state_def_id); // input is now typed

        if (input.startDate) { // input is now typed
          query = query.gte('entry_timestamp', input.startDate);
        }
        if (input.endDate) { // input is now typed
          query = query.lte('entry_timestamp', input.endDate);
        }

        query = query.order('entry_timestamp', { ascending: false });

        if (input.limit) { // input is now typed
          query = query.limit(input.limit);
        }

        const { data: entries, error } = await query;

        if (error) throw error;
        return entries ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch state entries',
        });
      }
    }),

  createEntry: protectedProcedure
    .input(CreateStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
      try {
        // Check definition ownership (already implemented correctly)
        const { error: defError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', input.tracked_state_def_id) // input is now typed
          .eq('user_id', ctx.userId)
          .single();

        if (defError) {
          throw new TRPCError({
            code: defError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Tracked state definition not found or invalid.',
          });
        }

        // Insert typed data
        const { data: entry, error } = await ctx.supabaseAdmin
          .from('state_entries')
          .insert({
            user_id: ctx.userId,
            definition_id: input.tracked_state_def_id, // input is now typed
            value_numeric: input.value_numeric,     // input is now typed
            value_text: input.value_text,         // input is now typed
            entry_timestamp: input.entry_timestamp || new Date().toISOString(), // input is now typed
            notes: input.notes,                 // input is now typed
          })
          .select(STATE_ENTRY_FIELDS)
          .single();

        if (error) throw error;
        return entry;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create state entry',
        });
      }
    }),

  updateEntry: protectedProcedure
    .input(updateStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input; // input is now typed

        // Check ownership (already implemented correctly)
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('state_entries')
          .select('id')
          .eq('id', id) // Use id from destructured input
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Entry not found or access denied.',
          });
        }

        // updateData is now correctly typed from the input schema
        const { data: updatedEntry, error } = await ctx.supabaseAdmin
          .from('state_entries')
          .update(updateData)
          .eq('id', id) // Use id from destructured input
          .eq('user_id', ctx.userId)
          .select(STATE_ENTRY_FIELDS)
          .single();

        if (error) throw error;
        return updatedEntry;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update state entry',
        });
      }
    }),

  deleteEntry: protectedProcedure
    .input(DeleteStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
       try {
        // Check ownership (already implemented correctly)
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('state_entries')
          .select('id')
          .eq('id', input.id) // input is now typed
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Entry not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('state_entries')
          .delete()
          .eq('id', input.id) // input is now typed
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id }; // input is now typed
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete state entry',
        });
      }
    }),
});```
\n\n## Realtime Channel: userRouter.ts
**File:** ./server/src/routers/userRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure, publicProcedure } from '../router';
import { TRPCError } from '@trpc/server';

export const userRouter = router({
  getProfile: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('id, username, avatar_url, full_name, bio, time_zone, onboarding_completed, created_at, updated_at')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  updateProfile: protectedProcedure
    .input(z.object({
      full_name: z.string().optional(),
      avatar_url: z.string().optional(),
      theme: z.string().optional(),
      time_zone: z.string().optional(),
      display_name: z.string().optional(),
      bio: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update(input)
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getUserSettings: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('id, user_id, notification_preferences, ui_preferences')
        .eq('user_id', ctx.userId)
        .single();
        
      if (error) {
        // If settings don't exist, create default settings
        if (error.code === 'PGRST116') {
          const { data: newSettings, error: createError } = await ctx.supabaseAdmin
            .from('user_settings')
            .insert({
              user_id: ctx.userId,
              notification_preferences: {
                email: true,
                push: true,
                task_reminders: true,
                goal_updates: true,
                habit_reminders: true
              },
              ui_preferences: {
                theme: 'system',
                compact_view: false,
                show_completed_tasks: true
              }
            })
            .select()
            .single();
            
          if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
          return newSettings;
        }
        
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      }
      
      return data;
    }),
    
  updateUserSettings: protectedProcedure
    .input(z.object({
      notification_preferences: z.object({
        email: z.boolean().optional(),
        push: z.boolean().optional(),
        task_reminders: z.boolean().optional(),
        goal_updates: z.boolean().optional(),
        habit_reminders: z.boolean().optional()
      }).optional(),
      ui_preferences: z.object({
        theme: z.string().optional(),
        compact_view: z.boolean().optional(),
        show_completed_tasks: z.boolean().optional()
      }).optional()
    }))
    .mutation(async ({ ctx, input }) => {
      // First check if settings exist
      const { data: existingSettings, error: fetchError } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('id')
        .eq('user_id', ctx.userId)
        .single();
        
      if (fetchError && fetchError.code === 'PGRST116') {
        // Create settings if they don't exist
        const defaultSettings = {
          user_id: ctx.userId,
          notification_preferences: {
            email: true,
            push: true,
            task_reminders: true,
            goal_updates: true,
            habit_reminders: true,
            ...input.notification_preferences
          },
          ui_preferences: {
            theme: 'system',
            compact_view: false,
            show_completed_tasks: true,
            ...input.ui_preferences
          }
        };
        
        const { data, error } = await ctx.supabaseAdmin
          .from('user_settings')
          .insert(defaultSettings)
          .select()
          .single();
          
        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        return data;
      } else if (fetchError) {
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: fetchError.message });
      }
      
      // Update existing settings
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .update(input)
        .eq('user_id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getOnboardingStatus: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('id, onboarding_completed')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { onboardingCompleted: data?.onboarding_completed || false };
    }),
    
  completeOnboarding: protectedProcedure
    .mutation(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update({ onboarding_completed: true })
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { success: true };
    }),
}); ```
\n\n## Realtime Channel: index.ts
**File:** ./server/src/index.ts
\n```
import express, { Request, Response } from 'express';
import cors from 'cors';
import { createExpressMiddleware } from '@trpc/server/adapters/express';
import { appRouter } from './router';
import { createContext } from './context';

const app = express();
const port = process.env.PORT || 3000;

// Enable CORS for client app
app.use(cors({
  origin: ['http://localhost:8081', 'http://localhost:19000', 'http://localhost:19006', 'exp://localhost:19000'],
  credentials: true,
}));

// Health check endpoint
app.get('/health', (_: Request, res: Response) => {
  res.status(200).json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Create tRPC middleware
app.use('/api/trpc', createExpressMiddleware({
  router: appRouter,
  createContext,
}));

// Start server
app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
  console.log(`tRPC API available at http://localhost:${port}/api/trpc`);
}); ```
\n\n## Realtime Channel: offline-sync.ts
**File:** ./utils/offline-sync.ts
\n```
import AsyncStorage from '@react-native-async-storage/async-storage';
import NetInfo from '@react-native-community/netinfo';
import { queryClient } from './query-client';
import { supabase } from './supabase';

// Keys for offline data
const OFFLINE_MUTATIONS_KEY = 'aether-offline-mutations';
const PENDING_ITEMS_KEY = 'aether-pending-items';

// Types
export interface PendingItem {
  id: string;
  type: string;
  data: any;
  createdAt: number;
  isNotSynced: boolean;
}

interface OfflineMutation {
  id: string;
  type: 'create' | 'update' | 'delete';
  entity: string;
  data: any;
  timestamp: number;
}

/**
 * Save a mutation to be processed when back online
 */
export async function saveOfflineMutation(
  type: 'create' | 'update' | 'delete',
  entity: string,
  data: any
): Promise<string> {
  try {
    // Generate a temporary ID for new items
    const id = `temp-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
    
    // Create mutation object
    const mutation: OfflineMutation = {
      id,
      type,
      entity,
      data,
      timestamp: Date.now(),
    };
    
    // Get existing mutations
    const existingMutationsStr = await AsyncStorage.getItem(OFFLINE_MUTATIONS_KEY);
    const existingMutations: OfflineMutation[] = existingMutationsStr 
      ? JSON.parse(existingMutationsStr) 
      : [];
    
    // Add new mutation
    existingMutations.push(mutation);
    
    // Save mutations back to storage
    await AsyncStorage.setItem(OFFLINE_MUTATIONS_KEY, JSON.stringify(existingMutations));
    
    // Also add to pending items for UI
    if (type === 'create' || type === 'update') {
      await addToPendingItems(id, entity, data);
    }
    
    return id;
  } catch (error) {
    console.error('Error saving offline mutation:', error);
    throw error;
  }
}

/**
 * Add an item to the pending items list for UI display
 */
async function addToPendingItems(id: string, type: string, data: any): Promise<void> {
  try {
    const existingItemsStr = await AsyncStorage.getItem(PENDING_ITEMS_KEY);
    const existingItems: PendingItem[] = existingItemsStr 
      ? JSON.parse(existingItemsStr)
      : [];
    
    // Create a pending item
    const pendingItem: PendingItem = {
      id,
      type,
      data,
      createdAt: Date.now(),
      isNotSynced: true,
    };
    
    // Add to list
    existingItems.push(pendingItem);
    
    // Save back to storage
    await AsyncStorage.setItem(PENDING_ITEMS_KEY, JSON.stringify(existingItems));
  } catch (error) {
    console.error('Error adding to pending items:', error);
  }
}

/**
 * Get all pending items for a specific type
 */
export async function getPendingItems(type: string): Promise<PendingItem[]> {
  try {
    const itemsStr = await AsyncStorage.getItem(PENDING_ITEMS_KEY);
    if (!itemsStr) return [];
    
    const items: PendingItem[] = JSON.parse(itemsStr);
    return items.filter(item => item.type === type);
  } catch (error) {
    console.error('Error getting pending items:', error);
    return [];
  }
}

/**
 * Synchronize offline mutations with the server
 */
export async function syncOfflineMutations(): Promise<boolean> {
  try {
    // Check if we're online
    const netInfo = await NetInfo.fetch();
    if (!netInfo.isConnected || netInfo.isInternetReachable === false) {
      console.log('Not connected to the internet, skipping sync');
      return false;
    }
    
    // Get all pending mutations
    const mutationsStr = await AsyncStorage.getItem(OFFLINE_MUTATIONS_KEY);
    if (!mutationsStr) return true; // Nothing to sync
    
    const mutations: OfflineMutation[] = JSON.parse(mutationsStr);
    if (!mutations.length) return true; // Nothing to sync
    
    console.log(`Syncing ${mutations.length} offline mutations...`);
    
    // Process each mutation in order
    const results = await Promise.allSettled(
      mutations.map(async (mutation) => {
        try {
          switch (mutation.type) {
            case 'create':
              return await processMutation('create', mutation);
            case 'update':
              return await processMutation('update', mutation);
            case 'delete':
              return await processMutation('delete', mutation);
            default:
              console.error('Unknown mutation type:', mutation.type);
              return false;
          }
        } catch (error) {
          console.error('Error processing mutation:', error);
          return false;
        }
      })
    );
    
    // Check results
    const allSucceeded = results.every(
      result => result.status === 'fulfilled' && result.value === true
    );
    
    if (allSucceeded) {
      // Clear pending mutations if all succeeded
      await AsyncStorage.removeItem(OFFLINE_MUTATIONS_KEY);
      await AsyncStorage.removeItem(PENDING_ITEMS_KEY);
      
      // Invalidate queries to refresh data
      queryClient.invalidateQueries();
      
      return true;
    } else {
      // Some mutations failed, remove the successful ones
      const successfulMutationIndexes = results.map((result, index) => 
        result.status === 'fulfilled' && result.value === true ? index : -1
      ).filter(index => index !== -1);
      
      const remainingMutations = mutations.filter(
        (_, index) => !successfulMutationIndexes.includes(index)
      );
      
      // Save remaining mutations
      await AsyncStorage.setItem(
        OFFLINE_MUTATIONS_KEY, 
        JSON.stringify(remainingMutations)
      );
      
      // Refresh query data
      queryClient.invalidateQueries();
      
      return false;
    }
  } catch (error) {
    console.error('Error syncing offline mutations:', error);
    return false;
  }
}

/**
 * Process a single mutation against the server
 */
async function processMutation(
  type: 'create' | 'update' | 'delete',
  mutation: OfflineMutation
): Promise<boolean> {
  try {
    // Get the entity table name
    const table = mutation.entity;
    
    switch (type) {
      case 'create': {
        // For create, we remove any temp id and insert the record
        const { id, ...data } = mutation.data;
        const { data: responseData, error } = await supabase
          .from(table)
          .insert(data)
          .select();
          
        if (error) throw error;
        return true;
      }
      
      case 'update': {
        // For update, we update the record by ID
        const { id, ...data } = mutation.data;
        const { error } = await supabase
          .from(table)
          .update(data)
          .eq('id', id);
          
        if (error) throw error;
        return true;
      }
      
      case 'delete': {
        // For delete, we delete the record by ID
        const { error } = await supabase
          .from(table)
          .delete()
          .eq('id', mutation.data.id);
          
        if (error) throw error;
        return true;
      }
      
      default:
        return false;
    }
  } catch (error) {
    console.error('Error processing mutation:', error);
    return false;
  }
}

/**
 * Hook up background sync when app comes online
 */
export function setupBackgroundSync(): () => void {
  // Subscribe to network changes
  const unsubscribe = NetInfo.addEventListener(state => {
    // When we go from offline to online, sync mutations
    if (state.isConnected && state.isInternetReachable !== false) {
      syncOfflineMutations()
        .then(success => {
          console.log('Background sync completed:', success ? 'success' : 'with errors');
        })
        .catch(error => {
          console.error('Background sync failed:', error);
        });
    }
  });
  
  return unsubscribe;
} ```
\n\n## Realtime Channel: settings.ts
**File:** ./utils/settings.ts
\n```
import * as SecureStore from 'expo-secure-store';
import { Platform } from 'react-native';

// Settings keys
export const APP_SETTINGS_KEY = 'aether_app_settings';

// Default settings
const DEFAULT_SETTINGS = {
  enableNotifications: true,
  enableDarkMode: null, // null means "use system setting"
  enableOfflineMode: true,
  syncOnCellular: true,
  lastSyncTimestamp: null,
};

// Type for app settings
export type AppSettings = typeof DEFAULT_SETTINGS;

/**
 * Get app settings from secure storage
 */
export async function getSettings(): Promise<AppSettings> {
  try {
    const storedSettings = await SecureStore.getItemAsync(APP_SETTINGS_KEY);
    if (!storedSettings) return DEFAULT_SETTINGS;
    
    return { ...DEFAULT_SETTINGS, ...JSON.parse(storedSettings) };
  } catch (error) {
    console.error('Error getting settings:', error);
    return DEFAULT_SETTINGS;
  }
}

/**
 * Save app settings to secure storage
 */
export async function saveSettings(settings: Partial<AppSettings>): Promise<void> {
  try {
    const currentSettings = await getSettings();
    const newSettings = { ...currentSettings, ...settings };
    
    await SecureStore.setItemAsync(
      APP_SETTINGS_KEY, 
      JSON.stringify(newSettings)
    );
  } catch (error) {
    console.error('Error saving settings:', error);
  }
}

/**
 * Update a single setting
 */
export async function updateSetting<K extends keyof AppSettings>(
  key: K, 
  value: AppSettings[K]
): Promise<void> {
  await saveSettings({ [key]: value } as Partial<AppSettings>);
}

/**
 * Get app version
 */
export function getAppVersion(): string {
  // In a real app, you would use expo-constants to get the app version
  // import Constants from 'expo-constants';
  // return Constants.expoConfig.version;
  return '1.0.0';
}

/**
 * Get platform information
 */
export function getPlatformInfo(): string {
  return `${Platform.OS} ${Platform.Version}`;
} ```
\n\n## Realtime Channel: nats-client.ts
**File:** ./utils/nats-client.ts
\n```
import { QueryClient } from '@tanstack/react-query';
import { connect, type ConnectionOptions, type NatsConnection, StringCodec } from 'nats.ws';

// Codec for encoding/decoding NATS messages
const sc = StringCodec();

// Type for cache update handlers
type CacheUpdateHandler = (data: any) => void;

// Global handlers for different subjects
const handlers: Record<string, CacheUpdateHandler[]> = {};

// Connection state
let natsConnection: NatsConnection | null = null;
let queryClient: QueryClient | null = null;
let isConnecting = false;

/**
 * Initialize the NATS client and connect to the server
 */
export async function initNatsClient(
  url: string, 
  qc: QueryClient,
  options: Partial<ConnectionOptions> = {}
): Promise<NatsConnection> {
  if (natsConnection) {
    return natsConnection;
  }
  
  if (isConnecting) {
    throw new Error('NATS connection is already in progress');
  }
  
  isConnecting = true;
  
  try {
    // Set the query client for cache updates
    queryClient = qc;
    
    // Connect to NATS server
    natsConnection = await connect({
      servers: url,
      // Add required polyfills for React Native
      // These would need to be properly implemented in a real app
      ...options,
    });
    
    console.log('Connected to NATS server');
    
    // Setup ping interval to keep connection alive
    const pingInterval = setInterval(() => {
      if (natsConnection && !natsConnection.isClosed) {
        // Note: Using a custom ping mechanism instead of the built-in one
        try {
          const start = Date.now();
          // Simple ping using a request to a dummy subject
          natsConnection.request('_PING_', undefined, { timeout: 1000 })
            .then(() => {
              const latency = Date.now() - start;
              console.log(`NATS server latency: ${latency}ms`);
            })
            .catch((err: Error) => {
              console.error('NATS ping error:', err.message);
            });
        } catch (err) {
          const error = err as Error;
          console.error('NATS ping error:', error.message);
        }
      } else {
        clearInterval(pingInterval);
      }
    }, 30000);
    
    // Handle connection close
    natsConnection.closed().then(() => {
      console.log('NATS connection closed');
      natsConnection = null;
      clearInterval(pingInterval);
      // Could implement reconnection logic here
    });
    
    return natsConnection;
  } catch (error) {
    console.error('Failed to connect to NATS server:', error);
    isConnecting = false;
    throw error;
  }
}

/**
 * Subscribe to a NATS subject and update the React Query cache
 */
export async function subscribeWithCache(
  subject: string,
  queryKey: unknown[],
  updateType: 'invalidate' | 'setData' = 'invalidate'
): Promise<() => void> {
  if (!natsConnection) {
    throw new Error('NATS client not initialized');
  }
  
  if (!queryClient) {
    throw new Error('QueryClient not set');
  }
  
  // Create subscription
  const subscription = natsConnection.subscribe(subject);
  
  // Setup message handler
  (async () => {
    for await (const msg of subscription) {
      try {
        const data = JSON.parse(sc.decode(msg.data));
        
        if (updateType === 'invalidate') {
          // Invalidate the cache for this query key
          queryClient.invalidateQueries({ queryKey });
        } else {
          // Update the cache directly
          queryClient.setQueryData(queryKey, data);
        }
        
        // Call any custom handlers
        if (handlers[subject]) {
          handlers[subject].forEach(handler => handler(data));
        }
      } catch (error) {
        const err = error as Error;
        console.error(`Error handling message for ${subject}:`, err.message);
      }
    }
  })();
  
  // Return unsubscribe function
  return () => {
    subscription.unsubscribe();
  };
}

/**
 * Add a custom handler for a subject
 */
export function addSubjectHandler(subject: string, handler: CacheUpdateHandler): () => void {
  if (!handlers[subject]) {
    handlers[subject] = [];
  }
  
  handlers[subject].push(handler);
  
  // Return a function to remove the handler
  return () => {
    if (handlers[subject]) {
      handlers[subject] = handlers[subject].filter(h => h !== handler);
    }
  };
}

/**
 * Get the NATS connection
 */
export function getNatsConnection(): NatsConnection | null {
  return natsConnection;
}

/**
 * Close the NATS connection
 */
export async function closeNatsConnection(): Promise<void> {
  if (natsConnection) {
    await natsConnection.close();
    natsConnection = null;
  }
} ```
\n\n## Realtime Channel: supabase.ts
**File:** ./utils/supabase.ts
\n```
import 'react-native-url-polyfill/auto';
import { createClient } from '@supabase/supabase-js';
import * as SecureStore from 'expo-secure-store';

// SecureStore adapter for Supabase auth persistence
const ExpoSecureStoreAdapter = {
  getItem: (key: string) => {
    return SecureStore.getItemAsync(key);
  },
  setItem: (key: string, value: string) => {
    return SecureStore.setItemAsync(key, value);
  },
  removeItem: (key: string) => {
    return SecureStore.deleteItemAsync(key);
  },
};

// Get Supabase URL and anon key from environment variables
// In production, these should be set in app.config.js or via EAS secrets
const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL || '';
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY || '';

if (!supabaseUrl || !supabaseAnonKey) {
  console.warn(
    'Supabase URL or anon key not found. Make sure to set EXPO_PUBLIC_SUPABASE_URL and EXPO_PUBLIC_SUPABASE_ANON_KEY environment variables.'
  );
}

// Create Supabase client
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: ExpoSecureStoreAdapter,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
});

// Helper function to check if user is authenticated
export const isAuthenticated = async () => {
  const { data, error } = await supabase.auth.getSession();
  return !!data.session;
};

// Helper function to get current user
export const getCurrentUser = async () => {
  const { data, error } = await supabase.auth.getUser();
  if (error) {
    console.error('Error getting user:', error.message);
    return null;
  }
  return data.user;
}; ```
\n\n## Realtime Channel: mock-api.ts
**File:** ./utils/mock-api.ts
\n```
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

// Initialize tRPC for our mock API
const t = initTRPC.create();

// Export a procedure builder
const router = t.router;
const publicProcedure = t.procedure;

// Example router with some procedures
export const appRouter = router({
  greeting: {
    hello: publicProcedure
      .input(z.object({ name: z.string().optional() }))
      .query(({ input }) => {
        return {
          greeting: `Hello ${input.name ?? 'world'}`,
        };
      }),
    goodbye: publicProcedure
      .query(() => {
        return {
          greeting: 'Goodbye!',
        };
      }),
  },
  user: {
    get: publicProcedure
      .input(z.object({ id: z.string() }))
      .query(({ input }) => {
        return {
          id: input.id,
          name: 'Mock User',
        };
      }),
    list: publicProcedure
      .query(() => {
        return [
          { id: '1', name: 'Mock User 1' },
          { id: '2', name: 'Mock User 2' },
        ];
      }),
  },
  auth: {
    refreshToken: publicProcedure
      .input(z.object({ refreshToken: z.string() }))
      .mutation(async ({ input }) => {
        console.log('Mock API: refreshToken called with', input.refreshToken);
        // Simulate checking refresh token and issuing new ones
        await new Promise(resolve => setTimeout(resolve, 300));
        if (input.refreshToken === 'valid-refresh-token') { // Example valid token
          return {
            accessToken: `mock-access-${Date.now()}`,
            refreshToken: `mock-refresh-${Date.now()}`,
          };
        } else {
          // Throw error for invalid refresh token
          throw new Error('Invalid refresh token'); 
        }
      }),
    // Add login/logout mutations here later
  },
  item: {
    add: publicProcedure
      .input(z.object({ name: z.string() }))
      .mutation(async ({ input }) => {
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 500));
        // In a real backend, save to DB
        console.log('Mock API: Adding item', input);
        return {
          id: Math.random().toString(36).substring(7), // Generate random ID
          name: input.name,
          status: 'added'
        };
      }),
  },
});

// Export type router type
export type AppRouter = typeof appRouter; ```
\n\n## Realtime Channel: Skeleton.tsx
**File:** ./components/ui/Skeleton.tsx
\n```
import React from 'react';
import { DimensionValue } from 'react-native';
import { YStack, XStack, styled, Stack } from 'tamagui';
import { useColorScheme } from '@/hooks/useColorScheme';

const SkeletonBase = styled(Stack, {
  name: 'SkeletonBase',
  backgroundColor: '$gray5',
  overflow: 'hidden',
  position: 'relative',
  variants: {
    colorMode: {
      light: { backgroundColor: '$gray5' },
      dark: { backgroundColor: '$gray9' },
    },
  } as const,
});

const SkeletonShimmer = styled(Stack, {
  name: 'SkeletonShimmer',
  position: 'absolute',
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  opacity: 0.5,
});

interface SkeletonProps {
  width?: DimensionValue;
  height?: DimensionValue;
  borderRadius?: number;
}

export function Skeleton({ width = '100%', height = 20, borderRadius = 4 }: SkeletonProps) {
  const colorScheme = useColorScheme();
  
  return (
    <SkeletonBase
      colorMode={colorScheme === 'dark' ? 'dark' : 'light'}
      width={width}
      height={height}
      borderRadius={borderRadius}
    />
  );
}

interface SkeletonRowProps {
  height?: DimensionValue;
  width?: DimensionValue;
  lines?: number;
  spacing?: number;
}

export function SkeletonRow({ height = 20, width = '100%', lines = 3, spacing = 10 }: SkeletonRowProps) {
  return (
    <YStack space={spacing}>
      {Array.from({ length: lines }).map((_, i) => (
        <Skeleton 
          key={i}
          height={height}
          width={i === lines - 1 && typeof width === 'string' ? '70%' : width}
        />
      ))}
    </YStack>
  );
}

interface SkeletonCardProps {
  height?: DimensionValue;
  width?: DimensionValue;
}

export function SkeletonCard({ height = 100, width = '100%' }: SkeletonCardProps) {
  return (
    <YStack space="$2">
      <Skeleton height={height} width={width} borderRadius={8} />
    </YStack>
  );
}

interface SkeletonAvatarProps {
  size?: number;
}

export function SkeletonAvatar({ size = 40 }: SkeletonAvatarProps) {
  return <Skeleton width={size} height={size} borderRadius={size / 2} />;
}

interface SkeletonProfileProps {
  avatarSize?: number;
}

export function SkeletonProfile({ avatarSize = 40 }: SkeletonProfileProps) {
  return (
    <XStack space="$3" alignItems="center">
      <SkeletonAvatar size={avatarSize} />
      <YStack space="$1" flex={1}>
        <Skeleton width="60%" height={16} />
        <Skeleton width="40%" height={12} />
      </YStack>
    </XStack>
  );
}

interface SkeletonCircleProps {
  size?: number;
}

export function SkeletonCircle({ size = 60 }: SkeletonCircleProps) {
  return <Skeleton width={size} height={size} borderRadius={size / 2} />;
}
```
\n\n## Realtime Channel: HabitTracker.tsx
**File:** ./components/planner/HabitTracker.tsx
\n```
import React, { useState } from "react";
import { View, StyleSheet } from "react-native";
import { XStack, YStack, Text, Button, H4, Separator } from "tamagui";
import StreakCalendar from './StreakCalendar';
import { Plus, Check } from "@tamagui/lucide-icons";
import { format } from "date-fns";

interface Habit {
  id: string;
  name: string;
  description?: string;
  completedDates: string[]; // ISO date strings
}

interface HabitTrackerProps {
  habits: Habit[];
  onAddHabit?: () => void;
  onToggleHabit?: (habitId: string, date: string, completed: boolean) => void;
  onHabitPress?: (habit: Habit) => void;
}

export function HabitTracker({
  habits = [],
  onAddHabit,
  onToggleHabit,
  onHabitPress,
}: HabitTrackerProps) {
  const today = format(new Date(), "yyyy-MM-dd");

  const handleToggleHabit = (habit: Habit) => {
    if (!onToggleHabit) return;
    
    const isCompleted = habit.completedDates.includes(today);
    onToggleHabit(habit.id, today, !isCompleted);
  };

  return (
    <YStack space="$4">
      <XStack justifyContent="space-between" alignItems="center">
        <H4>Habits</H4>
        <Button 
          size="$2" 
          circular 
          icon={<Plus size={16} />} 
          onPress={onAddHabit}
        />
      </XStack>

      {habits.length === 0 ? (
        <YStack 
          p="$4"
          alignItems="center" 
          justifyContent="center" 
          backgroundColor="$gray2" 
          borderRadius="$4"
        >
          <Text color="$gray11" textAlign="center">
            No habits yet. Add your first habit to start tracking.
          </Text>
        </YStack>
      ) : (
        <YStack space="$3">
          {habits.map((habit, index) => (
            <YStack key={habit.id} space="$2">
              {index > 0 && <Separator />}
              <HabitItem 
                habit={habit} 
                onToggle={() => handleToggleHabit(habit)}
                onPress={() => onHabitPress?.(habit)} 
              />
            </YStack>
          ))}
        </YStack>
      )}
    </YStack>
  );
}

interface HabitItemProps {
  habit: Habit;
  onToggle: () => void;
  onPress: () => void;
}

function HabitItem({ habit, onToggle, onPress }: HabitItemProps) {
  const today = format(new Date(), "yyyy-MM-dd");
  const isCompletedToday = habit.completedDates.includes(today);

  return (
    <XStack 
      p="$3"
      borderRadius="$4" 
      backgroundColor="$gray2"
      justifyContent="space-between"
      alignItems="center"
      pressStyle={{ opacity: 0.8 }}
      onPress={onPress}
    >
      <YStack space="$1" flex={1}>
        <Text fontSize="$3" fontWeight="$5">
          {habit.name}
        </Text>
        {habit.description && (
          <Text fontSize="$2" color="$gray11">
            {habit.description}
          </Text>
        )}
        
        <YStack mt="$2">
          <StreakCalendar
            completedDates={habit.completedDates}
          />
        </YStack>
      </YStack>

      <Button
        size="$3"
        circular
        backgroundColor={isCompletedToday ? "$primary9" : "$gray4"}
        onPress={(e) => {
          e.stopPropagation();
          onToggle();
        }}
        pressStyle={{
          backgroundColor: isCompletedToday ? "$primary8" : "$gray5",
        }}
      >
        <Check 
          size={18} 
          color={isCompletedToday ? "$gray1" : "$gray11"} 
        />
      </Button>
    </XStack>
  );
} ```
\n\n## Realtime Channel: EmptyOrSkeleton.tsx
**File:** ./components/EmptyOrSkeleton.tsx
\n```
import React, { ReactNode } from 'react';
import { StyleSheet, StyleProp, ViewStyle, TextStyle, ImageStyle, ImageSourcePropType, View, Image } from 'react-native';
import Animated from 'react-native-reanimated';
import { Text, YStack, StackProps } from 'tamagui';
import { useSkeleton, SkeletonOptions } from '@/hooks/useSkeleton';

export interface EmptyStateProps {
  /** Title text for the empty state */
  title?: string;
  /** Subtitle/description text for the empty state */
  message?: string;
  /** Optional image/illustration to display */
  image?: ImageSourcePropType;
  /** Optional custom component to render instead of default empty state */
  customEmptyComponent?: ReactNode;
  /** Style for the container */
  containerStyle?: StyleProp<ViewStyle>;
  /** Style for the title */
  titleStyle?: StyleProp<TextStyle>;
  /** Style for the message */
  messageStyle?: StyleProp<TextStyle>;
  /** Style for the image container */
  imageContainerStyle?: StyleProp<ViewStyle>;
  /** Style for the image */
  imageStyle?: StyleProp<ImageStyle>;
}

export interface EmptyOrSkeletonProps extends EmptyStateProps, StackProps {
  /** Whether data is loading */
  isLoading: boolean;
  /** Children to display when not loading and not empty */
  children: ReactNode;
  /** Whether the content is empty (no data) */
  isEmpty?: boolean;
  /** Number of skeleton placeholders to display when loading */
  skeletonCount?: number;
  /** Height of each skeleton item */
  skeletonHeight?: number;
  /** Width of each skeleton item (default: 100%) */
  skeletonWidth?: number | string;
  /** Gap between skeleton items */
  skeletonGap?: number;
  /** Border radius for skeleton items */
  skeletonBorderRadius?: number;
  /** Custom skeleton component */
  customSkeletonComponent?: ReactNode;
  /** Options for the skeleton animation */
  skeletonOptions?: SkeletonOptions;
}

/**
 * Placeholder component for the skeleton loading state
 */
const SkeletonPlaceholder = ({
  height, 
  width = '100%',
  borderRadius = 8,
  options
}: {
  height: number;
  width?: number | string;
  borderRadius?: number;
  options?: SkeletonOptions;
}) => {
  const { shimmerStyle, styles } = useSkeleton(options);
  
  return (
    <Animated.View 
      style={[
        styles.container, 
        { 
          height,
          width: typeof width === 'string' ? width : width,
          borderRadius
        } as ViewStyle
      ]}
    >
      <Animated.View style={[styles.shimmer, shimmerStyle]} />
    </Animated.View>
  );
};

/**
 * Default empty state component
 */
const EmptyState = ({
  title = 'No data found',
  message = 'There is nothing to display at the moment.',
  image,
  containerStyle,
  titleStyle,
  messageStyle,
  imageContainerStyle,
  imageStyle
}: EmptyStateProps) => {
  return (
    <YStack
      alignItems="center"
      justifyContent="center"
      padding="$4"
      space="$3"
      style={containerStyle}
    >
      {image && (
        <View style={[styles.imageContainer, imageContainerStyle]}>
          <Image source={image} style={[styles.image, imageStyle]} />
        </View>
      )}
      <Text 
        fontSize="$6" 
        fontWeight="bold" 
        textAlign="center"
        style={titleStyle}
      >
        {title}
      </Text>
      <Text 
        fontSize="$4" 
        color="$gray10" 
        textAlign="center"
        style={messageStyle}
      >
        {message}
      </Text>
    </YStack>
  );
};

/**
 * A component that conditionally renders skeleton, empty state, or content
 * based on loading and data states.
 */
export default function EmptyOrSkeleton({
  isLoading,
  isEmpty = false,
  children,
  skeletonCount = 3,
  skeletonHeight = 80,
  skeletonWidth = '100%',
  skeletonGap = 12,
  skeletonBorderRadius = 8,
  customSkeletonComponent,
  customEmptyComponent,
  skeletonOptions,
  title,
  message,
  image,
  containerStyle,
  titleStyle,
  messageStyle,
  imageContainerStyle,
  imageStyle,
  ...stackProps
}: EmptyOrSkeletonProps) {
  // If loading, show skeleton
  if (isLoading) {
    if (customSkeletonComponent) {
      return <>{customSkeletonComponent}</>;
    }
    
    return (
      <YStack space={skeletonGap} width="100%" {...stackProps}>
        {Array.from({ length: skeletonCount }).map((_, index) => (
          <SkeletonPlaceholder
            key={`skeleton-${index}`}
            height={skeletonHeight}
            width={skeletonWidth}
            borderRadius={skeletonBorderRadius}
            options={skeletonOptions}
          />
        ))}
      </YStack>
    );
  }
  
  // If empty, show empty state
  if (isEmpty) {
    if (customEmptyComponent) {
      return <>{customEmptyComponent}</>;
    }
    
    return (
      <EmptyState
        title={title}
        message={message}
        image={image}
        containerStyle={containerStyle}
        titleStyle={titleStyle}
        messageStyle={messageStyle}
        imageContainerStyle={imageContainerStyle}
        imageStyle={imageStyle}
      />
    );
  }
  
  // Otherwise, show children
  return <>{children}</>;
}

const styles = StyleSheet.create({
  imageContainer: {
    marginBottom: 20,
  },
  image: {
    width: 150,
    height: 150,
    resizeMode: 'contain',
  },
}); ```
\n\n## Realtime Channel: HabitCheckItem.tsx
**File:** ./components/dashboard/HabitCheckItem.tsx
\n```
import React, { useState, useEffect } from 'react';
import { Text, XStack, Button, YStack, useTheme } from 'tamagui';
import * as Haptics from 'expo-haptics';
import { trpc, RouterOutputs } from '@/utils/trpc';

// Custom types that match the backend expectations
type DashboardHabit = {
  id: string;
  name: string;  // Backend returns 'name'
  description?: string;
  habit_type?: string;
  streak?: number;
  completed: boolean; // Backend returns 'completed'
  duration_minutes?: number;
  last_entry_id?: string; // Add last_entry_id property
};

// Types for habit entry mutations
type CreateHabitEntryInput = {
  habit_id: string;
  date: string;
  completed?: boolean;
  quantity_value?: number | null;
  notes?: string | null;
};

type DeleteHabitEntryInput = {
  id: string; // Update property name
};

interface HabitCheckItemProps {
  habit: DashboardHabit;
  onToggle?: (habitId: string, completedToday: boolean) => void; 
}

export default function HabitCheckItem({ habit, onToggle }: HabitCheckItemProps) {
  const [checked, setChecked] = useState(habit.completed);
  const [isUpdating, setIsUpdating] = useState(false);
  const theme = useTheme(); 
  const utils = trpc.useUtils(); 

  // Define specific theme colors with safe access and fallbacks to theme variables
  const green10 = theme?.green10?.val ?? '$green10'; 
  const gray10 = theme?.gray10?.val ?? '$gray10'; 
  const orange10 = theme?.orange10?.val ?? '$orange10'; 


  const createEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: (updatedHabit) => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error creating habit entry:', error);
    }
  });

  const deleteEntryMutation = trpc.habit.deleteHabitEntry.useMutation({
    onSuccess: () => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error deleting habit entry:', error);
    }
  });

  useEffect(() => {
    setChecked(habit.completed);
  }, [habit.completed]);

  const handleToggle = () => {
    const newValue = !checked;
    setChecked(newValue); 
    setIsUpdating(true);

    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);

    const todayDateString = new Date().toISOString().split('T')[0];

    if (newValue) {
      const createInput: CreateHabitEntryInput = {
        habit_id: habit.id,
        date: todayDateString,
        completed: true, 
        quantity_value: null, 
        notes: null, 
      };
      createEntryMutation.mutate(createInput);
    } else {
      if (habit.last_entry_id) { 
        const deleteInput: DeleteHabitEntryInput = {
          id: habit.last_entry_id, 
        };
        deleteEntryMutation.mutate(deleteInput);
      } else {
        console.warn("Attempted to delete habit entry, but last_entry_id is missing.");
      }
    }

    if (onToggle) {
      onToggle(habit.id, newValue);
    }
  };

  const streakColor = checked ? green10 : gray10; // Use safe theme value
  const habitTypeColor = orange10; // Use safe theme value

  return (
    <XStack 
      backgroundColor="$backgroundStrong" // Use theme variable
      padding="$3"
      borderRadius="$4"
      alignItems="center"
      justifyContent="space-between"
      space="$3"
    >
      <YStack flex={1} gap="$1">
        <Text fontSize="$4" fontWeight="500" color="$color"> // Use theme variable
          {habit.name}
        </Text>
        
        {habit.streak != null && habit.streak > 0 && ( // Add null check
          <Text fontSize="$2" color={streakColor}> 
            Streak: {habit.streak ?? 0}
          </Text>
        )}
        {habit.habit_type && (
          <Text fontSize="$2" color={habitTypeColor}> // Use safe theme value
            ({habit.habit_type})
          </Text>
        )}
      </YStack>
      
      <Button
        size="$3"
        variant={checked ? undefined : 'outlined'} // Let variant handle appearance
        // Remove explicit colors - rely on theme/variant
        theme={checked ? 'green' : undefined} // Apply green theme when checked
        onPress={handleToggle}
        disabled={isUpdating} 
        iconAfter={checked ? <Text>✓</Text> : undefined}
      >
        {checked ? "Done" : "Check-in"}
      </Button>
    </XStack>
  );
}```
\n\n## Realtime Channel: TaskItem.tsx
**File:** ./components/dashboard/TaskItem.tsx
\n```
import React from 'react';
// Use Tamagui components
import { Text, XStack, YStack, Checkbox, Spinner } from 'tamagui'; 
import { trpc, RouterOutputs, RouterInputs } from '@/utils/trpc';
import { Check } from '@tamagui/lucide-icons';

// Custom Task type that matches the actual format returned from the backend
type Task = {
  id: string;
  name: string;  // Backend returns 'name' not 'title'
  status: string;
  priority?: number;
  due_date?: string; // Backend returns 'due_date' not 'due'
  notes?: string;
  goal_id?: string;
  // Include other fields as needed
};

interface TaskItemProps {
  task: Task;
  onPress: () => void;
}

export default function TaskItem({ task, onPress }: TaskItemProps) {
  
  // Setup toggleTask mutation with optimistic updates
  const utils = trpc.useContext();
  // Setup mutation for task toggling
  const toggleTaskMutation = trpc.task.toggleTask.useMutation({
    // Optimistically update the UI
    onMutate: async ({ taskId, completed }: { taskId: string; completed?: boolean }) => {
      // Default to toggling the current state if completed is not provided
      const newCompleted = completed !== undefined ? completed : !isCompleted;
      // Cancel outgoing fetches that might overwrite our optimistic update
      await utils.task.getTasks.cancel();
      await utils.dashboard.getDashboardData.cancel();
      
      // Get previous data for potential rollback
      const prevTasksData = utils.task.getTasks.getData();
      const prevDashboardData = utils.dashboard.getDashboardData.getData();
      
      // Optimistically update tasks data if present
      if (prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return old.map((t: any) => {
            if (t.id === taskId) {
              return {
                ...t,
                status: completed ? 'completed' : 'in-progress'
              };
            }
            return t;
          });
        });
      }
      
      // Optimistically update dashboard data if present
      if (prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return {
            ...old,
            tasks: old.tasks.map((t: any) => {
              if (t.id === taskId) {
                return {
                  ...t,
                  status: newCompleted ? 'completed' : 'in-progress'
                };
              }
              return t;
            }),
          };
        });
      }
      
      // Return previous data for rollback
      return { prevTasksData, prevDashboardData };
    },
    
    // If something goes wrong, rollback optimistic updates
    onError: (err: any, variables: any, context: any) => {
      if (context?.prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, context.prevTasksData);
      }
      if (context?.prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, context.prevDashboardData);
      }
      console.error('Error toggling task:', err);
    },
    
    // Always refetch after error or success
    onSettled: () => {
      utils.task.getTasks.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    }
  });

  // Handle checkbox toggle
  const handleToggle = () => {
    toggleTaskMutation.mutate({
      taskId: task.id, // Using taskId as expected by the backend
      completed: !isCompleted
    });
  };

  // Map priority to color
  const priorityColor = task.priority === 1 ? '$brandRed' : 
                        task.priority === 2 ? '$brandYellow' : 
                        '$brandGreen';
  
  // Format due date
  const formattedDate = task.due_date 
    ? new Date(task.due_date).toLocaleDateString(undefined, { 
        month: 'short', 
        day: 'numeric' 
      })
    : null;
    
  // Determine task completion status
  const isCompleted = task.status === 'completed';
  // No need for text style object since we use Tamagui props directly

  
  // Use YStack as the base component
  return (
    <YStack 
      backgroundColor="$backgroundStrong"
      padding="$3"
      borderRadius="$4"
      space="$1" // Add space between XStack and Date Text
    >
      <XStack alignItems="center" space="$2"> {/* Use XStack for horizontal layout */}
        {/* Checkbox for task completion */}
        <Checkbox
          size="$4"
          checked={isCompleted}
          onCheckedChange={handleToggle}
          disabled={toggleTaskMutation.isPending}
        >
          {toggleTaskMutation.isPending ? (
            <Spinner size="small" color="$brandPrimary" />
          ) : (
            <Checkbox.Indicator>
              <Check size={16} />
            </Checkbox.Indicator>
          )}
        </Checkbox>

        {/* Container for task details (clickable) */}
        <XStack flex={1} tag="pressable" onPress={onPress} pressStyle={{ opacity: 0.7 }}>
          {/* Priority Dot using YStack */}
          <YStack 
            width="$2" // Use size token for width
            height="$2" // Use size token for height
            borderRadius="$10" // Use a large radius token
            backgroundColor={priorityColor} 
            marginRight="$2" // Use space token for margin
          />
          <Text 
            fontSize="$4" // Use font size token
            fontWeight={task.priority === 1 ? '600' : '400'} // Keep fontWeight
            color="$color"
            flex={1} // Allow text to take remaining space
            opacity={isCompleted ? 0.7 : 1}
            textDecorationLine={isCompleted ? 'line-through' : undefined} // Proper Tamagui text decoration
          >
            {task.name}
          </Text>
        </XStack>
      </XStack>
      
      {formattedDate && (
        // Removed explicit margin, rely on outer YStack space
        <Text color="$gray9" fontSize="$2">
          Due: {formattedDate}
        </Text>
      )}
    </YStack>
  );
} ```
\n\n## Realtime Channel: dashboardRouter.test.ts
**File:** ./__tests__/server/routers/dashboardRouter.test.ts
\n```
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { createInnerTRPCContext, mockSupabaseAdmin, MockableTableOperations } from '../test-helpers';
import { DeepMockProxy, mockDeep } from 'jest-mock-extended';
import { appRouter } from '../../../server/src/router';
import { TRPCError } from '@trpc/server';

// Using mockSupabaseAdmin from test-helpers

// Type for database table names to avoid 'any' parameter type errors
type TableName = 'tasks' | 'goals' | 'habits' | 'habit_entries' | 'tracked_state_defs' | string;

/**
 * Create a test tRPC caller with proper context
 */
function createTestCaller(userId: string | null = 'test-user-id') {
  const ctx = createInnerTRPCContext({
    userId,
    supabase: mockSupabaseAdmin,
  });
  return appRouter.createCaller(ctx);
}

describe('dashboardRouter', () => {
  beforeEach(() => {
    // Reset all mocks before each test
    jest.clearAllMocks();
  });

  describe('getDashboardData', () => {
    it('should fetch dashboard data with default limits', async () => {
      // Mock data for habits aligned with updated schema
      const mockHabits = [
        {
          id: 'habit-1',
          user_id: 'test-user-id',
          title: 'Morning Run',
          cue: 'Wake up',
          routine: 'Go for a jog',
          reward: 'Coffee',
          streak: 3,
          best_streak: 5,
          created_at: '2024-04-20T12:00:00Z',
          updated_at: '2024-04-20T12:00:00Z'
        }
      ];

      // Mock data for goals aligned with updated schema
      const mockGoals = [
        {
          id: 'goal-1',
          user_id: 'test-user-id',
          title: 'Learn TypeScript',
          description: 'Master TypeScript for web development',
          progress: 0.5,
          target_date: '2024-06-01T00:00:00Z',
          created_at: '2024-04-15T10:00:00Z',
          updated_at: '2024-04-15T10:00:00Z'
        }
      ];

      // Mock data for tasks aligned with updated schema
      const mockTasks = [
        {
          id: 'task-1',
          user_id: 'test-user-id',
          title: 'Complete TypeScript course',
          notes: 'Focus on advanced types',
          status: 'in-progress',
          priority: 2,
          due: '2024-05-01T00:00:00Z',
          goal_id: 'goal-1',
          created_at: '2024-04-20T12:00:00Z',
          updated_at: '2024-04-20T12:00:00Z'
        }
      ];

      // Mock data for tracked states
      const mockTrackedStates: any[] = [];

      // Mock habit entries
      const mockHabitEntries = [
        {
          habit_id: 'habit-1',
          completed: true
        }
      ];

      // Create typed mock objects for each table, using our helper from test-helpers.ts
      function createTableMockWithData<T>(data: T) {
        const mock = mockDeep<MockableTableOperations>();
        
        // Configure chainable methods to return this (for method chaining)
        mock.select.mockReturnThis();
        mock.eq.mockReturnThis();
        mock.is.mockReturnThis();
        mock.neq.mockReturnThis();
        mock.or.mockReturnThis();
        mock.in.mockReturnThis();
        mock.order.mockReturnThis();
        mock.limit.mockReturnThis();
        
        // Make the mock awaitable with the provided data
        // Using a proper Promise interface implementation
        const response = { data, error: null, status: 200 };
        const mockPromise = Promise.resolve(response);
        
        // Add then/catch/finally methods to make the mock awaitable
        (mock as any).then = mockPromise.then.bind(mockPromise);
        (mock as any).catch = mockPromise.catch.bind(mockPromise);
        (mock as any).finally = mockPromise.finally.bind(mockPromise);
        
        return mock;
      }
      
      // Create mocks with the appropriate data
      const habitsTableMock = createTableMockWithData(mockHabits);
      const goalsTableMock = createTableMockWithData(mockGoals);
      const tasksTableMock = createTableMockWithData(mockTasks);
      const trackedStatesTableMock = createTableMockWithData(mockTrackedStates);
      const habitEntriesTableMock = createTableMockWithData(mockHabitEntries);

      // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
      mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
        if (table === 'habits') return habitsTableMock;
        if (table === 'goals') return goalsTableMock;
        if (table === 'tasks') return tasksTableMock;
        if (table === 'tracked_state_defs') return trackedStatesTableMock;
        if (table === 'habit_entries') return habitEntriesTableMock;
        
        // Default fallback - empty result mock
        return createTableMockWithData([]);
      });

      const caller = createTestCaller();
      const result = await caller.dashboard.getDashboardData();

      // Verify the result structure
      expect(result).toHaveProperty('habits');
      expect(result).toHaveProperty('goals');
      expect(result).toHaveProperty('tasks');
      expect(result).toHaveProperty('trackedStates');

      // Verify habits were formatted correctly
      expect(result.habits[0]).toEqual(expect.objectContaining({
        id: 'habit-1',
        title: 'Morning Run',
        streak: 3,
        completed: true
      }));

      // Verify goals were formatted correctly
      expect(result.goals[0]).toEqual(expect.objectContaining({
        id: 'goal-1',
        title: 'Learn TypeScript',
        progress: 0.5
      }));

      // Verify limits were passed correctly - now targeting the specific table mocks
      expect(habitsTableMock.limit).toHaveBeenCalledWith(5); // Default habit limit
      expect(tasksTableMock.limit).toHaveBeenCalledWith(10); // Default task limit
    });

    it('should fetch dashboard data with custom limits', async () => {
      // Create typed mock objects for each table
      const habitsTableMock = mockDeep<MockableTableOperations>();
      const goalsTableMock = mockDeep<MockableTableOperations>();
      const tasksTableMock = mockDeep<MockableTableOperations>();
      const trackedStatesTableMock = mockDeep<MockableTableOperations>();
      const habitEntriesTableMock = mockDeep<MockableTableOperations>();

      // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
      mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
        if (table === 'habits') return habitsTableMock;
        if (table === 'goals') return goalsTableMock;
        if (table === 'tasks') return tasksTableMock;
        if (table === 'tracked_state_defs') return trackedStatesTableMock;
        if (table === 'habit_entries') return habitEntriesTableMock;
        
        // Default case - should not happen in this test
        return mockDeep<MockableTableOperations>();
      });

      // No need to configure these mocks further - they already have their Promise behavior set
      // through the createTableMockWithData function with proper awaitable responses

      // Add specific behaviors needed for tasks
      tasksTableMock.neq.mockReturnThis();
      tasksTableMock.or.mockReturnThis();

      const caller = createTestCaller();
      await caller.dashboard.getDashboardData({
        habitLimit: 10,
        goalLimit: 15,
        taskLimit: 20
      });

      // Verify the custom limits were passed
      expect(mockSupabaseAdmin.limit).toHaveBeenCalledWith(10); // Custom habit limit
      expect(mockSupabaseAdmin.limit).toHaveBeenCalledWith(15); // Custom goal limit
      expect(mockSupabaseAdmin.limit).toHaveBeenCalledWith(20); // Custom task limit
    });

    it('should handle database errors properly', async () => {
      // Setup mock to simulate a database error
      mockSupabaseAdmin.from.mockImplementation(() => {
        return {
          ...mockSupabaseAdmin,
          select: jest.fn().mockReturnThis(),
          eq: jest.fn().mockReturnThis(),
          order: jest.fn().mockReturnThis(),
          limit: jest.fn().mockReturnValue({ 
            data: null, 
            error: { 
              message: 'Database error', 
              code: '42P01' // Table doesn't exist
            } 
          }),
        };
      });

      const caller = createTestCaller();
      
      // Expect the call to throw an INTERNAL_SERVER_ERROR
      await expect(caller.dashboard.getDashboardData()).rejects.toThrow(TRPCError);
    });

    it('should throw unauthorized error if no user is authenticated', async () => {
      const caller = createTestCaller(null);
      
      // Expect the call to throw an UNAUTHORIZED error
      await expect(caller.dashboard.getDashboardData()).rejects.toThrow(TRPCError);
    });
  });
});
```
\n\n## Realtime Channel: habitRouter.test.ts
**File:** ./__tests__/server/routers/habitRouter.test.ts
\n```
import { describe, it, expect, beforeEach, jest, afterEach } from '@jest/globals';
import { createInnerTRPCContext, mockSupabaseAdmin, resetSupabaseMocks } from '../test-helpers'; 
import { appRouter } from '../../../server/src/router';
import { TRPCError } from '@trpc/server';
import { Habit } from '../../../server/src/types/trpc-types'; 

/**
 * Helper function to create a test context
 * This mimics how the tRPC context would be created in a real request
 */
function createTestContext(userId: string | null = 'test-user-id') {
  return createInnerTRPCContext({
    userId,
    supabase: mockSupabaseAdmin,
  });
}

/**
 * Create a test tRPC caller with proper context
 * @param userId Optional user ID for authenticated routes
 * @returns A tRPC caller that can be used to call procedures
 */
function createTestCaller(userId: string | null = 'test-user-id') {
  const ctx = createTestContext(userId);
  return appRouter.createCaller(ctx);
}

// Helper function to create a properly awaitable mock with data
function createTableMockWithData<T>(data: T) {
  const mock = mockDeep<MockableTableOperations>();
  
  // Configure chainable methods to return this (for method chaining)
  mock.select.mockReturnThis();
  mock.eq.mockReturnThis();
  mock.order.mockReturnThis();
  mock.limit.mockReturnThis();
  mock.in.mockReturnThis();
  mock.update.mockReturnThis();
  mock.is.mockReturnThis();
  mock.isNull.mockReturnThis();
  mock.neq.mockReturnThis();
  mock.or.mockReturnThis();
  mock.filter.mockReturnThis();
  mock.delete.mockReturnThis();
  mock.upsert.mockReturnThis();
  mock.insert.mockReturnThis();
  
  // Add proper promise handling for awaitable operations
  const response = { data, error: null, status: 200, count: Array.isArray(data) ? data.length : undefined };
  const mockPromise = Promise.resolve(response);
  
  // Add then/catch/finally methods to make the mock awaitable
  (mock as any).then = mockPromise.then.bind(mockPromise);
  (mock as any).catch = mockPromise.catch.bind(mockPromise);
  (mock as any).finally = mockPromise.finally.bind(mockPromise);
  
  return mock;
}

describe('habitRouter', () => {
  beforeEach(() => {
    resetSupabaseMocks();
  });

  describe('getHabits', () => {
    it('should fetch active habits for the user with completion status', async () => {
      // --- Arrange --- 
      const userId = 'test-user-id';
      const todayStr = new Date().toISOString().split('T')[0];
      const mockHabits: Habit[] = [
        { id: 'habit-1', user_id: userId, title: 'Habit 1', cue: 'Morning', routine: 'Exercise', reward: 'Coffee', habit_type: 'boolean', goal_quantity: null, goal_unit: null, frequency_period: 'day', goal_frequency: 1, recurrence_rule: 'RRULE:FREQ=DAILY', recurrence_end_date: null, archived_at: null, streak: 5, best_streak: 10, created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
        { id: 'habit-2', user_id: userId, title: 'Habit 2', cue: 'Evening', routine: 'Read', reward: 'Relax', habit_type: 'quantity', goal_quantity: 30, goal_unit: 'minutes', frequency_period: 'week', goal_frequency: 3, recurrence_rule: 'RRULE:FREQ=WEEKLY;BYDAY=MO,WE,FR', recurrence_end_date: null, archived_at: null, streak: 2, best_streak: 2, created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
      ];
      const mockEntriesToday = [
        { habit_id: 'habit-1' }, // Only habit 1 is completed today
      ];

      // Create properly awaitable mocks with the test data
      const habitsMock = createTableMockWithData(mockHabits);
      const entriesMock = createTableMockWithData(mockEntriesToday);

      // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
      mockSupabaseAdmin.from.mockImplementation((table: string) => {
        if (table === 'habits') return habitsMock;
        if (table === 'habit_entries') return entriesMock;
        return createTableMockWithData([]); // Default empty result for other tables
      });
      
      // --- Act --- 
      const caller = createTestCaller(userId);
      const result = await caller.habit.getHabits();

      // --- Assert --- 
      expect(result).toHaveLength(2);
      // Check all fields, including new ones and completedToday
      expect(result[0]).toMatchObject({ 
        ...mockHabits[0], 
        frequency_period: 'day', 
        goal_frequency: 1,
        completedToday: true 
      });
      expect(result[1]).toMatchObject({ 
        ...mockHabits[1], 
        frequency_period: 'week',
        goal_frequency: 3,
        completedToday: false 
      });

      // Verify mocks - Check if specific methods were called
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(1, 'habits');
      expect(selectHabitsMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(eqHabitsMock).toHaveBeenCalledWith('user_id', userId);
      expect(isNullHabitsMock).toHaveBeenCalledWith('archived_at', null); // Check is call
      expect(habitsFilterMock).toHaveBeenCalledTimes(1); // Ensure filter was called

      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(2, 'habit_entries');
      expect(selectEntriesMock).toHaveBeenCalledWith('habit_id');
      expect(eqUserEntriesMock).toHaveBeenCalledWith('user_id', userId);
      expect(eqDateEntriesMock).toHaveBeenCalledWith('date', todayStr);
      // Check the final resolving mock was called correctly
      expect(entriesFilterMock).toHaveBeenCalledWith('habit_id', expect.arrayContaining([mockHabits[0].id, mockHabits[1].id]));
    });

    it('should return an empty array if no habits exist', async () => {
        // --- Arrange ---
      const userId = 'test-user-id';

      const habitsFilterMock = jest.fn<() => Promise<{ data: Habit[] | null; error: any }>>();
      habitsFilterMock.mockResolvedValue({ data: [], error: null }); // Resolve empty
      const isNullHabitsMock = jest.fn().mockReturnValue({ filter: habitsFilterMock });
      const eqHabitsMock = jest.fn().mockReturnValue({ isNull: isNullHabitsMock });
      const selectHabitsMock = jest.fn().mockReturnValue({ eq: eqHabitsMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectHabitsMock,
      } as any);

      // --- Act ---
      const caller = createTestCaller(userId);
      const result = await caller.habit.getHabits();

      // --- Assert ---
      expect(result).toEqual([]);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      // Ensure habit_entries was NOT called because the initial habit fetch was empty
      expect(mockSupabaseAdmin.from).toHaveBeenCalledTimes(1); 
      expect(habitsFilterMock).toHaveBeenCalledTimes(1); // Check filter was still called before resolving
    });

    it('should throw TRPCError on database error during habit fetch', async () => {
      // --- Arrange ---
      const userId = 'test-user-id';
      const dbError = { message: 'DB error fetching habits', code: '500' };
      
      const habitsFilterMock = jest.fn<() => Promise<{ data: Habit[] | null; error: any }>>();
      habitsFilterMock.mockResolvedValue({ data: null, error: dbError }); // Simulate error
      const isNullHabitsMock = jest.fn().mockReturnValue({ filter: habitsFilterMock });
      const eqHabitsMock = jest.fn().mockReturnValue({ isNull: isNullHabitsMock });
      const selectHabitsMock = jest.fn().mockReturnValue({ eq: eqHabitsMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectHabitsMock,
      } as any);
      
      // --- Act & Assert ---
      const caller = createTestCaller(userId);
      await expect(caller.habit.getHabits()).rejects.toThrowError(
        new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message })
      );
      expect(habitsFilterMock).toHaveBeenCalledTimes(1);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledTimes(1);
    });

    it('should throw TRPCError on database error during entry fetch', async () => {
        // --- Arrange ---
      const userId = 'test-user-id';
      const todayStr = new Date().toISOString().split('T')[0];
      const mockHabits: Habit[] = [
        { id: 'habit-1', user_id: userId, title: 'Habit 1', cue: 'Morning', routine: 'Exercise', reward: 'Coffee', habit_type: 'boolean', goal_quantity: null, goal_unit: null, frequency_period: 'day', goal_frequency: 1, recurrence_rule: 'RRULE:FREQ=DAILY', recurrence_end_date: null, archived_at: null, streak: 5, best_streak: 10, created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
      ];
      const dbError = { message: 'DB error fetching entries', code: '500' };

      // Mock successful habit fetch
      const habitsFilterMock = jest.fn<() => Promise<{ data: Habit[] | null; error: any }>>();
      habitsFilterMock.mockResolvedValue({ data: mockHabits, error: null });
      const isNullHabitsMock = jest.fn().mockReturnValue({ filter: habitsFilterMock });
      const eqHabitsMock = jest.fn().mockReturnValue({ isNull: isNullHabitsMock });
      const selectHabitsMock = jest.fn().mockReturnValue({ eq: eqHabitsMock });

      // Mock failing entry fetch
      const entriesFilterMock = jest.fn<() => Promise<{ data: any[] | null; error: any }>>();
      entriesFilterMock.mockResolvedValue({ data: null, error: dbError });
      const eqDateEntriesMock = jest.fn().mockReturnValue({ filter: entriesFilterMock });
      const eqUserEntriesMock = jest.fn().mockReturnValue({ eq: eqDateEntriesMock });
      const selectEntriesMock = jest.fn().mockReturnValue({ eq: eqUserEntriesMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectHabitsMock,
      } as any).mockReturnValueOnce({ // Mock for 'habit_entries'
        select: selectEntriesMock,
      } as any);
      
      // --- Act & Assert ---
      const caller = createTestCaller(userId);
      await expect(caller.habit.getHabits()).rejects.toThrowError(
        new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message })
      );
      expect(habitsFilterMock).toHaveBeenCalledTimes(1);
      expect(entriesFilterMock).toHaveBeenCalledTimes(1); // Ensure entry fetch was attempted
    });
  });

  describe('getHabitById', () => {
    it('should fetch a specific habit by ID', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-abc';
      const mockHabit: Habit = { id: habitId, user_id: userId, title: 'Test Habit', cue: null, routine: null, reward: null, habit_type: 'boolean', goal_quantity: null, goal_unit: null, frequency_period: 'day', goal_frequency: 1, recurrence_rule: null, recurrence_end_date: null, archived_at: null, streak: 0, best_streak: 0, created_at: new Date().toISOString(), updated_at: new Date().toISOString() };

      // Corrected mock structure for chained eq calls
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: mockHabit, error: null });
      const userEqMock = jest.fn().mockReturnValue({ single: singleMock });
      const idEqMock = jest.fn().mockReturnValue({ eq: userEqMock });
      const selectMock = jest.fn().mockReturnValue({ eq: idEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectMock
      } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      const result = await caller.habit.getHabitById({ id: habitId });
      expect(result).toEqual(mockHabit);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(selectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at'); // Check select fields
      expect(idEqMock).toHaveBeenCalledWith('id', habitId);
      expect(userEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(singleMock).toHaveBeenCalled();
    });

    it('should throw NOT_FOUND error if habit doesnt exist or belongs to another user', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-abc';
      // Router now throws specific error, not just Supabase error
      const expectedError = new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied' });

      // Corrected mock structure for failing call
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: null, error: { message: 'Row not found', code: 'PGRST116' } });
      const userEqMock = jest.fn().mockReturnValue({ single: singleMock });
      const idEqMock = jest.fn().mockReturnValue({ eq: userEqMock });
      const selectMock = jest.fn().mockReturnValue({ eq: idEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectMock
      } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.getHabitById({ id: habitId })).rejects.toThrowError(
        expectedError
      );
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(selectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(idEqMock).toHaveBeenCalledWith('id', habitId);
      expect(userEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(singleMock).toHaveBeenCalled();
    });

     it('should throw INTERNAL_SERVER_ERROR on other database errors', async () => {
       // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-db-error';
      const dbError = { message: 'Generic DB Error', code: '500' };
      const expectedError = new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message });

      // Corrected mock structure for generic error
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: null, error: dbError });
      const userEqMock = jest.fn().mockReturnValue({ single: singleMock });
      const idEqMock = jest.fn().mockReturnValue({ eq: userEqMock });
      const selectMock = jest.fn().mockReturnValue({ eq: idEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectMock
      } as any);

       // Act
      const caller = createTestCaller(userId);
       // Assert
      await expect(caller.habit.getHabitById({ id: habitId })).rejects.toThrowError(
        expectedError
      );
       expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
       expect(selectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
       expect(idEqMock).toHaveBeenCalledWith('id', habitId);
       expect(userEqMock).toHaveBeenCalledWith('user_id', userId);
       expect(singleMock).toHaveBeenCalled();
     });
   });

  describe('createHabit', () => { 
    it('should create a new habit with default streaks', async () => {
      // Arrange
      const userId = 'test-user-id';
      const inputData = { title: 'New Habit', habit_type: 'boolean' as const, frequency_period: 'day' as const, goal_frequency: 1 };
      const expectedOutput: Habit = { id: 'new-id', user_id: userId, ...inputData, streak: 0, best_streak: 0, created_at: new Date().toISOString(), updated_at: new Date().toISOString(), cue: null, routine: null, reward: null, goal_quantity: null, goal_unit: null, recurrence_rule: null, recurrence_end_date: null, archived_at: null };

      // Correct mock structure for insert -> select -> single
      // Explicitly type the mock function to help with type inference
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: expectedOutput, error: null }); 
      const selectMock = jest.fn().mockReturnValue({ single: singleMock });
      const insertMock = jest.fn().mockReturnValue({ select: selectMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        insert: insertMock
      } as any);

      // Act
      const caller = createTestCaller(userId);
      const result = await caller.habit.createHabit(inputData);

      // Assert
      expect(result).toEqual(expectedOutput);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      // Check insert arguments carefully
      expect(insertMock).toHaveBeenCalledWith(expect.objectContaining({ 
          ...inputData,
          user_id: userId, 
          streak: 0, 
          best_streak: 0 
      }));
      expect(selectMock).toHaveBeenCalled(); // Check select was called after insert
      expect(singleMock).toHaveBeenCalled(); // Check single was called after select
    });

    it('should throw TRPCError on database error', async () => {
      // Arrange
      const userId = 'test-user-id';
      const inputData = { title: 'Fail Habit', habit_type: 'boolean' as const, frequency_period: 'day' as const, goal_frequency: 1 };
      const dbError = { message: 'Insert failed', code: '500' };
      const expectedError = new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message });

      // Correct mock structure for failing insert
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: null, error: dbError });
      const selectMock = jest.fn().mockReturnValue({ single: singleMock });
      const insertMock = jest.fn().mockReturnValue({ select: selectMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
         insert: insertMock
      } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.createHabit(inputData)).rejects.toThrowError(
        expectedError
      );
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      // Check insert arguments
       expect(insertMock).toHaveBeenCalledWith(expect.objectContaining({ 
          ...inputData,
          user_id: userId, 
          streak: 0, 
          best_streak: 0 
      }));
      expect(selectMock).toHaveBeenCalled();
      expect(singleMock).toHaveBeenCalled();
    });
  });

  describe('updateHabit', () => { 
    it('should update an existing habit', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-to-update';
      const updateData = { title: 'Updated Title' };
      // Define the full initial and updated habit objects (need all fields for Habit type)
      const baseHabit = { id: habitId, user_id: userId, cue: null, routine: null, reward: null, habit_type: 'boolean' as const, goal_quantity: null, goal_unit: null, frequency_period: 'day' as const, goal_frequency: 1, recurrence_rule: null, recurrence_end_date: null, archived_at: null, streak: 5, best_streak: 10, created_at: new Date(Date.now() - 100000).toISOString(), updated_at: new Date(Date.now() - 50000).toISOString() }; 
      const initialHabit: Habit = { ...baseHabit, title: 'Old Title' };
      const updatedHabit: Habit = { ...initialHabit, ...updateData, updated_at: new Date().toISOString(), id: habitId, user_id: userId, cue: null, routine: null, reward: null, habit_type: 'boolean', goal_quantity: null, goal_unit: null, frequency_period: 'day', goal_frequency: 1, recurrence_rule: null, recurrence_end_date: null, archived_at: null, streak: 0, best_streak: 0, created_at: new Date().toISOString() };

      // Mock 1: Initial fetch for ownership check (getHabitById logic)
      const fetchSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      fetchSingleMock.mockResolvedValue({ data: initialHabit, error: null });
      const fetchUserEqMock = jest.fn().mockReturnValue({ single: fetchSingleMock });
      const fetchIdEqMock = jest.fn().mockReturnValue({ eq: fetchUserEqMock });
      const fetchSelectMock = jest.fn().mockReturnValue({ eq: fetchIdEqMock });

      // Mock 2: Update operation
      const updateSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      updateSingleMock.mockResolvedValue({ data: updatedHabit, error: null });
      const updateSelectMock = jest.fn().mockReturnValue({ single: updateSingleMock });
      const updateUserEqMock = jest.fn().mockReturnValue({ select: updateSelectMock });
      const updateIdEqMock = jest.fn().mockReturnValue({ eq: updateUserEqMock });
      const updateMock = jest.fn().mockReturnValue({ eq: updateIdEqMock });

      // Chain the mocks: from('habits') -> select (for fetch) -> update 
      mockSupabaseAdmin.from.mockReturnValueOnce({ select: fetchSelectMock } as any)
                             .mockReturnValueOnce({ update: updateMock } as any); // Second call to from('habits') is for update

      // Act
      const caller = createTestCaller(userId);
      const result = await caller.habit.updateHabit({ id: habitId, ...updateData });

      // Assert
      expect(result).toEqual(updatedHabit);

      // Assert fetch mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(1, 'habits');
      expect(fetchSelectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(fetchIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(fetchUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(fetchSingleMock).toHaveBeenCalled();

      // Assert update mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(2, 'habits');
      expect(updateMock).toHaveBeenCalledWith(expect.objectContaining(updateData));
      expect(updateIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(updateUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(updateSelectMock).toHaveBeenCalled();
      expect(updateSingleMock).toHaveBeenCalled();
    });

    it('should throw NOT_FOUND error if habit doesnt exist or belongs to another user during initial fetch', async () => { // Renamed for clarity
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'non-existent-habit';
      const updateData = { title: 'Wont Update' };
      const expectedError = new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied' });

      // Mock only the initial fetch, have it return not found
      const fetchSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      fetchSingleMock.mockResolvedValue({ data: null, error: { message: 'Row not found', code: 'PGRST116' } });
      const fetchUserEqMock = jest.fn().mockReturnValue({ single: fetchSingleMock });
      const fetchIdEqMock = jest.fn().mockReturnValue({ eq: fetchUserEqMock });
      const fetchSelectMock = jest.fn().mockReturnValue({ eq: fetchIdEqMock });

      // Only mock 'from' once for the fetch
      mockSupabaseAdmin.from.mockReturnValueOnce({ select: fetchSelectMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.updateHabit({ id: habitId, ...updateData })).rejects.toThrowError(expectedError);
      // Verify fetch mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenCalledTimes(1);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(fetchSelectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(fetchIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(fetchUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(fetchSingleMock).toHaveBeenCalled();
      // Crucially, ensure no update mock was ever created or called
    });

    it('should throw TRPCError on database error during update operation', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-to-update';
      const updateData = { title: 'Updated Title' };
      // Reuse initial habit definition
      const baseHabit = { id: habitId, user_id: userId, cue: null, routine: null, reward: null, habit_type: 'boolean' as const, goal_quantity: null, goal_unit: null, frequency_period: 'day' as const, goal_frequency: 1, recurrence_rule: null, recurrence_end_date: null, archived_at: null, streak: 5, best_streak: 10, created_at: new Date(Date.now() - 100000).toISOString(), updated_at: new Date(Date.now() - 50000).toISOString() }; 
      const initialHabit: Habit = { ...baseHabit, title: 'Old Title' };
      const dbError = { message: 'Update failed', code: '500' };
      const expectedError = new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message });

      // Mock 1: Initial fetch for ownership check (success)
      const fetchSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      fetchSingleMock.mockResolvedValue({ data: initialHabit, error: null });
      const fetchUserEqMock = jest.fn().mockReturnValue({ single: fetchSingleMock });
      const fetchIdEqMock = jest.fn().mockReturnValue({ eq: fetchUserEqMock });
      const fetchSelectMock = jest.fn().mockReturnValue({ eq: fetchIdEqMock });

      // Mock 2: Update operation (failure)
      const updateSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      updateSingleMock.mockResolvedValue({ data: null, error: dbError }); // Make the update return the error
      const updateSelectMock = jest.fn().mockReturnValue({ single: updateSingleMock });
      const updateUserEqMock = jest.fn().mockReturnValue({ select: updateSelectMock });
      const updateIdEqMock = jest.fn().mockReturnValue({ eq: updateUserEqMock });
      const updateMock = jest.fn().mockReturnValue({ eq: updateIdEqMock });

       // Chain the mocks: from('habits') -> select (for fetch) -> update (fails)
      mockSupabaseAdmin.from.mockReturnValueOnce({ select: fetchSelectMock } as any)
                             .mockReturnValueOnce({ update: updateMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.updateHabit({ id: habitId, ...updateData })).rejects.toThrowError(expectedError);

      // Assert fetch mock calls (should have succeeded)
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(1, 'habits');
      expect(fetchSelectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(fetchIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(fetchUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(fetchSingleMock).toHaveBeenCalled();

      // Assert update mock calls (should have been called but failed)
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(2, 'habits');
      expect(updateMock).toHaveBeenCalledWith(expect.objectContaining(updateData));
      expect(updateIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(updateUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(updateSelectMock).toHaveBeenCalled();
      expect(updateSingleMock).toHaveBeenCalled();
    });
  });

  describe('deleteHabit', () => { 
    it('should delete an existing habit and return true', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-to-delete';

      // Mock delete -> eq(id) -> eq(user_id) -> resolves successfully
      // Explicitly type the mock function to help with type inference
      const deleteUserEqMock = jest.fn<() => Promise<{ data: null; error: any }>>();
      deleteUserEqMock.mockResolvedValue({ data: null, error: null }); // Success is indicated by no error
      const deleteIdEqMock = jest.fn().mockReturnValue({ eq: deleteUserEqMock });
      const deleteMock = jest.fn().mockReturnValue({ eq: deleteIdEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ delete: deleteMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.deleteHabit({ id: habitId })).resolves.toBe(true);
      // Verify mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(deleteMock).toHaveBeenCalled();
      expect(deleteIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(deleteUserEqMock).toHaveBeenCalledWith('user_id', userId);
    });

    it('should throw NOT_FOUND error if habit to delete doesnt exist or belongs to another user', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'non-existent-habit';
      const expectedError = new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or cannot be deleted' });

      // Mock delete -> eq(id) -> eq(user_id) -> resolves with error (or indicates 0 rows affected)
      // Simulate a 'not found' scenario, Supabase might return an error or just indicate 0 rows affected.
      // Let's mock returning an error that the router interprets as NOT_FOUND.
      const dbError = { message: 'Row not found', code: 'PGRST116' }; // Example error
      const deleteUserEqMock = jest.fn<() => Promise<{ data: null; error: any }>>();
      deleteUserEqMock.mockResolvedValue({ data: null, error: dbError });
      const deleteIdEqMock = jest.fn().mockReturnValue({ eq: deleteUserEqMock });
      const deleteMock = jest.fn().mockReturnValue({ eq: deleteIdEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ delete: deleteMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.deleteHabit({ id: habitId })).rejects.toThrowError(expectedError);
      // Verify mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(deleteMock).toHaveBeenCalled();
      expect(deleteIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(deleteUserEqMock).toHaveBeenCalledWith('user_id', userId);
    });

    it('should throw TRPCError on database error during delete operation', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-delete-error';
      const dbError = { message: 'Internal DB Error', code: '500' };
      const expectedError = new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message });

      // Mock delete -> eq(id) -> eq(user_id) -> resolves with a generic error
      const deleteUserEqMock = jest.fn<() => Promise<{ data: null; error: any }>>();
      deleteUserEqMock.mockResolvedValue({ data: null, error: dbError });
      const deleteIdEqMock = jest.fn().mockReturnValue({ eq: deleteUserEqMock });
      const deleteMock = jest.fn().mockReturnValue({ eq: deleteIdEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ delete: deleteMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.deleteHabit({ id: habitId })).rejects.toThrowError(expectedError);
      // Verify mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(deleteMock).toHaveBeenCalled();
      expect(deleteIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(deleteUserEqMock).toHaveBeenCalledWith('user_id', userId);
    });
  });

  // TODO: Add describe blocks for archive/unarchive and habit entry procedures
});
```
\n\n## Realtime Channel: dashboardRouter.getWeeklyProgress.test.ts
**File:** ./__tests__/server/routers/dashboardRouter.getWeeklyProgress.test.ts
\n```
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { createInnerTRPCContext, mockSupabaseAdmin, MockableTableOperations } from '../test-helpers';
import { DeepMockProxy, mockDeep } from 'jest-mock-extended';
import { appRouter } from '../../../server/src/router';
import { TRPCError } from '@trpc/server';

// Type for database table names to avoid 'any' parameter type errors
type TableName = 'tasks' | 'goals' | 'habits' | 'habit_entries' | 'goal_progress_snapshots' | string;

// Using mockSupabaseAdmin from test-helpers

// Helper function to create test context
function createTestContext(userId: string | null = 'test-user-id') {
  return createInnerTRPCContext({
    userId,
    supabase: mockSupabaseAdmin,
  });
}

// Create test caller with context
function createTestCaller(userId: string | null = 'test-user-id') {
  const ctx = createTestContext(userId);
  return appRouter.createCaller(ctx);
}

describe('dashboardRouter.getWeeklyProgress', () => {
  beforeEach(() => {
    // Reset mocks before each test
    jest.clearAllMocks();
  });

  it('should fetch weekly progress with default parameters', async () => {
    // Setup mock data
    const habits = [
      { id: 'habit-1', name: 'Morning Run', frequency: 'daily', streak: 5, best_streak: 10 },
      { id: 'habit-2', name: 'Meditation', frequency: 'daily', streak: 3, best_streak: 7 },
    ];

    const habitEntries = [
      { id: 'entry-1', habit_id: 'habit-1', date: '2025-04-25', completed: true, habits: { id: 'habit-1', name: 'Morning Run', frequency: 'daily' } },
      { id: 'entry-2', habit_id: 'habit-1', date: '2025-04-26', completed: true, habits: { id: 'habit-1', name: 'Morning Run', frequency: 'daily' } },
      { id: 'entry-3', habit_id: 'habit-2', date: '2025-04-25', completed: false, habits: { id: 'habit-2', name: 'Meditation', frequency: 'daily' } },
    ];

    const completedTasks = [
      { id: 'task-1', title: 'Complete report', status: 'completed', updated_at: '2025-04-25T10:00:00Z', goal_id: 'goal-1' },
      { id: 'task-2', title: 'Send email', status: 'completed', updated_at: '2025-04-26T14:30:00Z', goal_id: null },
    ];

    const goalSnapshots = [
      { goal_id: 'goal-1', progress: 0.3, created_at: '2025-04-21T08:00:00Z' },
      { goal_id: 'goal-1', progress: 0.5, created_at: '2025-04-27T08:00:00Z' },
    ];

    // Create typed mock objects for each table
    const habitsTableMock = mockDeep<MockableTableOperations>();
    const habitEntriesTableMock = mockDeep<MockableTableOperations>();
    const tasksTableMock = mockDeep<MockableTableOperations>();
    const goalSnapshotsTableMock = mockDeep<MockableTableOperations>();

    // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
    mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
      if (table === 'habits') return habitsTableMock;
      if (table === 'habit_entries') return habitEntriesTableMock;
      if (table === 'tasks') return tasksTableMock;
      if (table === 'goal_progress_snapshots') return goalSnapshotsTableMock;
      
      // Default case - should not happen in this test
      return mockDeep<MockableTableOperations>();
    });

    // Configure each table mock's behavior
    // Habits table
    habitsTableMock.select.mockReturnThis();
    habitsTableMock.eq.mockReturnThis();
    habitsTableMock.order.mockReturnThis();
    habitsTableMock.limit.mockResolvedValue({ data: habits, error: null });

    // Habit entries table
    habitEntriesTableMock.select.mockReturnThis();
    habitEntriesTableMock.eq.mockReturnThis();
    habitEntriesTableMock.gte.mockReturnThis();
    habitEntriesTableMock.lte.mockReturnThis();
    habitEntriesTableMock.order.mockResolvedValue({ data: habitEntries, error: null });

    // Tasks table
    tasksTableMock.select.mockReturnThis();
    tasksTableMock.eq.mockReturnThis();
    tasksTableMock.gte.mockReturnThis();
    tasksTableMock.lte.mockReturnThis();
    // Add count method mock
    tasksTableMock.count.mockResolvedValue({ count: 10, error: null });
    tasksTableMock.order.mockResolvedValue({ data: completedTasks, error: null });

    // Goal progress snapshots table
    goalSnapshotsTableMock.select.mockReturnThis();
    goalSnapshotsTableMock.eq.mockReturnThis();
    goalSnapshotsTableMock.gte.mockReturnThis();
    goalSnapshotsTableMock.lte.mockReturnThis();
    goalSnapshotsTableMock.order.mockResolvedValue({ data: goalSnapshots, error: null });

    const caller = createTestCaller();
    const result = await caller.dashboard.getWeeklyProgress();

    // Verify structure of response
    expect(result).toHaveProperty('dailyProgress');
    expect(result).toHaveProperty('overallMetrics');
    expect(result).toHaveProperty('habitStreaks');
    expect(result).toHaveProperty('goalProgress');
    expect(result).toHaveProperty('dateRange');

    // Verify dates are processed correctly
    expect(result.dateRange.days.length).toBe(7); // Default is 7 days

    // Verify habit data is formatted correctly
    expect(result.habitStreaks).toContainEqual({
      id: 'habit-1',
      name: 'Morning Run',
      currentStreak: 5,
      bestStreak: 10,
    });

    // Verify goal progress is calculated correctly
    expect(result.goalProgress).toContainEqual(expect.objectContaining({
      goalId: 'goal-1',
      progressChange: 0.2, // 0.5 - 0.3
    }));
  });

  it('should handle custom date ranges', async () => {
    // Create typed mock objects for each table
    const tableMock = mockDeep<MockableTableOperations>();
    
    // Configure mockSupabaseAdmin.from to return the mock for any table
    mockSupabaseAdmin.from.mockImplementation(() => tableMock);
    
    // Configure basic behavior
    tableMock.select.mockReturnThis();
    tableMock.eq.mockReturnThis();
    tableMock.gte.mockReturnThis();
    tableMock.lte.mockReturnThis();
    tableMock.order.mockResolvedValue({ data: [], error: null });

    const caller = createTestCaller();
    const result = await caller.dashboard.getWeeklyProgress({ daysToInclude: 14 });

    // Verify date range is correct
    expect(result.dateRange.days.length).toBe(14);
  });

  it('should handle raw data inclusion when requested', async () => {
    // Setup minimal mock data
    const habitEntries = [
      { id: 'entry-1', habit_id: 'habit-1', date: '2025-04-25', completed: true },
    ];

    // Helper function to create mock table with data and thenable capability
    function createTableMockWithData<T>(data: T) {
      const mock = mockDeep<MockableTableOperations>();
      
      // Configure chainable methods to return this (for method chaining)
      mock.select.mockReturnThis();
      mock.eq.mockReturnThis();
      mock.gte.mockReturnThis();
      mock.lte.mockReturnThis();
      mock.order.mockReturnThis();
      
      // Make the mock awaitable with the provided data
      // Using a proper Promise interface implementation
      const response = { data, error: null, status: 200 };
      const mockPromise = Promise.resolve(response);
      
      // Add then/catch/finally methods to make the mock awaitable
      (mock as any).then = mockPromise.then.bind(mockPromise);
      (mock as any).catch = mockPromise.catch.bind(mockPromise);
      (mock as any).finally = mockPromise.finally.bind(mockPromise);
      
      return mock;
    }
    
    // Create typed mock objects with proper data
    const habitEntriesTableMock = createTableMockWithData(habitEntries);
    const defaultTableMock = createTableMockWithData([]);
    
    // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
    mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
      if (table === 'habit_entries') return habitEntriesTableMock;
      return defaultTableMock;
    });

    const caller = createTestCaller();
    const result = await caller.dashboard.getWeeklyProgress({ includeRawData: true });

    // Find the day that should have entries
    const dayWithData = result.dailyProgress.find(day => day.date === '2025-04-25');
    
    // Verify raw data is included
    expect(dayWithData).toHaveProperty('habitEntries');
    expect(dayWithData?.habitEntries).toHaveLength(1);
  });

  it('should handle database errors properly', async () => {
    // Create typed mock object for tables that will return an error
    const errorTableMock = mockDeep<MockableTableOperations>();
    
    // Configure mockSupabaseAdmin.from to return the error mock
    mockSupabaseAdmin.from.mockImplementation(() => errorTableMock);
    
    // Configure the mocked behavior to return an error
    errorTableMock.select.mockReturnThis();
    errorTableMock.eq.mockReturnThis();
    errorTableMock.gte.mockReturnThis();
    errorTableMock.lte.mockReturnThis();
    errorTableMock.order.mockResolvedValue({ 
      data: null, 
      error: { message: 'Database error', code: '42P01' } 
    });

    const caller = createTestCaller();
    
    // Expect the proper error to be thrown
    await expect(caller.dashboard.getWeeklyProgress()).rejects.toThrow(TRPCError);
  });

  it('should throw an error when user is not authenticated', async () => {
    const caller = createTestCaller(null);
    
    // Expect an unauthorized error
    await expect(caller.dashboard.getWeeklyProgress()).rejects.toThrow(TRPCError);
  });
});
```
\n\n## Realtime Channel: taskRouter.toggleTask.test.ts
**File:** ./__tests__/server/routers/taskRouter.toggleTask.test.ts
\n```
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { 
  createInnerTRPCContext, 
  mockSupabaseAdmin, 
  MockableTableOperations, 
  resetSupabaseMocks, 
  MockablePostgrestResponse 
} from '../test-helpers';
import { DeepMockProxy, mockDeep } from 'jest-mock-extended';
import { appRouter } from '../../../server/src/router';
import { TRPCError } from '@trpc/server';

// Type for database table names to avoid 'any' parameter type errors
type TableName = 'tasks' | 'goals' | 'habits' | string;

// Helper function to create test context
function createTestContext(userId: string | null = 'test-user-id') {
  return createInnerTRPCContext({
    userId,
    supabase: mockSupabaseAdmin,
  });
}

// Create test caller with context
function createTestCaller(userId: string | null = 'test-user-id') {
  const ctx = createTestContext(userId);
  return appRouter.createCaller(ctx);
}

describe('taskRouter.toggleTask', () => {
  beforeEach(() => {
    // Reset mocks before each test
    resetSupabaseMocks();
  });

  it('should toggle a task from incomplete to complete', async () => {
    const taskId = 'task-1';
    const userId = 'test-user-id';
    const initialTaskData = {
      id: taskId,
      user_id: userId,
      title: 'Test Task',
      notes: null,
      status: 'in-progress',
      priority: 2,
      due: null,
      goal_id: null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };
    const updatedTaskData = {
      id: taskId,
      user_id: userId,
      title: 'Test Task',
      notes: null,
      status: 'completed', // This is the expected final status
      priority: 2,
      due: null,
      goal_id: null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(), // Include fields returned by select
    };

    // Mock setup for 'tasks' table operations
    const fetchMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(fetchMock); // Consistently return fetchMock for 'tasks'

    // Configure chainable methods to return the mock itself
    fetchMock.select.mockReturnValue(fetchMock);
    fetchMock.eq.mockReturnValue(fetchMock);
    fetchMock.update.mockReturnValue(fetchMock);

    // Configure .single() to resolve differently for fetch vs update
    fetchMock.single
      .mockResolvedValueOnce({ data: initialTaskData, error: null }) // First call (fetch)
      .mockResolvedValueOnce({ data: updatedTaskData, error: null }); // Second call (update confirmation)

    const caller = createTestCaller(userId);
    const result = await caller.task.toggleTask({
      taskId: taskId,
    });

    // Verify the result
    expect(result.status).toBe('completed');

    // Verify calls
    expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('tasks');
    expect(fetchMock.select).toHaveBeenCalledWith('id, status, goal_id, title');
    expect(fetchMock.update).toHaveBeenCalledWith(expect.objectContaining({ status: 'completed' }));
    expect(fetchMock.eq).toHaveBeenCalledWith('id', taskId);
    expect(fetchMock.eq).toHaveBeenCalledWith('user_id', userId);
    expect(fetchMock.select).toHaveBeenCalledWith('id, title, status, goal_id, updated_at');
    expect(fetchMock.single).toHaveBeenCalledTimes(2); // Called for fetch and update
  });

  it('should toggle a task from complete to incomplete', async () => {
    const taskId = 'task-1';
    const userId = 'test-user-id';
    const initialTaskData = {
      id: taskId,
      title: 'Test Task',
      status: 'completed', // Starting completed
      goal_id: null,
    };
    const updatedTaskData = {
      id: taskId,
      title: 'Test Task',
      status: 'in-progress', // Expected final status
      goal_id: null,
      updated_at: new Date().toISOString(),
    };

    // Mock setup for 'tasks' table operations
    const fetchMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(fetchMock); // Consistently return fetchMock

    // Configure chainable methods
    fetchMock.select.mockReturnValue(fetchMock);
    fetchMock.eq.mockReturnValue(fetchMock);
    fetchMock.update.mockReturnValue(fetchMock);

    // Configure .single() resolutions
    fetchMock.single
      .mockResolvedValueOnce({ data: initialTaskData, error: null }) // First call (fetch)
      .mockResolvedValueOnce({ data: updatedTaskData, error: null }); // Second call (update confirmation)

    const caller = createTestCaller(userId);
    const result = await caller.task.toggleTask({
      taskId: taskId,
    });

    // Verify the result
    expect(result.status).toBe('in-progress');

    // Verify calls
    expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('tasks');
    expect(fetchMock.select).toHaveBeenCalledWith('id, status, goal_id, title');
    expect(fetchMock.update).toHaveBeenCalledWith(expect.objectContaining({ status: 'in-progress' }));
    expect(fetchMock.eq).toHaveBeenCalledWith('id', taskId);
    expect(fetchMock.eq).toHaveBeenCalledWith('user_id', userId);
    expect(fetchMock.select).toHaveBeenCalledWith('id, title, status, goal_id, updated_at');
    expect(fetchMock.single).toHaveBeenCalledTimes(2); // Called for fetch and update
  });

  it('should update goal progress when toggling a task with goal association', async () => {
    const taskId = 'task-1';
    const goalId = 'goal-1';
    const userId = 'test-user-id';

    // --- Task Mocks --- 
    const taskFetchMock = mockDeep<MockableTableOperations>();
    const initialTaskData = { id: taskId, title: 'Goal Task', status: 'in-progress', goal_id: goalId };
    const updatedTaskData = { ...initialTaskData, status: 'completed', updated_at: new Date().toISOString() };
    
    taskFetchMock.select.mockReturnValue(taskFetchMock);
    taskFetchMock.eq.mockReturnValue(taskFetchMock);
    taskFetchMock.update.mockReturnValue(taskFetchMock);
    taskFetchMock.single
      .mockResolvedValueOnce({ data: initialTaskData, error: null }) // Fetch task
      .mockResolvedValueOnce({ data: updatedTaskData, error: null }); // Update task

    // Helper function to create a properly awaitable mock with data
    function createTableMockWithData<T>(data: T) {
      const mock = mockDeep<MockableTableOperations>();
      
      // Configure chainable methods to return this (for method chaining)
      mock.select.mockReturnThis();
      mock.eq.mockReturnThis();
      mock.order.mockReturnThis();
      mock.limit.mockReturnThis();
      mock.in.mockReturnThis();
      mock.update.mockReturnThis();
      mock.is.mockReturnThis();
      mock.neq.mockReturnThis();
      mock.or.mockReturnThis();
      
      // Add proper promise handling for awaitable operations
      const response = { data, error: null, status: 200, count: Array.isArray(data) ? data.length : undefined };
      const mockPromise = Promise.resolve(response);
      
      // Add then/catch/finally methods to make the mock awaitable
      (mock as any).then = mockPromise.then.bind(mockPromise);
      (mock as any).catch = mockPromise.catch.bind(mockPromise);
      (mock as any).finally = mockPromise.finally.bind(mockPromise);
      
      return mock;
    }
    
    // --- Goal Task List Mock --- 
    // Create a properly awaitable mock with the goal tasks data
    const goalTasksData = [
        { id: taskId, status: 'completed' }, // The toggled task
        { id: 'task-2', status: 'in-progress' },
    ];
    const goalTasksListMock = createTableMockWithData(goalTasksData);

    // --- Goal Update Mock --- 
    const updatedGoalData = { id: goalId, name: 'Test Goal', progress: 0.5, /* other fields */ updated_at: new Date().toISOString() }; // Example with 50% progress
    
    // Create an awaitable mock with the goal update data
    const goalUpdateMock = createTableMockWithData(updatedGoalData);
    // Make sure single() returns a properly typed response
    goalUpdateMock.single.mockResolvedValue({ data: updatedGoalData, error: null });


    // --- Configure from() to return the right mock based on table --- 
    mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
      if (table === 'tasks') {
        // First call to 'tasks' is for the initial fetch/update of the specific task
        // Second call is to get all tasks for the goal
        // Need a way to differentiate... maybe check chained methods?
        // For now, let's assume the first call structure uses single(), the second doesn't directly
        // A more robust way might involve mockFn.mock.calls inspection or clearer separation.
        // Let's try returning taskFetchMock first, then goalTasksListMock.
        if (mockSupabaseAdmin.from.mock.calls.filter(c => c[0] === 'tasks').length <= 1) {
            return taskFetchMock;
        } else {
            return goalTasksListMock;
        }
      }
      if (table === 'goals') {
        return goalUpdateMock; // Only call to 'goals' is for the update
      }
      // Fallback for any other table calls in the test setup (if any)
      const defaultMock = mockDeep<MockableTableOperations>();
      defaultMock.select.mockReturnValue(defaultMock);
      defaultMock.eq.mockReturnValue(defaultMock);
      defaultMock.single.mockResolvedValue({ data: null, error: { message: 'Default mock', code: 'MOCK_ERR' } });
      return defaultMock;
    });

    const caller = createTestCaller(userId);
    const result = await caller.task.toggleTask({
      taskId: taskId,
    });

    // Assertions
    expect(result.status).toBe('completed');
    expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('tasks'); // Called multiple times
    expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('goals');
    
    // Verify task update
    expect(taskFetchMock.update).toHaveBeenCalledWith(expect.objectContaining({ status: 'completed' }));
    expect(taskFetchMock.single).toHaveBeenCalledTimes(2); // Fetch + Update task

    // Verify fetching goal tasks
    expect(goalTasksListMock.select).toHaveBeenCalledWith('id, status');
    expect(goalTasksListMock.eq).toHaveBeenCalledWith('goal_id', goalId);

    // Verify goal update
    expect(goalUpdateMock.update).toHaveBeenCalledWith({ progress: 0.5 }); // 1 out of 2 tasks complete
    expect(goalUpdateMock.eq).toHaveBeenCalledWith('id', goalId);
    expect(goalUpdateMock.select).toHaveBeenCalledWith('id, name, progress, updated_at');
    expect(goalUpdateMock.single).toHaveBeenCalledTimes(1);

    // Reset implementation for next tests if needed (though beforeEach should handle it)
    // mockSupabaseAdmin.from.mockRestore(); // Or reset in beforeEach

  });

  it('should not change status if already in the target state', async () => {
    const taskId = 'task-1';
    const userId = 'test-user-id';
    const existingTask = {
      id: taskId,
      title: 'Test Task',
      status: 'completed',
      goal_id: null,
    };

    // --- Configure from() for tasks table --- 
    const tasksTableMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(tasksTableMock);
    tasksTableMock.select.mockReturnValue(tasksTableMock);
    tasksTableMock.eq.mockReturnValue(tasksTableMock);
    tasksTableMock.single.mockResolvedValue({ data: existingTask, error: null });

    // --- Configure from() for goals table (should not be called) ---
    const goalsTableMock = mockDeep<MockableTableOperations>();
    // ... setup mocks for goals table ...
    // This setup is complex, let's simplify if goal logic isn't tested here
    // goalsTableMock.update.mockReturnValue(goalsTableMock);
    // goalsTableMock.eq.mockReturnValue(goalsTableMock);
    // goalsTableMock.select.mockReturnValue(goalsTableMock);
    // goalsTableMock.single.mockResolvedValue({ data: null, error: null });
    // mockSupabaseAdmin.from('goals').mockReturnValue(goalsTableMock);
    const caller = createTestCaller(userId);
    const result = await caller.task.toggleTask({
      taskId: taskId,
    });

    // Verify the result
    expect(result.status).toBe('completed');

    // Verify no update was performed
    expect(mockSupabaseAdmin.from('tasks').update).not.toHaveBeenCalled();
    expect(mockSupabaseAdmin.from('goals').update).not.toHaveBeenCalled(); // Ensure goal not updated
  });

  it('should throw NOT_FOUND error if task does not exist', async () => {
    // Mock the initial fetch to return no data
    const fetchMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(fetchMock);
    fetchMock.select.mockReturnValue(fetchMock);
    fetchMock.eq.mockReturnValue(fetchMock);
    fetchMock.single.mockResolvedValue({ data: null, error: null }); // Simulate task not found

    const caller = createTestCaller();
    await expect(caller.task.toggleTask({ taskId: 'nonexistent-task' }))
      .rejects.toMatchObject({ code: 'NOT_FOUND' });

    // Ensure update was not called
    expect(fetchMock.update).not.toHaveBeenCalled();
  });

  it('should throw an error if the database update fails', async () => {
    const taskId = 'task-1';
    const userId = 'test-user-id';
    const initialTaskData = { id: taskId, status: 'in-progress', goal_id: null, title: 'Test' };
    const dbError = { message: 'Update failed', code: 'DB_ERROR' };

    // Mock the initial fetch
    const fetchMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(fetchMock);
    fetchMock.select.mockReturnValue(fetchMock);
    fetchMock.eq.mockReturnValue(fetchMock);
    fetchMock.update.mockReturnValue(fetchMock); // Update returns mock for chaining

    // Mock .single() for initial fetch (success) and update (failure)
    fetchMock.single
      .mockResolvedValueOnce({ data: initialTaskData, error: null }) // Fetch succeeds
      .mockResolvedValueOnce({ data: null, error: dbError });       // Update fails

    const caller = createTestCaller(userId);
    await expect(caller.task.toggleTask({ taskId: taskId }))
      .rejects.toMatchObject({ message: 'Update failed', code: 'DB_ERROR' });

    // Verify update was attempted
    expect(fetchMock.update).toHaveBeenCalledWith(expect.objectContaining({ status: 'completed' }));
    expect(fetchMock.single).toHaveBeenCalledTimes(2); // Fetch + Update attempt
  });

});
```
\n\n## Realtime Channel: test-helpers.ts
**File:** ./__tests__/server/test-helpers.ts
\n```
import { mockDeep, mockReset, DeepMockProxy } from 'jest-mock-extended';
import { User, AuthError } from '@supabase/supabase-js';
import { type Context } from '@/server/src/context';
import { TRPCError } from '@trpc/server';

// --- Common Response Type --- 
// Represents the core structure of Supabase Postgrest responses
export type MockablePostgrestResponse<T> = Promise<{
  data: T | null;
  error: any;
  count?: number | null; 
  status?: number;
  statusText?: string;
}>;

// --- Interface for CHAINABLE Query Builder methods --- 
// These methods return the builder itself to allow chaining.
export interface MockableQueryBuilder {
  select: (query?: string, options?: { head?: boolean; count?: 'exact' | 'planned' | 'estimated' }) => MockableQueryBuilder;
  eq: (column: string, value: any) => MockableQueryBuilder;
  neq: (column: string, value: any) => MockableQueryBuilder;
  gt: (column: string, value: any) => MockableQueryBuilder;
  gte: (column: string, value: any) => MockableQueryBuilder;
  lt: (column: string, value: any) => MockableQueryBuilder;
  lte: (column: string, value: any) => MockableQueryBuilder;
  like: (column: string, pattern: string) => MockableQueryBuilder;
  ilike: (column: string, pattern: string) => MockableQueryBuilder;
  is: (column: string, value: boolean | null) => MockableQueryBuilder;
  in: (column: string, values: any[]) => MockableQueryBuilder;
  contains: (column: string, value: any) => MockableQueryBuilder;
  containedBy: (column: string, value: any) => MockableQueryBuilder;
  rangeGt: (column: string, range: string) => MockableQueryBuilder;
  rangeGte: (column: string, range: string) => MockableQueryBuilder;
  rangeLt: (column: string, range: string) => MockableQueryBuilder;
  rangeLte: (column: string, range: string) => MockableQueryBuilder;
  rangeAdjacent: (column: string, range: string) => MockableQueryBuilder;
  overlaps: (column: string, value: any) => MockableQueryBuilder;
  textSearch: (column: string, query: string, options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }) => MockableQueryBuilder;
  match: (query: Record<string, unknown>) => MockableQueryBuilder;
  not: (column: string, operator: string, value: any) => MockableQueryBuilder;
  or: (filters: string, options?: { referencedTable?: string }) => MockableQueryBuilder;
  filter: (column: string, operator: string, value: any) => MockableQueryBuilder;
  limit: (count: number, options?: { referencedTable?: string }) => MockableQueryBuilder;
  range: (from: number, to: number, options?: { referencedTable?: string }) => MockableQueryBuilder;
  order: (column: string, options?: { ascending?: boolean; nullsFirst?: boolean; referencedTable?: string }) => MockableQueryBuilder;
}

// --- Interface for Operations on a Table (after .from()) --- 
// Inherits chainable methods AND adds terminal methods returning Promises.
export interface MockableTableOperations extends MockableQueryBuilder {
  // Terminal methods (return Promises)
  single: <T = any>() => MockablePostgrestResponse<T>;
  maybeSingle: <T = any>() => MockablePostgrestResponse<T>;
  // Note: Insert/Update/Upsert often return arrays in Supabase v2, but the *methods* return the builder
  insert: <T = any>(values: any | any[], options?: any) => MockableTableOperations; 
  upsert: <T = any>(values: any | any[], options?: any) => MockableTableOperations; 
  update: <T = any>(values: any, options?: any) => MockableTableOperations; 
  delete: (options?: any) => MockableTableOperations; 
}

// --- Interface for the Supabase Client itself --- 
/**
 * Represents the structure of the Supabase client that we need to mock.
 * `from` returns an object combining chainable and terminal methods.
 */
export interface MockableSupabaseClient {
  // `from` now returns the object with both chainable and terminal methods
  from: (relation: string) => MockableTableOperations;

  // Top-level client methods
  auth: {
    getUser: (
      jwt?: string
    ) => Promise<{ data: { user: User | null }; error: AuthError | null }>;
    // Add other auth methods here if needed by tests (e.g., signUp, signInWithPassword)
  };
  rpc: <T = any>(fn: string, params?: object, options?: { head?: boolean; count?: 'exact' | 'planned' | 'estimated' }) => MockablePostgrestResponse<T>;
  // Add storage interface here if needed by tests
  // storage: { ... };
}

// --- Mock Implementation --- 

// Create a deep mock instance conforming to the refined interface
export const mockSupabaseAdmin = mockDeep<MockableSupabaseClient>();

// Helper to reset mocks
export function resetSupabaseMocks() {
  // Use mockReset for better compatibility with jest-mock-extended
  mockReset(mockSupabaseAdmin);

  // --- Re-apply default implementations after reset --- 

  // Default: Successful authentication
  mockSupabaseAdmin.auth.getUser.mockResolvedValue({
    data: { user: { id: 'test-user-id', /* other user props */ } as User },
    error: null,
  });

  // Default: Successful RPC call returning null data
  mockSupabaseAdmin.rpc.mockResolvedValue({ 
      data: null, 
      error: null, 
      count: 0, 
      status: 200, 
      statusText: 'OK' 
  });

  // Helper type to create Promise-like chain-terminating objects
  type AsyncResult<T> = Promise<{ data: T | null; error: any; count?: number; status?: number; statusText?: string; }>;

  // Helper function to create a proper mock that handles both chaining AND awaiting
  function createMockWithPromiseCapability<T>(defaultData: T | null = null): any {
    const mockObj = mockDeep<MockableTableOperations>();
    
    // Add an implicit then handler that allows awaiting the mock directly
    // This is what Supabase's actual Query Builder does
    const defaultResponse = { 
      data: defaultData, 
      error: null, 
      count: defaultData && Array.isArray(defaultData) ? defaultData.length : 0,
      status: 200, 
      statusText: 'OK' 
    };
    
    // Allow the mock to be awaited directly
    (mockObj as any).then = jest.fn((onFulfill, onReject) => {
      return Promise.resolve(defaultResponse).then(onFulfill, onReject);
    });
    
    return mockObj;
  }

  // Default behavior for 'from': Return a mock that handles chaining and terminal methods
  mockSupabaseAdmin.from.mockImplementation((relation: string) => {
    // This inner mock needs to satisfy MockableTableOperations
    // AND be awaitable like a promise for terminal operations
    const innerMock = createMockWithPromiseCapability<any[]>([]);

    // --- Configure Default CHAINABLE Methods (Return Self) --- 
    innerMock.select.mockReturnValue(innerMock);
    innerMock.eq.mockReturnValue(innerMock);
    innerMock.neq.mockReturnValue(innerMock);
    innerMock.gt.mockReturnValue(innerMock);
    innerMock.gte.mockReturnValue(innerMock);
    innerMock.lt.mockReturnValue(innerMock);
    innerMock.lte.mockReturnValue(innerMock);
    innerMock.like.mockReturnValue(innerMock);
    innerMock.ilike.mockReturnValue(innerMock);
    innerMock.is.mockReturnValue(innerMock);
    innerMock.in.mockReturnValue(innerMock);
    innerMock.contains.mockReturnValue(innerMock);
    innerMock.containedBy.mockReturnValue(innerMock);
    innerMock.rangeGt.mockReturnValue(innerMock);
    innerMock.rangeGte.mockReturnValue(innerMock);
    innerMock.rangeLt.mockReturnValue(innerMock);
    innerMock.rangeLte.mockReturnValue(innerMock);
    innerMock.rangeAdjacent.mockReturnValue(innerMock);
    innerMock.overlaps.mockReturnValue(innerMock);
    innerMock.textSearch.mockReturnValue(innerMock);
    innerMock.match.mockReturnValue(innerMock);
    innerMock.not.mockReturnValue(innerMock);
    innerMock.or.mockReturnValue(innerMock);
    innerMock.filter.mockReturnValue(innerMock);
    innerMock.limit.mockReturnValue(innerMock);
    innerMock.range.mockReturnValue(innerMock);
    innerMock.order.mockReturnValue(innerMock);

    // --- Configure Default TERMINAL Methods --- 
    // For single-returning methods, default to null
    const singleResponse = { 
      data: null, 
      error: null, 
      status: 200, 
      statusText: 'OK' 
    };
    
    innerMock.single.mockResolvedValue(singleResponse);
    innerMock.maybeSingle.mockResolvedValue(singleResponse);
    
    // For insert/update/upsert operations, return the builder that can be chained further or awaited
    innerMock.insert.mockImplementation(() => {
      const insertMock = createMockWithPromiseCapability();
      insertMock.select.mockReturnValue(insertMock);
      return insertMock;
    });
    
    innerMock.upsert.mockImplementation(() => {
      const upsertMock = createMockWithPromiseCapability();
      upsertMock.select.mockReturnValue(upsertMock);
      return upsertMock;
    });
    
    innerMock.update.mockImplementation(() => {
      const updateMock = createMockWithPromiseCapability();
      updateMock.select.mockReturnValue(updateMock);
      return updateMock;
    });
    
    innerMock.delete.mockImplementation(() => {
      const deleteMock = createMockWithPromiseCapability();
      deleteMock.select.mockReturnValue(deleteMock);
      return deleteMock;
    });

    return innerMock;
  });
}

// Initialize mocks on first load
resetSupabaseMocks();

// --- Context Creation --- 

// Expand this type as more tables are tested
export type TableName = 
  | 'users' 
  | 'user_profiles' 
  | 'user_settings'
  | 'values'
  | 'principles'
  | 'goals' 
  | 'tasks'
  | 'habits'
  | 'habit_entries'
  | 'tracked_state_defs' 
  | 'state_entries'     
  | 'reminders'         
  | 'goal_progress_notes'
  | 'rewards'           
  | 'user_badges';       

/**
 * Creates a TRPC context with a mocked Supabase client.
 * Ensures the user is authenticated unless explicitly bypassed.
 */
export function createInnerTRPCContext(opts: {
  userId: string | null;
  supabase?: any; // Keep as any for simplicity
}): Context {
  if (!opts.userId) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
      message: 'User must be authenticated to access this resource',
    });
  }

  return {
    userId: opts.userId,
    supabaseAdmin: opts.supabase || mockSupabaseAdmin,
  };
}

export function createTestContext(userId: string | null = 'test-user-id', supabase?: any) {
  return createInnerTRPCContext({
    userId,
    supabase,
  });
}

// Export mockDeep so it can be used directly in tests if needed
export { mockDeep };
```
\n\n## Realtime Channel: HabitCheckItem.test.tsx
**File:** ./__tests__/components/dashboard/HabitCheckItem.test.tsx
\n```
import React from 'react';
import { render, fireEvent, act } from '../test-utils';
import HabitCheckItem from '@/components/dashboard/HabitCheckItem';
import { trpc } from '@/utils/trpc';

// Mock the trpc hook
jest.mock('@/utils/trpc', () => ({
  trpc: {
    habit: {
      createHabitEntry: {
        useMutation: jest.fn().mockReturnValue({
          mutate: jest.fn(),
          isLoading: false,
          isError: false,
          error: null,
        }),
      },
      deleteHabitEntry: {
        useMutation: jest.fn().mockReturnValue({
          mutate: jest.fn(),
          isLoading: false,
          isError: false,
          error: null,
        }),
      },
    },
  },
}));

// Mock Haptics
jest.mock('expo-haptics', () => ({
  impactAsync: jest.fn(),
  ImpactFeedbackStyle: {
    Light: 'light',
  },
}));

describe('HabitCheckItem', () => {
  const mockHabit = {
    id: 'habit-1',
    title: 'Morning Run',
    streak: 3,
    completedToday: false,
    best_streak: 5,
    user_id: 'user-1',
    cue: 'Wake up',
    routine: 'Run 5k',
    reward: 'Coffee',
    habit_type: 'do',
    frequency_period: 'daily',
    goal_frequency: 1,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders correctly with uncompleted habit', () => {
    const { getByText } = render(<HabitCheckItem habit={mockHabit} />);
    
    expect(getByText('Morning Run')).toBeTruthy();
    expect(getByText(' 3 day streak')).toBeTruthy();
    expect(getByText('Check-in')).toBeTruthy();
  });

  it('renders correctly with completed habit for today', () => {
    const completedHabit = { ...mockHabit, completedToday: true };
    const { getByText } = render(<HabitCheckItem habit={completedHabit} />);
    
    expect(getByText('Morning Run')).toBeTruthy();
    expect(getByText(' 3 day streak')).toBeTruthy();
    expect(getByText('Done')).toBeTruthy();
  });

  it('calls createHabitEntry mutation when checking in', () => {
    const mockOnToggle = jest.fn();
    const mockCreateMutate = jest.fn();

    // Setup the mock create mutation
    (trpc.habit.createHabitEntry.useMutation as jest.Mock).mockReturnValue({
      mutate: mockCreateMutate,
      isLoading: false,
      isError: false,
      error: null,
    });

    const { getByText } = render(
      <HabitCheckItem habit={{...mockHabit, completedToday: false}} onToggle={mockOnToggle} />
    );

    // Press the check-in button
    fireEvent.press(getByText('Check-in'));

    // Verify the create mutation was called
    expect(mockCreateMutate).toHaveBeenCalledWith(expect.objectContaining({
      habitId: 'habit-1',
      date: expect.any(String),
      completed: true,
    }));

    // Verify the onToggle prop was called if provided
    expect(mockOnToggle).toHaveBeenCalledWith('habit-1', true);
  });

  it('calls deleteHabitEntry mutation when unchecking', () => {
    const mockOnToggle = jest.fn();
    const mockDeleteMutate = jest.fn();

    // Setup the mock delete mutation
    (trpc.habit.deleteHabitEntry.useMutation as jest.Mock).mockReturnValue({
      mutate: mockDeleteMutate,
      isLoading: false,
      isError: false,
      error: null,
    });

    const { getByText } = render(
      <HabitCheckItem habit={{...mockHabit, completedToday: true}} onToggle={mockOnToggle} />
    );

    // Press the done button
    fireEvent.press(getByText('Done'));

    // Verify the delete mutation was called
    expect(mockDeleteMutate).toHaveBeenCalledWith(expect.objectContaining({
      habitId: 'habit-1',
      date: expect.any(String),
    }));

    // Verify the onToggle prop was called if provided
    expect(mockOnToggle).toHaveBeenCalledWith('habit-1', false);
  });

  it('handles error state from mutation', async () => {
    // Mock console.error to prevent test output noise
    const originalConsoleError = console.error;
    console.error = jest.fn();

    // Assume createHabitEntry for error testing, could be delete too
    let errorCallback: (error: any) => void = () => {};
    
    (trpc.habit.createHabitEntry.useMutation as jest.Mock).mockImplementation(({ onError }) => {
      errorCallback = onError;
      return {
        mutate: jest.fn(),
        isLoading: false,
        isError: true,
      };
    });

    const { getByText } = render(<HabitCheckItem habit={mockHabit} />);

    // Press the check-in button (assuming initial state is not completed)
    fireEvent.press(getByText('Check-in'));

    // Simulate an error from the server
    await act(async () => {
      errorCallback(new Error('Network error'));
    });

    // Check that error was logged
    expect(console.error).toHaveBeenCalled();

    // Restore console.error
    console.error = originalConsoleError;
  });
});
```
\n\n## Realtime Channel: useSkeleton.ts
**File:** ./hooks/useSkeleton.ts
\n```
import { useEffect } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withTiming,
  withSequence,
  withDelay,
  Easing,
} from 'react-native-reanimated';
import { durations, easings } from '@/constants/motion';

export interface SkeletonOptions {
  /**
   * Width of the gradient shimmer (as % of the component width)
   * @default 0.7
   */
  shimmerWidth?: number;
  /**
   * Base color of the skeleton component
   * @default '#E1E9EE'
   */
  baseColor?: string;
  /**
   * Highlight color for the shimmer effect
   * @default '#F2F8FC'
   */
  highlightColor?: string;
  /**
   * Duration for a complete shimmer cycle in ms
   * @default 2000
   */
  duration?: number;
  /**
   * Delay before starting animation in ms
   * @default 0
   */
  delay?: number;
  /**
   * Whether animation should start automatically
   * @default true
   */
  autoStart?: boolean;
  /**
   * Loading state to determine if skeletons should be shown
   * @default false
   */
  isLoading?: boolean;
  /**
   * Number of skeleton items to generate
   * @default 1
   */
  count?: number;
  /**
   * Type of skeleton to generate
   * @default 'card'
   */
  type?: 'card' | 'row' | 'circle';
}

/**
 * Hook to create skeleton loading animations with shimmer effect
 */
export function useSkeleton(options: SkeletonOptions = {}) {
  const {
    shimmerWidth = 0.7,
    baseColor = '#E1E9EE',
    highlightColor = '#F2F8FC',
    duration = durations.long * 2,
    delay = 0,
    autoStart = true,
  } = options;
  
  // Animation value to track shimmer position
  const translateX = useSharedValue(-1);
  
  // Start the animation
  useEffect(() => {
    if (autoStart) {
      translateX.value = withDelay(
        delay,
        withRepeat(
          withSequence(
            withTiming(-1, { duration: 0 }),
            withTiming(1, { 
              duration, 
              easing: easings.linear 
            }),
          ),
          -1, // Infinite repeat
        ),
      );
    }
  }, [translateX, duration, delay, autoStart]);
  
  // Generate the animated styles for the shimmer effect
  const shimmerStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateX: translateX.value * (1 + shimmerWidth) }],
    };
  });
  
  // Create styles for both container and shimmer
  const styles = StyleSheet.create({
    container: {
      backgroundColor: baseColor,
      overflow: 'hidden',
    },
    shimmer: {
      width: `${shimmerWidth * 100}%`,
      height: '100%',
      backgroundColor: highlightColor,
      position: 'absolute',
      top: 0,
      bottom: 0,
      opacity: 0.7,
    },
  });
  
  // Utility function to manually start the animation
  const startAnimation = () => {
    translateX.value = withDelay(
      delay,
      withRepeat(
        withSequence(
          withTiming(-1, { duration: 0 }),
          withTiming(1, { 
            duration, 
            easing: easings.linear 
          }),
        ),
        -1, // Infinite repeat
      ),
    );
  };
  
  // Utility function to stop the animation
  const stopAnimation = () => {
    translateX.value = withTiming(-1, { duration: 200 });
  };
  
  // Generate array of skeletons based on count and type
  const generateSkeletons = () => {
    if (!options.isLoading) return [];
    
    const count = options.count || 1;
    const type = options.type || 'card';
    
    return Array.from({ length: count }).map((_, index) => ({
      key: `skeleton-${index}`,
      type,
    }));
  };
  
  return {
    baseColor,
    shimmerStyle,
    styles,
    startAnimation,
    stopAnimation,
    skeletons: generateSkeletons(),
  };
} ```
\n\n## Realtime Channel: useOfflineSync.ts
**File:** ./hooks/useOfflineSync.ts
\n```
import { useEffect, useCallback } from 'react';
import NetInfo from '@react-native-community/netinfo';
import { onlineManager } from '@tanstack/react-query';
import { saveOfflineMutation, syncOfflineMutations, getPendingItems, PendingItem, setupBackgroundSync } from '@/utils/offline-sync';
import { useState } from 'react';

/**
 * Hook to provide offline sync functionality
 */
export function useOfflineSync<T extends { id: string }>(entityType: string) {
  const [isOnline, setIsOnline] = useState(true);
  const [pendingItems, setPendingItems] = useState<PendingItem[]>([]);
  const [isSyncing, setIsSyncing] = useState(false);

  // Load pending items on mount
  useEffect(() => {
    loadPendingItems();
    
    // Set up network status listener
    const unsubscribe = NetInfo.addEventListener(state => {
      const online = state.isConnected !== false && state.isInternetReachable !== false;
      setIsOnline(online);
      
      // If going from offline to online, try to sync
      if (online) {
        syncItems();
      }
    });
    
    // Also set up background sync (network status changes outside this component)
    const unsubscribeBackground = setupBackgroundSync();
    
    return () => {
      unsubscribe();
      unsubscribeBackground();
    };
  }, [entityType]);

  // Load pending items from storage
  const loadPendingItems = useCallback(async () => {
    const items = await getPendingItems(entityType);
    setPendingItems(items);
  }, [entityType]);

  // Create an item (works offline)
  const createItem = useCallback(async (data: Omit<T, 'id'>): Promise<{ id: string, isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, create directly
        // In a real app, you'd use your API client (like supabase) here
        // const { data: newItem, error } = await supabase.from(entityType).insert(data).select();
        // if (error) throw error;
        // return { id: newItem.id, isOffline: false };
        
        // For demo purposes, simulate success
        return { id: `server-${Date.now()}`, isOffline: false };
      } else {
        // If offline, save to be synced later
        const tempId = await saveOfflineMutation('create', entityType, data);
        await loadPendingItems(); // Reload pending items
        return { id: tempId, isOffline: true };
      }
    } catch (error) {
      console.error('Error creating item:', error);
      // If API call fails, save offline
      const tempId = await saveOfflineMutation('create', entityType, data);
      await loadPendingItems(); // Reload pending items
      return { id: tempId, isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Update an item (works offline)
  const updateItem = useCallback(async (item: T): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, update directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).update(item).eq('id', item.id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('update', entityType, item);
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error updating item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('update', entityType, item);
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Delete an item (works offline)
  const deleteItem = useCallback(async (id: string): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, delete directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).delete().eq('id', id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('delete', entityType, { id });
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error deleting item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('delete', entityType, { id });
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Manually trigger sync
  const syncItems = useCallback(async (): Promise<boolean> => {
    if (isSyncing) return false;
    
    setIsSyncing(true);
    try {
      const success = await syncOfflineMutations();
      if (success) {
        await loadPendingItems(); // Reload pending items after successful sync
      }
      return success;
    } catch (error) {
      console.error('Error syncing items:', error);
      return false;
    } finally {
      setIsSyncing(false);
    }
  }, [isSyncing, loadPendingItems]);

  // Check if an item is pending sync
  const isItemPending = useCallback((id: string): boolean => {
    return pendingItems.some(item => item.id === id);
  }, [pendingItems]);

  return {
    isOnline,
    isSyncing,
    pendingItems,
    createItem,
    updateItem,
    deleteItem,
    syncItems,
    isItemPending,
  };
} ```
\n## Polling Implementation
\n\n## Polling: nats-client.ts
**File:** ./utils/nats-client.ts
\n```
import { QueryClient } from '@tanstack/react-query';
import { connect, type ConnectionOptions, type NatsConnection, StringCodec } from 'nats.ws';

// Codec for encoding/decoding NATS messages
const sc = StringCodec();

// Type for cache update handlers
type CacheUpdateHandler = (data: any) => void;

// Global handlers for different subjects
const handlers: Record<string, CacheUpdateHandler[]> = {};

// Connection state
let natsConnection: NatsConnection | null = null;
let queryClient: QueryClient | null = null;
let isConnecting = false;

/**
 * Initialize the NATS client and connect to the server
 */
export async function initNatsClient(
  url: string, 
  qc: QueryClient,
  options: Partial<ConnectionOptions> = {}
): Promise<NatsConnection> {
  if (natsConnection) {
    return natsConnection;
  }
  
  if (isConnecting) {
    throw new Error('NATS connection is already in progress');
  }
  
  isConnecting = true;
  
  try {
    // Set the query client for cache updates
    queryClient = qc;
    
    // Connect to NATS server
    natsConnection = await connect({
      servers: url,
      // Add required polyfills for React Native
      // These would need to be properly implemented in a real app
      ...options,
    });
    
    console.log('Connected to NATS server');
    
    // Setup ping interval to keep connection alive
    const pingInterval = setInterval(() => {
      if (natsConnection && !natsConnection.isClosed) {
        // Note: Using a custom ping mechanism instead of the built-in one
        try {
          const start = Date.now();
          // Simple ping using a request to a dummy subject
          natsConnection.request('_PING_', undefined, { timeout: 1000 })
            .then(() => {
              const latency = Date.now() - start;
              console.log(`NATS server latency: ${latency}ms`);
            })
            .catch((err: Error) => {
              console.error('NATS ping error:', err.message);
            });
        } catch (err) {
          const error = err as Error;
          console.error('NATS ping error:', error.message);
        }
      } else {
        clearInterval(pingInterval);
      }
    }, 30000);
    
    // Handle connection close
    natsConnection.closed().then(() => {
      console.log('NATS connection closed');
      natsConnection = null;
      clearInterval(pingInterval);
      // Could implement reconnection logic here
    });
    
    return natsConnection;
  } catch (error) {
    console.error('Failed to connect to NATS server:', error);
    isConnecting = false;
    throw error;
  }
}

/**
 * Subscribe to a NATS subject and update the React Query cache
 */
export async function subscribeWithCache(
  subject: string,
  queryKey: unknown[],
  updateType: 'invalidate' | 'setData' = 'invalidate'
): Promise<() => void> {
  if (!natsConnection) {
    throw new Error('NATS client not initialized');
  }
  
  if (!queryClient) {
    throw new Error('QueryClient not set');
  }
  
  // Create subscription
  const subscription = natsConnection.subscribe(subject);
  
  // Setup message handler
  (async () => {
    for await (const msg of subscription) {
      try {
        const data = JSON.parse(sc.decode(msg.data));
        
        if (updateType === 'invalidate') {
          // Invalidate the cache for this query key
          queryClient.invalidateQueries({ queryKey });
        } else {
          // Update the cache directly
          queryClient.setQueryData(queryKey, data);
        }
        
        // Call any custom handlers
        if (handlers[subject]) {
          handlers[subject].forEach(handler => handler(data));
        }
      } catch (error) {
        const err = error as Error;
        console.error(`Error handling message for ${subject}:`, err.message);
      }
    }
  })();
  
  // Return unsubscribe function
  return () => {
    subscription.unsubscribe();
  };
}

/**
 * Add a custom handler for a subject
 */
export function addSubjectHandler(subject: string, handler: CacheUpdateHandler): () => void {
  if (!handlers[subject]) {
    handlers[subject] = [];
  }
  
  handlers[subject].push(handler);
  
  // Return a function to remove the handler
  return () => {
    if (handlers[subject]) {
      handlers[subject] = handlers[subject].filter(h => h !== handler);
    }
  };
}

/**
 * Get the NATS connection
 */
export function getNatsConnection(): NatsConnection | null {
  return natsConnection;
}

/**
 * Close the NATS connection
 */
export async function closeNatsConnection(): Promise<void> {
  if (natsConnection) {
    await natsConnection.close();
    natsConnection = null;
  }
} ```
\n\n# 4️⃣ Core Query Hooks
\n\n## Hook: useSkeleton
**File:** hooks/useSkeleton.ts
\n```
import { useEffect } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withTiming,
  withSequence,
  withDelay,
  Easing,
} from 'react-native-reanimated';
import { durations, easings } from '@/constants/motion';

export interface SkeletonOptions {
  /**
   * Width of the gradient shimmer (as % of the component width)
   * @default 0.7
   */
  shimmerWidth?: number;
  /**
   * Base color of the skeleton component
   * @default '#E1E9EE'
   */
  baseColor?: string;
  /**
   * Highlight color for the shimmer effect
   * @default '#F2F8FC'
   */
  highlightColor?: string;
  /**
   * Duration for a complete shimmer cycle in ms
   * @default 2000
   */
  duration?: number;
  /**
   * Delay before starting animation in ms
   * @default 0
   */
  delay?: number;
  /**
   * Whether animation should start automatically
   * @default true
   */
  autoStart?: boolean;
  /**
   * Loading state to determine if skeletons should be shown
   * @default false
   */
  isLoading?: boolean;
  /**
   * Number of skeleton items to generate
   * @default 1
   */
  count?: number;
  /**
   * Type of skeleton to generate
   * @default 'card'
   */
  type?: 'card' | 'row' | 'circle';
}

/**
 * Hook to create skeleton loading animations with shimmer effect
 */
export function useSkeleton(options: SkeletonOptions = {}) {
  const {
    shimmerWidth = 0.7,
    baseColor = '#E1E9EE',
    highlightColor = '#F2F8FC',
    duration = durations.long * 2,
    delay = 0,
    autoStart = true,
  } = options;
  
  // Animation value to track shimmer position
  const translateX = useSharedValue(-1);
  
  // Start the animation
  useEffect(() => {
    if (autoStart) {
      translateX.value = withDelay(
        delay,
        withRepeat(
          withSequence(
            withTiming(-1, { duration: 0 }),
            withTiming(1, { 
              duration, 
              easing: easings.linear 
            }),
          ),
          -1, // Infinite repeat
        ),
      );
    }
  }, [translateX, duration, delay, autoStart]);
  
  // Generate the animated styles for the shimmer effect
  const shimmerStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateX: translateX.value * (1 + shimmerWidth) }],
    };
  });
  
  // Create styles for both container and shimmer
  const styles = StyleSheet.create({
    container: {
      backgroundColor: baseColor,
      overflow: 'hidden',
    },
    shimmer: {
      width: `${shimmerWidth * 100}%`,
      height: '100%',
      backgroundColor: highlightColor,
      position: 'absolute',
      top: 0,
      bottom: 0,
      opacity: 0.7,
    },
  });
  
  // Utility function to manually start the animation
  const startAnimation = () => {
    translateX.value = withDelay(
      delay,
      withRepeat(
        withSequence(
          withTiming(-1, { duration: 0 }),
          withTiming(1, { 
            duration, 
            easing: easings.linear 
          }),
        ),
        -1, // Infinite repeat
      ),
    );
  };
  
  // Utility function to stop the animation
  const stopAnimation = () => {
    translateX.value = withTiming(-1, { duration: 200 });
  };
  
  // Generate array of skeletons based on count and type
  const generateSkeletons = () => {
    if (!options.isLoading) return [];
    
    const count = options.count || 1;
    const type = options.type || 'card';
    
    return Array.from({ length: count }).map((_, index) => ({
      key: `skeleton-${index}`,
      type,
    }));
  };
  
  return {
    baseColor,
    shimmerStyle,
    styles,
    startAnimation,
    stopAnimation,
    skeletons: generateSkeletons(),
  };
} ```
\n\n## Hook: useColorScheme.web
**File:** hooks/useColorScheme.web.ts
\n```
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}
```
\n\n## Hook: useThemeColor
**File:** hooks/useThemeColor.ts
\n```
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}
```
\n\n## Hook: useColorScheme
**File:** hooks/useColorScheme.ts
\n```
export { useColorScheme } from 'react-native';
```
\n\n## Hook: useOfflineSync
**File:** hooks/useOfflineSync.ts
\n```
import { useEffect, useCallback } from 'react';
import NetInfo from '@react-native-community/netinfo';
import { onlineManager } from '@tanstack/react-query';
import { saveOfflineMutation, syncOfflineMutations, getPendingItems, PendingItem, setupBackgroundSync } from '@/utils/offline-sync';
import { useState } from 'react';

/**
 * Hook to provide offline sync functionality
 */
export function useOfflineSync<T extends { id: string }>(entityType: string) {
  const [isOnline, setIsOnline] = useState(true);
  const [pendingItems, setPendingItems] = useState<PendingItem[]>([]);
  const [isSyncing, setIsSyncing] = useState(false);

  // Load pending items on mount
  useEffect(() => {
    loadPendingItems();
    
    // Set up network status listener
    const unsubscribe = NetInfo.addEventListener(state => {
      const online = state.isConnected !== false && state.isInternetReachable !== false;
      setIsOnline(online);
      
      // If going from offline to online, try to sync
      if (online) {
        syncItems();
      }
    });
    
    // Also set up background sync (network status changes outside this component)
    const unsubscribeBackground = setupBackgroundSync();
    
    return () => {
      unsubscribe();
      unsubscribeBackground();
    };
  }, [entityType]);

  // Load pending items from storage
  const loadPendingItems = useCallback(async () => {
    const items = await getPendingItems(entityType);
    setPendingItems(items);
  }, [entityType]);

  // Create an item (works offline)
  const createItem = useCallback(async (data: Omit<T, 'id'>): Promise<{ id: string, isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, create directly
        // In a real app, you'd use your API client (like supabase) here
        // const { data: newItem, error } = await supabase.from(entityType).insert(data).select();
        // if (error) throw error;
        // return { id: newItem.id, isOffline: false };
        
        // For demo purposes, simulate success
        return { id: `server-${Date.now()}`, isOffline: false };
      } else {
        // If offline, save to be synced later
        const tempId = await saveOfflineMutation('create', entityType, data);
        await loadPendingItems(); // Reload pending items
        return { id: tempId, isOffline: true };
      }
    } catch (error) {
      console.error('Error creating item:', error);
      // If API call fails, save offline
      const tempId = await saveOfflineMutation('create', entityType, data);
      await loadPendingItems(); // Reload pending items
      return { id: tempId, isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Update an item (works offline)
  const updateItem = useCallback(async (item: T): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, update directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).update(item).eq('id', item.id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('update', entityType, item);
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error updating item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('update', entityType, item);
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Delete an item (works offline)
  const deleteItem = useCallback(async (id: string): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, delete directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).delete().eq('id', id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('delete', entityType, { id });
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error deleting item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('delete', entityType, { id });
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Manually trigger sync
  const syncItems = useCallback(async (): Promise<boolean> => {
    if (isSyncing) return false;
    
    setIsSyncing(true);
    try {
      const success = await syncOfflineMutations();
      if (success) {
        await loadPendingItems(); // Reload pending items after successful sync
      }
      return success;
    } catch (error) {
      console.error('Error syncing items:', error);
      return false;
    } finally {
      setIsSyncing(false);
    }
  }, [isSyncing, loadPendingItems]);

  // Check if an item is pending sync
  const isItemPending = useCallback((id: string): boolean => {
    return pendingItems.some(item => item.id === id);
  }, [pendingItems]);

  return {
    isOnline,
    isSyncing,
    pendingItems,
    createItem,
    updateItem,
    deleteItem,
    syncItems,
    isItemPending,
  };
} ```
\n## tRPC Query Usage Examples
\n\n## tRPC Query Example: compose.tsx
**File:** app/compose.tsx
\n```
// app/compose.tsx
import React from 'react';
import { ScrollView } from 'react-native'; // Using RN ScrollView directly
import { Stack, useRouter, useLocalSearchParams } from 'expo-router';
import { YStack, XStack, Form, Input, Label, TextArea, Button, Switch, Paragraph, Spinner } from 'tamagui';
import { useForm, Controller, ControllerRenderProps, FieldValues } from 'react-hook-form'; // Import ControllerRenderProps
import { zodResolver } from '@hookform/resolvers/zod';
import { useToastController } from '@tamagui/toast'; // Assuming ToastProvider is set up

import { trpc, type RouterInputs } from '@/utils/trpc'; // Assuming inputs are exported like this
import { haptics } from '@/utils/haptics'; // Assuming haptics helper exists

// Assuming your Zod schemas are exported like this. Adjust if necessary.
type CreateValueInput = RouterInputs['value']['createValue'];
type CreateStateInput = RouterInputs['state']['createDefinition'];

// 1️⃣ Define tagged types for discriminated union
type CreateValueInputTagged = CreateValueInput & { __type: 'value' };
type CreateStateInputTagged = CreateStateInput & { __type: 'state' };
type FormValues = CreateValueInputTagged | CreateStateInputTagged;

export default function ComposeModal() {
  const router = useRouter();
  const params = useLocalSearchParams<{ type: string }>();
  const type = params.type === 'value' || params.type === 'state' ? params.type : undefined;
  const toast = useToastController();
  const utils = trpc.useUtils();

  const isValue = type === 'value';

  // 2️⃣ Define stricter default values using tagged types
  const defaultValueValues: CreateValueInputTagged = {
    __type: 'value',
    title: '', // Use 'title' instead of 'name' - Patch #4
    description: ''
  };
  const defaultStateValues: CreateStateInputTagged = {
    __type: 'state',
    name: '',
    scale: '1-5',
    description: '',
    active: true,
    priority: 50
  };

  // --- Separate useMutation hooks ---
  const createValueMutation = trpc.value.createValue.useMutation({
    onSuccess: (data) => handleSuccess(data),
    onError: (error) => handleError(error),
  });
  const createStateDefMutation = trpc.state.createDefinition.useMutation({
    onSuccess: (data) => handleSuccess(data),
    onError: (error) => handleError(error),
  });

  // --- Form setup ---
  const { control, handleSubmit, formState: { errors }, reset } = useForm<FormValues>({
    // Note: ZodResolver might need specific configuration if schemas differ vastly
    // or consider not using it if relying solely on backend validation for this dynamic form.
    // Use the new stricter default value constants
    defaultValues: isValue ? defaultValueValues : defaultStateValues,
  });

  // Reset form if the type changes dynamically
  React.useEffect(() => {
    // Use the new stricter default value constants for reset
    reset(isValue ? defaultValueValues : defaultStateValues);
  }, [isValue, reset]);

  // --- Shared success/error handlers ---
  const handleSuccess = (data: any) => {
      toast.show('Created successfully!', { native: true });
      haptics.success();
      if (isValue) {
        utils.value.getValues.invalidate();
      } else {
        utils.state.getDefinitions.invalidate();
      }
      if (router.canGoBack()) {
        router.dismiss(); // Apply patch #5 - Use dismiss for modals
      } else {
        router.replace('/(tabs)/compass');
      }
  }

  const handleError = (error: any) => {
       toast.show(`Error: ${error.message}`, { type: 'error', native: true });
       haptics.error();
  }

  // --- Corrected onSubmit ---
  const onSubmit = (formData: FormValues) => {
    // 3️⃣ Use discriminant (__type) for type safety, remove casts
    if (formData.__type === 'value') {
      createValueMutation.mutate(formData);
    } else { // formData.__type === 'state'
      createStateDefMutation.mutate(formData);
    }
  };

  // Handle invalid type parameter gracefully
  if (!type) {
    return (
        <YStack flex={1} justifyContent="center" alignItems="center" padding="$4">
            <Paragraph color="$error">Invalid type specified.</Paragraph> {/* Use $error */}
            <Button onPress={() => router.back()} marginTop="$4">Go Back</Button>
        </YStack>
    );
  }

  // Determine current mutation state for button
  const isPending = isValue ? createValueMutation.isPending : createStateDefMutation.isPending;

  return (
    <ScrollView contentContainerStyle={{ flexGrow: 1 }}>
      <Form onSubmit={handleSubmit(onSubmit)} flex={1} padding="$4" space="$4" backgroundColor="$background">
        <Stack.Screen options={{ title: isValue ? 'Add Principle' : 'Define State' }} />

        {/* Conditionally render form fields */}
        {isValue ? (
          <>
            {/* --- Fields for Principle/Value --- */}
            <YStack space="$2">
              <Label htmlFor="title">Title</Label> {/* Patch #4: name -> title */}
              <Controller
                name="title" /* Patch #4: name -> title */
                control={control}
                rules={{ required: 'Title is required' }} /* Patch #4 */
                render={({ field }) => ( /* Use inferred types from FormValues */
                  <Input
                    id="title"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value}
                    placeholder="Principle Title"
                  />
                )}
              />
              {/* Use $error token */}
              {errors.title && <Paragraph color="$error">{errors.title?.message}</Paragraph>}
            </YStack>

            <YStack space="$2">
              <Label htmlFor="description">Description (Optional)</Label>
              <Controller
                name="description"
                control={control}
                render={({ field }) => ( // Use inferred types
                  <TextArea
                    id="description"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value ?? ''}
                    placeholder="Describe the principle..."
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && <Paragraph color="$error">{errors.description?.message}</Paragraph>}
            </YStack>
          </>
        ) : (
          <>
            {/* --- Fields for State Definition --- */}
            <YStack space="$2">
              <Label htmlFor="name">State Name</Label>
              <Controller
                name="name"
                control={control}
                rules={{ required: 'Name is required' }}
                render={({ field }) => ( // Use inferred types // Explicit type
                  <Input
                    id="name"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value}
                    placeholder="e.g., Energy Level, Mood" />
                )}
              />
              {errors.name && <Paragraph color="$error">{errors.name?.message}</Paragraph>}
            </YStack>

             <YStack space="$2">
               <Label htmlFor="scale">Scale</Label>
               <Controller
                 name="scale"
                 control={control}
                 rules={{ required: 'Scale is required' }}
                 render={({ field }) => ( // Use inferred types
                   <>
                    <Paragraph>Scale Selector Placeholder (Selected: {field.value})</Paragraph>
                    <XStack space="$2">
                      {/* Removed invalid theme prop */}
                      <Button size="$2" onPress={() => field.onChange('1-5')} theme={field.value === '1-5' ? 'active' : undefined}>1-5</Button>
                      <Button size="$2" onPress={() => field.onChange('1-10')} theme={field.value === '1-10' ? 'active' : undefined}>1-10</Button>
                    </XStack>
                   </>
                 )}
               />
                {errors.scale && <Paragraph color="$error">{errors.scale?.message}</Paragraph>}
             </YStack>

             <YStack space="$2">
              <Label htmlFor="description">Description (Optional)</Label>
              <Controller
                name="description"
                control={control}
                render={({ field }) => ( // Use inferred types
                  <TextArea
                    id="description"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value ?? ''}
                    placeholder="Describe when/how to track this state..."
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && <Paragraph color="$error">{errors.description?.message}</Paragraph>}
            </YStack>

            <XStack space="$4" alignItems="center">
               <Label htmlFor="active" flex={1}>Active</Label>
               <Controller
                 name="active"
                 control={control}
                 render={({ field }: { field: ControllerRenderProps<FieldValues, 'active'> }) => ( // Explicit type
                    <Switch
                      id="active"
                      checked={!!field.value} // Use checked
                      onCheckedChange={field.onChange} // Use onCheckedChange
                      size="$3"
                    >
                        <Switch.Thumb animation="quick" />
                    </Switch>
                 )}
               />
            </XStack>
          </>
        )}

        {/* Removed invalid theme prop */}
        <Form.Trigger asChild disabled={isPending}>
          <Button icon={isPending ? <Spinner /> : undefined}>
            {isPending ? 'Saving...' : 'Save'}
          </Button>
        </Form.Trigger>
      </Form>
    </ScrollView>
  );
}```
\n\n## tRPC Query Example: index.tsx
**File:** app/(tabs)/home/index.tsx
\n```
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/home/index.tsx
import React, { useCallback, useMemo } from 'react';
import { YStack, H1, Text, XStack, Button, ScrollView, Spinner } from 'tamagui';
import { SafeAreaView, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc, RouterOutputs } from '@/utils/trpc';
import DashboardSection from '@/components/dashboard/DashboardSection';
import GoalSummaryCard from '@/components/dashboard/GoalSummaryCard';
import HabitCheckItem from '@/components/dashboard/HabitCheckItem';
import TaskItem from '@/components/dashboard/TaskItem';
import StateIndicator from '@/components/dashboard/StateIndicator';
import DailyProgressBanner from '@/components/dashboard/DailyProgressBanner'; // Import Banner
import EmptyOrSkeleton from '@/components/ui/EmptyOrSkeleton';
import { SkeletonCard, SkeletonRow } from '@/components/ui/Skeleton';
import { useSkeleton } from '@/hooks/useSkeleton';
import { useColorScheme } from '@/hooks/useColorScheme';
import { useToastController } from '@tamagui/toast';
import { BlurView } from 'expo-blur';
import { Plus } from '@tamagui/lucide-icons';
import LottieView from 'lottie-react-native';
import SwipeableRow from '@/components/ui/SwipeableRow'; // Import SwipeableRow

// Types inferred from tRPC Router
type RouterOutput = RouterOutputs['dashboard']['getDashboardData'];
// --- Define types for the STRUCTURE AFTER mapping in useMemo ---
export type DashboardGoal = {
  id: string;
  title: string;
  progress: number;
  tasks: { completed: number; total: number };
  // Include other relevant fields if needed by GoalSummaryCard
  status?: string | null; 
  priority?: number | null;
};
export type DashboardHabit = {
  id: string;
  name: string;
  description?: string | null;
  completed: boolean; // Mapped from completedToday
  streak: number;
  last_entry_id?: string; // Mapped from habit.last_entry_id (null -> undefined)
  habit_type?: string | null;
};
export type DashboardTask = {
  id: string;
  name: string;
  status: string | null; // Allow null
  due_date?: Date | string | null;
  // Include other relevant fields if needed by TaskItem
};
export type DashboardState = {
  id: string;
  name: string | null;
  unit: string | null;
  currentValue: number | string | null;
  lastUpdated: string | null;
  lastEntry: { value: number | null; created_at: Date | string } | null; // Explicitly include lastEntry
};
// --- End mapped type definitions ---

export default function HomeScreen() {
  const colorScheme = useColorScheme();
  const toast = useToastController();
  const utils = trpc.useUtils(); // Get tRPC utils for mutations
  
  // Define types using RouterOutputs for clarity and safety
  // type DashboardGoal = RouterOutputs['dashboard']['getDashboardData']['goals'][number];
  // type DashboardHabit = RouterOutputs['dashboard']['getDashboardData']['habits'][number];
  // type DashboardTask = RouterOutputs['dashboard']['getDashboardData']['tasks'][number];

  // Use tRPC hooks to fetch data - Types are inferred but can be explicitly used
  const { 
    data: dashboardData, 
    isLoading, 
    error, 
    refetch,
    isRefetching 
  } = trpc.dashboard.getDashboardData.useQuery();

  // Define the habit entry mutation hook
  const createHabitEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: () => {
      refetch(); // Refresh data after successful mutation
      // Optional: Add success toast
      // toast.show('Habit updated!', { type: 'success' });
    },
    onError: (error) => {
      // Handle tRPC client error
      toast.show(error.message || 'Failed to update habit', { type: 'error' });
    }
  });

  // Handle errors
  React.useEffect(() => {
    if (error) {
      toast.show(error.message || 'Failed to load dashboard data', { type: 'error' });
    }
  }, [error, toast]);

  // Set up pull-to-refresh
  const onRefresh = useCallback(() => {
    refetch();
  }, [refetch]);

  // Custom skeleton states from your hooks
  const { isLoading: skeletonsLoading, count: skeletonCount = 3 } = {
    isLoading,
    count: 3 // Number of skeleton items to show
  };
  
  // Generate skeleton UI based on loading state
  const renderSkeletons = () => {
    return Array.from({ length: skeletonCount }).map((_, index) => (
      <SkeletonCard key={`skeleton-${index}`} />
    ));
  };

  // Get current date and greeting
  const greeting = getGreeting();
  const currentDate = new Date().toLocaleDateString('en-US', { 
    weekday: 'long', 
    month: 'long', 
    day: 'numeric' 
  });

  const dashboardDataMemo = useMemo(() => {
    // Fix: Add check to ensure dashboardData exists before accessing properties
    if (!dashboardData) {
      return null; // Or return default structure: { goals: [], habits: [], tasks: [], trackedStates: [] }
    }

    // Map and filter data, ensuring structure matches exported types
    return {
      // Filter goals to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      goals: (dashboardData.goals ?? [])
        .filter((goal): goal is typeof goal & { id: string } => !!goal?.id)
        .map((goal) => ({
        // Map to DashboardGoal structure
        id: goal.id, 
        title: goal.title ?? 'Untitled Goal', // Provide default for title
        progress: goal.progress ?? 0, 
        tasks: goal.tasks ?? { completed: 0, total: 0 }, 
        status: goal.status,
        priority: goal.priority,
      })),
      // Filter habits to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      habits: (dashboardData.habits ?? [])
        .filter((habit): habit is typeof habit & { id: string } => !!habit?.id)
        .map((habit) => ({
        // Map to DashboardHabit structure
        id: habit.id, 
        name: habit.name ?? 'Unnamed Habit', // Provide default for name
        description: habit.description,
        completed: habit.completedToday ?? false, // Map completedToday to completed
        streak: habit.streak ?? 0, 
        last_entry_id: habit.last_entry_id ?? undefined, // Map null to undefined
        habit_type: habit.habit_type,
      })),
      // Filter tasks to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      tasks: (dashboardData.tasks ?? [])
        .filter((task): task is typeof task & { id: string } => !!task?.id)
        .map((task) => ({
        // Map to DashboardTask structure
        id: task.id,
        name: task.name ?? 'Untitled Task', // Provide default name
        status: task.status,
        due_date: task.due_date,
      })),
      // Map trackedStates, ensuring lastEntry is preserved
      // Fix: Use nullish coalescing and optional chaining
      trackedStates: (dashboardData.trackedStates ?? [])
        .filter((state): state is typeof state & { id: string } => !!state?.id)
        .map((trackedState) => ({
        // Map to DashboardState structure
        id: trackedState.id,
        name: trackedState.name,
        unit: trackedState.unit,
        currentValue: trackedState.currentValue,
        lastUpdated: trackedState.lastUpdated,
        // Ensure lastEntry structure matches definition or is null
        lastEntry: trackedState.lastEntry ?? null, 
      })),
    };
  }, [dashboardData]);

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <ScrollView 
        showsVerticalScrollIndicator={false}
        contentContainerStyle={{ paddingBottom: 100 }}
        refreshControl={
          <RefreshControl
            refreshing={isRefetching}
            onRefresh={onRefresh}
            tintColor="transparent" // Hide default spinner
            colors={['transparent']} // Hide default spinner (Android)
            progressBackgroundColor="transparent" // Hide default bg (Android)
            refreshingComponent={
              <LottieView
                source={require('@/assets/refresh-sheikah.json')} // ASSUMES this file exists
                autoPlay
                loop
                style={{ width: 48, height: 48, alignSelf: 'center' }} // Center the animation
              />
            }
          />
        }
      >
        <YStack space="$4" paddingHorizontal="$4">
          {/* Header */}
          <YStack space="$1">
            <H1>{greeting}</H1>
            <Text color="$gray10">{currentDate}</Text>
          </YStack>

          {/* Daily Progress Banner */}
          <DailyProgressBanner 
            // tasksCompleted={...} 
            // totalTasks={...} 
            // habitsChecked={...} 
            // totalHabits={...} 
          />

          {/* Goals Section */}
          <DashboardSection 
            title="Goals"
            onSeeAll={() => router.push('/planner')}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load goals"
              />
            ) : !dashboardDataMemo?.goals || dashboardDataMemo.goals.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No goals yet"
                actionText="Create a goal"
                onAction={() => router.push('/planner/add-goal')}
              />
            ) : (
              <YStack space="$3">
                {dashboardDataMemo.goals.slice(0, 3).map((goal) => (
                  <SwipeableRow
                    key={goal.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.goal.delete.mutate({ id: goal.id })
                      console.log('Attempting to delete goal:', goal.id); // Placeholder
                      // utils.goal.delete.mutate({ id: goal.id });
                    }}
                  >
                    <GoalSummaryCard
                      goal={goal}
                      onPress={() => router.push(`/planner/goal/${goal.id}`)}
                    />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>

          {/* Today's Habits */}
          <DashboardSection 
            title="Today's Habits"
            onSeeAll={() => router.push('/planner?tab=habits')}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load habits"
              />
            ) : !dashboardDataMemo?.habits || dashboardDataMemo.habits.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No habits for today"
                actionText="Create a habit"
                onAction={() => router.push('/planner/add-habit')}
              />
            ) : (
              <YStack space="$2">
                {dashboardDataMemo.habits.slice(0, 4).map((habit) => (
                  <SwipeableRow
                    key={habit.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.habit.delete.mutate({ id: habit.id })
                      console.log('Attempting to delete habit:', habit.id); // Placeholder
                      // utils.habit.delete.mutate({ id: habit.id });
                    }}
                  >
                    <HabitCheckItem habit={habit} />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>

          {/* Today's State */}
          <DashboardSection
            title="Today's State"
            // TODO: Add navigation to a dedicated state tracking screen
            onSeeAll={() => console.log('Navigate to State Tracking screen')}
          >
            {isLoading ? (
              renderSkeletons() // Use generic skeletons or specific state skeletons
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load state"
              />
            ) : !dashboardDataMemo?.trackedStates || dashboardDataMemo.trackedStates.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No states being tracked"
                actionText="Track a state"
                // TODO: Navigate to state definition creation screen
                onAction={() => console.log('Navigate to Add State screen')}
              />
            ) : (
              <XStack space="$3" flexWrap="wrap"> 
                {dashboardDataMemo.trackedStates.map((stateData) => (
                  <StateIndicator
                    key={stateData.id}
                    state={stateData} // Pass the whole state object which includes lastEntry
                    lastEntry={stateData.lastEntry} // Pass lastEntry explicitly
                    // TODO: Handle interaction - e.g., navigate to state detail/entry screen
                    onPress={() => console.log('State pressed:', stateData.id)}
                  />
                ))}
              </XStack>
            )}
          </DashboardSection>

          {/* Upcoming Tasks */}
          <DashboardSection 
            title="Upcoming Tasks"
            onSeeAll={() => {/* Navigate to tasks list */}}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load tasks"
              />
            ) : !dashboardDataMemo?.tasks || dashboardDataMemo.tasks.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No upcoming tasks"
                actionText="Create a task"
                onAction={() => {/* Navigate to create task */}}
              />
            ) : (
              <YStack space="$2">
                {dashboardDataMemo.tasks.slice(0, 5).map((task) => (
                  <SwipeableRow
                    key={task.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.task.delete.mutate({ id: task.id })
                      console.log('Attempting to delete task:', task.id); // Placeholder
                      // utils.task.delete.mutate({ id: task.id });
                    }}
                  >
                    <TaskItem
                      task={{
                        // Explicitly pass props matching DashboardTask type
                        id: task.id, // Ensure id is passed
                        name: task.name, // Already defaulted in map
                        status: task.status, // Pass status
                        due_date: task.due_date, // Pass due_date
                      }}
                      isLast={false} // Adjust if needed for styling
                      onPress={() => console.log('Task Item Pressed:', task.id)}
                    />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>
        </YStack>
      </ScrollView>
      <QuickAddFAB />
    </SafeAreaView>
  );
}

// Helper function for greeting
function getGreeting() {
  const hour = new Date().getHours();
  if (hour < 12) return 'Good Morning';
  if (hour < 18) return 'Good Afternoon';
  return 'Good evening';
}

// Quick Add FAB Component
function QuickAddFAB() {
  return (
    <BlurView intensity={40} tint="default" style={{ position:'absolute', bottom:24, right:24, borderRadius:32, overflow: 'hidden' }}>
      <Button
        circular
        size="$5"
        backgroundColor="$accent"
        icon={Plus}
        elevate
        shadowColor="$shadowColor"
        shadowRadius={5}
        shadowOffset={{ width: 0, height: 2 }}
        pressStyle={{ scale: 0.95, opacity: 0.9 }}
        onPress={() => {
          router.push('/planner/add-task');
        }}
      />
    </BlurView>
  );
}
```
\n\n## tRPC Query Example: index.tsx
**File:** app/(tabs)/planner/index.tsx
\n```
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/planner/index.tsx
import React, { useState, Suspense } from 'react';
import { YStack, XStack, Text, Tabs, Button, Spinner, Card, ScrollView } from 'tamagui';
import { SafeAreaView, FlatList, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { RouterOutputs } from '@/utils/api-types';
import { SectionError } from '@/components/ui/ErrorBanner';


interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'goals',
    title: 'Goals',
    icon: <Ionicons name="trophy-outline" size={18} color="currentColor" />
  },
  {
    key: 'habits',
    title: 'Habits',
    icon: <Ionicons name="repeat-outline" size={18} color="currentColor" />
  },
  {
    key: 'calendar',
    title: 'Calendar',
    icon: <Ionicons name="calendar-outline" size={18} color="currentColor" />
  }
];

export default function PlannerScreen() {
  const [activeTab, setActiveTab] = useState<string>('goals');
  const colorScheme = useColorScheme();
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Planner</Text>
          <Button
            size="$3"
            circular
            onPress={() => {/* Handle new item */}}
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>
        
        {/* Tabs */}
        <Tabs
          defaultValue="goals"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List 
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {tab.icon}
                  <Text>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>
          
          {/* Tab Content */}
          <Tabs.Content value="goals" flex={1}>
            <ScrollView>
              <GoalsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="habits" flex={1}>
            <ScrollView>
              <HabitsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="calendar" flex={1}>
            <ScrollView>
              <CalendarTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Goals Tab
function GoalsTab() {
  // Fetch goals using tRPC
  const { data: goals, isLoading, error, refetch } = trpc.goal.getGoals.useQuery();
  
  // Define the inferred type for a single goal
  type PlannerGoal = RouterOutputs['goal']['getGoals'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load goals" 
      />
    );
  }
  
  if (!goals || goals.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No goals yet" 
        actionText="Create a goal" 
        onAction={() => router.push('/planner/add-goal')} 
      />
    );
  }
  
  return (
    <YStack space="$4">
      {goals.map((goal: PlannerGoal) => (
        <Button 
          key={goal.id} 
          height="$12" 
          justifyContent="flex-start" 
          paddingHorizontal="$3"
          onPress={() => router.push({ pathname: '/planner/goal/[id]', params: { id: goal.id } })}
        >
          <YStack>
            <Text fontWeight="bold">{goal.title}</Text>
            <Text fontSize="$2" color="$gray10">
              {goal.dueDate ? new Date(goal.dueDate).toLocaleDateString() : 'No due date'}
            </Text>
          </YStack>
        </Button>
      ))}
    </YStack>
  );
}

// Habits Tab
function HabitsTab() {
  // Fetch habits using tRPC
  const { data: habits, isLoading, error, refetch } = trpc.habit.getHabits.useQuery();
  
  // Define the inferred type for a single habit
  type PlannerHabit = RouterOutputs['habit']['getHabits'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={isLoading} count={3} type="row" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load habits" 
      />
    );
  }
  
  if (!habits || habits.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No habits yet" 
        actionText="Create a habit" 
        onAction={() => router.push('/planner/add-habit')} 
      />
    );
  }
  
  return (
    <YStack space="$3">
      {habits.map((habit: PlannerHabit) => (
        <XStack 
          key={habit.id} 
          justifyContent="space-between" 
          alignItems="center" 
          paddingVertical="$3" 
          paddingHorizontal="$3" 
          borderBottomWidth={1} 
          borderColor="$gray5"
          pressStyle={{ opacity: 0.7 }}
          tag="pressable"
          onPress={() => router.push({ pathname: '/planner/habit/[id]', params: { id: habit.id } })}
        >
          <Text>{habit.title}</Text>
          <Button
            size="$2"
            circular
            backgroundColor={habit.completed ? '$green9' : '$gray9'}
            onPress={() => {
              // Use today's date for the habit entry
              const today = new Date().toISOString().split('T')[0];
              
              // Create a mutation to toggle habit completion
              const toggleHabit = trpc.habit.createHabitEntry.useMutation({
                onSuccess: () => {
                  refetch(); // Refresh data after toggling
                },
                onError: (error) => {
                  // Show error message
                  console.error('Failed to toggle habit:', error.message);
                }
              });
              
              // Toggle the habit completion status
              toggleHabit.mutate({
                habitId: habit.id,
                completed: !habit.completed,
                date: today
              });
            }}
            icon={<Ionicons name="checkmark" size={18} color="white" />}
          />
        </XStack>
      ))}
    </YStack>
  );
}

// Calendar Tab
function CalendarTab() {
  return (
    <YStack alignItems="center" justifyContent="center" padding="$8">
      <Text fontSize="$5" textAlign="center">
        Calendar integration coming soon
      </Text>
      <Text marginTop="$2" color="$gray10" textAlign="center">
        This tab will display task and habit schedules in a calendar view
      </Text>
    </YStack>
  );
}
```
\n\n## tRPC Query Example: index.tsx
**File:** app/(tabs)/rewards/index.tsx
\n```
// Rewards screen with grid/list toggle and claim functionality
import React, { useState, useCallback } from 'react';
import { YStack, XStack, Text, Button, ScrollView, Card, Checkbox, useTheme, H1 } from 'tamagui';
import { SafeAreaView, View, FlatList, ImageBackground, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { RouterOutputs } from '@/utils/trpc'; // Import RouterOutputs
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton'; // Import helper component

// Define inferred type for rewards
type RewardItem = RouterOutputs['rewards']['getAvailableRewards'][number];

enum ViewMode {
  Grid = 'grid',
  List = 'list'
}

export default function RewardsScreen() {
  const [viewMode, setViewMode] = useState<ViewMode>(ViewMode.Grid);
  const colorScheme = useColorScheme();
  const theme = useTheme();

  // Define fallback colors
  const blue2 = theme?.blue2?.val ?? '#eff6ff';
  const blue5 = theme?.blue5?.val ?? '#60a5fa';
  const blue10 = theme?.blue10?.val ?? '#1e40af';
  const blue11 = theme?.blue11?.val ?? '#1e3a8a';
  const green9 = theme?.green9?.val ?? '#16a34a';

  // Fetch available rewards from tRPC
  const { 
    data: rewards, 
    isLoading, 
    error, 
    refetch 
  } = trpc.rewards.getAvailableRewards.useQuery();

  // Mutation for claiming rewards
  const claimMutation = trpc.rewards.earnReward.useMutation({
    onSuccess: (data) => {
      console.log('Reward claimed successfully:', data);
      // Maybe show confetti?
      Alert.alert('Reward Claimed!', `You spent ${data.reward.points_spent} points. Remaining: ${data.remainingPoints}`);
      refetch(); // Refetch the list of available rewards
    },
    onError: (err) => {
      console.error('Failed to claim reward:', err);
      Alert.alert('Claim Failed', err.message || 'Could not claim reward.');
    }
  });
  
  const handleClaimReward = useCallback((rewardId: string) => {
    if (claimMutation.isPending) return; // Prevent double-clicks
    
    Alert.alert(
      'Confirm Claim',
      'Are you sure you want to spend points on this reward?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Claim', 
          onPress: () => {
            claimMutation.mutate({ rewardId });
          },
          style: 'default'
        }
      ]
    );
  }, [claimMutation]);
  
  const renderItem = ({ item }: { item: RewardItem }) => { // Use inferred type
    // Assuming backend field is image_url, map to imagePath
    const imagePath = item.image_url; 
    // All items from getAvailableRewards are considered claimable (not yet claimed)
    const claimed = false; 
    // Map required_points to pointCost
    const pointCost = item.required_points;

    if (viewMode === ViewMode.Grid) {
      return (
        <Card
          size="$4"
          bordered
          width={160}
          height={200}
          margin="$2"
          overflow="hidden"
          elevation="$2"
          opacity={claimed ? 0.7 : 1}
        >
          <ImageBackground
            source={{ uri: imagePath }}
            style={{ width: '100%', height: 100 }}
          >
            <View style={{ 
              position: 'absolute', 
              top: 5, 
              right: 5, 
              backgroundColor: blue5,
              borderRadius: 10,
              padding: 4
            }}>
              <Text color="white" fontSize="$2" fontWeight="bold">
                {pointCost} pts
              </Text>
            </View>
          </ImageBackground>
          
          <YStack padding="$2" flex={1} justifyContent="space-between">
            <Text fontSize="$4" fontWeight="bold" numberOfLines={1}>
              {item.name}
            </Text>
            
            <Button
              size="$2"
              themeInverse={claimed}
              backgroundColor={claimed ? undefined : blue10}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </YStack>
        </Card>
      );
    } else {
      return (
        <Card
          bordered
          margin="$2"
          padding="$3"
          opacity={claimed ? 0.7 : 1}
        >
          <XStack space="$3" alignItems="center">
            {imagePath && (
              <View style={{ 
                width: 60, 
                height: 60, 
                borderRadius: 8, 
                overflow: 'hidden',
                backgroundColor: theme.gray3.val
              }}>
                <ImageBackground
                  source={{ uri: imagePath }}
                  style={{ width: '100%', height: '100%' }}
                />
              </View>
            )}
            
            <YStack flex={1} space="$1">
              <Text fontSize="$5" fontWeight="bold">{item.name}</Text>
              <Text fontSize="$3" color="$gray11" numberOfLines={2}>{item.description}</Text>
              <Text fontSize="$3" color={blue10} fontWeight="500">{pointCost} points</Text>
            </YStack>
            
            <Button
              size="$3"
              backgroundColor={claimed ? undefined : blue10}
              themeInverse={claimed}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </XStack>
        </Card>
      );
    }
  };
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        <YStack space="$4">
          {/* Header */}
          <XStack justifyContent="space-between" alignItems="center">
            <H1>Rewards</H1>
            
            <XStack space="$2">
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.Grid ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.Grid)}
              >
                <Ionicons 
                  name="grid-outline" 
                  size={22} 
                  color={viewMode === ViewMode.Grid ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
              
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.List ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.List)}
              >
                <Ionicons 
                  name="list-outline" 
                  size={22} 
                  color={viewMode === ViewMode.List ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
            </XStack>
          </XStack>
          
          {/* Stats */}
          <Card padding="$3" backgroundColor={blue2}>
            <XStack justifyContent="space-between" alignItems="center">
              <Text fontSize="$5" fontWeight="bold" color={blue11}>Your Points</Text>
              <Text fontSize="$6" fontWeight="bold" color={blue10}>275</Text>
            </XStack>
          </Card>
        </YStack>
        
        {/* Content Area */} 
        <EmptyOrSkeleton 
          isLoading={isLoading}
          isEmpty={!isLoading && !error && (!rewards || rewards.length === 0)}
          isError={!!error}
          text={error ? error.message : 'No rewards available yet.'} // Use text for error OR empty msg
          onRetry={refetch}
          type={viewMode === ViewMode.Grid ? 'card' : 'row'}
          count={viewMode === ViewMode.Grid ? 6 : 3}
        >
          <FlatList
            key={viewMode} // Change key based on viewMode to force re-render
            data={rewards}
            renderItem={renderItem}
            keyExtractor={(item, index) =>
              `${item?.id ?? `tmp-${index}`}-${viewMode}`   // fall back to index if ID is missing
            }
            
            // Optional: Log corrupt data in development
            onLayout={() => {
              if (__DEV__) {
                const missing = (rewards ?? []).filter(r => !r?.id);
                if (missing.length) console.warn('Rewards missing id:', missing);
              }
            }}
            numColumns={viewMode === ViewMode.Grid ? 2 : 1}
            contentContainerStyle={{ paddingBottom: 50 }} // Add padding at the bottom
            // Optional Optimizations (Patch #6)
            initialNumToRender={8}
            removeClippedSubviews={true} // Note: Can have visual glitches on iOS sometimes
          />
        </EmptyOrSkeleton>

      </YStack>
    </SafeAreaView>
  );
}
```
\n\n## tRPC Query Example: index.tsx
**File:** app/(tabs)/compass/index.tsx
\n```
// Compass screen with Principles and States tabs
import React, { useState } from 'react';
import { YStack, XStack, Text, Tabs, Button, ScrollView } from 'tamagui'; 
import { SafeAreaView } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc, type RouterOutputs } from '@/utils/trpc'; 
import { useColorScheme } from '@/hooks/useColorScheme'; 
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { router, type Href } from 'expo-router'; 
import { PrincipleCard } from '@/components/compass/PrincipleCard';
import PrinciplesTab from '@/components/compass/PrinciplesTab';
import { StateDefinitionCard } from '@/components/compass/StateDefinitionCard'; 

interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'principles',
    title: 'Principles',
    icon: <Ionicons name="compass-outline" size={18} color="currentColor" />
  },
  {
    key: 'states',
    title: 'States',
    icon: <Ionicons name="pulse-outline" size={18} color="currentColor" />
  }
];

export default function CompassScreen() {
  const [activeTab, setActiveTab] = useState<string>('principles');
  const colorScheme = useColorScheme();

  const handleAddPress = () => {
    const route = `/compose?type=${activeTab === 'principles' ? 'value' : 'state'}` as Href;
    router.push(route);
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Compass</Text>
          <Button
            size="$3"
            circular
            onPress={handleAddPress} 
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>

        {/* Tabs */}
        <Tabs
          defaultValue="principles"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {React.cloneElement(tab.icon as React.ReactElement, { color: activeTab === tab.key ? '$colorFocus' : '$color' })}
                  <Text color={activeTab === tab.key ? '$colorFocus' : '$color'}>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>

          {/* Tab Content */}
          <Tabs.Content value="principles" flex={1} key="principles-content">
            <ScrollView>
              <PrinciplesTab />
            </ScrollView>
          </Tabs.Content>

          <Tabs.Content value="states" flex={1} key="states-content">
            <ScrollView>
              <StatesTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Define the specific types from RouterOutputs
// Types are now defined in the PrinciplesTab component
type StateDefinition = RouterOutputs['state']['getDefinitions'][number]; 

// Principles Tab Component is now imported from '@/components/compass/PrinciplesTab'

// States Tab Component (manages data fetching and list rendering)
function StatesTab() {
  const { data: states, isLoading, error, refetch } = trpc.state.getDefinitions.useQuery(); 

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }

  if (error) {
    return (
      <EmptyOrSkeleton
        isEmpty={false}
        isError={true}
        onRetry={refetch}
        text="Failed to load tracked state definitions"
      />
    );
  }

  if (!states || states.length === 0) {
    return (
      <EmptyOrSkeleton
        isEmpty={true}
        text="No state definitions found"
        actionText="Define Your First State"
        onAction={() => router.push('/compose?type=state' as Href)}
      />
    );
  }

  return (
    <YStack space="$3"> 
      {states.map((state: StateDefinition) => (
        <StateDefinitionCard
          key={state.id}
          state={state}
          onPress={() => router.push(`/states/${state.id}` as Href)}
        />
      ))}
    </YStack>
  );
}

// 
// Removed inline PrincipleCard definition (extracted to components/compass/PrincipleCard.tsx)
// 

// 
// Removed inline StateDefinitionCard definition (extracted to components/compass/StateDefinitionCard.tsx)
// 
```
\n\n# 5️⃣ Dashboard Task
\n\n## SwipeableRow Component
**File:** components/ui/SwipeableRow.tsx
\n```
import React from 'react';
import { Swipeable } from 'react-native-gesture-handler';
import { XStack, Button, useTheme } from 'tamagui';
import { Trash, Check } from '@tamagui/lucide-icons';
import * as Haptics from 'expo-haptics';

type SwipeableRowProps = {
  children: React.ReactNode;
  onDelete?: () => void;
  onComplete?: () => void;
  // Add any other props needed, like unique key for Swipeable instance management
};

export default function SwipeableRow({ children, onDelete, onComplete }: SwipeableRowProps) {
  const theme = useTheme();

  const renderRightActions = () => {
    if (!onDelete) return null;
    return (
      <XStack flex={1} justifyContent="flex-end">
        <Button
          // size="$3" // Match ListItem size?
          backgroundColor="$destructive"
          borderTopRightRadius="$0" // Flatten edges
          borderBottomRightRadius="$0"
          icon={<Trash color={theme.color?.get()} />} // Use theme color for icon
          onPress={() => {
            Haptics.selectionAsync();
            onDelete();
            // Consider closing the Swipeable here if needed
          }}
          width={80} // Fixed width for the action button
          height="100%" // Fill height
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  const renderLeftActions = () => {
    if (!onComplete) return null;
    return (
      <XStack flex={1} justifyContent="flex-start">
        <Button
          // size="$3"
          backgroundColor="$success"
          borderTopLeftRadius="$0"
          borderBottomLeftRadius="$0"
          icon={<Check color={theme.color?.get()} />}
          onPress={() => {
            Haptics.selectionAsync();
            onComplete();
            // Consider closing the Swipeable here if needed
          }}
          width={80}
          height="100%"
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  return (
    <Swipeable
      renderRightActions={renderRightActions}
      renderLeftActions={renderLeftActions}
      overshootFriction={8} // Standard friction
      containerStyle={{ backgroundColor: '$background' }} // Ensure background matches item
    >
      {children}
    </Swipeable>
  );
}
```
\n\n## TaskItem Component
**File:** components/dashboard/TaskItem.tsx
\n```
import React from 'react';
// Use Tamagui components
import { Text, XStack, YStack, Checkbox, Spinner } from 'tamagui'; 
import { trpc, RouterOutputs, RouterInputs } from '@/utils/trpc';
import { Check } from '@tamagui/lucide-icons';

// Custom Task type that matches the actual format returned from the backend
type Task = {
  id: string;
  name: string;  // Backend returns 'name' not 'title'
  status: string;
  priority?: number;
  due_date?: string; // Backend returns 'due_date' not 'due'
  notes?: string;
  goal_id?: string;
  // Include other fields as needed
};

interface TaskItemProps {
  task: Task;
  onPress: () => void;
}

export default function TaskItem({ task, onPress }: TaskItemProps) {
  
  // Setup toggleTask mutation with optimistic updates
  const utils = trpc.useContext();
  // Setup mutation for task toggling
  const toggleTaskMutation = trpc.task.toggleTask.useMutation({
    // Optimistically update the UI
    onMutate: async ({ taskId, completed }: { taskId: string; completed?: boolean }) => {
      // Default to toggling the current state if completed is not provided
      const newCompleted = completed !== undefined ? completed : !isCompleted;
      // Cancel outgoing fetches that might overwrite our optimistic update
      await utils.task.getTasks.cancel();
      await utils.dashboard.getDashboardData.cancel();
      
      // Get previous data for potential rollback
      const prevTasksData = utils.task.getTasks.getData();
      const prevDashboardData = utils.dashboard.getDashboardData.getData();
      
      // Optimistically update tasks data if present
      if (prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return old.map((t: any) => {
            if (t.id === taskId) {
              return {
                ...t,
                status: completed ? 'completed' : 'in-progress'
              };
            }
            return t;
          });
        });
      }
      
      // Optimistically update dashboard data if present
      if (prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return {
            ...old,
            tasks: old.tasks.map((t: any) => {
              if (t.id === taskId) {
                return {
                  ...t,
                  status: newCompleted ? 'completed' : 'in-progress'
                };
              }
              return t;
            }),
          };
        });
      }
      
      // Return previous data for rollback
      return { prevTasksData, prevDashboardData };
    },
    
    // If something goes wrong, rollback optimistic updates
    onError: (err: any, variables: any, context: any) => {
      if (context?.prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, context.prevTasksData);
      }
      if (context?.prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, context.prevDashboardData);
      }
      console.error('Error toggling task:', err);
    },
    
    // Always refetch after error or success
    onSettled: () => {
      utils.task.getTasks.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    }
  });

  // Handle checkbox toggle
  const handleToggle = () => {
    toggleTaskMutation.mutate({
      taskId: task.id, // Using taskId as expected by the backend
      completed: !isCompleted
    });
  };

  // Map priority to color
  const priorityColor = task.priority === 1 ? '$brandRed' : 
                        task.priority === 2 ? '$brandYellow' : 
                        '$brandGreen';
  
  // Format due date
  const formattedDate = task.due_date 
    ? new Date(task.due_date).toLocaleDateString(undefined, { 
        month: 'short', 
        day: 'numeric' 
      })
    : null;
    
  // Determine task completion status
  const isCompleted = task.status === 'completed';
  // No need for text style object since we use Tamagui props directly

  
  // Use YStack as the base component
  return (
    <YStack 
      backgroundColor="$backgroundStrong"
      padding="$3"
      borderRadius="$4"
      space="$1" // Add space between XStack and Date Text
    >
      <XStack alignItems="center" space="$2"> {/* Use XStack for horizontal layout */}
        {/* Checkbox for task completion */}
        <Checkbox
          size="$4"
          checked={isCompleted}
          onCheckedChange={handleToggle}
          disabled={toggleTaskMutation.isPending}
        >
          {toggleTaskMutation.isPending ? (
            <Spinner size="small" color="$brandPrimary" />
          ) : (
            <Checkbox.Indicator>
              <Check size={16} />
            </Checkbox.Indicator>
          )}
        </Checkbox>

        {/* Container for task details (clickable) */}
        <XStack flex={1} tag="pressable" onPress={onPress} pressStyle={{ opacity: 0.7 }}>
          {/* Priority Dot using YStack */}
          <YStack 
            width="$2" // Use size token for width
            height="$2" // Use size token for height
            borderRadius="$10" // Use a large radius token
            backgroundColor={priorityColor} 
            marginRight="$2" // Use space token for margin
          />
          <Text 
            fontSize="$4" // Use font size token
            fontWeight={task.priority === 1 ? '600' : '400'} // Keep fontWeight
            color="$color"
            flex={1} // Allow text to take remaining space
            opacity={isCompleted ? 0.7 : 1}
            textDecorationLine={isCompleted ? 'line-through' : undefined} // Proper Tamagui text decoration
          >
            {task.name}
          </Text>
        </XStack>
      </XStack>
      
      {formattedDate && (
        // Removed explicit margin, rely on outer YStack space
        <Text color="$gray9" fontSize="$2">
          Due: {formattedDate}
        </Text>
      )}
    </YStack>
  );
} ```
\n\n## Task Completion Handler: SwipeableRow.tsx
**File:** ./components/ui/SwipeableRow.tsx
\n```
import React from 'react';
import { Swipeable } from 'react-native-gesture-handler';
import { XStack, Button, useTheme } from 'tamagui';
import { Trash, Check } from '@tamagui/lucide-icons';
import * as Haptics from 'expo-haptics';

type SwipeableRowProps = {
  children: React.ReactNode;
  onDelete?: () => void;
  onComplete?: () => void;
  // Add any other props needed, like unique key for Swipeable instance management
};

export default function SwipeableRow({ children, onDelete, onComplete }: SwipeableRowProps) {
  const theme = useTheme();

  const renderRightActions = () => {
    if (!onDelete) return null;
    return (
      <XStack flex={1} justifyContent="flex-end">
        <Button
          // size="$3" // Match ListItem size?
          backgroundColor="$destructive"
          borderTopRightRadius="$0" // Flatten edges
          borderBottomRightRadius="$0"
          icon={<Trash color={theme.color?.get()} />} // Use theme color for icon
          onPress={() => {
            Haptics.selectionAsync();
            onDelete();
            // Consider closing the Swipeable here if needed
          }}
          width={80} // Fixed width for the action button
          height="100%" // Fill height
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  const renderLeftActions = () => {
    if (!onComplete) return null;
    return (
      <XStack flex={1} justifyContent="flex-start">
        <Button
          // size="$3"
          backgroundColor="$success"
          borderTopLeftRadius="$0"
          borderBottomLeftRadius="$0"
          icon={<Check color={theme.color?.get()} />}
          onPress={() => {
            Haptics.selectionAsync();
            onComplete();
            // Consider closing the Swipeable here if needed
          }}
          width={80}
          height="100%"
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  return (
    <Swipeable
      renderRightActions={renderRightActions}
      renderLeftActions={renderLeftActions}
      overshootFriction={8} // Standard friction
      containerStyle={{ backgroundColor: '$background' }} // Ensure background matches item
    >
      {children}
    </Swipeable>
  );
}
```
\n\n## Task Completion Handler: TaskList.tsx
**File:** ./components/lists/TaskList.tsx
\n```
import React from 'react';
import { FlatList, RefreshControl, ListRenderItem } from 'react-native';
import { YStack, XStack, Text, Stack } from 'tamagui';
import { router } from 'expo-router';
import { RouterOutputs } from '@/utils/api-types';
import { AetherCard } from '@/components/ui/primitives';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { Ionicons } from '@expo/vector-icons';

type Task = RouterOutputs['task']['list'][number];

interface TaskListProps {
  tasks?: Task[];
  isLoading: boolean;
  isError?: boolean;
  refetch: () => void;
  onSelectTask?: (task: Task) => void;
  onCompleteTask?: (taskId: string, completed: boolean) => void;
}

/**
 * TaskCard - Individual task card component
 */
export function TaskCard({ 
  task, 
  onPress, 
  onComplete 
}: { 
  task: Task; 
  onPress: () => void; 
  onComplete?: (completed: boolean) => void;
}) {
  // Get the completion status of the task
  const [isCompleted, setIsCompleted] = React.useState(Boolean(task.completed));
  
  // Format the due date
  const formattedDate = task.due
    ? new Date(task.due).toLocaleDateString(undefined, {
        month: 'short',
        day: 'numeric',
      })
    : 'No due date';
    
  // Check if task is overdue
  const isOverdue = task.due && new Date(task.due) < new Date() && !isCompleted;

  const handleToggle = () => {
    const newStatus = !isCompleted;
    setIsCompleted(newStatus);
    if (onComplete) {
      onComplete(newStatus);
    }
  };

  return (
    <AetherCard 
      isInteractive 
      variant="default"
      onPress={onPress}
    >
      <YStack space="$2">
        {/* Title with completion toggle */}
        <XStack space="$3" justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center" flex={1}>
            <Stack 
              onPress={handleToggle}
              pressStyle={{ opacity: 0.8 }}
            >
              <Ionicons 
                name={isCompleted ? "checkmark-circle" : "checkmark-circle-outline"} 
                size={26} 
                color={isCompleted ? "$success" : "$colorMuted"} 
              />
            </Stack>
            <Text 
              fontSize="$5" 
              fontWeight="bold" 
              color={isCompleted ? "$colorMuted" : "$color"} 
              numberOfLines={1} 
              flex={1}
              textDecorationLine={isCompleted ? 'line-through' : 'none'}
            >
              {task.title}
            </Text>
          </XStack>
        </XStack>
        
        {/* Notes if available */}
        {task.notes && !isCompleted && (
          <Text color="$colorMuted" fontSize="$3" numberOfLines={2} paddingLeft="$7">
            {task.notes}
          </Text>
        )}
        
        {/* Footer with due date and goal information */}
        <XStack justifyContent="space-between" alignItems="center" paddingLeft="$7">
          <XStack space="$2" alignItems="center">
            <Ionicons 
              name="calendar-outline" 
              size={16} 
              color={isOverdue ? "$error" : "$colorMuted"} 
            />
            <Text 
              fontSize="$2" 
              color={isOverdue ? "$error" : "$colorMuted"}
              fontWeight={isOverdue ? "bold" : "normal"}
            >
              {isOverdue ? "Overdue: " : ""}{formattedDate}
            </Text>
          </XStack>
          
          {/* If task is linked to a goal, show goal name */}
          {task.goal_id && (
            <XStack 
              backgroundColor="$backgroundStrong" 
              paddingHorizontal="$2" 
              paddingVertical="$1" 
              borderRadius="$2"
            >
              <Text fontSize="$2" color="$primary">
                {task.goal?.title || 'Linked goal'}
              </Text>
            </XStack>
          )}
        </XStack>
      </YStack>
    </AetherCard>
  );
}

/**
 * TaskList - List component for displaying tasks
 */
export function TaskList({ 
  tasks, 
  isLoading, 
  isError, 
  refetch, 
  onSelectTask,
  onCompleteTask 
}: TaskListProps) {
  const renderTaskItem: ListRenderItem<Task> = ({ item }) => (
    <TaskCard 
      task={item} 
      onPress={() => {
        if (onSelectTask) {
          onSelectTask(item);
        } else {
          // Default navigation
          router.push({ 
            pathname: '/planner/task/[id]', 
            params: { id: item.id } 
          });
        }
      }}
      onComplete={(completed) => {
        if (onCompleteTask) {
          onCompleteTask(item.id, completed);
        }
      }}
    />
  );

  if (isLoading) {
    return <EmptyOrSkeleton isLoading count={3} type="card" />;
  }

  if (isError) {
    return (
      <YStack padding="$4" space="$4" alignItems="center" justifyContent="center">
        <Ionicons name="alert-circle-outline" size={48} color="$error" />
        <YStack>
          <YStack alignItems="center">
            <Text fontSize="$5" fontWeight="bold" color="$color" textAlign="center">
              Unable to load tasks
            </Text>
            <Text fontSize="$3" color="$colorMuted" textAlign="center" marginTop="$2">
              Please check your connection and try again
            </Text>
          </YStack>
        </YStack>
        <AetherCard onPress={refetch} isInteractive padding="$3" paddingHorizontal="$5">
          <XStack alignItems="center" space="$2">
            <Ionicons name="refresh-outline" size={18} color="$primary" />
            <Text fontSize="$4" fontWeight="500" color="$primary">
              Retry
            </Text>
          </XStack>
        </AetherCard>
      </YStack>
    );
  }

  if (!tasks || tasks.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty 
        text="No tasks yet" 
        actionText="Create a task" 
        onAction={() => router.push('/planner/add-task')} 
      />
    );
  }

  return (
    <FlatList
      data={tasks}
      keyExtractor={(item) => item.id}
      renderItem={renderTaskItem}
      contentContainerStyle={{ padding: 16, paddingBottom: 32 }}
      ItemSeparatorComponent={() => <YStack height="$4" />}
      refreshControl={
        <RefreshControl 
          refreshing={isLoading} 
          onRefresh={refetch} 
        />
      }
    />
  );
}
```
\n\n## Task Completion Handler: ConfettiBurst.tsx
**File:** ./components/rewards/ConfettiBurst.tsx
\n```
import React, { useEffect } from 'react';
import { StyleSheet, Dimensions } from 'react-native';
import { View } from 'tamagui';
import Animated, {
  useSharedValue,
  withDelay,
  withTiming,
  useAnimatedStyle,
  withSequence,
  runOnJS,
  Easing,
} from 'react-native-reanimated';
import { durations, easings } from '@/constants/motion';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

// Define confetti piece colors
const COLORS = [
  '#FF5252', // Red
  '#FFD740', // Amber
  '#64FFDA', // Teal
  '#448AFF', // Blue
  '#B388FF', // Deep Purple
  '#FF80AB', // Pink
  '#1DE9B6', // Green
  '#F48FB1', // Light Pink
];

// Number of confetti pieces
const CONFETTI_COUNT = 50;

// Confetti piece configuration
interface ConfettiPiece {
  id: number;
  x: number;
  y: number;
  size: number;
  color: string;
  rotation: number;
  delay: number;
  duration: number;
}

interface ConfettiBurstProps {
  /** Whether to show the confetti */
  isVisible: boolean;
  /** Called when animation completes */
  onComplete?: () => void;
  /** Number of confetti pieces to display (default: 50) */
  count?: number;
  /** Custom colors to use for confetti pieces */
  colors?: string[];
  /** Duration of the animation in ms (default: 2000) */
  duration?: number;
}

/**
 * A component that displays a burst of confetti animation
 */
export default function ConfettiBurst({
  isVisible,
  onComplete,
  count = CONFETTI_COUNT,
  colors = COLORS,
  duration = 2000,
}: ConfettiBurstProps) {
  // Create confetti pieces
  const pieces = React.useMemo(() => {
    const result: ConfettiPiece[] = [];
    
    for (let i = 0; i < count; i++) {
      result.push({
        id: i,
        x: Math.random() * SCREEN_WIDTH,
        y: -20, // Start above the screen
        size: Math.random() * 8 + 4, // Size between 4-12
        color: colors[Math.floor(Math.random() * colors.length)],
        rotation: Math.random() * 360,
        delay: Math.random() * 500, // Random delay up to 500ms
        duration: Math.random() * 1000 + 1500, // Duration between 1.5-2.5s
      });
    }
    
    return result;
  }, [count, colors]);
  
  // Trigger animation complete callback
  const animationComplete = () => {
    if (onComplete) {
      onComplete();
    }
  };
  
  return (
    <>
      {isVisible && (
        <View style={styles.container} pointerEvents="none">
          {pieces.map((piece) => (
            <ConfettiPiece
              key={piece.id}
              piece={piece}
              animationDuration={duration}
              onComplete={animationComplete}
            />
          ))}
        </View>
      )}
    </>
  );
}

// Individual confetti piece component
function ConfettiPiece({
  piece,
  animationDuration,
  onComplete,
}: {
  piece: ConfettiPiece;
  animationDuration: number;
  onComplete: () => void;
}) {
  const translateY = useSharedValue(piece.y);
  const translateX = useSharedValue(piece.x);
  const rotate = useSharedValue(piece.rotation);
  const opacity = useSharedValue(1);
  
  // Track if this is the last piece to complete
  const wasLastPiece = React.useRef(false);
  
  useEffect(() => {
    // Last piece will trigger onComplete
    if (piece.id === CONFETTI_COUNT - 1) {
      wasLastPiece.current = true;
    }
    
    // Start Y animation (falling down)
    translateY.value = withDelay(
      piece.delay,
      withTiming(
        SCREEN_HEIGHT + 50, // End below the screen
        {
          duration: piece.duration,
          easing: easings.accelerate,
        },
        () => {
          if (wasLastPiece.current) {
            runOnJS(onComplete)();
          }
        }
      )
    );
    
    // Swaying horizontal movement
    translateX.value = withDelay(
      piece.delay,
      withSequence(
        withTiming(piece.x - 50 + Math.random() * 100, {
          duration: piece.duration * 0.3,
          easing: easings.standard,
        }),
        withTiming(piece.x + 50 + Math.random() * 100, {
          duration: piece.duration * 0.3,
          easing: easings.standard,
        }),
        withTiming(piece.x - 25 + Math.random() * 50, {
          duration: piece.duration * 0.4,
          easing: easings.standard,
        })
      )
    );
    
    // Rotation animation
    rotate.value = withDelay(
      piece.delay,
      withTiming(piece.rotation + Math.random() * 720, {
        duration: piece.duration,
        easing: easings.standard,
      })
    );
    
    // Fade out toward the end
    opacity.value = withDelay(
      piece.delay + (piece.duration * 0.7),
      withTiming(0, {
        duration: piece.duration * 0.3,
        easing: easings.standard,
      })
    );
  }, []);
  
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: translateX.value },
        { translateY: translateY.value },
        { rotate: `${rotate.value}deg` },
      ],
      opacity: opacity.value,
    };
  });
  
  return (
    <Animated.View
      style={[
        {
          position: 'absolute',
          width: piece.size,
          height: piece.size * (Math.random() * 0.8 + 0.2), // Varying heights
          backgroundColor: piece.color,
          borderRadius: Math.random() > 0.5 ? piece.size / 2 : 0, // Some round, some square
        },
        animatedStyle,
      ]}
    />
  );
}

const styles = StyleSheet.create({
  container: {
    ...StyleSheet.absoluteFillObject,
    zIndex: 999,
    pointerEvents: 'none',
  },
}); ```
\n\n## Task Completion Handler: TaskList.test.tsx
**File:** ./__tests__/components/lists/TaskList.test.tsx
\n```
import React from 'react';
import { render, fireEvent } from '../test-utils';
import { TaskList, TaskCard } from '@/components/lists/TaskList';
import { router } from 'expo-router';

// Mock router.push
jest.mock('expo-router', () => ({
  router: {
    push: jest.fn(),
  },
}));

// Define sample mock data that matches our Supabase schema via tRPC
const mockTasks = [
  {
    id: 'task-1',
    title: 'Create UI components',
    notes: 'Focus on reusable design patterns',
    due: '2025-05-01',
    completed: false,
    goal_id: 'goal-1',
    goal: { title: 'App Refactoring' },
    user_id: 'user-123',
  },
  {
    id: 'task-2',
    title: 'Write tests',
    notes: 'Ensure good coverage of components',
    due: '2025-05-03',
    completed: true,
    goal_id: null,
    goal: null,
    user_id: 'user-123',
  },
];

describe('TaskCard Component', () => {
  it('renders task information correctly', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <TaskCard task={mockTasks[0]} onPress={onPressMock} />
    );
    
    expect(getByText('Create UI components')).toBeTruthy();
    expect(getByText('Focus on reusable design patterns')).toBeTruthy();
    expect(getByText('May 1')).toBeTruthy();
    expect(getByText('App Refactoring')).toBeTruthy();
  });
  
  it('handles completion toggle correctly', () => {
    const onPressMock = jest.fn();
    const onCompleteMock = jest.fn();
    const { getByTestId } = render(
      <TaskCard 
        task={mockTasks[0]} 
        onPress={onPressMock} 
        onComplete={onCompleteMock} 
      />
    );
    
    // Find the toggle button (checkmark)
    const toggleButton = getByTestId('icon-checkmark-circle-outline');
    fireEvent.press(toggleButton.parent);
    
    // Should call onComplete with true (completed)
    expect(onCompleteMock).toHaveBeenCalledWith(true);
  });
  
  it('displays completed task with line-through', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <TaskCard task={mockTasks[1]} onPress={onPressMock} />
    );
    
    const titleElement = getByText('Write tests');
    // Text should have line-through style
    expect(titleElement.props.style).toBeDefined();
    // Would check for textDecorationLine: 'line-through' here, but we're mocking styles
  });
  
  it('shows overdue status for past due tasks', () => {
    const pastDueTask = {
      ...mockTasks[0],
      due: '2025-04-01', // Past date
    };
    
    const { getByText } = render(
      <TaskCard task={pastDueTask} onPress={jest.fn()} />
    );
    
    // Should show "Overdue" text
    expect(getByText(/Overdue:/)).toBeTruthy();
  });
});

describe('TaskList Component', () => {
  it('renders loading state correctly', () => {
    const { getByTestId } = render(
      <TaskList isLoading={true} refetch={jest.fn()} />
    );
    
    expect(getByTestId('skeleton-loader')).toBeTruthy();
  });
  
  it('renders error state correctly', () => {
    const refetchMock = jest.fn();
    const { getByText } = render(
      <TaskList isLoading={false} isError={true} refetch={refetchMock} />
    );
    
    expect(getByText('Unable to load tasks')).toBeTruthy();
    
    // Test retry functionality
    fireEvent.press(getByText('Retry'));
    expect(refetchMock).toHaveBeenCalledTimes(1);
  });
  
  it('renders empty state correctly', () => {
    const { getByText } = render(
      <TaskList isLoading={false} tasks={[]} refetch={jest.fn()} />
    );
    
    expect(getByText('No tasks yet')).toBeTruthy();
    
    // Test create action
    fireEvent.press(getByText('Create a task'));
    expect(router.push).toHaveBeenCalledWith('/planner/add-task');
  });
  
  it('renders tasks correctly', () => {
    const { getAllByText } = render(
      <TaskList isLoading={false} tasks={mockTasks} refetch={jest.fn()} />
    );
    
    // Should render both tasks
    expect(getAllByText(/Create UI components|Write tests/).length).toBe(2);
  });
  
  it('calls onCompleteTask when provided', () => {
    const onCompleteTaskMock = jest.fn();
    const { getByText, getAllByTestId } = render(
      <TaskList 
        isLoading={false} 
        tasks={mockTasks} 
        refetch={jest.fn()} 
        onCompleteTask={onCompleteTaskMock} 
      />
    );
    
    // Find the first task's toggle button
    const toggleButtons = getAllByTestId('icon-checkmark-circle-outline');
    fireEvent.press(toggleButtons[0].parent);
    
    // Should call onCompleteTask with the task ID and completion status
    expect(onCompleteTaskMock).toHaveBeenCalledWith('task-1', true);
  });
});
```
