# Aether Code Atlas  
_generated 2025-04-30-10-56-46_

## Contents
- [Definitions Table](#definitions-table)
- [Route Definitions](#route-definitions)
- [Database Schema Summary](#database-schema-summary)
- [Dependency Graph](#dependency-graph)
- [External Dependencies](#external-dependencies)
- [TODOs / FIXMEs](#todos-/-fixmes)
- [Excluded Files](#excluded-files)
- [Type Check Results (tsc)](#type-check-results-(tsc))
- [Linting Results (eslint)](#linting-results-(eslint))
- [Buckets](#buckets)

## Definitions Table
| File | Export Name | Type |
|---|---|---|
| __tests__/server/test-helpers.ts | `createInnerTRPCContext` | function |
| __tests__/server/test-helpers.ts | `createTestContext` | function |
| __tests__/server/test-helpers.ts | `MockablePostgrestResponse` | type |
| __tests__/server/test-helpers.ts | `MockableQueryBuilder` | interface |
| __tests__/server/test-helpers.ts | `MockableSupabaseClient` | interface |
| __tests__/server/test-helpers.ts | `MockableTableOperations` | interface |
| __tests__/server/test-helpers.ts | `mockDeep` | re-export |
| __tests__/server/test-helpers.ts | `mockSupabaseAdmin` | unknown |
| __tests__/server/test-helpers.ts | `resetSupabaseMocks` | function |
| __tests__/server/test-helpers.ts | `TableName` | type |
| __tests__/test-utils.tsx | `render` | re-export |
| app/(auth)/_layout.tsx | `default` | function |
| app/(auth)/forgot-password.tsx | `default` | function |
| app/(auth)/login.tsx | `default` | function |
| app/(auth)/register.tsx | `default` | function |
| app/(tabs)/_layout.tsx | `default` | function |
| app/(tabs)/compass/index.tsx | `default` | function |
| app/(tabs)/home/index.tsx | `default` | function |
| app/(tabs)/planner/_layout.tsx | `default` | function |
| app/(tabs)/planner/add-goal.tsx | `default` | function |
| app/(tabs)/planner/add-habit.tsx | `default` | function |
| app/(tabs)/planner/add-task.tsx | `default` | function |
| app/(tabs)/planner/goal/[id].tsx | `default` | function |
| app/(tabs)/planner/habit/[id].tsx | `default` | function |
| app/(tabs)/planner/index.tsx | `default` | function |
| app/(tabs)/rewards/index.tsx | `default` | function |
| app/(tabs)/settings/_layout.tsx | `default` | function |
| app/(tabs)/settings/about.tsx | `default` | function |
| app/(tabs)/settings/help.tsx | `default` | function |
| app/(tabs)/settings/index.tsx | `default` | function |
| app/(tabs)/settings/notifications.tsx | `default` | function |
| app/(tabs)/settings/privacy.tsx | `default` | function |
| app/(tabs)/settings/profile.tsx | `default` | function |
| app/(tabs)/settings/security.tsx | `default` | function |
| app/_layout.tsx | `default` | function |
| app/components/SectionCard.tsx | `SectionCard` | component |
| app/components/SwipeableRow.tsx | `SwipeableRow` | component |
| app/components/TaskRow.tsx | `TaskRow` | component |
| app/compose.tsx | `default` | function |
| app/index.tsx | `default` | function |
| app/lib/useDashboardQuery.ts | `DashboardData` | type |
| app/lib/useDashboardQuery.ts | `useDashboardQuery` | hook |
| app/lib/useToggleTaskStatus.ts | `useToggleTaskStatus` | hook |
| app/planner/add-habit.tsx | `default` | function |
| app/planner/index.tsx | `default` | unknown |
| app/settings/index.tsx | `default` | unknown |
| app/states/[id].tsx | `default` | function |
| app/utils/api-types.ts | `RouterInputs` | type |
| app/utils/api-types.ts | `RouterOutputs` | type |
| app/values/[id].tsx | `default` | function |
| components/EmptyOrSkeleton.tsx | `default` | function |
| components/EmptyOrSkeleton.tsx | `EmptyOrSkeletonProps` | interface |
| components/EmptyOrSkeleton.tsx | `EmptyStateProps` | interface |
| components/aether/ProgressRing.tsx | `default` | function |
| components/auth/FloatingInput.tsx | `default` | function |
| components/auth/FloatingInput.tsx | `FloatingInputProps` | interface |
| components/compass/PrincipleCard.tsx | `PrincipleCard` | function |
| components/compass/PrinciplesTab.tsx | `default` | function |
| components/compass/StateDefinitionCard.tsx | `StateDefinitionCard` | function |
| components/dashboard/DailyProgressBanner.tsx | `default` | function |
| components/dashboard/DashboardSection.tsx | `default` | function |
| components/dashboard/GoalSummaryCard.tsx | `default` | function |
| components/dashboard/HabitCheckItem.tsx | `default` | function |
| components/dashboard/StateIndicator.tsx | `default` | function |
| components/dashboard/TaskItem.tsx | `default` | function |
| components/lists/GoalList.tsx | `GoalCard` | function |
| components/lists/GoalList.tsx | `GoalList` | function |
| components/lists/HabitList.tsx | `HabitCard` | function |
| components/lists/HabitList.tsx | `HabitList` | function |
| components/lists/TaskList.tsx | `TaskCard` | function |
| components/lists/TaskList.tsx | `TaskList` | function |
| components/lists/index.ts | `GoalCard` | re-export |
| components/lists/index.ts | `GoalList` | re-export |
| components/lists/index.ts | `HabitCard` | re-export |
| components/lists/index.ts | `HabitList` | re-export |
| components/lists/index.ts | `TaskCard` | re-export |
| components/lists/index.ts | `TaskList` | re-export |
| components/planner/GoalsList.tsx | `default` | function |
| components/planner/GoalsList.tsx | `Goal` | interface |
| components/planner/GoalsList.tsx | `GoalsListProps` | interface |
| components/planner/HabitTracker.tsx | `HabitTracker` | function |
| components/planner/HabitsList.tsx | `default` | function |
| components/planner/HabitsList.tsx | `Habit` | interface |
| components/planner/HabitsList.tsx | `HabitsListProps` | interface |
| components/planner/StreakCalendar.tsx | `default` | function |
| components/planner/StreakCalendar.tsx | `StreakCalendarProps` | interface |
| components/rewards/ConfettiBurst.tsx | `default` | function |
| components/settings/NotificationRow.tsx | `default` | function |
| components/settings/NotificationRow.tsx | `NotificationRowProps` | interface |
| components/settings/ThemePreview.tsx | `default` | function |
| components/settings/ThemePreview.tsx | `ThemePreviewProps` | interface |
| components/ui/Container.tsx | `Container` | component |
| components/ui/Container.tsx | `default` | unknown |
| components/ui/EmptyOrSkeleton.tsx | `EmptyOrSkeleton` | component |
| components/ui/EmptyOrSkeleton.tsx | `EmptyOrSkeletonProps` | interface |
| components/ui/ErrorBanner.tsx | `ErrorBanner` | function |
| components/ui/ErrorBanner.tsx | `SectionError` | function |
| components/ui/InteractiveCard.tsx | `default` | unknown |
| components/ui/Section.tsx | `default` | unknown |
| components/ui/Skeleton.tsx | `Skeleton` | function |
| components/ui/Skeleton.tsx | `SkeletonAvatar` | function |
| components/ui/Skeleton.tsx | `SkeletonCard` | function |
| components/ui/Skeleton.tsx | `SkeletonCircle` | function |
| components/ui/Skeleton.tsx | `SkeletonProfile` | function |
| components/ui/Skeleton.tsx | `SkeletonRow` | function |
| components/ui/SwipeableRow.tsx | `default` | function |
| components/ui/primitives/AetherCard.tsx | `AetherCard` | function |
| components/ui/primitives/AetherListItem.tsx | `AetherListItem` | function |
| components/ui/primitives/AetherListItem.tsx | `AetherListItemProps` | interface |
| components/ui/primitives/SectionHeader.tsx | `SectionHeader` | function |
| components/ui/primitives/SectionHeader.tsx | `SectionHeaderProps` | interface |
| components/ui/primitives/index.ts | `AetherCard` | re-export |
| components/ui/primitives/index.ts | `AetherListItem` | re-export |
| components/ui/primitives/index.ts | `AetherListItemProps` | re-export |
| components/ui/primitives/index.ts | `SectionHeader` | re-export |
| components/ui/primitives/index.ts | `SectionHeaderProps` | re-export |
| constants/Colors.ts | `Colors` | component |
| constants/motion.ts | `componentAnimations` | unknown |
| constants/motion.ts | `durations` | unknown |
| constants/motion.ts | `easings` | unknown |
| constants/motion.ts | `presets` | unknown |
| debug/toast-test.tsx | `default` | function |
| design-system/Animations.ts | `fadeInUp` | unknown |
| design-system/Animations.ts | `korokReveal` | unknown |
| design-system/Animations.ts | `sheikahGlow` | unknown |
| design-system/Animations.ts | `slideOutLeft` | unknown |
| design-system/Animations.ts | `taskComplete` | unknown |
| design-system/Primitives.tsx | `Button` | component |
| design-system/Primitives.tsx | `Center` | component |
| design-system/Primitives.tsx | `gs` | re-export |
| design-system/Primitives.tsx | `HStack` | component |
| design-system/Primitives.tsx | `Pressable` | component |
| design-system/Primitives.tsx | `ScrollView` | component |
| design-system/Primitives.tsx | `Stack` | component |
| design-system/Primitives.tsx | `Text` | component |
| design-system/Primitives.tsx | `useColorMode` | hook |
| design-system/Primitives.tsx | `useColorModeValue` | function |
| design-system/Primitives.tsx | `useToast` | hook |
| design-system/Primitives.tsx | `VStack` | component |
| design-system/theme.glue.ts | `glueTheme` | unknown |
| design-system/tokens.ts | `colors` | unknown |
| design-system/tokens.ts | `default` | unknown |
| design-system/tokens.ts | `fonts` | unknown |
| design-system/tokens.ts | `radii` | unknown |
| design-system/tokens.ts | `sizes` | unknown |
| design-system/tokens.ts | `space` | unknown |
| hooks/useColorScheme.ts | `useColorScheme` | re-export |
| hooks/useColorScheme.web.ts | `useColorScheme` | function |
| hooks/useOfflineSync.ts | `useOfflineSync` | function |
| hooks/useSkeleton.ts | `SkeletonOptions` | interface |
| hooks/useSkeleton.ts | `useSkeleton` | function |
| hooks/useThemeColor.ts | `useThemeColor` | function |
| modals/compose.tsx | `default` | function |
| providers/AppProvider.tsx | `AppProvider` | function |
| providers/ConfettiProvider.tsx | `ConfettiProvider` | function |
| providers/ConfettiProvider.tsx | `useConfetti` | hook |
| providers/SupabaseProvider.tsx | `SupabaseContext` | component |
| providers/SupabaseProvider.tsx | `SupabaseProvider` | function |
| providers/SupabaseProvider.tsx | `useSupabase` | hook |
| providers/TRPCProvider.tsx | `trpc` | unknown |
| providers/TRPCProvider.tsx | `TRPCProvider` | function |
| server/src/context.ts | `Context` | interface |
| server/src/context.ts | `createContext` | function |
| server/src/context.ts | `supabaseAdmin` | unknown |
| server/src/router.ts | `appRouter` | unknown |
| server/src/router.ts | `AppRouter` | type |
| server/src/router.ts | `protectedProcedure` | unknown |
| server/src/router.ts | `publicProcedure` | unknown |
| server/src/router.ts | `router` | unknown |
| server/src/routers/dashboardRouter.ts | `dashboardRouter` | unknown |
| server/src/routers/goalProgressNoteRouter.ts | `goalProgressNoteRouter` | unknown |
| server/src/routers/goalRouter.ts | `goalRouter` | unknown |
| server/src/routers/habitRouter.ts | `habitRouter` | unknown |
| server/src/routers/principleRouter.ts | `principleRouter` | unknown |
| server/src/routers/reminderRouter.ts | `reminderRouter` | unknown |
| server/src/routers/rewardsRouter.ts | `rewardsRouter` | unknown |
| server/src/routers/taskRouter.ts | `taskRouter` | unknown |
| server/src/routers/trackedStateRouter.ts | `trackedStateRouter` | unknown |
| server/src/routers/userRouter.ts | `userRouter` | unknown |
| server/src/routers/valueRouter.ts | `valueRouter` | unknown |
| server/src/types/index.ts | `Badge` | interface |
| server/src/types/index.ts | `BadgeId` | type |
| server/src/types/index.ts | `Goal` | interface |
| server/src/types/index.ts | `GoalId` | type |
| server/src/types/index.ts | `Habit` | interface |
| server/src/types/index.ts | `HabitId` | type |
| server/src/types/index.ts | `KeyResult` | interface |
| server/src/types/index.ts | `Principle` | interface |
| server/src/types/index.ts | `Task` | interface |
| server/src/types/index.ts | `TaskId` | type |
| server/src/types/index.ts | `TrackedStateDef` | interface |
| server/src/types/index.ts | `Value` | interface |
| server/src/types/index.ts | `ValueId` | type |
| server/src/types/trpc-types.ts | `awardBadgeInput` | unknown |
| server/src/types/trpc-types.ts | `BadgeDefinition` | component |
| server/src/types/trpc-types.ts | `BadgeDefinition` | type |
| server/src/types/trpc-types.ts | `claimLootInput` | unknown |
| server/src/types/trpc-types.ts | `createGoalInput` | unknown |
| server/src/types/trpc-types.ts | `createGoalProgressNoteInput` | unknown |
| server/src/types/trpc-types.ts | `createHabitEntryInput` | unknown |
| server/src/types/trpc-types.ts | `createHabitInput` | unknown |
| server/src/types/trpc-types.ts | `createPrincipleInput` | unknown |
| server/src/types/trpc-types.ts | `createReminderInput` | unknown |
| server/src/types/trpc-types.ts | `CreateStateEntryInput` | component |
| server/src/types/trpc-types.ts | `createTaskInput` | unknown |
| server/src/types/trpc-types.ts | `createTrackedStateDefInput` | unknown |
| server/src/types/trpc-types.ts | `createValueInput` | unknown |
| server/src/types/trpc-types.ts | `DeleteGoalProgressNoteInput` | component |
| server/src/types/trpc-types.ts | `DeleteReminderInput` | component |
| server/src/types/trpc-types.ts | `DeleteStateEntryInput` | component |
| server/src/types/trpc-types.ts | `DeleteTrackedStateDefInput` | component |
| server/src/types/trpc-types.ts | `GetGoalProgressNotesInput` | component |
| server/src/types/trpc-types.ts | `GetRemindersForEntityInput` | component |
| server/src/types/trpc-types.ts | `GetStateEntriesInput` | component |
| server/src/types/trpc-types.ts | `GetTrackedStateDefByIdInput` | component |
| server/src/types/trpc-types.ts | `Goal` | component |
| server/src/types/trpc-types.ts | `Goal` | type |
| server/src/types/trpc-types.ts | `GoalProgressNote` | component |
| server/src/types/trpc-types.ts | `GoalProgressNote` | type |
| server/src/types/trpc-types.ts | `greetingInput` | unknown |
| server/src/types/trpc-types.ts | `greetingOutput` | unknown |
| server/src/types/trpc-types.ts | `Habit` | component |
| server/src/types/trpc-types.ts | `Habit` | type |
| server/src/types/trpc-types.ts | `HabitEntry` | component |
| server/src/types/trpc-types.ts | `HabitEntry` | type |
| server/src/types/trpc-types.ts | `HabitFrequencyPeriodEnum` | component |
| server/src/types/trpc-types.ts | `HabitTypeEnum` | component |
| server/src/types/trpc-types.ts | `NotificationPrefs` | component |
| server/src/types/trpc-types.ts | `PointTransaction` | component |
| server/src/types/trpc-types.ts | `PointTransaction` | type |
| server/src/types/trpc-types.ts | `Principle` | component |
| server/src/types/trpc-types.ts | `Principle` | type |
| server/src/types/trpc-types.ts | `Reminder` | component |
| server/src/types/trpc-types.ts | `Reminder` | type |
| server/src/types/trpc-types.ts | `Reward` | component |
| server/src/types/trpc-types.ts | `Reward` | type |
| server/src/types/trpc-types.ts | `RewardTypeEnum` | component |
| server/src/types/trpc-types.ts | `RouterInputs` | type |
| server/src/types/trpc-types.ts | `RouterOutputs` | type |
| server/src/types/trpc-types.ts | `StateEntry` | component |
| server/src/types/trpc-types.ts | `StateEntry` | type |
| server/src/types/trpc-types.ts | `Task` | component |
| server/src/types/trpc-types.ts | `Task` | type |
| server/src/types/trpc-types.ts | `TaskPriorityEnum` | component |
| server/src/types/trpc-types.ts | `TaskStatusEnum` | component |
| server/src/types/trpc-types.ts | `TrackedStateDef` | component |
| server/src/types/trpc-types.ts | `TrackedStateDef` | type |
| server/src/types/trpc-types.ts | `UiPrefs` | component |
| server/src/types/trpc-types.ts | `updateGoalInput` | unknown |
| server/src/types/trpc-types.ts | `updateGoalProgressNoteInput` | unknown |
| server/src/types/trpc-types.ts | `updateHabitEntryInput` | unknown |
| server/src/types/trpc-types.ts | `updateHabitInput` | unknown |
| server/src/types/trpc-types.ts | `updatePrincipleInput` | unknown |
| server/src/types/trpc-types.ts | `updateProfileInput` | unknown |
| server/src/types/trpc-types.ts | `updateReminderInput` | unknown |
| server/src/types/trpc-types.ts | `updateSettingsInput` | unknown |
| server/src/types/trpc-types.ts | `updateStateEntryInput` | unknown |
| server/src/types/trpc-types.ts | `updateTaskInput` | unknown |
| server/src/types/trpc-types.ts | `updateTaskStatusInput` | unknown |
| server/src/types/trpc-types.ts | `updateTrackedStateDefInput` | unknown |
| server/src/types/trpc-types.ts | `updateValueInput` | unknown |
| server/src/types/trpc-types.ts | `UserBadge` | component |
| server/src/types/trpc-types.ts | `UserBadge` | type |
| server/src/types/trpc-types.ts | `UserProfile` | component |
| server/src/types/trpc-types.ts | `UserProfile` | type |
| server/src/types/trpc-types.ts | `UserReward` | component |
| server/src/types/trpc-types.ts | `UserReward` | type |
| server/src/types/trpc-types.ts | `UserSettings` | component |
| server/src/types/trpc-types.ts | `UserSettings` | type |
| server/src/types/trpc-types.ts | `Value` | component |
| server/src/types/trpc-types.ts | `Value` | type |
| stores/uiStore.ts | `useUiStore` | hook |
| tamagui.config.ts | `default` | unknown |
| utils/api-types.ts | `RouterInputs` | type |
| utils/api-types.ts | `RouterOutputs` | type |
| utils/auth.ts | `getUserProfile` | function |
| utils/auth.ts | `logout` | function |
| utils/colors.ts | `palette` | unknown |
| utils/colors.ts | `semanticTokens` | unknown |
| utils/colors.ts | `useColors` | function |
| utils/colors.ts | `withOpacity` | function |
| utils/generated-hooks.ts | `useDashboard` | hook |
| utils/generated-hooks.ts | `useGoal` | hook |
| utils/generated-hooks.ts | `useGoalProgressNote` | hook |
| utils/generated-hooks.ts | `useHabit` | hook |
| utils/generated-hooks.ts | `usePrinciple` | hook |
| utils/generated-hooks.ts | `useReminder` | hook |
| utils/generated-hooks.ts | `useRewards` | hook |
| utils/generated-hooks.ts | `useState` | hook |
| utils/generated-hooks.ts | `useTask` | hook |
| utils/generated-hooks.ts | `useUser` | hook |
| utils/generated-hooks.ts | `useValue` | hook |
| utils/haptics.ts | `haptics` | unknown |
| utils/mock-api.ts | `appRouter` | unknown |
| utils/mock-api.ts | `AppRouter` | type |
| utils/nats-client.ts | `addSubjectHandler` | function |
| utils/nats-client.ts | `closeNatsConnection` | function |
| utils/nats-client.ts | `getNatsConnection` | function |
| utils/nats-client.ts | `initNatsClient` | function |
| utils/nats-client.ts | `subscribeWithCache` | function |
| utils/offline-mutations.ts | `asyncStoragePersister` | unknown |
| utils/offline-mutations.ts | `configureQueryClientForOffline` | function |
| utils/offline-mutations.ts | `getPendingMutations` | function |
| utils/offline-mutations.ts | `markItemAsOffline` | function |
| utils/offline-mutations.ts | `markItemAsSynced` | function |
| utils/offline-mutations.ts | `reactQueryPersistOptions` | unknown |
| utils/offline-mutations.ts | `useResumeNetworkMutations` | function |
| utils/offline-sync.ts | `getPendingItems` | function |
| utils/offline-sync.ts | `PendingItem` | interface |
| utils/offline-sync.ts | `saveOfflineMutation` | function |
| utils/offline-sync.ts | `setupBackgroundSync` | function |
| utils/offline-sync.ts | `syncOfflineMutations` | function |
| utils/query-client.ts | `queryClient` | unknown |
| utils/settings.ts | `APP_SETTINGS_KEY` | component |
| utils/settings.ts | `AppSettings` | type |
| utils/settings.ts | `getAppVersion` | function |
| utils/settings.ts | `getPlatformInfo` | function |
| utils/settings.ts | `getSettings` | function |
| utils/settings.ts | `saveSettings` | function |
| utils/settings.ts | `updateSetting` | function |
| utils/supabase.ts | `getCurrentUser` | unknown |
| utils/supabase.ts | `isAuthenticated` | unknown |
| utils/supabase.ts | `supabase` | unknown |
| utils/trpc.ts | `RouterInputs` | type |
| utils/trpc.ts | `RouterOutputs` | type |
| utils/trpc.ts | `trpc` | unknown |

## Route Definitions
| Route File | Type |
|---|---|
| app/(auth)/forgot-password.tsx | screen |
| app/(auth)/login.tsx | screen |
| app/(auth)/register.tsx | screen |
| app/(tabs)/compass/index.tsx | screen |
| app/(tabs)/home/index.tsx | screen |
| app/(tabs)/planner/add-goal.tsx | screen |
| app/(tabs)/planner/add-habit.tsx | screen |
| app/(tabs)/planner/add-task.tsx | screen |
| app/(tabs)/planner/goal/[id].tsx | screen |
| app/(tabs)/planner/habit/[id].tsx | screen |
| app/(tabs)/planner/index.tsx | screen |
| app/(tabs)/rewards/index.tsx | screen |
| app/(tabs)/settings/about.tsx | screen |
| app/(tabs)/settings/help.tsx | screen |
| app/(tabs)/settings/index.tsx | screen |
| app/(tabs)/settings/notifications.tsx | screen |
| app/(tabs)/settings/privacy.tsx | screen |
| app/(tabs)/settings/profile.tsx | screen |
| app/(tabs)/settings/security.tsx | screen |
| app/components/SectionCard.tsx | screen |
| app/components/SwipeableRow.tsx | screen |
| app/components/TaskRow.tsx | screen |
| app/compose.tsx | layout (implicit) |
| app/index.tsx | screen |
| app/planner/add-habit.tsx | screen |
| app/planner/index.tsx | screen |
| app/settings/index.tsx | screen |
| app/states/[id].tsx | screen |
| app/values/[id].tsx | screen |

## Database Schema Summary

_Extracted from: types/database.types.ts_

### Tables

**`badge_definitions`**

| Column | Type |
|---|---|
| `description` | `string \| null` |
| `icon` | `string` |
| `id` | `string` |
| `title` | `string` |

**`goal_progress_notes`**

| Column | Type |
|---|---|
| `created_at` | `string` |
| `goal_id` | `string` |
| `id` | `string` |
| `note` | `string` |
| `user_id` | `string` |

**`goal_values`**

| Column | Type |
|---|---|
| `goal_id` | `string` |
| `user_id` | `string` |
| `value_id` | `string` |

**`goals`**

| Column | Type |
|---|---|
| `archived_at` | `string \| null` |
| `created_at` | `string \| null` |
| `description` | `string \| null` |
| `id` | `string` |
| `progress` | `number \| null` |
| `sort_order` | `number \| null` |
| `target_date` | `string \| null` |
| `title` | `string` |
| `updated_at` | `string \| null` |
| `user_id` | `string` |

**`habit_entries`**

| Column | Type |
|---|---|
| `completed` | `boolean` |
| `created_at` | `string` |
| `date` | `string` |
| `habit_id` | `string` |
| `id` | `string` |
| `notes` | `string \| null` |
| `quantity_value` | `number \| null` |
| `user_id` | `string` |

**`habit_values`**

| Column | Type |
|---|---|
| `habit_id` | `string` |
| `user_id` | `string` |
| `value_id` | `string` |

**`habits`**

| Column | Type |
|---|---|
| `archived_at` | `string \| null` |
| `best_streak` | `number` |
| `created_at` | `string` |
| `cue` | `string \| null` |
| `frequency_period` | `Database["public"]["Enums"]["habit_frequency_period"]` |
| `goal_frequency` | `number` |
| `goal_quantity` | `number \| null` |
| `goal_unit` | `string \| null` |
| `habit_type` | `Database["public"]["Enums"]["habit_type"]` |
| `id` | `string` |
| `recurrence_end_date` | `string \| null` |
| `recurrence_rule` | `string \| null` |
| `reward` | `string \| null` |
| `routine` | `string \| null` |
| `streak` | `number` |
| `title` | `string` |
| `updated_at` | `string` |
| `user_id` | `string` |

**`key_results`**

| Column | Type |
|---|---|
| `created_at` | `string` |
| `goal_id` | `string` |
| `id` | `string` |
| `progress` | `number \| null` |
| `title` | `string` |
| `updated_at` | `string` |
| `user_id` | `string` |

**`point_transactions`**

| Column | Type |
|---|---|
| `created_at` | `string` |
| `id` | `string` |
| `points` | `number` |
| `reason` | `string` |
| `source_id` | `string \| null` |
| `source_type` | `string` |
| `user_id` | `string` |

**`principle_values`**

| Column | Type |
|---|---|
| `principle_id` | `string` |
| `user_id` | `string` |
| `value_id` | `string` |

**`principles`**

| Column | Type |
|---|---|
| `body` | `string` |
| `created_at` | `string` |
| `id` | `string` |
| `sort_order` | `number \| null` |
| `title` | `string` |
| `updated_at` | `string` |
| `user_id` | `string` |

**`profiles`**

| Column | Type |
|---|---|
| `created_at` | `string \| null` |
| `email` | `string` |
| `id` | `string` |
| `lifetime_points` | `number` |
| `points` | `number` |
| `username` | `string \| null` |

**`reminders`**

| Column | Type |
|---|---|
| `created_at` | `string` |
| `id` | `string` |
| `is_active` | `boolean` |
| `related_entity_id` | `string` |
| `related_entity_type` | `string` |
| `reminder_time` | `string` |
| `updated_at` | `string` |
| `user_id` | `string` |

**`rewards`**

| Column | Type |
|---|---|
| `can_earn_multiple` | `boolean` |
| `created_at` | `string` |
| `description` | `string \| null` |
| `id` | `string` |
| `image_url` | `string \| null` |
| `metadata` | `Json \| null` |
| `name` | `string` |
| `required_points` | `number` |
| `type` | `Database["public"]["Enums"]["reward_type"]` |
| `updated_at` | `string` |

**`state_entries`**

| Column | Type |
|---|---|
| `definition_id` | `string` |
| `entry_timestamp` | `string` |
| `id` | `string` |
| `notes` | `string \| null` |
| `user_id` | `string` |
| `value_numeric` | `number \| null` |
| `value_text` | `string \| null` |

**`task_values`**

| Column | Type |
|---|---|
| `task_id` | `string` |
| `user_id` | `string` |
| `value_id` | `string` |

**`tasks`**

| Column | Type |
|---|---|
| `archived_at` | `string \| null` |
| `created_at` | `string \| null` |
| `due` | `string \| null` |
| `goal_id` | `string \| null` |
| `id` | `string` |
| `notes` | `string \| null` |
| `parent_task_id` | `string \| null` |
| `priority` | `Database["public"]["Enums"]["task_priority"] \| null` |
| `recurrence_end_date` | `string \| null` |
| `recurrence_rule` | `string \| null` |
| `sort_order` | `number \| null` |
| `status` | `Database["public"]["Enums"]["task_status"]` |
| `title` | `string` |
| `updated_at` | `string \| null` |
| `user_id` | `string` |

**`tracked_state_defs`**

| Column | Type |
|---|---|
| `active` | `boolean` |
| `created_at` | `string` |
| `custom_labels` | `string[] \| null` |
| `id` | `string` |
| `name` | `string` |
| `priority` | `number` |
| `scale` | `Database["public"]["Enums"]["tracked_state_scale"]` |
| `target_max_value` | `number \| null` |
| `target_min_value` | `number \| null` |
| `updated_at` | `string` |
| `user_id` | `string` |

**`tracked_state_values`**

| Column | Type |
|---|---|
| `state_id` | `string` |
| `user_id` | `string` |
| `value_id` | `string` |

**`user_badges`**

| Column | Type |
|---|---|
| `badge_id` | `string` |
| `earned_at` | `string` |
| `progress` | `number \| null` |
| `user_id` | `string` |

**`user_rewards`**

| Column | Type |
|---|---|
| `created_at` | `string` |
| `earned_at` | `string` |
| `id` | `string` |
| `metadata` | `Json \| null` |
| `points_spent` | `number` |
| `reward_id` | `string` |
| `reward_type` | `string \| null` |
| `updated_at` | `string` |
| `user_id` | `string` |

**`user_settings`**

| Column | Type |
|---|---|
| `created_at` | `string` |
| `id` | `string` |
| `notification_preferences` | `Json` |
| `ui_preferences` | `Json` |
| `updated_at` | `string` |
| `user_id` | `string` |

**`values`**

| Column | Type |
|---|---|
| `color` | `string \| null` |
| `created_at` | `string` |
| `description` | `string \| null` |
| `domain_id` | `string \| null` |
| `id` | `string` |
| `sort_order` | `number \| null` |
| `title` | `string` |
| `updated_at` | `string` |
| `user_id` | `string` |

### Enums

**`habit_frequency_period`**: *(No values extracted)*

**`habit_type`**: *(No values extracted)*

**`reward_type`**: *(No values extracted)*

**`task_priority`**: *(No values extracted)*

**`task_status`**: *(No values extracted)*

**`tracked_state_scale`**: *(No values extracted)*

## Dependency Graph
*Note: This graph shows dependencies between local files only.*
```mermaid
graph TD;
  __tests___components_ui_primitives_AetherCard_test_tsx["__tests__/components/ui/primitives/AetherCard.test.tsx"] --> __tests___test_utils_tsx["__tests__/test-utils.tsx"];
  __tests___server_routers_dashboardRouter_getWeeklyProgress_test_ts["__tests__/server/routers/dashboardRouter.getWeeklyProgress.test.ts"] --> __tests___server_test_helpers_ts["__tests__/server/test-helpers.ts"];
  __tests___server_routers_dashboardRouter_getWeeklyProgress_test_ts["__tests__/server/routers/dashboardRouter.getWeeklyProgress.test.ts"] --> server_src_router_ts["server/src/router.ts"];
  __tests___server_routers_dashboardRouter_test_ts["__tests__/server/routers/dashboardRouter.test.ts"] --> __tests___server_test_helpers_ts["__tests__/server/test-helpers.ts"];
  __tests___server_routers_dashboardRouter_test_ts["__tests__/server/routers/dashboardRouter.test.ts"] --> server_src_router_ts["server/src/router.ts"];
  __tests___server_routers_habitRouter_test_ts["__tests__/server/routers/habitRouter.test.ts"] --> __tests___server_test_helpers_ts["__tests__/server/test-helpers.ts"];
  __tests___server_routers_habitRouter_test_ts["__tests__/server/routers/habitRouter.test.ts"] --> server_src_router_ts["server/src/router.ts"];
  __tests___server_routers_habitRouter_test_ts["__tests__/server/routers/habitRouter.test.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  __tests___server_routers_taskRouter_toggleTask_test_ts["__tests__/server/routers/taskRouter.toggleTask.test.ts"] --> __tests___server_test_helpers_ts["__tests__/server/test-helpers.ts"];
  __tests___server_routers_taskRouter_toggleTask_test_ts["__tests__/server/routers/taskRouter.toggleTask.test.ts"] --> server_src_router_ts["server/src/router.ts"];
  __tests___test_utils_tsx["__tests__/test-utils.tsx"] --> tamagui_config_ts["tamagui.config.ts"];
  app_utils_api_types_ts["app/utils/api-types.ts"] --> server_src_router_ts["server/src/router.ts"];
  components_compass_PrinciplesTab_tsx["components/compass/PrinciplesTab.tsx"] --> components_compass_PrincipleCard_tsx["components/compass/PrincipleCard.tsx"];
  components_planner_HabitTracker_tsx["components/planner/HabitTracker.tsx"] --> components_planner_StreakCalendar_tsx["components/planner/StreakCalendar.tsx"];
  components_ui_EmptyOrSkeleton_tsx["components/ui/EmptyOrSkeleton.tsx"] --> components_ui_Skeleton_tsx["components/ui/Skeleton.tsx"];
  components_ui_EmptyOrSkeleton_tsx["components/ui/EmptyOrSkeleton.tsx"] --> components_ui_ErrorBanner_tsx["components/ui/ErrorBanner.tsx"];
  design_system_theme_glue_ts["design-system/theme.glue.ts"] --> design_system_tokens_ts["design-system/tokens.ts"];
  index_js["index.js"] --> tamagui_config_ts["tamagui.config.ts"];
  providers_AppProvider_tsx["providers/AppProvider.tsx"] --> tamagui_config_ts["tamagui.config.ts"];
  server_src_index_ts["server/src/index.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_index_ts["server/src/index.ts"] --> server_src_context_ts["server/src/context.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_context_ts["server/src/context.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_dashboardRouter_ts["server/src/routers/dashboardRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_valueRouter_ts["server/src/routers/valueRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_principleRouter_ts["server/src/routers/principleRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_goalRouter_ts["server/src/routers/goalRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_taskRouter_ts["server/src/routers/taskRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_habitRouter_ts["server/src/routers/habitRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_trackedStateRouter_ts["server/src/routers/trackedStateRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_userRouter_ts["server/src/routers/userRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_rewardsRouter_ts["server/src/routers/rewardsRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_reminderRouter_ts["server/src/routers/reminderRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_goalProgressNoteRouter_ts["server/src/routers/goalProgressNoteRouter.ts"];
  server_src_routers_dashboardRouter_ts["server/src/routers/dashboardRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_goalProgressNoteRouter_ts["server/src/routers/goalProgressNoteRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_goalProgressNoteRouter_ts["server/src/routers/goalProgressNoteRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_routers_goalRouter_ts["server/src/routers/goalRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_goalRouter_ts["server/src/routers/goalRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_routers_habitRouter_ts["server/src/routers/habitRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_habitRouter_ts["server/src/routers/habitRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_routers_principleRouter_ts["server/src/routers/principleRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_principleRouter_ts["server/src/routers/principleRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_routers_reminderRouter_ts["server/src/routers/reminderRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_reminderRouter_ts["server/src/routers/reminderRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_routers_rewardsRouter_ts["server/src/routers/rewardsRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_rewardsRouter_ts["server/src/routers/rewardsRouter.ts"] --> server_src_context_ts["server/src/context.ts"];
  server_src_routers_rewardsRouter_ts["server/src/routers/rewardsRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_routers_taskRouter_ts["server/src/routers/taskRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_taskRouter_ts["server/src/routers/taskRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_routers_trackedStateRouter_ts["server/src/routers/trackedStateRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_trackedStateRouter_ts["server/src/routers/trackedStateRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_routers_userRouter_ts["server/src/routers/userRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_valueRouter_ts["server/src/routers/valueRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_valueRouter_ts["server/src/routers/valueRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"] --> server_src_router_ts["server/src/router.ts"];
  utils_api_types_ts["utils/api-types.ts"] --> server_src_router_ts["server/src/router.ts"];
  utils_auth_ts["utils/auth.ts"] --> utils_supabase_ts["utils/supabase.ts"];
  utils_generated_hooks_ts["utils/generated-hooks.ts"] --> utils_trpc_ts["utils/trpc.ts"];
  utils_generated_hooks_ts["utils/generated-hooks.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  utils_offline_sync_ts["utils/offline-sync.ts"] --> utils_query_client_ts["utils/query-client.ts"];
  utils_offline_sync_ts["utils/offline-sync.ts"] --> utils_supabase_ts["utils/supabase.ts"];
  utils_trpc_ts["utils/trpc.ts"] --> server_src_router_ts["server/src/router.ts"];
  utils_trpc_ts["utils/trpc.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
```

## External Dependencies
- `@/app/_layout`
- `@/app/components/SectionCard`
- `@/app/components/SwipeableRow`
- `@/app/components/TaskRow`
- `@/app/lib/useDashboardQuery`
- `@/app/lib/useToggleTaskStatus`
- `@/components/EmptyOrSkeleton`
- `@/components/aether/ProgressRing`
- `@/components/compass/PrincipleCard`
- `@/components/compass/PrinciplesTab`
- `@/components/compass/StateDefinitionCard`
- `@/components/dashboard/HabitCheckItem`
- `@/components/lists/GoalList`
- `@/components/lists/HabitList`
- `@/components/lists/TaskList`
- `@/components/ui/EmptyOrSkeleton`
- `@/components/ui/ErrorBanner`
- `@/components/ui/Skeleton`
- `@/components/ui/iOS/Button`
- `@/components/ui/nativewind-setup`
- `@/components/ui/primitives`
- `@/components/ui/primitives/AetherCard`
- `@/components/ui/primitives/AetherListItem`
- `@/constants/Colors`
- `@/constants/motion`
- `@/design-system/Primitives`
- `@/design-system/theme.glue`
- `@/global.css`
- `@/hooks/useColorScheme`
- `@/hooks/useSkeleton`
- `@/providers/SupabaseProvider`
- `@/providers/TRPCProvider`
- `@/providers/ToastProvider`
- `@/server/src/context`
- `@/stores/uiStore`
- `@/utils/api-types`
- `@/utils/colors`
- `@/utils/haptics`
- `@/utils/offline-sync`
- `@/utils/query-client`
- `@/utils/supabase`
- `@/utils/trpc`
- `@expo/vector-icons`
- `@gluestack-ui/config`
- `@gluestack-ui/themed`
- `@hookform/resolvers/zod`
- `@jest/globals`
- `@react-native-async-storage/async-storage`
- `@react-native-community/netinfo`
- `@shopify/flash-list`
- `@supabase/supabase-js`
- `@tamagui/animations-react-native`
- `@tamagui/lucide-icons`
- `@tamagui/toast`
- `@tanstack/query-async-storage-persister`
- `@tanstack/react-query`
- `@tanstack/react-query-persist-client`
- `@testing-library/react-native`
- `@trpc/client`
- `@trpc/react-query`
- `@trpc/server`
- `@trpc/server/adapters/express`
- `cors`
- `date-fns`
- `dotenv`
- `expo-blur`
- `expo-haptics`
- `expo-router`
- `expo-router/entry`
- `expo-secure-store`
- `expo-status-bar`
- `express`
- `globby`
- `jest-mock-extended`
- `nativewind`
- `nats.ws`
- `node:child_process`
- `node:crypto`
- `node:fs`
- `node:path`
- `node:url`
- `react`
- `react-hook-form`
- `react-native`
- `react-native-gesture-handler`
- `react-native-gesture-handler/Swipeable`
- `react-native-reanimated`
- `react-native-safe-area-context`
- `react-native-svg`
- `react-native-url-polyfill/auto`
- `server/src/router`
- `tamagui`
- `zod`
- `zustand`

## TODOs / FIXMEs

**__tests__/server/routers/habitRouter.test.ts**
- (L595) Add describe blocks for archive/unarchive and habit entry procedures

**app/states/[id].tsx**
- (L11) Fetch state definition details using trpc.state.getDefinitionById.useQuery({ id })

**app/values/[id].tsx**
- (L11) Fetch value details using trpc.value.getValueById.useQuery({ id })

**server/src/routers/dashboardRouter.ts**
- (L355) Add logic for 'weekly', 'monthly' etc. as needed

**server/src/routers/habitRouter.ts**
- (L411) Implement logic to fetch habit entries for a specific habit
- (L543) Implement logic to find if entry exists for habitId/date/userId.

**server/src/routers/principleRouter.ts**
- (L22) Parse with Principle schema from trpc-types?
- (L53) Parse with Principle schema from trpc-types?
- (L79) Parse with Principle schema from trpc-types?
- (L120) Parse with Principle schema from trpc-types?

**server/src/routers/reminderRouter.ts**
- (L63) Potentially validate that related_entity_id exists and belongs to user?

**server/src/routers/taskRouter.ts**
- (L67) Add filters for status, priority, dates etc.?
- (L81) Add complex priority enum sorting? (e.g. high > medium > low)
- (L88) Parse with Task schema?
- (L119) Parse with Task schema?
- (L187) Parse with Task schema?
- (L265) Add deeper cycle detection if needed (check if new parent is a descendant)
- (L291) Parse with Task schema?
- (L356) Parse with Task schema?
- (L369) Consider archiving subtasks recursively?
- (L388) Parse with Task schema?
- (L402) Consider check if parent is archived?
- (L421) Parse with Task schema?
- (L458) Parse with Task schema?
- (L490) Parse with Task schema?
- (L515) Parse with Task schema?
- (L540) Parse with Task schema?

**server/src/routers/valueRouter.ts**
- (L18) Parse with Value schema from trpc-types?
- (L49) Parse with Value schema from trpc-types?
- (L75) Parse with Value schema from trpc-types?
- (L116) Parse with Value schema from trpc-types?

## Excluded Files

_31 files were excluded based on the patterns in the script._

- .tamagui/tamagui.config.json
- assets/fonts/SpaceMono-Regular.ttf
- assets/images/adaptive-icon.png
- assets/images/favicon.png
- assets/images/icon.png
- assets/images/partial-react-logo.png
- assets/images/react-logo.png
- assets/images/react-logo@2x.png
- assets/images/react-logo@3x.png
- assets/images/splash-icon.png
- babel.config.js
- global.d.ts
- jest.config.server.js
- jest.config.ui.js
- jest.server.setup.js
- jest.setup.js
- logs/code-atlas_2025-04-30-10-29-32.md
- logs/code-atlas_2025-04-30-10-33-00.md
- logs/code-atlas_2025-04-30-10-41-10.md
- logs/code-atlas_2025-04-30-10-44-00.md
- metro.config.js
- nativewind-env.d.ts
- output/app_code_overview.txt
- output/routing.md
- output/tamagui.md
- output/type-diagnosis.md
- postcss.config.js
- server/yarn.lock
- types/database.types.ts
- why.txt
- yarn.lock

## Type Check Results (tsc)

```log
Error running tsc: Command failed: npx tsc --noEmit --pretty false

STDOUT:
__tests__/components/dashboard/HabitCheckItem.test.tsx(2,40): error TS2307: Cannot find module '../test-utils' or its corresponding type declarations.
__tests__/components/dashboard/HabitCheckItem.test.tsx(7,1): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/dashboard/HabitCheckItem.test.tsx(11,22): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/dashboard/HabitCheckItem.test.tsx(12,19): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/dashboard/HabitCheckItem.test.tsx(19,22): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/dashboard/HabitCheckItem.test.tsx(20,19): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/dashboard/HabitCheckItem.test.tsx(31,1): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/dashboard/HabitCheckItem.test.tsx(32,16): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/dashboard/HabitCheckItem.test.tsx(38,1): error TS2593: Cannot find name 'describe'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/dashboard/HabitCheckItem.test.tsx(56,3): error TS2304: Cannot find name 'beforeEach'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(57,5): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/dashboard/HabitCheckItem.test.tsx(60,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/dashboard/HabitCheckItem.test.tsx(61,50): error TS2739: Type '{ id: string; title: string; streak: number; completedToday: boolean; best_streak: number; user_id: string; cue: string; routine: string; reward: string; habit_type: string; frequency_period: string; goal_frequency: number; created_at: string; updated_at: string; }' is missing the following properties from type 'DashboardHabit': name, completed
__tests__/components/dashboard/HabitCheckItem.test.tsx(63,5): error TS2304: Cannot find name 'expect'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(64,5): error TS2304: Cannot find name 'expect'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(65,5): error TS2304: Cannot find name 'expect'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(68,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/dashboard/HabitCheckItem.test.tsx(70,50): error TS2739: Type '{ completedToday: boolean; id: string; title: string; streak: number; best_streak: number; user_id: string; cue: string; routine: string; reward: string; habit_type: string; frequency_period: string; goal_frequency: number; created_at: string; updated_at: string; }' is missing the following properties from type 'DashboardHabit': name, completed
__tests__/components/dashboard/HabitCheckItem.test.tsx(72,5): error TS2304: Cannot find name 'expect'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(73,5): error TS2304: Cannot find name 'expect'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(74,5): error TS2304: Cannot find name 'expect'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(77,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/dashboard/HabitCheckItem.test.tsx(78,26): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/dashboard/HabitCheckItem.test.tsx(79,30): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/dashboard/HabitCheckItem.test.tsx(82,54): error TS2694: Namespace 'global.jest' has no exported member 'Mock'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(90,45): error TS2353: Object literal may only specify known properties, and 'completedToday' does not exist in type 'DashboardHabit'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(97,5): error TS2304: Cannot find name 'expect'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(97,51): error TS2304: Cannot find name 'expect'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(99,13): error TS2304: Cannot find name 'expect'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(104,5): error TS2304: Cannot find name 'expect'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(107,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/dashboard/HabitCheckItem.test.tsx(108,26): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/dashboard/HabitCheckItem.test.tsx(109,30): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/dashboard/HabitCheckItem.test.tsx(112,54): error TS2694: Namespace 'global.jest' has no exported member 'Mock'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(120,45): error TS2353: Object literal may only specify known properties, and 'completedToday' does not exist in type 'DashboardHabit'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(127,5): error TS2304: Cannot find name 'expect'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(127,51): error TS2304: Cannot find name 'expect'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(129,13): error TS2304: Cannot find name 'expect'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(133,5): error TS2304: Cannot find name 'expect'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(136,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/dashboard/HabitCheckItem.test.tsx(139,21): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/dashboard/HabitCheckItem.test.tsx(144,54): error TS2694: Namespace 'global.jest' has no exported member 'Mock'.
__tests__/components/dashboard/HabitCheckItem.test.tsx(144,82): error TS7031: Binding element 'onError' implicitly has an 'any' type.
__tests__/components/dashboard/HabitCheckItem.test.tsx(147,17): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/dashboard/HabitCheckItem.test.tsx(153,50): error TS2739: Type '{ id: string; title: string; streak: number; completedToday: boolean; best_streak: number; user_id: string; cue: string; routine: string; reward: string; habit_type: string; frequency_period: string; goal_frequency: number; created_at: string; updated_at: string; }' is missing the following properties from type 'DashboardHabit': name, completed
__tests__/components/dashboard/HabitCheckItem.test.tsx(164,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/GoalList.test.tsx(2,35): error TS2307: Cannot find module '../test-utils' or its corresponding type declarations.
__tests__/components/lists/GoalList.test.tsx(7,1): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/GoalList.test.tsx(9,11): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/GoalList.test.tsx(33,1): error TS2593: Cannot find name 'describe'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/GoalList.test.tsx(34,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/GoalList.test.tsx(35,25): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/GoalList.test.tsx(40,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/GoalList.test.tsx(41,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/GoalList.test.tsx(42,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/GoalList.test.tsx(43,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/GoalList.test.tsx(46,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/GoalList.test.tsx(47,25): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/GoalList.test.tsx(56,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/GoalList.test.tsx(60,1): error TS2593: Cannot find name 'describe'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/GoalList.test.tsx(61,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/GoalList.test.tsx(63,43): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/GoalList.test.tsx(66,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/GoalList.test.tsx(69,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/GoalList.test.tsx(70,25): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/GoalList.test.tsx(75,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/GoalList.test.tsx(79,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/GoalList.test.tsx(82,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/GoalList.test.tsx(84,55): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/GoalList.test.tsx(87,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/GoalList.test.tsx(91,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/GoalList.test.tsx(94,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/GoalList.test.tsx(96,62): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/GoalList.test.tsx(100,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/GoalList.test.tsx(103,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/GoalList.test.tsx(105,62): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/GoalList.test.tsx(113,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/GoalList.test.tsx(119,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/GoalList.test.tsx(120,26): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/GoalList.test.tsx(125,18): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/GoalList.test.tsx(135,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/GoalList.test.tsx(137,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/HabitList.test.tsx(2,35): error TS2307: Cannot find module '../test-utils' or its corresponding type declarations.
__tests__/components/lists/HabitList.test.tsx(7,1): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/HabitList.test.tsx(9,11): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/HabitList.test.tsx(37,1): error TS2593: Cannot find name 'describe'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/HabitList.test.tsx(38,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/HabitList.test.tsx(39,25): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/HabitList.test.tsx(44,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/HabitList.test.tsx(45,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/HabitList.test.tsx(46,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/HabitList.test.tsx(49,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/HabitList.test.tsx(50,25): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/HabitList.test.tsx(51,26): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/HabitList.test.tsx(65,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/HabitList.test.tsx(69,1): error TS2593: Cannot find name 'describe'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/HabitList.test.tsx(70,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/HabitList.test.tsx(72,44): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/HabitList.test.tsx(75,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/HabitList.test.tsx(78,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/HabitList.test.tsx(79,25): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/HabitList.test.tsx(84,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/HabitList.test.tsx(88,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/HabitList.test.tsx(91,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/HabitList.test.tsx(93,57): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/HabitList.test.tsx(96,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/HabitList.test.tsx(100,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/HabitList.test.tsx(103,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/HabitList.test.tsx(105,65): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/HabitList.test.tsx(109,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/HabitList.test.tsx(112,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/HabitList.test.tsx(113,31): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/HabitList.test.tsx(118,18): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/HabitList.test.tsx(128,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/TaskList.test.tsx(2,35): error TS2307: Cannot find module '../test-utils' or its corresponding type declarations.
__tests__/components/lists/TaskList.test.tsx(7,1): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/TaskList.test.tsx(9,11): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/TaskList.test.tsx(37,1): error TS2593: Cannot find name 'describe'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/TaskList.test.tsx(38,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/TaskList.test.tsx(39,25): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/TaskList.test.tsx(44,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/TaskList.test.tsx(45,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/TaskList.test.tsx(46,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/TaskList.test.tsx(47,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/TaskList.test.tsx(50,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/TaskList.test.tsx(51,25): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/TaskList.test.tsx(52,28): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/TaskList.test.tsx(66,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/TaskList.test.tsx(69,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/TaskList.test.tsx(70,25): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/TaskList.test.tsx(77,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/TaskList.test.tsx(81,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/TaskList.test.tsx(88,45): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/TaskList.test.tsx(92,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/TaskList.test.tsx(96,1): error TS2593: Cannot find name 'describe'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/TaskList.test.tsx(97,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/TaskList.test.tsx(99,43): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/TaskList.test.tsx(102,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/TaskList.test.tsx(105,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/TaskList.test.tsx(106,25): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/TaskList.test.tsx(111,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/TaskList.test.tsx(115,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/TaskList.test.tsx(118,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/TaskList.test.tsx(120,55): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/TaskList.test.tsx(123,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/TaskList.test.tsx(127,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/TaskList.test.tsx(130,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/TaskList.test.tsx(132,62): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/TaskList.test.tsx(136,5): error TS2304: Cannot find name 'expect'.
__tests__/components/lists/TaskList.test.tsx(139,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/lists/TaskList.test.tsx(140,32): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/TaskList.test.tsx(145,18): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/lists/TaskList.test.tsx(155,5): error TS2304: Cannot find name 'expect'.
__tests__/components/ui/primitives/AetherCard.test.tsx(6,1): error TS2593: Cannot find name 'describe'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/ui/primitives/AetherCard.test.tsx(7,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/ui/primitives/AetherCard.test.tsx(14,5): error TS2304: Cannot find name 'expect'.
__tests__/components/ui/primitives/AetherCard.test.tsx(17,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/ui/primitives/AetherCard.test.tsx(26,5): error TS2304: Cannot find name 'expect'.
__tests__/components/ui/primitives/AetherCard.test.tsx(35,5): error TS2304: Cannot find name 'expect'.
__tests__/components/ui/primitives/AetherCard.test.tsx(44,5): error TS2304: Cannot find name 'expect'.
__tests__/components/ui/primitives/AetherCard.test.tsx(47,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/ui/primitives/AetherCard.test.tsx(48,25): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/ui/primitives/AetherCard.test.tsx(58,5): error TS2304: Cannot find name 'expect'.
__tests__/components/ui/primitives/AetherListItem.test.tsx(5,1): error TS2593: Cannot find name 'describe'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/ui/primitives/AetherListItem.test.tsx(6,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/ui/primitives/AetherListItem.test.tsx(11,5): error TS2304: Cannot find name 'expect'.
__tests__/components/ui/primitives/AetherListItem.test.tsx(14,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/ui/primitives/AetherListItem.test.tsx(22,5): error TS2304: Cannot find name 'expect'.
__tests__/components/ui/primitives/AetherListItem.test.tsx(23,5): error TS2304: Cannot find name 'expect'.
__tests__/components/ui/primitives/AetherListItem.test.tsx(26,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/ui/primitives/AetherListItem.test.tsx(34,5): error TS2304: Cannot find name 'expect'.
__tests__/components/ui/primitives/AetherListItem.test.tsx(35,5): error TS2304: Cannot find name 'expect'.
__tests__/components/ui/primitives/AetherListItem.test.tsx(38,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/ui/primitives/AetherListItem.test.tsx(46,5): error TS2304: Cannot find name 'expect'.
__tests__/components/ui/primitives/AetherListItem.test.tsx(49,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/ui/primitives/AetherListItem.test.tsx(50,25): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/components/ui/primitives/AetherListItem.test.tsx(58,18): error TS2531: Object is possibly 'null'.
__tests__/components/ui/primitives/AetherListItem.test.tsx(59,21): error TS2345: Argument of type 'ReactTestInstance | null' is not assignable to parameter of type 'ReactTestInstance'.
  Type 'null' is not assignable to type 'ReactTestInstance'.
__tests__/components/ui/primitives/AetherListItem.test.tsx(61,5): error TS2304: Cannot find name 'expect'.
__tests__/components/ui/primitives/AetherListItem.test.tsx(64,3): error TS2593: Cannot find name 'it'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.
__tests__/components/ui/primitives/AetherListItem.test.tsx(70,16): error TS2531: Object is possibly 'null'.
__tests__/components/ui/primitives/AetherListItem.test.tsx(71,5): error TS2304: Cannot find name 'expect'.
__tests__/components/ui/primitives/AetherListItem.test.tsx(71,12): error TS18047: 'item' is possibly 'null'.
__tests__/components/ui/primitives/AetherListItem.test.tsx(75,12): error TS2531: Object is possibly 'null'.
__tests__/components/ui/primitives/AetherListItem.test.tsx(76,5): error TS2304: Cannot find name 'expect'.
__tests__/components/ui/primitives/AetherListItem.test.tsx(76,12): error TS18047: 'item' is possibly 'null'.
__tests__/server/routers/dashboardRouter.getWeeklyProgress.test.ts(3,41): error TS2307: Cannot find module 'jest-mock-extended' or its corresponding type declarations.
__tests__/server/routers/dashboardRouter.getWeeklyProgress.test.ts(5,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
__tests__/server/routers/dashboardRouter.getWeeklyProgress.test.ts(195,51): error TS7006: Parameter 'day' implicitly has an 'any' type.
__tests__/server/routers/dashboardRouter.test.ts(3,41): error TS2307: Cannot find module 'jest-mock-extended' or its corresponding type declarations.
__tests__/server/routers/dashboardRouter.test.ts(5,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
__tests__/server/routers/habitRouter.test.ts(4,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
__tests__/server/routers/habitRouter.test.ts(30,16): error TS2304: Cannot find name 'mockDeep'.
__tests__/server/routers/habitRouter.test.ts(30,25): error TS2304: Cannot find name 'MockableTableOperations'.
__tests__/server/routers/habitRouter.test.ts(111,14): error TS2304: Cannot find name 'selectHabitsMock'.
__tests__/server/routers/habitRouter.test.ts(112,14): error TS2552: Cannot find name 'eqHabitsMock'. Did you mean 'habitsMock'?
__tests__/server/routers/habitRouter.test.ts(113,14): error TS2304: Cannot find name 'isNullHabitsMock'.
__tests__/server/routers/habitRouter.test.ts(114,14): error TS2304: Cannot find name 'habitsFilterMock'.
__tests__/server/routers/habitRouter.test.ts(117,14): error TS2304: Cannot find name 'selectEntriesMock'.
__tests__/server/routers/habitRouter.test.ts(118,14): error TS2304: Cannot find name 'eqUserEntriesMock'.
__tests__/server/routers/habitRouter.test.ts(119,14): error TS2304: Cannot find name 'eqDateEntriesMock'.
__tests__/server/routers/habitRouter.test.ts(121,14): error TS2304: Cannot find name 'entriesFilterMock'.
__tests__/server/routers/taskRouter.toggleTask.test.ts(9,41): error TS2307: Cannot find module 'jest-mock-extended' or its corresponding type declarations.
__tests__/server/routers/taskRouter.toggleTask.test.ts(11,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
__tests__/server/routers/taskRouter.toggleTask.test.ts(215,54): error TS7006: Parameter 'c' implicitly has an 'any' type.
__tests__/server/test-helpers.ts(1,52): error TS2307: Cannot find module 'jest-mock-extended' or its corresponding type declarations.
__tests__/server/test-helpers.ts(4,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
__tests__/server/test-helpers.ts(127,29): error TS2708: Cannot use namespace 'jest' as a value.
__tests__/server/test-helpers.ts(127,38): error TS7006: Parameter 'onFulfill' implicitly has an 'any' type.
__tests__/server/test-helpers.ts(127,49): error TS7006: Parameter 'onReject' implicitly has an 'any' type.
app/(auth)/forgot-password.tsx(72,13): error TS2322: Type '"$blue10"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'.
app/(auth)/forgot-password.tsx(83,17): error TS2322: Type '"$blue10"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
app/(auth)/login.tsx(74,9): error TS2322: Type '"$blue10"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'.
app/(auth)/login.tsx(83,17): error TS2322: Type '"$blue10"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
app/(auth)/login.tsx(87,17): error TS2322: Type '"$blue10"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
app/(auth)/register.tsx(91,9): error TS2322: Type '"$blue10"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'.
app/(auth)/register.tsx(101,17): error TS2322: Type '"$blue10"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
app/(tabs)/home/index.tsx(12,10): error TS2305: Module '"@gluestack-ui/themed"' has no exported member 'useColorModeValue'.
app/(tabs)/home/index.tsx(34,9): error TS2322: Type '{ children: any[]; title: string; action: Element; }' is not assignable to type 'IntrinsicAttributes & SectionCardProps'.
  Property 'action' does not exist on type 'IntrinsicAttributes & SectionCardProps'.
app/(tabs)/home/index.tsx(48,27): error TS7006: Parameter 'task' implicitly has an 'any' type.
app/(tabs)/planner/index.tsx(222,13): error TS2322: Type '"$gray9" | "$green9"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'.
  Type '"$green9"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'. Did you mean '"green"'?
app/(tabs)/planner/index.tsx(232,27): error TS7006: Parameter 'error' implicitly has an 'any' type.
app/(tabs)/rewards/index.tsx(41,17): error TS7006: Parameter 'data' implicitly has an 'any' type.
app/(tabs)/rewards/index.tsx(47,15): error TS7006: Parameter 'err' implicitly has an 'any' type.
app/(tabs)/rewards/index.tsx(241,56): error TS7006: Parameter 'r' implicitly has an 'any' type.
app/(tabs)/settings/index.tsx(9,10): error TS2614: Module '"@/app/_layout"' has no exported member 'useAccent'. Did you mean to use 'import useAccent from "@/app/_layout"' instead?
app/compose.tsx(6,73): error TS2307: Cannot find module 'react-hook-form' or its corresponding type declarations.
app/compose.tsx(7,29): error TS2307: Cannot find module '@hookform/resolvers/zod' or its corresponding type declarations.
app/compose.tsx(48,17): error TS7006: Parameter 'data' implicitly has an 'any' type.
app/compose.tsx(49,15): error TS7006: Parameter 'error' implicitly has an 'any' type.
app/compose.tsx(52,17): error TS7006: Parameter 'data' implicitly has an 'any' type.
app/compose.tsx(53,15): error TS7006: Parameter 'error' implicitly has an 'any' type.
app/compose.tsx(129,28): error TS7031: Binding element 'field' implicitly has an 'any' type.
app/compose.tsx(148,28): error TS7031: Binding element 'field' implicitly has an 'any' type.
app/compose.tsx(171,28): error TS7031: Binding element 'field' implicitly has an 'any' type.
app/compose.tsx(189,29): error TS7031: Binding element 'field' implicitly has an 'any' type.
app/compose.tsx(194,79): error TS2322: Type '"active" | undefined' is not assignable to type 'ThemeName | null | undefined'.
  Type '"active"' is not assignable to type 'ThemeName | null | undefined'.
app/compose.tsx(195,80): error TS2322: Type '"active" | undefined' is not assignable to type 'ThemeName | null | undefined'.
  Type '"active"' is not assignable to type 'ThemeName | null | undefined'.
app/compose.tsx(208,28): error TS7031: Binding element 'field' implicitly has an 'any' type.
app/lib/useToggleTaskStatus.ts(14,24): error TS7031: Binding element 'taskId' implicitly has an 'any' type.
app/lib/useToggleTaskStatus.ts(14,32): error TS7031: Binding element 'completed' implicitly has an 'any' type.
app/lib/useToggleTaskStatus.ts(22,60): error TS7006: Parameter 'oldData' implicitly has an 'any' type.
app/lib/useToggleTaskStatus.ts(26,37): error TS7006: Parameter 'task' implicitly has an 'any' type.
app/lib/useToggleTaskStatus.ts(43,15): error TS7006: Parameter 'error' implicitly has an 'any' type.
app/lib/useToggleTaskStatus.ts(43,22): error TS7006: Parameter 'variables' implicitly has an 'any' type.
app/lib/useToggleTaskStatus.ts(43,33): error TS7006: Parameter 'context' implicitly has an 'any' type.
app/planner/index.tsx(3,30): error TS2322: Type 'number' is not assignable to type 'undefined'.
app/planner/index.tsx(3,36): error TS2322: Type 'string' is not assignable to type 'undefined'.
app/planner/index.tsx(3,48): error TS2322: Type 'string' is not assignable to type 'undefined'.
app/settings/index.tsx(3,30): error TS2322: Type 'number' is not assignable to type 'undefined'.
app/settings/index.tsx(3,36): error TS2322: Type 'string' is not assignable to type 'undefined'.
app/settings/index.tsx(3,48): error TS2322: Type 'string' is not assignable to type 'undefined'.
app/utils/api-types.ts(6,60): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
components/aether/ProgressRing.tsx(36,35): error TS18048: 'theme.blue10' is possibly 'undefined'.
components/dashboard/DailyProgressBanner.tsx(34,36): error TS2322: Type 'string' is not assignable to type '"unset" | GetThemeValueForKey<"color"> | undefined'.
components/dashboard/DailyProgressBanner.tsx(42,31): error TS2820: Type '"$onSurfaceSubtle"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'. Did you mean '"$surfaceSubtle"'?
components/dashboard/DailyProgressBanner.tsx(50,31): error TS2322: Type 'string' is not assignable to type '"unset" | GetThemeValueForKey<"color"> | undefined'.
components/dashboard/DailyProgressBanner.tsx(58,31): error TS2820: Type '"$onSurfaceSubtle"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'. Did you mean '"$surfaceSubtle"'?
components/dashboard/HabitCheckItem.tsx(49,17): error TS7006: Parameter 'updatedHabit' implicitly has an 'any' type.
components/dashboard/HabitCheckItem.tsx(54,15): error TS7006: Parameter 'error' implicitly has an 'any' type.
components/dashboard/HabitCheckItem.tsx(67,15): error TS7006: Parameter 'error' implicitly has an 'any' type.
components/dashboard/HabitCheckItem.tsx(145,9): error TS2322: Type '"green" | undefined' is not assignable to type 'ThemeName | null | undefined'.
  Type '"green"' is not assignable to type 'ThemeName | null | undefined'.
components/dashboard/TaskItem.tsx(157,13): error TS2322: Type '"$brandRed" | "$brandYellow" | "$brandGreen"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'.
  Type '"$brandRed"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'.
components/lists/GoalList.tsx(54,17): error TS2322: Type '"$colorMuted"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
components/lists/GoalList.tsx(63,33): error TS2322: Type '"$colorMuted"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
components/lists/GoalList.tsx(114,33): error TS2322: Type '"$colorMuted"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
components/lists/HabitList.tsx(86,33): error TS2322: Type '"$colorMuted"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
components/lists/HabitList.tsx(93,33): error TS2322: Type '"$colorMuted"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
components/lists/HabitList.tsx(149,33): error TS2322: Type '"$colorMuted"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
components/lists/TaskList.tsx(78,15): error TS2322: Type '"$color" | "$colorMuted"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
  Type '"$colorMuted"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
components/lists/TaskList.tsx(90,17): error TS2322: Type '"$colorMuted"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
components/lists/TaskList.tsx(105,15): error TS2322: Type '"$error" | "$colorMuted"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
  Type '"$colorMuted"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
components/lists/TaskList.tsx(151,13): error TS2820: Type '"/planner/task/[id]"' is not assignable to type 'RelativePathString | ExternalPathString | "/compose" | "/" | "/_sitemap" | "/(auth)/forgot-password" | "/forgot-password" | "/(auth)/login" | ... 42 more ... | "/values/[id]"'. Did you mean '"/planner/goal/[id]"'?
components/lists/TaskList.tsx(177,33): error TS2322: Type '"$colorMuted"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
components/planner/GoalsList.tsx(73,29): error TS2322: Type '"$2"' is not assignable to type '200 | 300 | 100 | 400 | 500 | 800 | "unset" | GetThemeValueForKey<"fontWeight"> | 600 | 700 | 900 | undefined'.
components/planner/GoalsList.tsx(73,45): error TS2322: Type 'string' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
components/planner/GoalsList.tsx(85,33): error TS2322: Type '"$2"' is not assignable to type '200 | 300 | 100 | 400 | 500 | 800 | "unset" | GetThemeValueForKey<"fontWeight"> | 600 | 700 | 900 | undefined'.
components/planner/GoalsList.tsx(93,49): error TS2322: Type 'string' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'.
components/planner/GoalsList.tsx(163,31): error TS2322: Type '"$3"' is not assignable to type '200 | 300 | 100 | 400 | 500 | 800 | "unset" | GetThemeValueForKey<"fontWeight"> | 600 | 700 | 900 | undefined'.
components/planner/HabitsList.tsx(116,13): error TS2322: Type '"$2"' is not assignable to type '200 | 300 | 100 | 400 | 500 | 800 | "unset" | GetThemeValueForKey<"fontWeight"> | 600 | 700 | 900 | undefined'.
components/planner/HabitsList.tsx(131,67): error TS2322: Type '"$2"' is not assignable to type '200 | 300 | 100 | 400 | 500 | 800 | "unset" | GetThemeValueForKey<"fontWeight"> | 600 | 700 | 900 | undefined'.
components/planner/HabitsList.tsx(191,31): error TS2322: Type '"$3"' is not assignable to type '200 | 300 | 100 | 400 | 500 | 800 | "unset" | GetThemeValueForKey<"fontWeight"> | 600 | 700 | 900 | undefined'.
components/planner/HabitTracker.tsx(51,11): error TS2322: Type 'string' is not assignable to type 'undefined'.
components/planner/HabitTracker.tsx(91,7): error TS2322: Type 'string' is not assignable to type 'undefined'.
components/planner/HabitTracker.tsx(109,17): error TS2322: Type 'string' is not assignable to type 'undefined'.
components/planner/HabitTracker.tsx(119,9): error TS2322: Type '"$gray4" | "$primary9"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'.
  Type '"$primary9"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'. Did you mean '"$primary"'?
components/planner/HabitTracker.tsx(125,11): error TS2322: Type '"$gray5" | "$primary8"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'.
  Type '"$primary8"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'. Did you mean '"$primary"'?
components/planner/StreakCalendar.tsx(83,27): error TS2322: Type '"$3"' is not assignable to type '200 | 300 | 100 | 400 | 500 | 800 | "unset" | GetThemeValueForKey<"fontWeight"> | 600 | 700 | 900 | undefined'.
components/planner/StreakCalendar.tsx(83,43): error TS2322: Type '"$content.primary"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
components/planner/StreakCalendar.tsx(102,19): error TS2322: Type '"$content.subtle" | "$brand.primary"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
  Type '"$content.subtle"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
components/planner/StreakCalendar.tsx(103,19): error TS2322: Type '"$2" | "$3"' is not assignable to type '200 | 300 | 100 | 400 | 500 | 800 | "unset" | GetThemeValueForKey<"fontWeight"> | 600 | 700 | 900 | undefined'.
  Type '"$2"' is not assignable to type '200 | 300 | 100 | 400 | 500 | 800 | "unset" | GetThemeValueForKey<"fontWeight"> | 600 | 700 | 900 | undefined'.
components/planner/StreakCalendar.tsx(132,31): error TS2322: Type '"$content.subtle"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
components/planner/StreakCalendar.tsx(144,31): error TS2322: Type '"$content.subtle"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
components/settings/NotificationRow.tsx(52,7): error TS2322: Type 'string' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'.
components/settings/NotificationRow.tsx(61,13): error TS2322: Type '"$2"' is not assignable to type '200 | 300 | 100 | 400 | 500 | 800 | "unset" | GetThemeValueForKey<"fontWeight"> | 600 | 700 | 900 | undefined'.
components/settings/NotificationRow.tsx(62,13): error TS2322: Type 'string' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
components/settings/ThemePreview.tsx(54,11): error TS2322: Type '"$2"' is not assignable to type '200 | 300 | 100 | 400 | 500 | 800 | "unset" | GetThemeValueForKey<"fontWeight"> | 600 | 700 | 900 | undefined'.
components/settings/ThemePreview.tsx(55,11): error TS2322: Type 'string' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"color"> | undefined'.
components/settings/ThemePreview.tsx(63,13): error TS2820: Type '"$cardBackground"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'. Did you mean '"$background"'?
components/ui/Container.tsx(2,24): error TS2724: '"react-native"' has no exported member named 'SafeAreaViewProps'. Did you mean 'SafeAreaView'?
components/ui/Container.tsx(14,55): error TS2339: Property 'style' does not exist on type 'ContainerProps'.
components/ui/InteractiveCard.tsx(13,5): error TS2322: Type '"$color.transparent"' is not assignable to type '"unset" | GetThemeValueForKey<"shadowColor"> | OpaqueColorValue | undefined'.
components/ui/primitives/AetherCard.tsx(15,3): error TS2820: Type '"$cardBackground"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'. Did you mean '"$background"'?
components/ui/primitives/AetherCard.tsx(48,11): error TS2820: Type '"$cardBackgroundPress"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'. Did you mean '"$backgroundPress"'?
components/ui/primitives/AetherCard.tsx(52,11): error TS2820: Type '"$cardBackgroundHover"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'. Did you mean '"$backgroundHover"'?
components/ui/primitives/AetherCard.tsx(59,5): error TS2322: Type 'string' is not assignable to type 'undefined'.
components/ui/primitives/AetherCard.tsx(60,5): error TS2322: Type 'false' is not assignable to type 'undefined'.
components/ui/primitives/AetherCard.tsx(72,17): error TS2322: Type '{ children: any; theme?: ThemeName | null | undefined; debug?: DebugProp | undefined; id?: string | undefined; hitSlop?: number | Insets | null | undefined; ... 551 more ...; isInteractive: boolean | undefined; }' is not assignable to type 'IntrinsicAttributes & Omit<RNTamaguiViewNonStyleProps, "size" | "elevation" | keyof StackStyleBase | ... 12 more ... | "unstyled"> & ... 5 more ... & RefAttributes<...>'.
  Property 'variant' does not exist on type 'IntrinsicAttributes & Omit<RNTamaguiViewNonStyleProps, "size" | "elevation" | keyof StackStyleBase | ... 12 more ... | "unstyled"> & ... 5 more ... & RefAttributes<...>'.
components/ui/primitives/AetherListItem.tsx(8,3): error TS2820: Type '"$cardBackground"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'. Did you mean '"$background"'?
components/ui/SwipeableRow.tsx(26,24): error TS2322: Type 'string' is not assignable to type '"unset" | GetThemeValueForKey<"color"> | undefined'.
components/ui/SwipeableRow.tsx(50,24): error TS2322: Type 'string' is not assignable to type '"unset" | GetThemeValueForKey<"color"> | undefined'.
debug/toast-test.tsx(3,26): error TS2307: Cannot find module '@/providers/ToastProvider' or its corresponding type declarations.
debug/toast-test.tsx(52,11): error TS2820: Type '"$green6"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'. Did you mean '"green"'?
debug/toast-test.tsx(60,11): error TS2820: Type '"$red6"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'. Did you mean '"red"'?
debug/toast-test.tsx(68,11): error TS2820: Type '"$blue6"' is not assignable to type '"unset" | OpaqueColorValue | GetThemeValueForKey<"backgroundColor"> | undefined'. Did you mean '"blue"'?
design-system/Primitives.tsx(3,10): error TS2305: Module '"nativewind"' has no exported member 'styled'.
design-system/Primitives.tsx(20,32): error TS2339: Property 'useColorMode' does not exist on type 'typeof import("/Users/tylerbedford/Documents/Coding Projects/AetherIphone/node_modules/@gluestack-ui/themed/build/index")'.
hooks/useOfflineSync.ts(2,21): error TS2307: Cannot find module '@react-native-community/netinfo' or its corresponding type declarations.
hooks/useOfflineSync.ts(20,50): error TS7006: Parameter 'state' implicitly has an 'any' type.
modals/compose.tsx(3,24): error TS2307: Cannot find module '@/components/ui/iOS/Button' or its corresponding type declarations.
providers/AppProvider.tsx(7,36): error TS2307: Cannot find module '@/components/ui/nativewind-setup' or its corresponding type declarations.
server/src/context.ts(2,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
server/src/index.ts(3,41): error TS2307: Cannot find module '@trpc/server/adapters/express' or its corresponding type declarations.
server/src/router.ts(1,26): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
server/src/router.ts(3,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
server/src/router.ts(14,54): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/router.ts(14,59): error TS7031: Binding element 'next' implicitly has an 'any' type.
server/src/router.ts(39,23): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(3,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
server/src/routers/dashboardRouter.ts(21,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(21,26): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(79,65): error TS7006: Parameter 's' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(106,45): error TS7006: Parameter 'h' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(115,73): error TS7006: Parameter 'e' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(117,52): error TS7006: Parameter 'h' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(128,43): error TS7006: Parameter 'g' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(138,22): error TS2347: Untyped function calls may not accept type arguments.
server/src/routers/dashboardRouter.ts(138,109): error TS7006: Parameter 'acc' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(138,114): error TS7006: Parameter 'task' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(149,51): error TS7006: Parameter 'g' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(167,51): error TS7006: Parameter 't' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(177,77): error TS7006: Parameter 'def' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(226,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(226,26): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(260,61): error TS7006: Parameter 'h' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(330,32): error TS7006: Parameter 'task' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(360,33): error TS7006: Parameter 'habit' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(410,57): error TS7006: Parameter 'habit' implicitly has an 'any' type.
server/src/routers/dashboardRouter.ts(420,39): error TS7006: Parameter 'snapshot' implicitly has an 'any' type.
server/src/routers/goalProgressNoteRouter.ts(3,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
server/src/routers/goalProgressNoteRouter.ts(18,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/goalProgressNoteRouter.ts(18,26): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/goalProgressNoteRouter.ts(56,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/goalProgressNoteRouter.ts(56,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/goalProgressNoteRouter.ts(94,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/goalProgressNoteRouter.ts(94,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/goalProgressNoteRouter.ts(134,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/goalProgressNoteRouter.ts(134,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/goalRouter.ts(3,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
server/src/routers/goalRouter.ts(10,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/goalRouter.ts(35,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/goalRouter.ts(35,26): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/goalRouter.ts(65,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/goalRouter.ts(65,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/goalRouter.ts(88,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/goalRouter.ts(88,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/goalRouter.ts(130,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/goalRouter.ts(130,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/goalRouter.ts(165,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/goalRouter.ts(185,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/goalRouter.ts(206,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/goalRouter.ts(206,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/goalRouter.ts(237,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/goalRouter.ts(237,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(3,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
server/src/routers/habitRouter.ts(165,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(185,38): error TS7006: Parameter 'h' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(189,30): error TS2347: Untyped function calls may not accept type arguments.
server/src/routers/habitRouter.ts(189,89): error TS7006: Parameter 'acc' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(189,94): error TS7006: Parameter 'entry' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(194,44): error TS7006: Parameter 'h' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(210,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(210,26): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(227,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(227,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(245,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(245,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(274,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(274,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(297,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(319,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(319,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(344,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(344,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(373,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(373,26): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(410,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(410,26): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(427,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(427,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(454,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(454,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(497,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(497,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(542,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/habitRouter.ts(542,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/principleRouter.ts(4,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
server/src/routers/principleRouter.ts(12,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/principleRouter.ts(36,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/principleRouter.ts(36,26): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/principleRouter.ts(67,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/principleRouter.ts(67,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/principleRouter.ts(91,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/principleRouter.ts(91,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/principleRouter.ts(136,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/principleRouter.ts(136,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/reminderRouter.ts(3,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
server/src/routers/reminderRouter.ts(17,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/reminderRouter.ts(39,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/reminderRouter.ts(39,26): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/reminderRouter.ts(61,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/reminderRouter.ts(61,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/reminderRouter.ts(87,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/reminderRouter.ts(87,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/reminderRouter.ts(127,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/reminderRouter.ts(127,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/rewardsRouter.ts(1,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
server/src/routers/rewardsRouter.ts(12,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/rewardsRouter.ts(33,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/rewardsRouter.ts(52,61): error TS7006: Parameter 'er' implicitly has an 'any' type.
server/src/routers/rewardsRouter.ts(53,53): error TS7006: Parameter 'reward' implicitly has an 'any' type.
server/src/routers/rewardsRouter.ts(67,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/rewardsRouter.ts(91,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/rewardsRouter.ts(91,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/rewardsRouter.ts(198,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/rewardsRouter.ts(198,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/rewardsRouter.ts(301,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/rewardsRouter.ts(301,26): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(3,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
server/src/routers/taskRouter.ts(69,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(69,26): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(102,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(102,26): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(133,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(133,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(201,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(201,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(307,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(307,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(346,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(368,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(368,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(401,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(401,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(435,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(435,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(471,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(498,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(523,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(552,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/taskRouter.ts(552,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/trackedStateRouter.ts(5,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
server/src/routers/trackedStateRouter.ts(24,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/trackedStateRouter.ts(46,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/trackedStateRouter.ts(46,26): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/trackedStateRouter.ts(73,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/trackedStateRouter.ts(73,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/trackedStateRouter.ts(96,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/trackedStateRouter.ts(96,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/trackedStateRouter.ts(135,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/trackedStateRouter.ts(135,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/trackedStateRouter.ts(172,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/trackedStateRouter.ts(172,26): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/trackedStateRouter.ts(207,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/trackedStateRouter.ts(207,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/trackedStateRouter.ts(251,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/trackedStateRouter.ts(251,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/trackedStateRouter.ts(292,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/trackedStateRouter.ts(292,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/userRouter.ts(3,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
server/src/routers/userRouter.ts(7,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/userRouter.ts(27,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/userRouter.ts(27,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/userRouter.ts(40,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/userRouter.ts(95,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/userRouter.ts(95,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/userRouter.ts(148,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/userRouter.ts(160,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/valueRouter.ts(3,27): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
server/src/routers/valueRouter.ts(8,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/valueRouter.ts(32,21): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/valueRouter.ts(32,26): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/valueRouter.ts(63,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/valueRouter.ts(63,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/valueRouter.ts(87,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/valueRouter.ts(87,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/routers/valueRouter.ts(132,24): error TS7031: Binding element 'ctx' implicitly has an 'any' type.
server/src/routers/valueRouter.ts(132,29): error TS7031: Binding element 'input' implicitly has an 'any' type.
server/src/types/trpc-types.ts(12,55): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
utils/api-types.ts(6,60): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
utils/auth.ts(13,20): error TS2345: Argument of type '"/auth/login"' is not assignable to parameter of type 'RelativePathString | ExternalPathString | "/compose" | `/compose#${string}` | `/compose?${string}` | "/" | `/#${string}` | `/?${string}` | "/_sitemap" | `/_sitemap#${string}` | `/_sitemap?${string}` | ... 160 more ... | { ...; }'.
utils/auth.ts(17,20): error TS2345: Argument of type '"/auth/login"' is not assignable to parameter of type 'RelativePathString | ExternalPathString | "/compose" | `/compose#${string}` | `/compose?${string}` | "/" | `/#${string}` | `/?${string}` | "/_sitemap" | `/_sitemap#${string}` | `/_sitemap?${string}` | ... 160 more ... | { ...; }'.
utils/mock-api.ts(1,26): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.
utils/mock-api.ts(2,19): error TS2307: Cannot find module 'zod' or its corresponding type declarations.
utils/mock-api.ts(16,17): error TS7031: Binding element 'input' implicitly has an 'any' type.
utils/mock-api.ts(31,17): error TS7031: Binding element 'input' implicitly has an 'any' type.
utils/mock-api.ts(48,26): error TS7031: Binding element 'input' implicitly has an 'any' type.
utils/mock-api.ts(67,26): error TS7031: Binding element 'input' implicitly has an 'any' type.
utils/nats-client.ts(2,83): error TS2307: Cannot find module 'nats.ws' or its corresponding type declarations.
utils/offline-mutations.ts(1,26): error TS2307: Cannot find module '@react-native-async-storage/async-storage' or its corresponding type declarations.
utils/offline-mutations.ts(13,54): error TS2307: Cannot find module '@react-native-community/netinfo' or its corresponding type declarations.
utils/offline-mutations.ts(15,21): error TS2307: Cannot find module '@react-native-community/netinfo' or its corresponding type declarations.
utils/offline-mutations.ts(103,48): error TS7006: Parameter 'state' implicitly has an 'any' type.
utils/offline-sync.ts(1,26): error TS2307: Cannot find module '@react-native-async-storage/async-storage' or its corresponding type declarations.
utils/offline-sync.ts(2,21): error TS2307: Cannot find module '@react-native-community/netinfo' or its corresponding type declarations.
utils/offline-sync.ts(262,48): error TS7006: Parameter 'state' implicitly has an 'any' type.
utils/trpc.ts(2,65): error TS2307: Cannot find module '@trpc/server' or its corresponding type declarations.


STDERR:
```

## Linting Results (eslint)

```log
Error running eslint: Command failed: npx eslint .eslintrc.js HAHA.js __tests__/components/dashboard/HabitCheckItem.test.tsx __tests__/components/lists/GoalList.test.tsx __tests__/components/lists/HabitList.test.tsx __tests__/components/lists/TaskList.test.tsx __tests__/components/ui/primitives/AetherCard.test.tsx __tests__/components/ui/primitives/AetherListItem.test.tsx __tests__/server/routers/dashboardRouter.getWeeklyProgress.test.ts __tests__/server/routers/dashboardRouter.test.ts __tests__/server/routers/habitRouter.test.ts __tests__/server/routers/taskRouter.toggleTask.test.ts __tests__/server/test-helpers.ts __tests__/test-utils.tsx app/(auth)/_layout.tsx app/(auth)/forgot-password.tsx app/(auth)/login.tsx app/(auth)/register.tsx app/(tabs)/_layout.tsx app/(tabs)/compass/index.tsx app/(tabs)/home/index.tsx app/(tabs)/planner/_layout.tsx app/(tabs)/planner/add-goal.tsx app/(tabs)/planner/add-habit.tsx app/(tabs)/planner/add-task.tsx app/(tabs)/planner/goal/[id].tsx app/(tabs)/planner/habit/[id].tsx app/(tabs)/planner/index.tsx app/(tabs)/rewards/index.tsx app/(tabs)/settings/_layout.tsx app/(tabs)/settings/about.tsx app/(tabs)/settings/help.tsx app/(tabs)/settings/index.tsx app/(tabs)/settings/notifications.tsx app/(tabs)/settings/privacy.tsx app/(tabs)/settings/profile.tsx app/(tabs)/settings/security.tsx app/_layout.tsx app/components/SectionCard.tsx app/components/SwipeableRow.tsx app/components/TaskRow.tsx app/compose.tsx app/index.tsx app/lib/useDashboardQuery.ts app/lib/useToggleTaskStatus.ts app/planner/add-habit.tsx app/planner/index.tsx app/settings/index.tsx app/states/[id].tsx app/utils/api-types.ts app/values/[id].tsx babel-tap.js components/EmptyOrSkeleton.tsx components/aether/ProgressRing.tsx components/auth/FloatingInput.tsx components/compass/PrincipleCard.tsx components/compass/PrinciplesTab.tsx components/compass/StateDefinitionCard.tsx components/dashboard/DailyProgressBanner.tsx components/dashboard/DashboardSection.tsx components/dashboard/GoalSummaryCard.tsx components/dashboard/HabitCheckItem.tsx components/dashboard/StateIndicator.tsx components/dashboard/TaskItem.tsx components/lists/GoalList.tsx components/lists/HabitList.tsx components/lists/TaskList.tsx components/lists/index.ts components/planner/GoalsList.tsx components/planner/HabitTracker.tsx components/planner/HabitsList.tsx components/planner/StreakCalendar.tsx components/rewards/ConfettiBurst.tsx components/settings/NotificationRow.tsx components/settings/ThemePreview.tsx components/ui/Container.tsx components/ui/EmptyOrSkeleton.tsx components/ui/ErrorBanner.tsx components/ui/InteractiveCard.tsx components/ui/Section.tsx components/ui/Skeleton.tsx components/ui/SwipeableRow.tsx components/ui/primitives/AetherCard.tsx components/ui/primitives/AetherListItem.tsx components/ui/primitives/SectionHeader.tsx components/ui/primitives/index.ts constants/Colors.ts constants/motion.ts debug/toast-test.tsx design-system/Animations.ts design-system/Primitives.tsx design-system/theme.glue.ts design-system/tokens.ts gather_debug_info.js hooks/useColorScheme.ts hooks/useColorScheme.web.ts hooks/useOfflineSync.ts hooks/useSkeleton.ts hooks/useThemeColor.ts index.js jest.server.config.js modals/compose.tsx providers/AppProvider.tsx providers/ConfettiProvider.tsx providers/SupabaseProvider.tsx providers/TRPCProvider.tsx providers/index.ts scripts/generate-all.js scripts/generate-trpc-client.js scripts/generate-trpc-types.js scripts/reset-project.js server/src/context.ts server/src/index.ts server/src/router.ts server/src/routers/dashboardRouter.ts server/src/routers/goalProgressNoteRouter.ts server/src/routers/goalRouter.ts server/src/routers/habitRouter.ts server/src/routers/principleRouter.ts server/src/routers/reminderRouter.ts server/src/routers/rewardsRouter.ts server/src/routers/taskRouter.ts server/src/routers/trackedStateRouter.ts server/src/routers/userRouter.ts server/src/routers/valueRouter.ts server/src/types/index.ts server/src/types/trpc-types.ts stores/uiStore.ts tailwind.config.js tamagui.config.ts utils/api-types.ts utils/auth.ts utils/colors.ts utils/generated-hooks.ts utils/haptics.ts utils/mock-api.ts utils/nats-client.ts utils/offline-mutations.ts utils/offline-sync.ts utils/query-client.ts utils/settings.ts utils/supabase.ts utils/trpc.ts
/bin/sh: -c: line 0: syntax error near unexpected token `('
/bin/sh: -c: line 0: `npx eslint .eslintrc.js HAHA.js __tests__/components/dashboard/HabitCheckItem.test.tsx __tests__/components/lists/GoalList.test.tsx __tests__/components/lists/HabitList.test.tsx __tests__/components/lists/TaskList.test.tsx __tests__/components/ui/primitives/AetherCard.test.tsx __tests__/components/ui/primitives/AetherListItem.test.tsx __tests__/server/routers/dashboardRouter.getWeeklyProgress.test.ts __tests__/server/routers/dashboardRouter.test.ts __tests__/server/routers/habitRouter.test.ts __tests__/server/routers/taskRouter.toggleTask.test.ts __tests__/server/test-helpers.ts __tests__/test-utils.tsx app/(auth)/_layout.tsx app/(auth)/forgot-password.tsx app/(auth)/login.tsx app/(auth)/register.tsx app/(tabs)/_layout.tsx app/(tabs)/compass/index.tsx app/(tabs)/home/index.tsx app/(tabs)/planner/_layout.tsx app/(tabs)/planner/add-goal.tsx app/(tabs)/planner/add-habit.tsx app/(tabs)/planner/add-task.tsx app/(tabs)/planner/goal/[id].tsx app/(tabs)/planner/habit/[id].tsx app/(tabs)/planner/index.tsx app/(tabs)/rewards/index.tsx app/(tabs)/settings/_layout.tsx app/(tabs)/settings/about.tsx app/(tabs)/settings/help.tsx app/(tabs)/settings/index.tsx app/(tabs)/settings/notifications.tsx app/(tabs)/settings/privacy.tsx app/(tabs)/settings/profile.tsx app/(tabs)/settings/security.tsx app/_layout.tsx app/components/SectionCard.tsx app/components/SwipeableRow.tsx app/components/TaskRow.tsx app/compose.tsx app/index.tsx app/lib/useDashboardQuery.ts app/lib/useToggleTaskStatus.ts app/planner/add-habit.tsx app/planner/index.tsx app/settings/index.tsx app/states/[id].tsx app/utils/api-types.ts app/values/[id].tsx babel-tap.js components/EmptyOrSkeleton.tsx components/aether/ProgressRing.tsx components/auth/FloatingInput.tsx components/compass/PrincipleCard.tsx components/compass/PrinciplesTab.tsx components/compass/StateDefinitionCard.tsx components/dashboard/DailyProgressBanner.tsx components/dashboard/DashboardSection.tsx components/dashboard/GoalSummaryCard.tsx components/dashboard/HabitCheckItem.tsx components/dashboard/StateIndicator.tsx components/dashboard/TaskItem.tsx components/lists/GoalList.tsx components/lists/HabitList.tsx components/lists/TaskList.tsx components/lists/index.ts components/planner/GoalsList.tsx components/planner/HabitTracker.tsx components/planner/HabitsList.tsx components/planner/StreakCalendar.tsx components/rewards/ConfettiBurst.tsx components/settings/NotificationRow.tsx components/settings/ThemePreview.tsx components/ui/Container.tsx components/ui/EmptyOrSkeleton.tsx components/ui/ErrorBanner.tsx components/ui/InteractiveCard.tsx components/ui/Section.tsx components/ui/Skeleton.tsx components/ui/SwipeableRow.tsx components/ui/primitives/AetherCard.tsx components/ui/primitives/AetherListItem.tsx components/ui/primitives/SectionHeader.tsx components/ui/primitives/index.ts constants/Colors.ts constants/motion.ts debug/toast-test.tsx design-system/Animations.ts design-system/Primitives.tsx design-system/theme.glue.ts design-system/tokens.ts gather_debug_info.js hooks/useColorScheme.ts hooks/useColorScheme.web.ts hooks/useOfflineSync.ts hooks/useSkeleton.ts hooks/useThemeColor.ts index.js jest.server.config.js modals/compose.tsx providers/AppProvider.tsx providers/ConfettiProvider.tsx providers/SupabaseProvider.tsx providers/TRPCProvider.tsx providers/index.ts scripts/generate-all.js scripts/generate-trpc-client.js scripts/generate-trpc-types.js scripts/reset-project.js server/src/context.ts server/src/index.ts server/src/router.ts server/src/routers/dashboardRouter.ts server/src/routers/goalProgressNoteRouter.ts server/src/routers/goalRouter.ts server/src/routers/habitRouter.ts server/src/routers/principleRouter.ts server/src/routers/reminderRouter.ts server/src/routers/rewardsRouter.ts server/src/routers/taskRouter.ts server/src/routers/trackedStateRouter.ts server/src/routers/userRouter.ts server/src/routers/valueRouter.ts server/src/types/index.ts server/src/types/trpc-types.ts stores/uiStore.ts tailwind.config.js tamagui.config.ts utils/api-types.ts utils/auth.ts utils/colors.ts utils/generated-hooks.ts utils/haptics.ts utils/mock-api.ts utils/nats-client.ts utils/offline-mutations.ts utils/offline-sync.ts utils/query-client.ts utils/settings.ts utils/supabase.ts utils/trpc.ts'


STDOUT:


STDERR:
/bin/sh: -c: line 0: syntax error near unexpected token `('
/bin/sh: -c: line 0: `npx eslint .eslintrc.js HAHA.js __tests__/components/dashboard/HabitCheckItem.test.tsx __tests__/components/lists/GoalList.test.tsx __tests__/components/lists/HabitList.test.tsx __tests__/components/lists/TaskList.test.tsx __tests__/components/ui/primitives/AetherCard.test.tsx __tests__/components/ui/primitives/AetherListItem.test.tsx __tests__/server/routers/dashboardRouter.getWeeklyProgress.test.ts __tests__/server/routers/dashboardRouter.test.ts __tests__/server/routers/habitRouter.test.ts __tests__/server/routers/taskRouter.toggleTask.test.ts __tests__/server/test-helpers.ts __tests__/test-utils.tsx app/(auth)/_layout.tsx app/(auth)/forgot-password.tsx app/(auth)/login.tsx app/(auth)/register.tsx app/(tabs)/_layout.tsx app/(tabs)/compass/index.tsx app/(tabs)/home/index.tsx app/(tabs)/planner/_layout.tsx app/(tabs)/planner/add-goal.tsx app/(tabs)/planner/add-habit.tsx app/(tabs)/planner/add-task.tsx app/(tabs)/planner/goal/[id].tsx app/(tabs)/planner/habit/[id].tsx app/(tabs)/planner/index.tsx app/(tabs)/rewards/index.tsx app/(tabs)/settings/_layout.tsx app/(tabs)/settings/about.tsx app/(tabs)/settings/help.tsx app/(tabs)/settings/index.tsx app/(tabs)/settings/notifications.tsx app/(tabs)/settings/privacy.tsx app/(tabs)/settings/profile.tsx app/(tabs)/settings/security.tsx app/_layout.tsx app/components/SectionCard.tsx app/components/SwipeableRow.tsx app/components/TaskRow.tsx app/compose.tsx app/index.tsx app/lib/useDashboardQuery.ts app/lib/useToggleTaskStatus.ts app/planner/add-habit.tsx app/planner/index.tsx app/settings/index.tsx app/states/[id].tsx app/utils/api-types.ts app/values/[id].tsx babel-tap.js components/EmptyOrSkeleton.tsx components/aether/ProgressRing.tsx components/auth/FloatingInput.tsx components/compass/PrincipleCard.tsx components/compass/PrinciplesTab.tsx components/compass/StateDefinitionCard.tsx components/dashboard/DailyProgressBanner.tsx components/dashboard/DashboardSection.tsx components/dashboard/GoalSummaryCard.tsx components/dashboard/HabitCheckItem.tsx components/dashboard/StateIndicator.tsx components/dashboard/TaskItem.tsx components/lists/GoalList.tsx components/lists/HabitList.tsx components/lists/TaskList.tsx components/lists/index.ts components/planner/GoalsList.tsx components/planner/HabitTracker.tsx components/planner/HabitsList.tsx components/planner/StreakCalendar.tsx components/rewards/ConfettiBurst.tsx components/settings/NotificationRow.tsx components/settings/ThemePreview.tsx components/ui/Container.tsx components/ui/EmptyOrSkeleton.tsx components/ui/ErrorBanner.tsx components/ui/InteractiveCard.tsx components/ui/Section.tsx components/ui/Skeleton.tsx components/ui/SwipeableRow.tsx components/ui/primitives/AetherCard.tsx components/ui/primitives/AetherListItem.tsx components/ui/primitives/SectionHeader.tsx components/ui/primitives/index.ts constants/Colors.ts constants/motion.ts debug/toast-test.tsx design-system/Animations.ts design-system/Primitives.tsx design-system/theme.glue.ts design-system/tokens.ts gather_debug_info.js hooks/useColorScheme.ts hooks/useColorScheme.web.ts hooks/useOfflineSync.ts hooks/useSkeleton.ts hooks/useThemeColor.ts index.js jest.server.config.js modals/compose.tsx providers/AppProvider.tsx providers/ConfettiProvider.tsx providers/SupabaseProvider.tsx providers/TRPCProvider.tsx providers/index.ts scripts/generate-all.js scripts/generate-trpc-client.js scripts/generate-trpc-types.js scripts/reset-project.js server/src/context.ts server/src/index.ts server/src/router.ts server/src/routers/dashboardRouter.ts server/src/routers/goalProgressNoteRouter.ts server/src/routers/goalRouter.ts server/src/routers/habitRouter.ts server/src/routers/principleRouter.ts server/src/routers/reminderRouter.ts server/src/routers/rewardsRouter.ts server/src/routers/taskRouter.ts server/src/routers/trackedStateRouter.ts server/src/routers/userRouter.ts server/src/routers/valueRouter.ts server/src/types/index.ts server/src/types/trpc-types.ts stores/uiStore.ts tailwind.config.js tamagui.config.ts utils/api-types.ts utils/auth.ts utils/colors.ts utils/generated-hooks.ts utils/haptics.ts utils/mock-api.ts utils/nats-client.ts utils/offline-mutations.ts utils/offline-sync.ts utils/query-client.ts utils/settings.ts utils/supabase.ts utils/trpc.ts'
```

## Buckets

### .

- **.env** (0.4 KB, 4 lines) *(No explicit exports)*

  ```text
EXPO_PUBLIC_SUPABASE_URL=https://fjzzeprbdjwpxnhnltqm.supabase.co
EXPO_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZqenplcHJiZGp3cHhuaG5sdHFtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5NjU1ODEsImV4cCI6MjA2MDU0MTU4MX0.iXWsMcw72PV6dtzDnna9LuPFF1MPYvlmFcasx0Qlo34
SUPABASE_URL=https://fjzzeprbdjwpxnhnltqm.supabase.co
SUPABASE_SERVICE_ROLE_KEY=<your-service-role-key-from-supabase-settings>
  ```

- **.env.example** (0.1 KB, 2 lines) *(No explicit exports)*

  ```example
# Supabase Configuration\nEXPO_PUBLIC_SUPABASE_URL=your_supabase_url_here\nEXPO_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key_here

  ```

- **.eslintrc.js** (0.5 KB, 17 lines) *(No explicit exports)*

  ```js
// https://docs.expo.dev/guides/using-eslint/
module.exports = {
  extends: 'expo',
  ignorePatterns: ['/dist/*'],
  env: {
    'react-native/react-native': true, // for React Native environment (e.g. __DEV__)
    node: true,                      // allows Node globals like process, module
    jest: true                       // if you have test files using Jest globals
  },
  globals: {
    __DEV__: 'readonly',
  },
  rules: {
    // Optional: adjust specific lint rules if needed
  }
};

  ```

- **.gitignore** (0.4 KB, 42 lines) *(No explicit exports)*

  ```text
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

app-example

.DS_Store


  ```

- **.windsurfrules** (0.0 KB, 1 lines) *(No explicit exports)*

  ```text

  ```

- **AETHER_TODO.md** (6.4 KB, 147 lines) *(No explicit exports)*

  ```md
# AETHER ― UI / UX & CODE UPGRADE TODO

## 1. GLOBAL DESIGN PRINCIPLES
- [ ] One source of truth → Tamagui theme tokens only (no hex)  
- [ ] Hierarchy first → large titles, section headers, cards  
- [ ] Micro-feedback everywhere → haptics + 200–300 ms fade / slide  
- [ ] Three state rule → loading ⬩ empty ⬩ error for every list / card  
- [ ] Motion restraint → 60 fps on low-end device; keep Lottie / confetti ≤2 s  

## 2. APP-LEVEL TASK LIST (sorted by impact / effort ratio)
- [ ] Finish TypeScript wiring for tRPC & Expo-router: remove all `as any`, `// @ts-ignore`
- [ ] Replace Tabs-in-Settings with list-style grouped sections
- [ ] Add pull-to-refresh to Home dashboard (`RefreshControl`)
- [ ] Introduce global `<ErrorToast>` + dashboard section `error` prop
- [ ] Introduce Floating-Action-Button (FAB) that speed-dials to "New Task / Habit / Goal"
- [ ] Add confetti + haptic success when reward claimed
- [ ] Skeleton component refactor – consume everywhere
- [ ] Dark-mode safe "frosted card" variant wrapped in Tamagui `styled(Card)`

## 3. SCREEN-BY-SCREEN GUIDANCE
### A. HOME (DASHBOARD)
- [ ] Header: `headerLargeTitle ("Good Morning")` with date sub-title
- [ ] Each section = `DashboardSection` (show 3 items + "See All")
  - [ ] Props to add: `skeletonCount`, `error`, `onRetry`
- [ ] Quick Actions → replace 3 buttons with FAB (`@expo/react-native-action-sheet` or custom)
- [ ] Animations: `AnimatePresence` fade-in list items; bounce card on habit check
- [ ] Pull-to-refresh: `<ScrollView refreshControl={<RefreshControl …/>}>`

### B. PLANNER (Tabs Goals / Habits / Calendar)
- [ ] Goals Tab → mount `GoalsList`; pass `isLoading`, `error`
  - [ ] Goal card progress bar animates width on mount (`withTiming`)
- [ ] Habits Tab → reuse `HabitsList`; optimistic toggle + revert on error
- [ ] Calendar Tab → prototype with `react-native-calendars`; dots = tasks/habits
- [ ] Tab switch animation: wrap each `<Tabs.Content>` in `<MotiView from={{opacity:0}} animate={{opacity:1}}>`

### C. COMPASS (Principles / States)
- [ ] Principles list (Card per principle). Empty state with 🧭 illustration
- [ ] State Definitions list: reuse `StateIndicator`; allow swipe-to-edit
- [ ] Add "Add Principle / Add State" FAB local to tab

### D. REWARDS
- [ ] Points card: count-up animation (`useValue, withTiming`)
- [ ] Earned rewards → horizontal `FlatList` (keyExtractor)
- [ ] Available rewards → 2-col grid; button shows `<Spinner>` while claiming
- [ ] Success: confetti (`react-native-confetti-cannon`) + `Haptics.notificationAsync(success)`

### E. SETTINGS
- [ ] Convert Tabs to grouped list:  
  - [ ] Profile (username, avatar)  
  - [ ] Account (password, 2FA, delete)  
  - [ ] Appearance (Dark Mode, System-theme)  
  - [ ] Notifications (push, email toggles)  
- [ ] Dark-mode switch: tri-state (Light / Dark / System)
- [ ] Each row: Tamagui `ListItem` variant with right-chevron

### F. AUTH FLOW
- [ ] Add logo to Login / Register
- [ ] Use Toast (non-blocking) for basic errors; Alert for critical
- [ ] Show / hide password icon inside Inputs (`secureTextEntry` toggle)
- [ ] After Register → Verify screen: add "Open email app" deep-link button (`Linking.openURL('message://')`)

## 4. COMPONENT REFACTOR NOTES
### 1. DashboardSection
```typescript
interface DashboardSectionProps<T> {  
  title: string;  
  data: T[];  
  renderItem(item:T): ReactNode;  
  seeAllRoute?: string;  
  isLoading?: boolean;  
  skeletonCount?: number;   // NEW  
  error?: string;           // NEW  
  onRetry?(): void;         // NEW  
}
```

### 2. Skeleton
- [ ] `Skeleton` = Tamagui `Stack` with animated opacity pulse
- [ ] Use in DashboardSection, GoalsList, HabitsList, etc.

### 3. HabitCheckItem vs HabitsList item
- [ ] Extract pure dumb `HabitToggleRow` (checkbox + title + streak)
- [ ] Dashboard & list reuse; parent passes `onToggle()` & disables during mutation

### 4. GoalSummaryCard vs GoalCard
- [ ] Keep Summary (ring) for dashboard; Detailed (bars) for Goals tab / Details
- [ ] Both share style variant via Tamagui `styled(Card)`

### 5. OfflineIndicator
- [ ] Replace hardcoded red with `$errorBackground`; use `safeAreaInsets.top` on Android too

## 5. TYPESCRIPT / ESLINT REMEDIATION
### A. Server build error (TS6059)
- [ ] Fix: extend `rootDir` OR move shared `types/` under `server/src/`
  Quick fix in `server/tsconfig.json`:
  ```json
  "rootDir": "../",
  "include": ["src/**/*", "../types/**/*"]
  ```

### B. tRPC client typing
- [ ] Generate helper type once:  
  ```typescript
  import type { AppRouter } from 'server/src/router';  
  export const trpc = createTRPCReact<AppRouter>();  
  ```
- [ ] Remove every `// @ts-ignore` + `as any` route cast

### C. Expo-router path types
- [ ] `app.d.ts`
  ```typescript
  declare module 'expo-router' {  
    interface LinkProps { href: `/compose` | `/planner` | ... }  
  }
  ```
- [ ] Or simpler: `router.push({ pathname:'/planner' })`

### D. Missing type-defs packages
- [ ] `@types/shopify__flash-list`, `@types/react-native-reanimated`, etc.  
  `yarn add -D @types/shopify__flash-list`

### E. Lint script
- [ ] `"lint": "eslint \"{app,components,server}/**/*.{ts,tsx}\" --fix"`  
- [ ] Fix all unused vars / imports; prefer `catch (err: unknown)`

## 6. TAMAGUI BEST PRACTICES CHECKLIST
- [ ] Only Tamagui components for layout (YStack/XStack/Text/Card)
- [ ] Use theme tokens (`$color`, `$backgroundStrong`)
- [ ] Create `styled()` variants for repeatable styles (frostedCard, sectionHeader)
- [ ] Configure Tamagui Compiler (metro) for perf
- [ ] Use `AnimatePresence` & `Stack animation="quick"` rather than StyleSheet animations where possible

## 7. IMPLEMENTATION PLAN (2-Week Sprint)
- [ ] Day 1-2   → Fix TypeScript config, remove ignores, green CI
- [ ] Day 3-4   → Refactor Skeleton + DashboardSection; integrate error prop
- [ ] Day 5     → FAB component + swap into Home
- [ ] Day 6-7   → Settings redesign to grouped list
- [ ] Day 8     → Rewards polish (confetti, claim spinner)
- [ ] Day 9-10  → Minor screens (Compass, Planner animations), QA, polish

## Deliverables for this sprint
- [ ] All TS errors resolved, no `@ts-ignore` in `app/` or `server/`  
- [ ] Dashboard displays error banners and supports pull-to-refresh  
- [ ] FAB replaces "Quick Actions" buttons  
- [ ] Settings → grouped list; Dark-Mode tri-state switch  
- [ ] Claiming a reward plays confetti + haptic  
- [ ] 100% ESLint clean (`npm run lint` passes) 
  ```

- **HAHA.js** (4.7 KB, 139 lines) *(No explicit exports)*

  ```js
#!/usr/bin/env node
// ------------------------------------------------------------------------------------
//  gather-context.js          v1.0
//  ------------------------------------------------------------------
//  Robust project summary generator in **pure Node.js**
//  • Works inside or outside a Git repo
//  • Quick-mode (-q) = only changed files since merge-base with origin/main
//  • Size limit flag (-s N) to inline files up to N KiB (default 512)
//  • Skips node_modules, .git, dist, coverage, assets, binaries, and huge files
//  • Generates a timestamped markdown (aetherOUT.md by default)
// ------------------------------------------------------------------------------------
import { execSync } from 'node:child_process';
import { statSync, createWriteStream, readFileSync, writeFileSync } from 'node:fs';
import { join, relative, dirname, extname } from 'node:path';
import globby from 'globby';
const { globbySync } = globby;
import { fileURLToPath } from 'node:url';
import { createHash } from 'node:crypto';

// ---------------------- CLI flags ----------------------
const argv = process.argv.slice(2);
const QUICK = argv.includes('-q');
const sizeIdx = argv.findIndex((f) => f === '-s');
const MAX_INLINE = (sizeIdx !== -1 ? Number(argv[sizeIdx + 1]) : 512) * 1024; // bytes
const OUT = 'aetherOUT.md';

// ---------------------- helpers ------------------------
const cwd = process.cwd();
const isGit = (() => {
  try { execSync('git rev-parse --is-inside-work-tree', { stdio: 'ignore' }); return true; }
  catch { return false; }
})();
const now = () => new Date().toISOString().replace(/[:T]/g, '-').split('.')[0];

const excludeGlobs = [
  '**/node_modules/**',
  '**/.git/**',
  '**/dist/**',
  '**/build/**',
  '**/coverage/**',
  '**/ios/Pods/**',
  '**/android/.gradle/**',
  '**/*.lock',
  '**/*.png',
  '**/*.jpg',
  '**/*.jpeg',
  '**/*.gif',
  '**/*.pdf',
  '**/*.ttf',
  '**/*.otf',
];

// Determine language fence from extension
const langMap = {
  '.ts': 'typescript', '.tsx': 'typescript', '.js': 'javascript', '.jsx': 'javascript',
  '.sh': 'bash', '.json': 'json', '.yml': 'yaml', '.yaml': 'yaml',
  '.sql': 'sql', '.graphql': 'graphql', '.gql': 'graphql', '.prisma': 'prisma',
  '.md': 'markdown', '.css': 'css', '.scss': 'scss',
};
const fenceFor = (f) => langMap[extname(f).toLowerCase()] ?? '';

const human = (bytes) => (bytes / 1024).toFixed(1) + ' KiB';

// ---------------------- collect file list --------------
let files = [];
if (isGit) {
  if (QUICK) {
    const base = execSync('git merge-base HEAD origin/main', { encoding: 'utf8' }).trim();
    files = execSync(`git diff --name-only ${base}..HEAD`, { encoding: 'utf8' })
      .split('\n').filter(Boolean);
  } else {
    files = execSync('git ls-files', { encoding: 'utf8' }).split('\n').filter(Boolean);
  }
  // add untracked
  files.push(
    ...execSync('git ls-files --others --exclude-standard', { encoding: 'utf8' })
      .split('\n').filter(Boolean)
  );
} else {
  files = globbySync(['**/*'], { gitignore: true });
}
// apply excludes
files = files.filter((f) => !excludeGlobs.some((pattern) => globbySync.isMatch(f, pattern)));
files.sort();

// ---------------------- write markdown -----------------
const out = createWriteStream(OUT, 'utf8');
const write = (s = '') => out.write(s + '\n');

write(`# Aether Context Dump — ${now()}`);
write('');
write('<!-- TOC -->\n');

let currentDir = '';
for (const file of files) {
  const dir = dirname(file).split('/')[0] || '(root)';
  if (dir !== currentDir) {
    currentDir = dir;
    write(`\n# ${dir}\n`);
  }

  const size = statSync(file).size;
  write(`\n### ${file}`);
  write(`**Size:** ${human(size)}`);

  if (size > MAX_INLINE) {
    write(`*(omitted — ${human(size)} > limit ${human(MAX_INLINE)})*`);
    continue;
  }

  const buf = readFileSync(file);
  const mime = execSync(`file -b --mime-type ${file}`).toString().trim();
  if (mime.startsWith('application/') && !mime.includes('json')) {
    write('*(binary omitted)*');
    continue;
  }

  const fence = fenceFor(file);
  write(`\n\`\`\`${fence}`);
  write(buf.toString('utf8'));
  write('```');
}

// ------------- post-process: inject TOC ----------------
out.end(() => {
  const md = readFileSync(OUT, 'utf8');
  const toc = md.split('\n')
    .filter((l) => l.match(/^#+\s/))
    .map((l) => {
      const lvl = l.match(/^#+/)[0].length;
      const title = l.replace(/^#+\s*/, '');
      const anchor = title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
      return `${'  '.repeat(lvl - 1)}- [${title}](#${anchor})`;
    }).join('\n');
  const final = md.replace('<!-- TOC -->', toc);
  writeFileSync(OUT, final);
  console.log(`✅  ${OUT} written (${files.length} files, inline ≤ ${human(MAX_INLINE)})`);
});

  ```

- **README.md** (2.3 KB, 119 lines) *(No explicit exports)*

  ```md
# Aether App

A modern mobile application built with Expo, React Native, tRPC, and Tamagui.

## Project Structure

- `/app` - Expo Router app screens and navigation
- `/components` - Reusable UI components
- `/utils` - Utility functions and helpers
- `/server` - Express/tRPC backend server

## Getting Started

### Prerequisites

- Node.js 18+ 
- npm or yarn
- iOS Simulator or Android Emulator for mobile testing

### Installing

1. Clone the repository
2. Install dependencies:

```bash
npm install
```

3. Install server dependencies:

```bash
cd server
npm install
cd ..
```

### Running the App

**Start the backend server:**

```bash
cd server
npm run dev
```

This will start the tRPC server on [http://localhost:3000](http://localhost:3000).

**Start the Expo app:**

In a separate terminal:

```bash
npm start
```

This will launch the Expo development server. Press:
- `i` to open in iOS simulator
- `a` to open in Android emulator
- `w` to open in web browser

## Authentication

The app uses Supabase for secure authentication:

1. Create a free Supabase account at [supabase.com](https://supabase.com)
2. Create a new project and note your project URL and anon key
3. Create a `.env` file in the root of the project (copy from `.env.example`) and add your Supabase credentials
4. Authentication is already set up with the following features:
   - Email/password sign up and login
   - Session persistence with SecureStore
   - Password reset (through Supabase)

Demo credentials:
  - Email: `demo@example.com`
  - Password: `password`

## Development

### Backend Server

The backend server uses:
- Express
- tRPC for type-safe API
- In-memory data store (replace with a real DB in production)

Key endpoints:
- `/health` - Health check endpoint
- `/api/trpc` - tRPC API endpoint

### Mobile App

The app is organized using Expo Router file-based routing:
- `/app/(tabs)` - Main tabs after login
- `/app/auth` - Authentication screens (login/register)
- `/app/compose` - Modal screen example

## Project Roadmap

Phase 1 (In Progress):
- Core authentication flow
- Basic UI components
- API integration

Phase 2 (Upcoming):
- Offline sync capabilities
- Push notifications
- Performance optimizations

## Technologies

- Expo SDK 52
- React Native 0.76.x
- React 18.3
- TypeScript
- tRPC
- Tamagui UI
- NativeWind/Tailwind CSS
- React Query for data fetching/caching

  ```

- **REFACTORING_PLAN_V2.yaml** (13.3 KB, 252 lines) *(No explicit exports)*

  ```yaml
title: Aether iPhone App - Enhanced Refactoring Plan (Post-Schema Update)
version: 2.0
last_updated: 2025-04-28 # Update with current date when executing

phases:
  - phase: 0
    name: Schema Update & Regeneration
    description: >
      Apply the enhanced database schema migration (`enhance_functional_schema.sql`) and regenerate all dependent types.
      This sets the stage for implementing new features and aligning existing code with the improved data model.
    status: Completed # Phase completed
    tasks:
      - id: SCHEMA-01
        name: Apply Enhanced Schema Migration
        details: >
          Apply the `enhance_functional_schema.sql` migration to the Supabase database using
          `supabase db push` or equivalent. Handle any manual data migration steps (e.g., for task priority enum mapping).
        status: Completed # Assuming this was done prior to type generation
        files_affected:
          - supabase/migrations/ (new file applied)
        testing_impact: None directly, but subsequent type generation depends on this. DB structure changes.
      - id: SCHEMA-02
        name: Regenerate Database Types
        details: >
          Run `npx supabase gen types typescript --linked > types/database.types.ts` to update
          the TypeScript definitions based on the newly migrated schema, capturing all new tables and columns.
        status: Completed # types/database.types.ts reflects new schema
        files_affected:
          - types/database.types.ts
        testing_impact: Foundational for all subsequent type checking and tests. Existing code referencing old types will show errors.

  - phase: 1
    name: Backend Alignment (Enhanced Schema)
    description: >
      Update Zod schemas and tRPC routers to fully reflect the enhanced database schema,
      including new fields for recurrence, archiving, sorting, habit types, reminders, etc.
      Update server-side tests accordingly.
    status: In Progress # Zod schemas done, Routers partially done
    tasks:
      - id: TYPE-02
        name: Update Zod Schemas for Enhanced DB
        details: >
          Modify Zod schemas in `server/src/types/trpc-types.ts` for `Goal`, `Habit`, `Task`,
          `Value`, `Principle`, `TrackedStateDef`, `HabitEntry`, `StateEntry` to include new fields
          (recurrence_rule, archived_at, sort_order, habit_type, goal_quantity, goal_unit,
          quantity_value, notes, target_min/max_value, etc.). Define new Zod schemas for
          `Reminder` and `GoalProgressNote`. Ensure enums match DB enums defined in the migration.
        status: Completed # server/src/types/trpc-types.ts updated
        files_affected:
          - server/src/types/trpc-types.ts
        testing_impact: Server tests will fail until routers are updated. Foundational for frontend typing.
      - id: BACKEND-06
        name: Refactor Routers for Enhanced Schema & CRUD
        details: >
          Update all tRPC routers (`goalRouter`, `habitRouter`, `taskRouter`, `valueRouter`,
          `trackedStateRouter`, `dashboardRouter`, etc.) to select, insert, and update
          the new fields defined in TYPE-02. Implement filtering for `archived_at` (e.g., `isNull('archived_at')`
          for active items). Add procedures for managing `Reminder` and `GoalProgressNote` tables. Update existing procedures to handle new fields (e.g., `habit_type`, `quantity_value` in habit logic).
        status: In Progress # Routers completed: Value, Principle, Goal, Task, Dashboard, Habit. Remaining: trackedStateRouter, reminderRouter, goalProgressNoteRouter
        files_affected:
          - server/src/routers/*.ts
        testing_impact: Requires significant updates to server tests (`__tests__/server/`) to mock and assert new fields and procedures.
      - id: BACKEND-07
        name: Update Server Tests for Enhanced Schema
        details: >
          Rewrite/update all tests in `__tests__/server/` to mock the enhanced Supabase schema
          (using `test-helpers.ts`) and assert that router procedures correctly handle the new
          fields, types (enums), and logic (e.g., archiving filters, recurrence handling if tested at router level).
        status: Not Started # Tests need update for new schema/logic
        files_affected:
          - __tests__/server/**/*.test.ts
          - __tests__/server/test-helpers.ts
        testing_impact: Ensures backend logic aligns with the new database structure.

  - phase: 2
    name: Frontend Type Consumption & Test Overhaul (Enhanced Schema)
    description: >
      Update frontend components and hooks to use the inferred `RouterOutputs` based on the
      enhanced backend schema from Phase 1. Remove remaining type casts and overhaul the UI test suite.
    status: Partially Implemented # Basic structure exists, but needs alignment with *new* types
    tasks:
      - id: FRONTEND-04
        name: Update Frontend Components for Enhanced Types
        details: >
          Refactor components in `app/` and `components/` (including `HomeScreen`, `PlannerScreen`,
          dashboard items, list items) to strictly use `RouterOutputs` inferred from the Phase 1
          backend changes. Access properties using correct names and types (including new fields like
          `archived_at`, `sort_order`, `quantity_value`, `notes`, etc., where applicable). Remove remaining
          `as any` / `@ts-ignore`.
        status: Partially Implemented # Needs update for new fields/types
        files_affected:
          - app/**/*.tsx
          - components/**/*.tsx
        testing_impact: Requires updating UI tests with mocks matching the *new* `RouterOutputs`.
      - id: TEST-02
        name: Overhaul Jest UI Test Suite & Config (Enhanced Schema)
        details: >
          Update all UI tests (`__tests__/` excluding `server/`) mocks, assertions, and snapshots
          to reflect the enhanced data structures and component props. Address flaky tests.
          Consolidate Jest configurations if still needed (remove `jest.server.config.js` if redundant).
        status: Partially Implemented # Needs update for new fields/types and config consolidation
        files_affected:
          - __tests__/**/*.test.tsx
          - __tests__/**/*.snap
          - jest.config.ui.js
          - jest.setup.js
          - jest.config.server.js / jest.server.config.js

  - phase: 3
    name: Feature Implementation (Core Functionality)
    description: >
      Build out core user-facing features leveraging the enhanced schema, including missing screens,
      recurrence, sub-tasks, reminders, archiving, and sorting.
    status: Not Started # Core features leveraging new schema are not built
    tasks:
      - id: FEAT-03
        name: Implement Recurrence UI & Logic
        details: >
          Add UI elements (e.g., in creation/edit modals) for setting `recurrence_rule` on tasks/habits.
          Update frontend logic to display recurring items correctly in lists/calendars.
        status: Not Started
        files_affected:
          - components/modals/* (TBD)
          - app/(tabs)/planner/index.tsx
          - components/lists/*.tsx
        testing_impact: Requires new UI tests for recurrence configuration and display.
      - id: FEAT-04
        name: Implement Sub-task UI & Logic
        details: >
          Allow creating tasks linked via `parent_task_id`. Update task detail screens and lists
          to display parent/child relationships and potentially roll up progress.
        status: Not Started
        files_affected:
          - components/modals/AddTask.tsx (TBD)
          - app/(tabs)/planner/task/[id].tsx (TBD)
          - components/lists/TaskList.tsx
        testing_impact: Requires new UI tests for sub-task creation, display, and interaction.
      - id: FEAT-05
        name: Implement Reminders UI & Logic
        details: >
          Add UI for setting `reminder_time` on tasks/goals/habits using the new `reminders` table.
          Implement logic to schedule/manage these reminders (potentially via `expo-notifications`).
        status: Not Started
        files_affected:
          - components/modals/* (TBD)
          - utils/notifications.ts (TBD)
          - server/src/routers/reminderRouter.ts (TBD)
        testing_impact: Requires new UI tests for setting reminders and potentially integration tests for notification scheduling.
      - id: FEAT-06
        name: Implement Archiving UI & Logic
        details: >
          Add "Archive" buttons/actions to goals, tasks, habits. Update list queries/filters
          to respect the `archived_at` field. Provide an "Archived Items" view (perhaps in Settings).
        status: Not Started
        files_affected:
          - components/lists/*.tsx
          - app/(tabs)/planner/*
          - app/(tabs)/settings/* (TBD Archive View)
        testing_impact: Requires UI tests for archive actions and filtering.
      - id: FEAT-07
        name: Implement Manual Sorting UI & Logic
        details: >
          Add drag-and-drop functionality (e.g., using `react-native-gesture-handler` + `reanimated`)
          to lists where `sort_order` exists (Goals, Values, Principles, Tasks). Update backend to
          handle reordering mutations.
        status: Not Started
        files_affected:
          - components/lists/*.tsx
          - app/(tabs)/planner/index.tsx
          - app/(tabs)/compass/index.tsx
        testing_impact: Requires complex UI interaction tests for drag-and-drop.
      - id: FEAT-08
        name: Implement Enhanced Habit Tracking UI
        details: >
          Update habit creation/edit modals and habit entry UI to support `habit_type` (boolean/quantity),
          `goal_quantity`, `goal_unit`, and entry `notes`/`quantity_value`. Update `HabitToggleRow` or replace.
        status: Not Started
        files_affected:
          - components/modals/AddHabit.tsx (TBD)
          - components/lists/HabitList.tsx
          - components/ui/HabitToggleRow.tsx (or replacement)
        testing_impact: Requires UI tests for quantity input, notes, and different habit type displays.
      - id: FEAT-09
        name: Implement Contextual Notes UI
        details: >
          Add input fields for `notes` on state entries and goal progress updates (`goal_progress_notes` table). Display these notes appropriately.
        status: Not Started
        files_affected:
          - app/(tabs)/compass/* (TBD State Entry UI)
          - app/(tabs)/planner/goal/[id].tsx (TBD Goal Detail)
        testing_impact: Requires UI tests for note input and display.
      - id: ROUTE-04
        name: Implement Missing Screens (Planner/Settings Details)
        details: >
          Build out the UI for detail screens identified as missing (e.g., `planner/goal/[id].tsx`,
          `settings/profile.tsx`). Create placeholder files first (ROUTE-02 from original plan). Connect them to the corresponding (now type-aligned) tRPC routers.
        status: Not Started # Files still missing
        files_affected:
          - app/(tabs)/planner/ (create files)
          - app/(tabs)/settings/ (create files)
        testing_impact: Requires writing new UI and integration tests for these screens.

  - phase: 4
    name: Advanced Features & Polish
    description: >
      Implement remaining major features (Compass, Rewards), complete the Tamagui migration,
      fully integrate offline sync, and address final cleanup tasks.
    status: Not Started # Advanced features not implemented
    tasks:
      - id: FEAT-10
        name: Implement Compass & Rewards Screens
        details: >
          Build out the UI for Compass (analytics using enhanced state/goal data) and Rewards screens using the backend data.
          Implement charts and reward redemption logic.
        status: Not Started
        files_affected:
          - app/(tabs)/compass/index.tsx
          - app/(tabs)/rewards/index.tsx
          - components/charts/* (TBD)
          - components/rewards/*
        testing_impact: Requires new UI tests for charts, reward lists, and redemption flow.
      - id: FEAT-11
        name: Fully Integrate Offline Mutation Queue
        details: >
          Ensure `saveOfflineMutation` is robustly integrated into *all* relevant `useMutation` hooks.
          Add UI indicators for pending sync items (`useOfflineSync` hook). Test edge cases thoroughly.
        status: Not Implemented # Integration is pending
        files_affected:
          - Hooks/Components using `useMutation`
          - components/ui/OfflineIndicator.tsx (or similar)
        testing_impact: Requires comprehensive offline integration testing.
      - id: REFACTOR-02
        name: Complete Tamagui Migration & Cleanup
        details: >
          Eliminate remaining non-Tamagui primitives (`View`, `Text`, etc.). Ensure consistent token usage. Remove custom
          `providers/ToastProvider.tsx` in favor of `@tamagui/toast`.
        status: Partially Implemented # Migration ongoing, ToastProvider exists
        files_affected:
          - components/**/*.tsx
          - app/**/*.tsx
          - providers/ToastProvider.tsx (delete)
          - providers/Providers.tsx
        testing_impact: Update UI tests. Snapshots will change.
      - id: CLEANUP-02
        name: Address Remaining TODOs and Lint Warnings
        details: >
          Final pass through `AETHER_TODO.md`, `refactor_checklist.md`. Resolve all lint warnings/errors.
        status: Partially Implemented # TODOs remain
        files_affected:
          - Various
        testing_impact: Minor test adjustments likely.

  ```

- **SUPABASE_INTEGRATION.md** (4.7 KB, 173 lines) *(No explicit exports)*

  ```md
# Aether App - Supabase Integration

## What's Been Integrated

1. **Supabase Authentication**
   - Email/password login and registration
   - Secure token storage using Expo SecureStore
   - Authentication state management
   - Automatic session refresh

2. **User Profiles**
   - Basic profile retrieval through Supabase
   - User metadata storage

3. **App Configuration**
   - Added settings management with SecureStore
   - Environment variable setup for Supabase credentials

## Setup Instructions

1. **Create a Supabase Project**
   - Sign up at [supabase.com](https://supabase.com)
   - Create a new project
   - Note your project URL and anon key

2. **Local Setup**
   - Copy `.env.example` to `.env`
   - Fill in your Supabase URL and anon key
   ```
   EXPO_PUBLIC_SUPABASE_URL=your_supabase_url_here
   EXPO_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key_here
   ```

3. **Database Setup in Supabase**
   - Create a `profiles` table with the SQL below:

   ```sql
   create table public.profiles (
     id uuid references auth.users not null primary key,
     username text,
     avatar_url text,
     created_at timestamp with time zone default now(),
     updated_at timestamp with time zone default now()
   );

   -- Enable RLS
   alter table public.profiles enable row level security;

   -- Create a policy that allows users to read all profiles
   create policy "Profiles are viewable by everyone" on profiles
     for select using (true);

   -- Create a policy that allows users to update only their own profile
   create policy "Users can update their own profile" on profiles
     for update using (auth.uid() = id);

   -- Function to create a profile when a user signs up
   create or replace function public.handle_new_user()
   returns trigger as $$
   begin
     insert into public.profiles (id, username, avatar_url)
     values (new.id, new.raw_user_meta_data->>'username', null);
     return new;
   end;
   $$ language plpgsql security definer;

   -- Trigger to create a profile when a user signs up
   create trigger on_auth_user_created
     after insert on auth.users
     for each row execute procedure public.handle_new_user();
   ```

## Next Steps

1. **Real-time Data Sync**
   - Set up Supabase Realtime for subscriptions
   - Implement data sync with React Query + Supabase

2. **Storage**
   - Implement Supabase Storage for file uploads (profile pictures, attachments)

3. **Offline Support**
   - Implement offline queue for mutations
   - Set up background sync

4. **Testing**
   - Create a test project in Supabase for CI/CD environments

## Implementation Details

### Authentication Flow

1. User enters credentials in login/register screen
2. Supabase SDK handles authentication
3. Supabase stores tokens in SecureStore
4. Authentication state is managed in _layout.tsx
5. Pages use authentication state to redirect as needed

### Profile Management

The `getUserProfile` function demonstrates how to:
1. Get the current authenticated user
2. Query their profile information from the database
3. Handle cases where the profile hasn't been created yet

### Logout Flow

The logout function:
1. Calls Supabase signOut
2. Clears session state
3. Redirects to login 

## Offline Support

We've implemented a comprehensive offline-first architecture using:

1. **React Query Persistence**
   - Queries are cached in AsyncStorage
   - Mutations are paused when offline and resumed when online
   - Cache is rehydrated on app restart

2. **Visual Indicators**
   - OfflineIndicator component shows network status
   - Pending items are marked with a visual badge

3. **Custom Offline Sync System**
   - Mutations are stored in AsyncStorage when offline
   - Automatic sync when the device reconnects
   - Support for create, update, and delete operations

### Using Offline Sync in Components

```tsx
import { useOfflineSync } from '@/hooks/useOfflineSync';

// In your component
function TaskList() {
  // Set up offline sync for the 'tasks' entity
  const { 
    isOnline, 
    pendingItems, 
    createItem, 
    updateItem, 
    deleteItem, 
    isItemPending 
  } = useOfflineSync<Task>('tasks');

  // Create a new task (works offline)
  const handleAddTask = async () => {
    const { id, isOffline } = await createItem({ 
      title: 'New Task',
      completed: false
    });
    
    // The task is created with a temporary ID if offline
    console.log(`Task created with ID: ${id}, offline: ${isOffline}`);
  };

  // In your render function, show pending state
  return (
    <View>
      {tasks.map(task => (
        <View key={task.id}>
          <Text>{task.title}</Text>
          {isItemPending(task.id) && (
            <Badge>Pending Sync</Badge>
          )}
        </View>
      ))}
    </View>
  );
}
``` 
  ```

- **aetherOUT.md** (1071.6 KB, 32588 lines) *(No explicit exports)*

  ```md
# Aether iPhone: Complete Migration Context
Generated on Wed Apr 30 04:23:50 CDT 2025

- [ Aether iPhone: Complete Migration Context](#-aether-iphone-complete-migration-context)
- [ (root files)](#-root-files-)
    - [ .env](#-env)
    - [ .env.example](#-env-example)
- [ Supabase Configuration\nEXPO_PUBLIC_SUPABASE_URL=your_supabase_url_here\nEXPO_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key_here](#-supabase-configuration-nexpo-public-supabase-url-your-supabase-url-here-nexpo-public-supabase-anon-key-your-supabase-anon-key-here)
    - [ .eslintrc.js](#-eslintrc-js)
- [ .github](#-github)
    - [ ci.yml](#-ci-yml)
- [ (root files)](#-root-files-)
    - [ .gitignore](#-gitignore)
- [ Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files](#-learn-more-https-docs-github-com-en-get-started-getting-started-with-git-ignoring-files)
- [ dependencies](#-dependencies)
- [ Expo](#-expo)
- [ Native](#-native)
- [ Metro](#-metro)
- [ debug](#-debug)
- [ macOS](#-macos)
- [ local env files](#-local-env-files)
- [ typescript](#-typescript)
- [ .tamagui](#-tamagui)
    - [ tamagui.config.json](#-tamagui-config-json)
- [ (root files)](#-root-files-)
    - [ .windsurfrules](#-windsurfrules)
    - [ AETHER_TODO.md](#-aether-todo-md)
- [ AETHER ― UI / UX & CODE UPGRADE TODO](#-aether-ui-ux-code-upgrade-todo)
  - [ 1. GLOBAL DESIGN PRINCIPLES](#-1-global-design-principles)
  - [ 2. APP-LEVEL TASK LIST (sorted by impact / effort ratio)](#-2-app-level-task-list-sorted-by-impact-effort-ratio-)
  - [ 3. SCREEN-BY-SCREEN GUIDANCE](#-3-screen-by-screen-guidance)
    - [ A. HOME (DASHBOARD)](#-a-home-dashboard-)
    - [ B. PLANNER (Tabs Goals / Habits / Calendar)](#-b-planner-tabs-goals-habits-calendar-)
    - [ C. COMPASS (Principles / States)](#-c-compass-principles-states-)
    - [ D. REWARDS](#-d-rewards)
    - [ E. SETTINGS](#-e-settings)
    - [ F. AUTH FLOW](#-f-auth-flow)
  - [ 4. COMPONENT REFACTOR NOTES](#-4-component-refactor-notes)
    - [ 1. DashboardSection](#-1-dashboardsection)
    - [ 2. Skeleton](#-2-skeleton)
    - [ 3. HabitCheckItem vs HabitsList item](#-3-habitcheckitem-vs-habitslist-item)
    - [ 4. GoalSummaryCard vs GoalCard](#-4-goalsummarycard-vs-goalcard)
    - [ 5. OfflineIndicator](#-5-offlineindicator)
  - [ 5. TYPESCRIPT / ESLINT REMEDIATION](#-5-typescript-eslint-remediation)
    - [ A. Server build error (TS6059)](#-a-server-build-error-ts6059-)
    - [ B. tRPC client typing](#-b-trpc-client-typing)
    - [ C. Expo-router path types](#-c-expo-router-path-types)
    - [ D. Missing type-defs packages](#-d-missing-type-defs-packages)
    - [ E. Lint script](#-e-lint-script)
  - [ 6. TAMAGUI BEST PRACTICES CHECKLIST](#-6-tamagui-best-practices-checklist)
  - [ 7. IMPLEMENTATION PLAN (2-Week Sprint)](#-7-implementation-plan-2-week-sprint-)
  - [ Deliverables for this sprint](#-deliverables-for-this-sprint)
    - [ README.md](#-readme-md)
- [ Aether App](#-aether-app)
  - [ Project Structure](#-project-structure)
  - [ Getting Started](#-getting-started)
    - [ Prerequisites](#-prerequisites)
    - [ Installing](#-installing)
    - [ Running the App](#-running-the-app)
  - [ Authentication](#-authentication)
  - [ Development](#-development)
    - [ Backend Server](#-backend-server)
    - [ Mobile App](#-mobile-app)
  - [ Project Roadmap](#-project-roadmap)
  - [ Technologies](#-technologies)
    - [ REFACTORING_PLAN_V2.yaml](#-refactoring-plan-v2-yaml)
    - [ SUPABASE_INTEGRATION.md](#-supabase-integration-md)
- [ Aether App - Supabase Integration](#-aether-app-supabase-integration)
  - [ What's Been Integrated](#-what-s-been-integrated)
  - [ Setup Instructions](#-setup-instructions)
  - [ Next Steps](#-next-steps)
  - [ Implementation Details](#-implementation-details)
    - [ Authentication Flow](#-authentication-flow)
    - [ Profile Management](#-profile-management)
    - [ Logout Flow](#-logout-flow)
  - [ Offline Support](#-offline-support)
    - [ Using Offline Sync in Components](#-using-offline-sync-in-components)
- [ __tests__](#-tests-)
    - [ HabitCheckItem.test.tsx](#-habitcheckitem-test-tsx)
    - [ GoalList.test.tsx](#-goallist-test-tsx)
    - [ HabitList.test.tsx](#-habitlist-test-tsx)
    - [ TaskList.test.tsx](#-tasklist-test-tsx)
    - [ AetherCard.test.tsx](#-aethercard-test-tsx)
    - [ AetherListItem.test.tsx](#-aetherlistitem-test-tsx)
    - [ dashboardRouter.getWeeklyProgress.test.ts](#-dashboardrouter-getweeklyprogress-test-ts)
    - [ dashboardRouter.test.ts](#-dashboardrouter-test-ts)
    - [ habitRouter.test.ts](#-habitrouter-test-ts)
    - [ taskRouter.toggleTask.test.ts](#-taskrouter-toggletask-test-ts)
    - [ test-helpers.ts](#-test-helpers-ts)
    - [ test-utils.tsx](#-test-utils-tsx)
- [ (root files)](#-root-files-)
    - [ aether_styling_context.txt](#-aether-styling-context-txt)
    - [ app.json](#-app-json)
- [ app](#-app)
    - [ _layout.tsx](#-layout-tsx)
    - [ forgot-password.tsx](#-forgot-password-tsx)
    - [ login.tsx](#-login-tsx)
    - [ register.tsx](#-register-tsx)
    - [ _layout.tsx](#-layout-tsx)
    - [ index.tsx](#-index-tsx)
    - [ index.gluestack.tsx](#-index-gluestack-tsx)
    - [ index.tsx](#-index-tsx)
    - [ _layout.tsx](#-layout-tsx)
    - [ add-goal.tsx](#-add-goal-tsx)
    - [ add-habit.tsx](#-add-habit-tsx)
    - [ add-task.tsx](#-add-task-tsx)
    - [ [id].tsx](#-id-tsx)
    - [ [id].tsx](#-id-tsx)
    - [ index.tsx](#-index-tsx)
    - [ index.tsx](#-index-tsx)
    - [ _layout.tsx](#-layout-tsx)
    - [ about.tsx](#-about-tsx)
    - [ help.tsx](#-help-tsx)
    - [ index.tsx](#-index-tsx)
    - [ notifications.tsx](#-notifications-tsx)
    - [ privacy.tsx](#-privacy-tsx)
    - [ profile.tsx](#-profile-tsx)
    - [ security.tsx](#-security-tsx)
    - [ _layout.tsx](#-layout-tsx)
    - [ SectionCard.tsx](#-sectioncard-tsx)
    - [ SwipeableRow.tsx](#-swipeablerow-tsx)
    - [ TaskRow.tsx](#-taskrow-tsx)
    - [ compose.tsx](#-compose-tsx)
    - [ index.tsx](#-index-tsx)
    - [ useDashboardQuery.ts](#-usedashboardquery-ts)
    - [ useToggleTaskStatus.ts](#-usetoggletaskstatus-ts)
    - [ add-habit.tsx](#-add-habit-tsx)
    - [ index.tsx](#-index-tsx)
    - [ index.tsx](#-index-tsx)
    - [ [id].tsx](#-id-tsx)
    - [ api-types.ts](#-api-types-ts)
    - [ [id].tsx](#-id-tsx)
- [ (root files)](#-root-files-)
    - [ babel.config.js](#-babel-config-js)
- [ components](#-components)
    - [ EmptyOrSkeleton.tsx](#-emptyorskeleton-tsx)
    - [ ProgressRing.tsx](#-progressring-tsx)
    - [ FloatingInput.tsx](#-floatinginput-tsx)
    - [ PrincipleCard.tsx](#-principlecard-tsx)
    - [ PrinciplesTab.tsx](#-principlestab-tsx)
    - [ StateDefinitionCard.tsx](#-statedefinitioncard-tsx)
    - [ DailyProgressBanner.tsx](#-dailyprogressbanner-tsx)
    - [ DashboardSection.tsx](#-dashboardsection-tsx)
    - [ GoalSummaryCard.tsx](#-goalsummarycard-tsx)
    - [ HabitCheckItem.tsx](#-habitcheckitem-tsx)
    - [ StateIndicator.tsx](#-stateindicator-tsx)
    - [ TaskItem.tsx](#-taskitem-tsx)
    - [ GoalList.tsx](#-goallist-tsx)
    - [ HabitList.tsx](#-habitlist-tsx)
    - [ TaskList.tsx](#-tasklist-tsx)
    - [ index.ts](#-index-ts)
    - [ GoalsList.tsx](#-goalslist-tsx)
    - [ HabitTracker.tsx](#-habittracker-tsx)
    - [ HabitsList.tsx](#-habitslist-tsx)
    - [ StreakCalendar.tsx](#-streakcalendar-tsx)
    - [ ConfettiBurst.tsx](#-confettiburst-tsx)
    - [ NotificationRow.tsx](#-notificationrow-tsx)
    - [ ThemePreview.tsx](#-themepreview-tsx)
    - [ Container.tsx](#-container-tsx)
    - [ EmptyOrSkeleton.tsx](#-emptyorskeleton-tsx)
    - [ ErrorBanner.tsx](#-errorbanner-tsx)
    - [ InteractiveCard.tsx](#-interactivecard-tsx)
    - [ Section.tsx](#-section-tsx)
    - [ Skeleton.tsx](#-skeleton-tsx)
    - [ SwipeableRow.tsx](#-swipeablerow-tsx)
    - [ AetherCard.tsx](#-aethercard-tsx)
    - [ AetherListItem.tsx](#-aetherlistitem-tsx)
    - [ SectionHeader.tsx](#-sectionheader-tsx)
    - [ index.ts](#-index-ts)
- [ constants](#-constants)
    - [ Colors.ts](#-colors-ts)
    - [ motion.ts](#-motion-ts)
- [ debug](#-debug)
    - [ toast-test.tsx](#-toast-test-tsx)
- [ (root files)](#-root-files-)
    - [ debug_context.txt](#-debug-context-txt)
- [ design-system](#-design-system)
    - [ Animations.ts](#-animations-ts)
    - [ Primitives.tsx](#-primitives-tsx)
    - [ theme.glue.ts](#-theme-glue-ts)
    - [ tokens.ts](#-tokens-ts)
- [ (root files)](#-root-files-)
    - [ eas.json](#-eas-json)
    - [ file_hierarchy.txt](#-file-hierarchy-txt)
    - [ gather_debug_info.js](#-gather-debug-info-js)
    - [ gather_implementation_details.sh](#-gather-implementation-details-sh)
                    - [!/bin/bash](#-bin-bash)
- [ Create or truncate the implementation_details.txt file](#-create-or-truncate-the-implementation-details-txt-file)
- [ Function to add a file to the output with header](#-function-to-add-a-file-to-the-output-with-header)
- [ Function to add just a section header](#-function-to-add-just-a-section-header)
- [ 1. tRPC Routers and Procedures](#-1-trpc-routers-and-procedures)
- [ First, find all router files](#-first-find-all-router-files)
- [ Look for router imports/exports to find the main app router](#-look-for-router-imports-exports-to-find-the-main-app-router)
- [ Check if there's a dashboard-specific router](#-check-if-there-s-a-dashboard-specific-router)
- [ Core entity routers (based on user's mention)](#-core-entity-routers-based-on-user-s-mention-)
- [ 2. Points Economy Endpoint](#-2-points-economy-endpoint)
- [ Look for reward or points related files](#-look-for-reward-or-points-related-files)
- [ Check for reward/points routers](#-check-for-reward-points-routers)
- [ Check for points mutation handlers](#-check-for-points-mutation-handlers)
- [ Frontend reward/points components](#-frontend-reward-points-components)
- [ 3. Realtime Strategy](#-3-realtime-strategy)
- [ Check for Supabase realtime implementation](#-check-for-supabase-realtime-implementation)
- [ Look for channel subscriptions](#-look-for-channel-subscriptions)
- [ Check for polling mechanisms](#-check-for-polling-mechanisms)
- [ 4. Core Query Hooks](#-4-core-query-hooks)
- [ Extract query hooks from the codebase](#-extract-query-hooks-from-the-codebase)
- [ Look for any usage of tRPC queries](#-look-for-any-usage-of-trpc-queries)
- [ 5. Swipe-to-Complete Implementation](#-5-swipe-to-complete-implementation)
- [ Look for swipe implementations](#-look-for-swipe-implementations)
- [ Check task completion handlers](#-check-task-completion-handlers)
    - [ gather_integrated_context.sh](#-gather-integrated-context-sh)
                    - [!/bin/bash](#-bin-bash)
- [ Create or truncate the project.txt file](#-create-or-truncate-the-project-txt-file)
- [ Function to add a file to the project.txt with header](#-function-to-add-a-file-to-the-project-txt-with-header)
- [ Function to add just the section header](#-function-to-add-just-the-section-header)
- [ --- 1. Core Design System ---](#-1-core-design-system-)
- [ Add current tamagui.config.ts](#-add-current-tamagui-config-ts)
- [ Add current tailwind.config.js](#-add-current-tailwind-config-js)
- [ Add constants/motion.ts for animation reference](#-add-constants-motion-ts-for-animation-reference)
- [ Note planned files that don't exist yet](#-note-planned-files-that-don-t-exist-yet)
- [ --- 2. Global Providers ---](#-2-global-providers-)
- [ Current app/_layout.tsx implementation](#-current-app-layout-tsx-implementation)
- [ Show existing provider implementations](#-show-existing-provider-implementations)
- [ Note planned providers](#-note-planned-providers)
- [ --- 3. Navigation Shells ---](#-3-navigation-shells-)
- [ Current tab layout implementation](#-current-tab-layout-implementation)
- [ Current auth layout implementation](#-current-auth-layout-implementation)
- [ --- 4. Reusable Components ---](#-4-reusable-components-)
- [ Show current primitive components](#-show-current-primitive-components)
- [ Show some key components that will need conversion](#-show-some-key-components-that-will-need-conversion)
- [ Note planned components](#-note-planned-components)
- [ --- 5. Feature Screens ---](#-5-feature-screens-)
- [ Show current implementations of main feature screens](#-show-current-implementations-of-main-feature-screens)
- [ --- 6. Utilities & Hooks ---](#-6-utilities-hooks-)
- [ Show current client implementations](#-show-current-client-implementations)
- [ --- 7. Type Definitions (for reference) ---](#-7-type-definitions-for-reference-)
- [ --- 8. Assets ---](#-8-assets-)
- [ Just list asset directories](#-just-list-asset-directories)
    - [ gather_project_context.sh](#-gather-project-context-sh)
                    - [!/bin/bash](#-bin-bash)
- [ Create or truncate the project.txt file](#-create-or-truncate-the-project-txt-file)
- [ Add refactoring plan to the beginning](#-add-refactoring-plan-to-the-beginning)
  - [ Refactoring Plan](#-refactoring-plan)
    - [ 1️⃣ Core Design System (/design-system)](#-1-core-design-system-design-system-)
    - [ 2️⃣ Global Providers](#-2-global-providers)
    - [ 3️⃣ Navigation Shells (Expo Router)](#-3-navigation-shells-expo-router-)
    - [ 4️⃣ Reusable Components (app/components)](#-4-reusable-components-app-components-)
    - [ 5️⃣ Feature Folders](#-5-feature-folders)
      - [ 🛡 Home app/dashboard](#-home-app-dashboard)
      - [ 📜 Planner app/planner](#-planner-app-planner)
      - [ 🧭 Compass app/compass](#-compass-app-compass)
      - [ 🎁 Rewards app/rewards](#-rewards-app-rewards)
      - [ ⚙️ Settings app/settings](#-settings-app-settings)
    - [ 6️⃣ Utils & Hooks (app/lib)](#-6-utils-hooks-app-lib-)
    - [ 7️⃣ Assets](#-7-assets)
    - [ 8️⃣ Testing & CI](#-8-testing-ci)
    - [ 🔮 Assumptions / Unknowns](#-assumptions-unknowns)
- [ Function to add a file to the project.txt](#-function-to-add-a-file-to-the-project-txt)
- [ 1) Core Configuration Files](#-1-core-configuration-files)
- [ Main config files](#-main-config-files)
- [ 2) Type Definitions (important for migrating to new system)](#-2-type-definitions-important-for-migrating-to-new-system-)
- [ 3) Global Providers](#-3-global-providers)
- [ Find all provider files](#-find-all-provider-files)
- [ Find utils with client setup (for trpc and supabase)](#-find-utils-with-client-setup-for-trpc-and-supabase-)
- [ 4) Navigation Layout Files](#-4-navigation-layout-files)
- [ 5) Key UI Components for Migration](#-5-key-ui-components-for-migration)
- [ UI primitives first](#-ui-primitives-first)
- [ Core shared components that will need migration](#-core-shared-components-that-will-need-migration)
- [ 6) Feature Screens](#-6-feature-screens)
- [ Core feature screens](#-core-feature-screens)
- [ 7) Assets](#-7-assets)
- [ Just list asset directories](#-just-list-asset-directories)
    - [ gather_tamagui_styles.sh](#-gather-tamagui-styles-sh)
                    - [!/bin/bash](#-bin-bash)
- [ Create or truncate the project.txt file](#-create-or-truncate-the-project-txt-file)
- [ Function to add a file to the project.txt](#-function-to-add-a-file-to-the-project-txt)
- [ Add main Tamagui configuration files](#-add-main-tamagui-configuration-files)
- [ Process all component directories](#-process-all-component-directories)
- [ Find all component files](#-find-all-component-files)
- [ Process all app screens](#-process-all-app-screens)
- [ Find all app screen files](#-find-all-app-screen-files)
- [ Add constants and utils](#-add-constants-and-utils)
- [ List of styling utility files](#-list-of-styling-utility-files)
    - [ global.d.ts](#-global-d-ts)
- [ hooks](#-hooks)
    - [ useColorScheme.ts](#-usecolorscheme-ts)
    - [ useColorScheme.web.ts](#-usecolorscheme-web-ts)
    - [ useOfflineSync.ts](#-useofflinesync-ts)
    - [ useSkeleton.ts](#-useskeleton-ts)
    - [ useThemeColor.ts](#-usethemecolor-ts)
- [ (root files)](#-root-files-)
    - [ implementation_details.txt](#-implementation-details-txt)
    - [ index.js](#-index-js)
    - [ jest.config.server.js](#-jest-config-server-js)
    - [ jest.config.ui.js](#-jest-config-ui-js)
    - [ jest.server.config.js](#-jest-server-config-js)
    - [ jest.server.setup.js](#-jest-server-setup-js)
    - [ jest.setup.js](#-jest-setup-js)
    - [ metro.config.js](#-metro-config-js)
- [ modals](#-modals)
    - [ compose.tsx](#-compose-tsx)
- [ (root files)](#-root-files-)
    - [ o3.txt](#-o3-txt)
- [ output](#-output)
    - [ app_code_overview.txt](#-app-code-overview-txt)
    - [ routing.md](#-routing-md)
- [ Aether iPhone App – Routing Audit](#-aether-iphone-app-routing-audit)
  - [ 1. Current Route File Structure (`app/`)](#-1-current-route-file-structure-app-)
  - [ 2. Tab Layout vs. Discovered Children](#-2-tab-layout-vs-discovered-children)
  - [ 3. Navigation Calls (`router.push`) vs. Real Files](#-3-navigation-calls-router-push-vs-real-files)
    - [ 3.1  Planner-related pushes](#-3-1-planner-related-pushes)
    - [ 3.2 Home quick-actions](#-3-2-home-quick-actions)
    - [ 3.3 Settings pushes](#-3-3-settings-pushes)
    - [ 3.4 Auth flow](#-3-4-auth-flow)
  - [ 4. Initial Route / Deep Linking](#-4-initial-route-deep-linking)
  - [ 5. Recommended Fixes (Action List)](#-5-recommended-fixes-action-list-)
  - [ 6. After Patching](#-6-after-patching)
    - [ tamagui.md](#-tamagui-md)
- [ Aether iPhone App – Tamagui Integration Blueprint](#-aether-iphone-app-tamagui-integration-blueprint)
  - [ 1. Why Tamagui?](#-1-why-tamagui-)
  - [ 2. Current Pain Points](#-2-current-pain-points)
  - [ 3. Foundations – One Source of Truth](#-3-foundations-one-source-of-truth)
    - [ 3.1 Tamagui config](#-3-1-tamagui-config)
    - [ 3.2 Providers Layer](#-3-2-providers-layer)
  - [ 4. Screen Composition Pattern](#-4-screen-composition-pattern)
    - [ Rules](#-rules)
  - [ 5. Toast Strategy](#-5-toast-strategy)
  - [ 6. tRPC + Tamagui + React Query Glue](#-6-trpc-tamagui-react-query-glue)
  - [ 7. Routing Alignment](#-7-routing-alignment)
  - [ 8. Migration Checklist](#-8-migration-checklist)
  - [ 9. Resources & References](#-9-resources-references)
  - [ 10. Conclusion](#-10-conclusion)
  - [ 11. Screen-by-Screen Tamagui Implementation Plan](#-11-screen-by-screen-tamagui-implementation-plan)
    - [ Implementation Order](#-implementation-order)
    - [ Type-Safety Hooks](#-type-safety-hooks)
    - [ Global ESLint Rule](#-global-eslint-rule)
  - [ 12. Confirmation of Comprehensive Tamagui Usage](#-12-confirmation-of-comprehensive-tamagui-usage)
    - [ type-diagnosis.md](#-type-diagnosis-md)
- [ Aether iPhone App – End-to-End Type-System Diagnosis](#-aether-iphone-app-end-to-end-type-system-diagnosis)
  - [ 1. Summary](#-1-summary)
  - [ 2. Screens & Components](#-2-screens-components)
  - [ 3. tRPC Procedures](#-3-trpc-procedures)
  - [ 4. Shared Type Definitions (`server/src/types/trpc-types.ts`)](#-4-shared-type-definitions-server-src-types-trpc-types-ts-)
  - [ 5. Gaps & Recommendations](#-5-gaps-recommendations)
  - [ 6. Next Steps Checklist](#-6-next-steps-checklist)
    - [ 🚀 Once these fixes land, the client and server will share a robust, fully inferred end-to-end type-system.](#-once-these-fixes-land-the-client-and-server-will-share-a-robust-fully-inferred-end-to-end-type-system-)
- [ (root files)](#-root-files-)
    - [ package.json](#-package-json)
    - [ postcss.config.js](#-postcss-config-js)
    - [ project.txt](#-project-txt)
- [ Aether iPhone: Tamagui to Gluestack/NativeWind Migration](#-aether-iphone-tamagui-to-gluestack-nativewind-migration)
    - [ project_structure.txt](#-project-structure-txt)
- [ providers](#-providers)
    - [ AppProvider.tsx](#-appprovider-tsx)
    - [ ConfettiProvider.tsx](#-confettiprovider-tsx)
    - [ GluestackProvider.tsx](#-gluestackprovider-tsx)
    - [ Providers.tsx](#-providers-tsx)
- [ (root files)](#-root-files-)
    - [ refactor_checklist.md](#-refactor-checklist-md)
- [ Aether App – Holistic Refactor Checklist](#-aether-app-holistic-refactor-checklist)
  - [ 0  Legend](#-0-legend)
  - [ 1  Design-System / Tamagui](#-1-design-system-tamagui)
  - [ 2  Data Layer (tRPC ⇄ Supabase)](#-2-data-layer-trpc-supabase-)
  - [ 3  Screens – Functional Requirements](#-3-screens-functional-requirements)
    - [ 3.1  Home (Dashboard)](#-3-1-home-dashboard-)
    - [ 3.2  Planner](#-3-2-planner)
    - [ 3.3  Compass](#-3-3-compass)
    - [ 3.4  Rewards](#-3-4-rewards)
    - [ 3.5  Settings](#-3-5-settings)
  - [ 4  Creation & Detail Screens](#-4-creation-detail-screens)
  - [ 5  Reusable Components to Implement](#-5-reusable-components-to-implement)
  - [ 6  UX Enhancements](#-6-ux-enhancements)
  - [ 7  Testing & CI](#-7-testing-ci)
  - [ 8  Technical Debt / Notes](#-8-technical-debt-notes)
  - [ 9  Priority Roadmap (macro)](#-9-priority-roadmap-macro-)
    - [ refactoring_plan.md](#-refactoring-plan-md)
- [ Aether iOS App – Comprehensive Refactor Plan](#-aether-ios-app-comprehensive-refactor-plan)
  - [ 1  Objectives](#-1-objectives)
  - [ 2  Guiding Principles & Key Packages](#-2-guiding-principles-key-packages)
  - [ 3  Navigation Hierarchy](#-3-navigation-hierarchy)
  - [ 4  Screen-by-Screen Specs](#-4-screen-by-screen-specs)
    - [ 4.1  Home (`(tabs)/home/index.tsx`)](#-4-1-home-tabs-home-index-tsx-)
    - [ 4.2  Planner Index (`(tabs)/planner/index.tsx`)](#-4-2-planner-index-tabs-planner-index-tsx-)
    - [ 4.3  Creation Modals (`add-goal.tsx`, `add-habit.tsx`, `add-task.tsx`)](#-4-3-creation-modals-add-goal-tsx-add-habit-tsx-add-task-tsx-)
    - [ 4.4  Detail Screens](#-4-4-detail-screens)
    - [ 4.5  Compass & Rewards (MVP)](#-4-5-compass-rewards-mvp-)
    - [ 4.6  Settings Stack](#-4-6-settings-stack)
  - [ 5  Reusable Components Library](#-5-reusable-components-library)
  - [ 6  State & Logic](#-6-state-logic)
  - [ 7  Environment & Secrets](#-7-environment-secrets)
- [ app.config.js reads these via process.env](#-app-config-js-reads-these-via-process-env)
  - [ 8  Testing & CI](#-8-testing-ci)
  - [ 9  TODO Checklist (Living)](#-9-todo-checklist-living-)
- [ scripts](#-scripts)
    - [ generate-all.js](#-generate-all-js)
    - [ generate-trpc-client.js](#-generate-trpc-client-js)
    - [ generate-trpc-types.js](#-generate-trpc-types-js)
    - [ generate_app_code_overview.sh](#-generate-app-code-overview-sh)
                    - [!/bin/bash](#-bin-bash)
- [ Create output directory if it doesn't exist](#-create-output-directory-if-it-doesn-t-exist)
- [ Clear output file if it exists](#-clear-output-file-if-it-exists)
- [ Function to add file content to the output file](#-function-to-add-file-content-to-the-output-file)
- [ Find all relevant files](#-find-all-relevant-files)
- [ Exclude:](#-exclude-)
- [ - node_modules](#-node-modules)
- [ - .git](#-git)
- [ - .expo](#-expo)
- [ - .tamagui (generated code)](#-tamagui-generated-code-)
- [ - Large files like package-lock.json](#-large-files-like-package-lock-json)
- [ - Binary files](#-binary-files)
- [ Include important code files with extensions:](#-include-important-code-files-with-extensions-)
- [ - .tsx, .ts, .js, .jsx](#-tsx-ts-js-jsx)
- [ - .json (except package-lock.json)](#-json-except-package-lock-json-)
- [ - .md for documentation](#-md-for-documentation)
- [ Add select JSON files (excluding package-lock.json which is already excluded above)](#-add-select-json-files-excluding-package-lock-json-which-is-already-excluded-above-)
    - [ reset-project.js](#-reset-project-js)
                          - [!/usr/bin/env node](#-usr-bin-env-node)
- [ server](#-server)
    - [ .env](#-env)
    - [ package.json](#-package-json)
    - [ context.ts](#-context-ts)
    - [ index.ts](#-index-ts)
    - [ router.ts](#-router-ts)
    - [ dashboardRouter.ts](#-dashboardrouter-ts)
    - [ goalProgressNoteRouter.ts](#-goalprogressnoterouter-ts)
    - [ goalRouter.ts](#-goalrouter-ts)
    - [ habitRouter.ts](#-habitrouter-ts)
    - [ principleRouter.ts](#-principlerouter-ts)
    - [ reminderRouter.ts](#-reminderrouter-ts)
    - [ rewardsRouter.ts](#-rewardsrouter-ts)
    - [ taskRouter.ts](#-taskrouter-ts)
    - [ trackedStateRouter.ts](#-trackedstaterouter-ts)
    - [ userRouter.ts](#-userrouter-ts)
    - [ valueRouter.ts](#-valuerouter-ts)
    - [ index.ts](#-index-ts)
    - [ trpc-types.ts](#-trpc-types-ts)
    - [ tsconfig.json](#-tsconfig-json)
- [ stores](#-stores)
    - [ uiStore.ts](#-uistore-ts)
- [ (root files)](#-root-files-)
    - [ styling_report.txt](#-styling-report-txt)
- [ AetherIphone Tamagui Styling Report](#-aetheriphone-tamagui-styling-report)
  - [ 1. Core Theme Setup (`Providers.tsx`)](#-1-core-theme-setup-providers-tsx-)
  - [ 2. Theme Configuration (`tamagui.config.ts`)](#-2-theme-configuration-tamagui-config-ts-)
    - [ 2.1. Tokens](#-2-1-tokens)
    - [ 2.2. Themes](#-2-2-themes)
  - [ 3. Theme Usage Examples](#-3-theme-usage-examples)
    - [ 3.1. Screen Example (`app/(tabs)/planner/index.tsx`)](#-3-1-screen-example-app-tabs-planner-index-tsx-)
    - [ 3.2. Primitive Component Example (`components/ui/primitives/AetherCard.tsx`)](#-3-2-primitive-component-example-components-ui-primitives-aethercard-tsx-)
  - [ 4. Summary & Best Practices](#-4-summary-best-practices)
- [ supabase](#-supabase)
    - [ .gitignore](#-gitignore)
- [ Supabase](#-supabase)
- [ dotenvx](#-dotenvx)
    - [ config.toml](#-config-toml)
- [ For detailed configuration reference documentation, visit:](#-for-detailed-configuration-reference-documentation-visit-)
- [ https://supabase.com/docs/guides/local-development/cli/config](#-https-supabase-com-docs-guides-local-development-cli-config)
- [ A string used to distinguish different Supabase projects on the same host. Defaults to the](#-a-string-used-to-distinguish-different-supabase-projects-on-the-same-host-defaults-to-the)
- [ working directory name when running `supabase init`.](#-working-directory-name-when-running-supabase-init-)
- [ Port to use for the API URL.](#-port-to-use-for-the-api-url-)
- [ Schemas to expose in your API. Tables, views and stored procedures in this schema will get API](#-schemas-to-expose-in-your-api-tables-views-and-stored-procedures-in-this-schema-will-get-api)
- [ endpoints. `public` and `graphql_public` schemas are included by default.](#-endpoints-public-and-graphql-public-schemas-are-included-by-default-)
- [ Extra schemas to add to the search_path of every request.](#-extra-schemas-to-add-to-the-search-path-of-every-request-)
- [ The maximum number of rows returns from a view, table, or stored procedure. Limits payload size](#-the-maximum-number-of-rows-returns-from-a-view-table-or-stored-procedure-limits-payload-size)
- [ for accidental or malicious requests.](#-for-accidental-or-malicious-requests-)
- [ Enable HTTPS endpoints locally using a self-signed certificate.](#-enable-https-endpoints-locally-using-a-self-signed-certificate-)
- [ Port to use for the local database URL.](#-port-to-use-for-the-local-database-url-)
- [ Port used by db diff command to initialize the shadow database.](#-port-used-by-db-diff-command-to-initialize-the-shadow-database-)
- [ The database major version to use. This has to be the same as your remote database's. Run `SHOW](#-the-database-major-version-to-use-this-has-to-be-the-same-as-your-remote-database-s-run-show)
- [ server_version;` on the remote database to check.](#-server-version-on-the-remote-database-to-check-)
- [ Port to use for the local connection pooler.](#-port-to-use-for-the-local-connection-pooler-)
- [ Specifies when a server connection can be reused by other clients.](#-specifies-when-a-server-connection-can-be-reused-by-other-clients-)
- [ Configure one of the supported pooler modes: `transaction`, `session`.](#-configure-one-of-the-supported-pooler-modes-transaction-session-)
- [ How many server connections to allow per user/database pair.](#-how-many-server-connections-to-allow-per-user-database-pair-)
- [ Maximum number of client connections allowed.](#-maximum-number-of-client-connections-allowed-)
- [ [db.vault]](#-db-vault-)
- [ secret_key = "env(SECRET_VALUE)"](#-secret-key-env-secret-value-)
- [ Specifies an ordered list of schema files that describe your database.](#-specifies-an-ordered-list-of-schema-files-that-describe-your-database-)
- [ Supports glob patterns relative to supabase directory: "./schemas/*.sql"](#-supports-glob-patterns-relative-to-supabase-directory-schemas-sql-)
- [ If enabled, seeds the database after migrations during a db reset.](#-if-enabled-seeds-the-database-after-migrations-during-a-db-reset-)
- [ Specifies an ordered list of seed files to load during db reset.](#-specifies-an-ordered-list-of-seed-files-to-load-during-db-reset-)
- [ Supports glob patterns relative to supabase directory: "./seeds/*.sql"](#-supports-glob-patterns-relative-to-supabase-directory-seeds-sql-)
- [ Bind realtime via either IPv4 or IPv6. (default: IPv4)](#-bind-realtime-via-either-ipv4-or-ipv6-default-ipv4-)
- [ ip_version = "IPv6"](#-ip-version-ipv6-)
- [ The maximum length in bytes of HTTP request headers. (default: 4096)](#-the-maximum-length-in-bytes-of-http-request-headers-default-4096-)
- [ max_header_length = 4096](#-max-header-length-4096)
- [ Port to use for Supabase Studio.](#-port-to-use-for-supabase-studio-)
- [ External URL of the API server that frontend connects to.](#-external-url-of-the-api-server-that-frontend-connects-to-)
- [ OpenAI API Key to use for Supabase AI in the Supabase Studio.](#-openai-api-key-to-use-for-supabase-ai-in-the-supabase-studio-)
- [ Email testing server. Emails sent with the local dev setup are not actually sent - rather, they](#-email-testing-server-emails-sent-with-the-local-dev-setup-are-not-actually-sent-rather-they)
- [ are monitored, and you can view the emails that would have been sent from the web interface.](#-are-monitored-and-you-can-view-the-emails-that-would-have-been-sent-from-the-web-interface-)
- [ Port to use for the email testing server web interface.](#-port-to-use-for-the-email-testing-server-web-interface-)
- [ Uncomment to expose additional ports for testing user applications that send emails.](#-uncomment-to-expose-additional-ports-for-testing-user-applications-that-send-emails-)
- [ smtp_port = 54325](#-smtp-port-54325)
- [ pop3_port = 54326](#-pop3-port-54326)
- [ admin_email = "admin@email.com"](#-admin-email-admin-email-com-)
- [ sender_name = "Admin"](#-sender-name-admin-)
- [ The maximum file size allowed (e.g. "5MB", "500KB").](#-the-maximum-file-size-allowed-e-g-5mb-500kb-)
- [ Image transformation API is available to Supabase Pro plan.](#-image-transformation-api-is-available-to-supabase-pro-plan-)
- [ [storage.image_transformation]](#-storage-image-transformation-)
- [ enabled = true](#-enabled-true)
- [ Uncomment to configure local storage buckets](#-uncomment-to-configure-local-storage-buckets)
- [ [storage.buckets.images]](#-storage-buckets-images-)
- [ public = false](#-public-false)
- [ file_size_limit = "50MiB"](#-file-size-limit-50mib-)
- [ allowed_mime_types = ["image/png", "image/jpeg"]](#-allowed-mime-types-image-png-image-jpeg-)
- [ objects_path = "./images"](#-objects-path-images-)
- [ The base URL of your website. Used as an allow-list for redirects and for constructing URLs used](#-the-base-url-of-your-website-used-as-an-allow-list-for-redirects-and-for-constructing-urls-used)
- [ in emails.](#-in-emails-)
- [ A list of *exact* URLs that auth providers are permitted to redirect to post authentication.](#-a-list-of-exact-urls-that-auth-providers-are-permitted-to-redirect-to-post-authentication-)
- [ How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).](#-how-long-tokens-are-valid-for-in-seconds-defaults-to-3600-1-hour-maximum-604-800-1-week-)
- [ If disabled, the refresh token will never expire.](#-if-disabled-the-refresh-token-will-never-expire-)
- [ Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.](#-allows-refresh-tokens-to-be-reused-after-expiry-up-to-the-specified-interval-in-seconds-)
- [ Requires enable_refresh_token_rotation = true.](#-requires-enable-refresh-token-rotation-true-)
- [ Allow/disallow new user signups to your project.](#-allow-disallow-new-user-signups-to-your-project-)
- [ Allow/disallow anonymous sign-ins to your project.](#-allow-disallow-anonymous-sign-ins-to-your-project-)
- [ Allow/disallow testing manual linking of accounts](#-allow-disallow-testing-manual-linking-of-accounts)
- [ Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.](#-passwords-shorter-than-this-value-will-be-rejected-as-weak-minimum-6-recommended-8-or-more-)
- [ Passwords that do not meet the following requirements will be rejected as weak. Supported values](#-passwords-that-do-not-meet-the-following-requirements-will-be-rejected-as-weak-supported-values)
- [ are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`](#-are-letters-digits-lower-upper-letters-digits-lower-upper-letters-digits-symbols-)
- [ Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.](#-number-of-emails-that-can-be-sent-per-hour-requires-auth-email-smtp-to-be-enabled-)
- [ Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.](#-number-of-sms-messages-that-can-be-sent-per-hour-requires-auth-sms-to-be-enabled-)
- [ Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.](#-number-of-anonymous-sign-ins-that-can-be-made-per-hour-per-ip-address-requires-enable-anonymous-sign-ins-true-)
- [ Number of sessions that can be refreshed in a 5 minute interval per IP address.](#-number-of-sessions-that-can-be-refreshed-in-a-5-minute-interval-per-ip-address-)
- [ Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).](#-number-of-sign-up-and-sign-in-requests-that-can-be-made-in-a-5-minute-interval-per-ip-address-excludes-anonymous-users-)
- [ Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.](#-number-of-otp-magic-link-verifications-that-can-be-made-in-a-5-minute-interval-per-ip-address-)
- [ Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.](#-configure-one-of-the-supported-captcha-providers-hcaptcha-turnstile-)
- [ [auth.captcha]](#-auth-captcha-)
- [ enabled = true](#-enabled-true)
- [ provider = "hcaptcha"](#-provider-hcaptcha-)
- [ secret = ""](#-secret-)
- [ Allow/disallow new user signups via email to your project.](#-allow-disallow-new-user-signups-via-email-to-your-project-)
- [ If enabled, a user will be required to confirm any email change on both the old, and new email](#-if-enabled-a-user-will-be-required-to-confirm-any-email-change-on-both-the-old-and-new-email)
- [ addresses. If disabled, only the new email is required to confirm.](#-addresses-if-disabled-only-the-new-email-is-required-to-confirm-)
- [ If enabled, users need to confirm their email address before signing in.](#-if-enabled-users-need-to-confirm-their-email-address-before-signing-in-)
- [ If enabled, users will need to reauthenticate or have logged in recently to change their password.](#-if-enabled-users-will-need-to-reauthenticate-or-have-logged-in-recently-to-change-their-password-)
- [ Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.](#-controls-the-minimum-amount-of-time-that-must-pass-before-sending-another-signup-confirmation-or-password-reset-email-)
- [ Number of characters used in the email OTP.](#-number-of-characters-used-in-the-email-otp-)
- [ Number of seconds before the email OTP expires (defaults to 1 hour).](#-number-of-seconds-before-the-email-otp-expires-defaults-to-1-hour-)
- [ Use a production-ready SMTP server](#-use-a-production-ready-smtp-server)
- [ [auth.email.smtp]](#-auth-email-smtp-)
- [ enabled = true](#-enabled-true)
- [ host = "smtp.sendgrid.net"](#-host-smtp-sendgrid-net-)
- [ port = 587](#-port-587)
- [ user = "apikey"](#-user-apikey-)
- [ pass = "env(SENDGRID_API_KEY)"](#-pass-env-sendgrid-api-key-)
- [ admin_email = "admin@email.com"](#-admin-email-admin-email-com-)
- [ sender_name = "Admin"](#-sender-name-admin-)
- [ Uncomment to customize email template](#-uncomment-to-customize-email-template)
- [ [auth.email.template.invite]](#-auth-email-template-invite-)
- [ subject = "You have been invited"](#-subject-you-have-been-invited-)
- [ content_path = "./supabase/templates/invite.html"](#-content-path-supabase-templates-invite-html-)
- [ Allow/disallow new user signups via SMS to your project.](#-allow-disallow-new-user-signups-via-sms-to-your-project-)
- [ If enabled, users need to confirm their phone number before signing in.](#-if-enabled-users-need-to-confirm-their-phone-number-before-signing-in-)
- [ Template for sending OTP to users](#-template-for-sending-otp-to-users)
- [ Controls the minimum amount of time that must pass before sending another sms otp.](#-controls-the-minimum-amount-of-time-that-must-pass-before-sending-another-sms-otp-)
- [ Use pre-defined map of phone number to OTP for testing.](#-use-pre-defined-map-of-phone-number-to-otp-for-testing-)
- [ [auth.sms.test_otp]](#-auth-sms-test-otp-)
- [ 4152127777 = "123456"](#-4152127777-123456-)
- [ Configure logged in session timeouts.](#-configure-logged-in-session-timeouts-)
- [ [auth.sessions]](#-auth-sessions-)
- [ Force log out after the specified duration.](#-force-log-out-after-the-specified-duration-)
- [ timebox = "24h"](#-timebox-24h-)
- [ Force log out if the user has been inactive longer than the specified duration.](#-force-log-out-if-the-user-has-been-inactive-longer-than-the-specified-duration-)
- [ inactivity_timeout = "8h"](#-inactivity-timeout-8h-)
- [ This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.](#-this-hook-runs-before-a-token-is-issued-and-allows-you-to-add-additional-claims-based-on-the-authentication-method-used-)
- [ [auth.hook.custom_access_token]](#-auth-hook-custom-access-token-)
- [ enabled = true](#-enabled-true)
- [ uri = "pg-functions://<database>/<schema>/<hook_name>"](#-uri-pg-functions-database-schema-hook-name-)
- [ Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.](#-configure-one-of-the-supported-sms-providers-twilio-twilio-verify-messagebird-textlocal-vonage-)
- [ DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:](#-do-not-commit-your-twilio-auth-token-to-git-use-environment-variable-substitution-instead-)
- [ Multi-factor-authentication is available to Supabase Pro plan.](#-multi-factor-authentication-is-available-to-supabase-pro-plan-)
- [ Control how many MFA factors can be enrolled at once per user.](#-control-how-many-mfa-factors-can-be-enrolled-at-once-per-user-)
- [ Control MFA via App Authenticator (TOTP)](#-control-mfa-via-app-authenticator-totp-)
- [ Configure MFA via Phone Messaging](#-configure-mfa-via-phone-messaging)
- [ Configure MFA via WebAuthn](#-configure-mfa-via-webauthn)
- [ [auth.mfa.web_authn]](#-auth-mfa-web-authn-)
- [ enroll_enabled = true](#-enroll-enabled-true)
- [ verify_enabled = true](#-verify-enabled-true)
- [ Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,](#-use-an-external-oauth-provider-the-full-list-of-providers-are-apple-azure-bitbucket-)
- [ `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,](#-discord-facebook-github-gitlab-google-keycloak-linkedin-oidc-notion-twitch-)
- [ `twitter`, `slack`, `spotify`, `workos`, `zoom`.](#-twitter-slack-spotify-workos-zoom-)
- [ DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:](#-do-not-commit-your-oauth-provider-secret-to-git-use-environment-variable-substitution-instead-)
- [ Overrides the default auth redirectUrl.](#-overrides-the-default-auth-redirecturl-)
- [ Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,](#-overrides-the-default-auth-provider-url-used-to-support-self-hosted-gitlab-single-tenant-azure-)
- [ or any other third-party OIDC providers.](#-or-any-other-third-party-oidc-providers-)
- [ If enabled, the nonce check will be skipped. Required for local sign in with Google auth.](#-if-enabled-the-nonce-check-will-be-skipped-required-for-local-sign-in-with-google-auth-)
- [ Use Firebase Auth as a third-party provider alongside Supabase Auth.](#-use-firebase-auth-as-a-third-party-provider-alongside-supabase-auth-)
- [ project_id = "my-firebase-project"](#-project-id-my-firebase-project-)
- [ Use Auth0 as a third-party provider alongside Supabase Auth.](#-use-auth0-as-a-third-party-provider-alongside-supabase-auth-)
- [ tenant = "my-auth0-tenant"](#-tenant-my-auth0-tenant-)
- [ tenant_region = "us"](#-tenant-region-us-)
- [ Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.](#-use-aws-cognito-amplify-as-a-third-party-provider-alongside-supabase-auth-)
- [ user_pool_id = "my-user-pool-id"](#-user-pool-id-my-user-pool-id-)
- [ user_pool_region = "us-east-1"](#-user-pool-region-us-east-1-)
- [ Use Clerk as a third-party provider alongside Supabase Auth.](#-use-clerk-as-a-third-party-provider-alongside-supabase-auth-)
- [ Obtain from https://clerk.com/setup/supabase](#-obtain-from-https-clerk-com-setup-supabase)
- [ domain = "example.clerk.accounts.dev"](#-domain-example-clerk-accounts-dev-)
- [ Configure one of the supported request policies: `oneshot`, `per_worker`.](#-configure-one-of-the-supported-request-policies-oneshot-per-worker-)
- [ Use `oneshot` for hot reload, or `per_worker` for load testing.](#-use-oneshot-for-hot-reload-or-per-worker-for-load-testing-)
- [ Port to attach the Chrome inspector for debugging edge functions.](#-port-to-attach-the-chrome-inspector-for-debugging-edge-functions-)
- [ The Deno major version to use.](#-the-deno-major-version-to-use-)
- [ [edge_runtime.secrets]](#-edge-runtime-secrets-)
- [ secret_key = "env(SECRET_VALUE)"](#-secret-key-env-secret-value-)
- [ Configure one of the supported backends: `postgres`, `bigquery`.](#-configure-one-of-the-supported-backends-postgres-bigquery-)
- [ Experimental features may be deprecated any time](#-experimental-features-may-be-deprecated-any-time)
- [ Configures Postgres storage engine to use OrioleDB (S3)](#-configures-postgres-storage-engine-to-use-orioledb-s3-)
- [ Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com](#-configures-s3-bucket-url-eg-bucket-name-s3-region-amazonaws-com)
- [ Configures S3 bucket region, eg. us-east-1](#-configures-s3-bucket-region-eg-us-east-1)
- [ Configures AWS_ACCESS_KEY_ID for S3 bucket](#-configures-aws-access-key-id-for-s3-bucket)
- [ Configures AWS_SECRET_ACCESS_KEY for S3 bucket](#-configures-aws-secret-access-key-for-s3-bucket)
    - [ 20250424033333_initial_schema.sql](#-20250424033333-initial-schema-sql)
    - [ 20250424035232_add_missing_tables.sql](#-20250424035232-add-missing-tables-sql)
    - [ 20250424035717_add_missing_tables.sql](#-20250424035717-add-missing-tables-sql)
    - [ 20250425000000_create_user_settings_table.sql](#-20250425000000-create-user-settings-table-sql)
    - [ 20250426000000_create_rewards_tables.sql](#-20250426000000-create-rewards-tables-sql)
    - [ 20250428124230_standardize_field_naming.sql](#-20250428124230-standardize-field-naming-sql)
    - [ 20250428130834_enhance_functional_schema.sql](#-20250428130834-enhance-functional-schema-sql)
- [ (root files)](#-root-files-)
    - [ tailwind.config.js](#-tailwind-config-js)
    - [ tamagui.config.ts](#-tamagui-config-ts)
    - [ testing_strategy.md](#-testing-strategy-md)
- [ Testing Strategy](#-testing-strategy)
  - [ 1. Tech-Stack & How the Pieces Interact](#-1-tech-stack-how-the-pieces-interact)
    - [ 1.1 Supabase Schema & Type-Generation](#-1-1-supabase-schema-type-generation)
  - [ 2. Pyramid of Tests](#-2-pyramid-of-tests)
  - [ 3. Testing Concerns by Folder](#-3-testing-concerns-by-folder)
    - [ 3.1 Mapping of Procedures ➟ Tables ➟ UI](#-3-1-mapping-of-procedures-tables-ui)
  - [ 4. Bidirectional Coverage Matrix (Screen → DB and DB → Screen)](#-4-bidirectional-coverage-matrix-screen-db-and-db-screen-)
    - [ 4.1 Screen-Centric Trace](#-4-1-screen-centric-trace)
    - [ 4.2 Schema-Centric Trace](#-4-2-schema-centric-trace)
    - [ 4.3 Gap List & Action Items](#-4-3-gap-list-action-items)
  - [ 5. Tooling Configuration](#-5-tooling-configuration)
    - [ 5.1 Jest Runners](#-5-1-jest-runners)
    - [ 5.2 Mocking Conventions](#-5-2-mocking-conventions)
    - [ 5.3 Utilities](#-5-3-utilities)
    - [ 5.4 Contract & Integration Testing Flow](#-5-4-contract-integration-testing-flow)
  - [ 6. Red-Green-Refactor Workflow](#-6-red-green-refactor-workflow)
  - [ 7. Continuous Integration](#-7-continuous-integration)
  - [ 8. Future Work](#-8-future-work)
  - [ 9. Appendix – Why This Approach?](#-9-appendix-why-this-approach-)
    - [ tsconfig.json](#-tsconfig-json)
- [ types](#-types)
    - [ database.types.ts](#-database-types-ts)
- [ utils](#-utils)
    - [ api-types.ts](#-api-types-ts)
    - [ auth.ts](#-auth-ts)
    - [ colors.ts](#-colors-ts)
    - [ generated-hooks.ts](#-generated-hooks-ts)
    - [ haptics.ts](#-haptics-ts)
    - [ mock-api.ts](#-mock-api-ts)
    - [ nats-client.ts](#-nats-client-ts)
    - [ offline-mutations.ts](#-offline-mutations-ts)
    - [ offline-sync.ts](#-offline-sync-ts)
    - [ query-client.ts](#-query-client-ts)
    - [ settings.ts](#-settings-ts)
    - [ supabase.ts](#-supabase-ts)
    - [ trpc.ts](#-trpc-ts)
- [ (root files)](#-root-files-)
    - [ why.txt](#-why-txt)


# (root files)

### .env
**Path:** .env
**Size:** 431 bytes

```
EXPO_PUBLIC_SUPABASE_URL=https://fjzzeprbdjwpxnhnltqm.supabase.co
EXPO_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZqenplcHJiZGp3cHhuaG5sdHFtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5NjU1ODEsImV4cCI6MjA2MDU0MTU4MX0.iXWsMcw72PV6dtzDnna9LuPFF1MPYvlmFcasx0Qlo34
SUPABASE_URL=https://fjzzeprbdjwpxnhnltqm.supabase.co
SUPABASE_SERVICE_ROLE_KEY=<your-service-role-key-from-supabase-settings>```

### .env.example
**Path:** .env.example
**Size:** 133 bytes

```
# Supabase Configuration\nEXPO_PUBLIC_SUPABASE_URL=your_supabase_url_here\nEXPO_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key_here
```

### .eslintrc.js
**Path:** .eslintrc.js
**Size:** 493 bytes

```javascript
// https://docs.expo.dev/guides/using-eslint/
module.exports = {
  extends: 'expo',
  ignorePatterns: ['/dist/*'],
  env: {
    'react-native/react-native': true, // for React Native environment (e.g. __DEV__)
    node: true,                      // allows Node globals like process, module
    jest: true                       // if you have test files using Jest globals
  },
  globals: {
    __DEV__: 'readonly',
  },
  rules: {
    // Optional: adjust specific lint rules if needed
  }
};
```


# .github

### ci.yml
**Path:** .github/workflows/ci.yml
**Size:** 1124 bytes

```yaml
name: CI

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: TypeScript check
        run: npx tsc --noEmit

      # Add this step once we have tests
      # - name: Run tests
      #   run: npm test
        
      - name: Expo config validation
        run: npx expo-cli prebuild --clean --no-install
        
  server-build:
    runs-on: ubuntu-latest
    
    defaults:
      run:
        working-directory: ./server
        
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: 'npm'
          cache-dependency-path: './server/package.json'
      
      - name: Install server dependencies
        run: npm ci
        
      - name: Build server
        run: npm run build ```


# (root files)

### .gitignore
**Path:** .gitignore
**Size:** 414 bytes

```
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

app-example

.DS_Store

```


# .tamagui

### tamagui.config.json
**Path:** .tamagui/tamagui.config.json
**Size:** 982514 bytes
*(omitted – binary or >204800 bytes)*


# (root files)

### .windsurfrules
**Path:** .windsurfrules
**Size:** 0 bytes

```
```

### AETHER_TODO.md
**Path:** AETHER_TODO.md
**Size:** 6507 bytes

```markdown
# AETHER ― UI / UX & CODE UPGRADE TODO

## 1. GLOBAL DESIGN PRINCIPLES
- [ ] One source of truth → Tamagui theme tokens only (no hex)  
- [ ] Hierarchy first → large titles, section headers, cards  
- [ ] Micro-feedback everywhere → haptics + 200–300 ms fade / slide  
- [ ] Three state rule → loading ⬩ empty ⬩ error for every list / card  
- [ ] Motion restraint → 60 fps on low-end device; keep Lottie / confetti ≤2 s  

## 2. APP-LEVEL TASK LIST (sorted by impact / effort ratio)
- [ ] Finish TypeScript wiring for tRPC & Expo-router: remove all `as any`, `// @ts-ignore`
- [ ] Replace Tabs-in-Settings with list-style grouped sections
- [ ] Add pull-to-refresh to Home dashboard (`RefreshControl`)
- [ ] Introduce global `<ErrorToast>` + dashboard section `error` prop
- [ ] Introduce Floating-Action-Button (FAB) that speed-dials to "New Task / Habit / Goal"
- [ ] Add confetti + haptic success when reward claimed
- [ ] Skeleton component refactor – consume everywhere
- [ ] Dark-mode safe "frosted card" variant wrapped in Tamagui `styled(Card)`

## 3. SCREEN-BY-SCREEN GUIDANCE
### A. HOME (DASHBOARD)
- [ ] Header: `headerLargeTitle ("Good Morning")` with date sub-title
- [ ] Each section = `DashboardSection` (show 3 items + "See All")
  - [ ] Props to add: `skeletonCount`, `error`, `onRetry`
- [ ] Quick Actions → replace 3 buttons with FAB (`@expo/react-native-action-sheet` or custom)
- [ ] Animations: `AnimatePresence` fade-in list items; bounce card on habit check
- [ ] Pull-to-refresh: `<ScrollView refreshControl={<RefreshControl …/>}>`

### B. PLANNER (Tabs Goals / Habits / Calendar)
- [ ] Goals Tab → mount `GoalsList`; pass `isLoading`, `error`
  - [ ] Goal card progress bar animates width on mount (`withTiming`)
- [ ] Habits Tab → reuse `HabitsList`; optimistic toggle + revert on error
- [ ] Calendar Tab → prototype with `react-native-calendars`; dots = tasks/habits
- [ ] Tab switch animation: wrap each `<Tabs.Content>` in `<MotiView from={{opacity:0}} animate={{opacity:1}}>`

### C. COMPASS (Principles / States)
- [ ] Principles list (Card per principle). Empty state with 🧭 illustration
- [ ] State Definitions list: reuse `StateIndicator`; allow swipe-to-edit
- [ ] Add "Add Principle / Add State" FAB local to tab

### D. REWARDS
- [ ] Points card: count-up animation (`useValue, withTiming`)
- [ ] Earned rewards → horizontal `FlatList` (keyExtractor)
- [ ] Available rewards → 2-col grid; button shows `<Spinner>` while claiming
- [ ] Success: confetti (`react-native-confetti-cannon`) + `Haptics.notificationAsync(success)`

### E. SETTINGS
- [ ] Convert Tabs to grouped list:  
  - [ ] Profile (username, avatar)  
  - [ ] Account (password, 2FA, delete)  
  - [ ] Appearance (Dark Mode, System-theme)  
  - [ ] Notifications (push, email toggles)  
- [ ] Dark-mode switch: tri-state (Light / Dark / System)
- [ ] Each row: Tamagui `ListItem` variant with right-chevron

### F. AUTH FLOW
- [ ] Add logo to Login / Register
- [ ] Use Toast (non-blocking) for basic errors; Alert for critical
- [ ] Show / hide password icon inside Inputs (`secureTextEntry` toggle)
- [ ] After Register → Verify screen: add "Open email app" deep-link button (`Linking.openURL('message://')`)

## 4. COMPONENT REFACTOR NOTES
### 1. DashboardSection
```typescript
interface DashboardSectionProps<T> {  
  title: string;  
  data: T[];  
  renderItem(item:T): ReactNode;  
  seeAllRoute?: string;  
  isLoading?: boolean;  
  skeletonCount?: number;   // NEW  
  error?: string;           // NEW  
  onRetry?(): void;         // NEW  
}
```

### 2. Skeleton
- [ ] `Skeleton` = Tamagui `Stack` with animated opacity pulse
- [ ] Use in DashboardSection, GoalsList, HabitsList, etc.

### 3. HabitCheckItem vs HabitsList item
- [ ] Extract pure dumb `HabitToggleRow` (checkbox + title + streak)
- [ ] Dashboard & list reuse; parent passes `onToggle()` & disables during mutation

### 4. GoalSummaryCard vs GoalCard
- [ ] Keep Summary (ring) for dashboard; Detailed (bars) for Goals tab / Details
- [ ] Both share style variant via Tamagui `styled(Card)`

### 5. OfflineIndicator
- [ ] Replace hardcoded red with `$errorBackground`; use `safeAreaInsets.top` on Android too

## 5. TYPESCRIPT / ESLINT REMEDIATION
### A. Server build error (TS6059)
- [ ] Fix: extend `rootDir` OR move shared `types/` under `server/src/`
  Quick fix in `server/tsconfig.json`:
  ```json
  "rootDir": "../",
  "include": ["src/**/*", "../types/**/*"]
  ```

### B. tRPC client typing
- [ ] Generate helper type once:  
  ```typescript
  import type { AppRouter } from 'server/src/router';  
  export const trpc = createTRPCReact<AppRouter>();  
  ```
- [ ] Remove every `// @ts-ignore` + `as any` route cast

### C. Expo-router path types
- [ ] `app.d.ts`
  ```typescript
  declare module 'expo-router' {  
    interface LinkProps { href: `/compose` | `/planner` | ... }  
  }
  ```
- [ ] Or simpler: `router.push({ pathname:'/planner' })`

### D. Missing type-defs packages
- [ ] `@types/shopify__flash-list`, `@types/react-native-reanimated`, etc.  
  `yarn add -D @types/shopify__flash-list`

### E. Lint script
- [ ] `"lint": "eslint \"{app,components,server}/**/*.{ts,tsx}\" --fix"`  
- [ ] Fix all unused vars / imports; prefer `catch (err: unknown)`

## 6. TAMAGUI BEST PRACTICES CHECKLIST
- [ ] Only Tamagui components for layout (YStack/XStack/Text/Card)
- [ ] Use theme tokens (`$color`, `$backgroundStrong`)
- [ ] Create `styled()` variants for repeatable styles (frostedCard, sectionHeader)
- [ ] Configure Tamagui Compiler (metro) for perf
- [ ] Use `AnimatePresence` & `Stack animation="quick"` rather than StyleSheet animations where possible

## 7. IMPLEMENTATION PLAN (2-Week Sprint)
- [ ] Day 1-2   → Fix TypeScript config, remove ignores, green CI
- [ ] Day 3-4   → Refactor Skeleton + DashboardSection; integrate error prop
- [ ] Day 5     → FAB component + swap into Home
- [ ] Day 6-7   → Settings redesign to grouped list
- [ ] Day 8     → Rewards polish (confetti, claim spinner)
- [ ] Day 9-10  → Minor screens (Compass, Planner animations), QA, polish

## Deliverables for this sprint
- [ ] All TS errors resolved, no `@ts-ignore` in `app/` or `server/`  
- [ ] Dashboard displays error banners and supports pull-to-refresh  
- [ ] FAB replaces "Quick Actions" buttons  
- [ ] Settings → grouped list; Dark-Mode tri-state switch  
- [ ] Claiming a reward plays confetti + haptic  
- [ ] 100% ESLint clean (`npm run lint` passes) ```

### README.md
**Path:** README.md
**Size:** 2381 bytes

```markdown
# Aether App

A modern mobile application built with Expo, React Native, tRPC, and Tamagui.

## Project Structure

- `/app` - Expo Router app screens and navigation
- `/components` - Reusable UI components
- `/utils` - Utility functions and helpers
- `/server` - Express/tRPC backend server

## Getting Started

### Prerequisites

- Node.js 18+ 
- npm or yarn
- iOS Simulator or Android Emulator for mobile testing

### Installing

1. Clone the repository
2. Install dependencies:

```bash
npm install
```

3. Install server dependencies:

```bash
cd server
npm install
cd ..
```

### Running the App

**Start the backend server:**

```bash
cd server
npm run dev
```

This will start the tRPC server on [http://localhost:3000](http://localhost:3000).

**Start the Expo app:**

In a separate terminal:

```bash
npm start
```

This will launch the Expo development server. Press:
- `i` to open in iOS simulator
- `a` to open in Android emulator
- `w` to open in web browser

## Authentication

The app uses Supabase for secure authentication:

1. Create a free Supabase account at [supabase.com](https://supabase.com)
2. Create a new project and note your project URL and anon key
3. Create a `.env` file in the root of the project (copy from `.env.example`) and add your Supabase credentials
4. Authentication is already set up with the following features:
   - Email/password sign up and login
   - Session persistence with SecureStore
   - Password reset (through Supabase)

Demo credentials:
  - Email: `demo@example.com`
  - Password: `password`

## Development

### Backend Server

The backend server uses:
- Express
- tRPC for type-safe API
- In-memory data store (replace with a real DB in production)

Key endpoints:
- `/health` - Health check endpoint
- `/api/trpc` - tRPC API endpoint

### Mobile App

The app is organized using Expo Router file-based routing:
- `/app/(tabs)` - Main tabs after login
- `/app/auth` - Authentication screens (login/register)
- `/app/compose` - Modal screen example

## Project Roadmap

Phase 1 (In Progress):
- Core authentication flow
- Basic UI components
- API integration

Phase 2 (Upcoming):
- Offline sync capabilities
- Push notifications
- Performance optimizations

## Technologies

- Expo SDK 52
- React Native 0.76.x
- React 18.3
- TypeScript
- tRPC
- Tamagui UI
- NativeWind/Tailwind CSS
- React Query for data fetching/caching
```

### REFACTORING_PLAN_V2.yaml
**Path:** REFACTORING_PLAN_V2.yaml
**Size:** 13603 bytes

```yaml
title: Aether iPhone App - Enhanced Refactoring Plan (Post-Schema Update)
version: 2.0
last_updated: 2025-04-28 # Update with current date when executing

phases:
  - phase: 0
    name: Schema Update & Regeneration
    description: >
      Apply the enhanced database schema migration (`enhance_functional_schema.sql`) and regenerate all dependent types.
      This sets the stage for implementing new features and aligning existing code with the improved data model.
    status: Completed # Phase completed
    tasks:
      - id: SCHEMA-01
        name: Apply Enhanced Schema Migration
        details: >
          Apply the `enhance_functional_schema.sql` migration to the Supabase database using
          `supabase db push` or equivalent. Handle any manual data migration steps (e.g., for task priority enum mapping).
        status: Completed # Assuming this was done prior to type generation
        files_affected:
          - supabase/migrations/ (new file applied)
        testing_impact: None directly, but subsequent type generation depends on this. DB structure changes.
      - id: SCHEMA-02
        name: Regenerate Database Types
        details: >
          Run `npx supabase gen types typescript --linked > types/database.types.ts` to update
          the TypeScript definitions based on the newly migrated schema, capturing all new tables and columns.
        status: Completed # types/database.types.ts reflects new schema
        files_affected:
          - types/database.types.ts
        testing_impact: Foundational for all subsequent type checking and tests. Existing code referencing old types will show errors.

  - phase: 1
    name: Backend Alignment (Enhanced Schema)
    description: >
      Update Zod schemas and tRPC routers to fully reflect the enhanced database schema,
      including new fields for recurrence, archiving, sorting, habit types, reminders, etc.
      Update server-side tests accordingly.
    status: In Progress # Zod schemas done, Routers partially done
    tasks:
      - id: TYPE-02
        name: Update Zod Schemas for Enhanced DB
        details: >
          Modify Zod schemas in `server/src/types/trpc-types.ts` for `Goal`, `Habit`, `Task`,
          `Value`, `Principle`, `TrackedStateDef`, `HabitEntry`, `StateEntry` to include new fields
          (recurrence_rule, archived_at, sort_order, habit_type, goal_quantity, goal_unit,
          quantity_value, notes, target_min/max_value, etc.). Define new Zod schemas for
          `Reminder` and `GoalProgressNote`. Ensure enums match DB enums defined in the migration.
        status: Completed # server/src/types/trpc-types.ts updated
        files_affected:
          - server/src/types/trpc-types.ts
        testing_impact: Server tests will fail until routers are updated. Foundational for frontend typing.
      - id: BACKEND-06
        name: Refactor Routers for Enhanced Schema & CRUD
        details: >
          Update all tRPC routers (`goalRouter`, `habitRouter`, `taskRouter`, `valueRouter`,
          `trackedStateRouter`, `dashboardRouter`, etc.) to select, insert, and update
          the new fields defined in TYPE-02. Implement filtering for `archived_at` (e.g., `isNull('archived_at')`
          for active items). Add procedures for managing `Reminder` and `GoalProgressNote` tables. Update existing procedures to handle new fields (e.g., `habit_type`, `quantity_value` in habit logic).
        status: In Progress # Routers completed: Value, Principle, Goal, Task, Dashboard, Habit. Remaining: trackedStateRouter, reminderRouter, goalProgressNoteRouter
        files_affected:
          - server/src/routers/*.ts
        testing_impact: Requires significant updates to server tests (`__tests__/server/`) to mock and assert new fields and procedures.
      - id: BACKEND-07
        name: Update Server Tests for Enhanced Schema
        details: >
          Rewrite/update all tests in `__tests__/server/` to mock the enhanced Supabase schema
          (using `test-helpers.ts`) and assert that router procedures correctly handle the new
          fields, types (enums), and logic (e.g., archiving filters, recurrence handling if tested at router level).
        status: Not Started # Tests need update for new schema/logic
        files_affected:
          - __tests__/server/**/*.test.ts
          - __tests__/server/test-helpers.ts
        testing_impact: Ensures backend logic aligns with the new database structure.

  - phase: 2
    name: Frontend Type Consumption & Test Overhaul (Enhanced Schema)
    description: >
      Update frontend components and hooks to use the inferred `RouterOutputs` based on the
      enhanced backend schema from Phase 1. Remove remaining type casts and overhaul the UI test suite.
    status: Partially Implemented # Basic structure exists, but needs alignment with *new* types
    tasks:
      - id: FRONTEND-04
        name: Update Frontend Components for Enhanced Types
        details: >
          Refactor components in `app/` and `components/` (including `HomeScreen`, `PlannerScreen`,
          dashboard items, list items) to strictly use `RouterOutputs` inferred from the Phase 1
          backend changes. Access properties using correct names and types (including new fields like
          `archived_at`, `sort_order`, `quantity_value`, `notes`, etc., where applicable). Remove remaining
          `as any` / `@ts-ignore`.
        status: Partially Implemented # Needs update for new fields/types
        files_affected:
          - app/**/*.tsx
          - components/**/*.tsx
        testing_impact: Requires updating UI tests with mocks matching the *new* `RouterOutputs`.
      - id: TEST-02
        name: Overhaul Jest UI Test Suite & Config (Enhanced Schema)
        details: >
          Update all UI tests (`__tests__/` excluding `server/`) mocks, assertions, and snapshots
          to reflect the enhanced data structures and component props. Address flaky tests.
          Consolidate Jest configurations if still needed (remove `jest.server.config.js` if redundant).
        status: Partially Implemented # Needs update for new fields/types and config consolidation
        files_affected:
          - __tests__/**/*.test.tsx
          - __tests__/**/*.snap
          - jest.config.ui.js
          - jest.setup.js
          - jest.config.server.js / jest.server.config.js

  - phase: 3
    name: Feature Implementation (Core Functionality)
    description: >
      Build out core user-facing features leveraging the enhanced schema, including missing screens,
      recurrence, sub-tasks, reminders, archiving, and sorting.
    status: Not Started # Core features leveraging new schema are not built
    tasks:
      - id: FEAT-03
        name: Implement Recurrence UI & Logic
        details: >
          Add UI elements (e.g., in creation/edit modals) for setting `recurrence_rule` on tasks/habits.
          Update frontend logic to display recurring items correctly in lists/calendars.
        status: Not Started
        files_affected:
          - components/modals/* (TBD)
          - app/(tabs)/planner/index.tsx
          - components/lists/*.tsx
        testing_impact: Requires new UI tests for recurrence configuration and display.
      - id: FEAT-04
        name: Implement Sub-task UI & Logic
        details: >
          Allow creating tasks linked via `parent_task_id`. Update task detail screens and lists
          to display parent/child relationships and potentially roll up progress.
        status: Not Started
        files_affected:
          - components/modals/AddTask.tsx (TBD)
          - app/(tabs)/planner/task/[id].tsx (TBD)
          - components/lists/TaskList.tsx
        testing_impact: Requires new UI tests for sub-task creation, display, and interaction.
      - id: FEAT-05
        name: Implement Reminders UI & Logic
        details: >
          Add UI for setting `reminder_time` on tasks/goals/habits using the new `reminders` table.
          Implement logic to schedule/manage these reminders (potentially via `expo-notifications`).
        status: Not Started
        files_affected:
          - components/modals/* (TBD)
          - utils/notifications.ts (TBD)
          - server/src/routers/reminderRouter.ts (TBD)
        testing_impact: Requires new UI tests for setting reminders and potentially integration tests for notification scheduling.
      - id: FEAT-06
        name: Implement Archiving UI & Logic
        details: >
          Add "Archive" buttons/actions to goals, tasks, habits. Update list queries/filters
          to respect the `archived_at` field. Provide an "Archived Items" view (perhaps in Settings).
        status: Not Started
        files_affected:
          - components/lists/*.tsx
          - app/(tabs)/planner/*
          - app/(tabs)/settings/* (TBD Archive View)
        testing_impact: Requires UI tests for archive actions and filtering.
      - id: FEAT-07
        name: Implement Manual Sorting UI & Logic
        details: >
          Add drag-and-drop functionality (e.g., using `react-native-gesture-handler` + `reanimated`)
          to lists where `sort_order` exists (Goals, Values, Principles, Tasks). Update backend to
          handle reordering mutations.
        status: Not Started
        files_affected:
          - components/lists/*.tsx
          - app/(tabs)/planner/index.tsx
          - app/(tabs)/compass/index.tsx
        testing_impact: Requires complex UI interaction tests for drag-and-drop.
      - id: FEAT-08
        name: Implement Enhanced Habit Tracking UI
        details: >
          Update habit creation/edit modals and habit entry UI to support `habit_type` (boolean/quantity),
          `goal_quantity`, `goal_unit`, and entry `notes`/`quantity_value`. Update `HabitToggleRow` or replace.
        status: Not Started
        files_affected:
          - components/modals/AddHabit.tsx (TBD)
          - components/lists/HabitList.tsx
          - components/ui/HabitToggleRow.tsx (or replacement)
        testing_impact: Requires UI tests for quantity input, notes, and different habit type displays.
      - id: FEAT-09
        name: Implement Contextual Notes UI
        details: >
          Add input fields for `notes` on state entries and goal progress updates (`goal_progress_notes` table). Display these notes appropriately.
        status: Not Started
        files_affected:
          - app/(tabs)/compass/* (TBD State Entry UI)
          - app/(tabs)/planner/goal/[id].tsx (TBD Goal Detail)
        testing_impact: Requires UI tests for note input and display.
      - id: ROUTE-04
        name: Implement Missing Screens (Planner/Settings Details)
        details: >
          Build out the UI for detail screens identified as missing (e.g., `planner/goal/[id].tsx`,
          `settings/profile.tsx`). Create placeholder files first (ROUTE-02 from original plan). Connect them to the corresponding (now type-aligned) tRPC routers.
        status: Not Started # Files still missing
        files_affected:
          - app/(tabs)/planner/ (create files)
          - app/(tabs)/settings/ (create files)
        testing_impact: Requires writing new UI and integration tests for these screens.

  - phase: 4
    name: Advanced Features & Polish
    description: >
      Implement remaining major features (Compass, Rewards), complete the Tamagui migration,
      fully integrate offline sync, and address final cleanup tasks.
    status: Not Started # Advanced features not implemented
    tasks:
      - id: FEAT-10
        name: Implement Compass & Rewards Screens
        details: >
          Build out the UI for Compass (analytics using enhanced state/goal data) and Rewards screens using the backend data.
          Implement charts and reward redemption logic.
        status: Not Started
        files_affected:
          - app/(tabs)/compass/index.tsx
          - app/(tabs)/rewards/index.tsx
          - components/charts/* (TBD)
          - components/rewards/*
        testing_impact: Requires new UI tests for charts, reward lists, and redemption flow.
      - id: FEAT-11
        name: Fully Integrate Offline Mutation Queue
        details: >
          Ensure `saveOfflineMutation` is robustly integrated into *all* relevant `useMutation` hooks.
          Add UI indicators for pending sync items (`useOfflineSync` hook). Test edge cases thoroughly.
        status: Not Implemented # Integration is pending
        files_affected:
          - Hooks/Components using `useMutation`
          - components/ui/OfflineIndicator.tsx (or similar)
        testing_impact: Requires comprehensive offline integration testing.
      - id: REFACTOR-02
        name: Complete Tamagui Migration & Cleanup
        details: >
          Eliminate remaining non-Tamagui primitives (`View`, `Text`, etc.). Ensure consistent token usage. Remove custom
          `providers/ToastProvider.tsx` in favor of `@tamagui/toast`.
        status: Partially Implemented # Migration ongoing, ToastProvider exists
        files_affected:
          - components/**/*.tsx
          - app/**/*.tsx
          - providers/ToastProvider.tsx (delete)
          - providers/Providers.tsx
        testing_impact: Update UI tests. Snapshots will change.
      - id: CLEANUP-02
        name: Address Remaining TODOs and Lint Warnings
        details: >
          Final pass through `AETHER_TODO.md`, `refactor_checklist.md`. Resolve all lint warnings/errors.
        status: Partially Implemented # TODOs remain
        files_affected:
          - Various
        testing_impact: Minor test adjustments likely.
```

### SUPABASE_INTEGRATION.md
**Path:** SUPABASE_INTEGRATION.md
**Size:** 4778 bytes

```markdown
# Aether App - Supabase Integration

## What's Been Integrated

1. **Supabase Authentication**
   - Email/password login and registration
   - Secure token storage using Expo SecureStore
   - Authentication state management
   - Automatic session refresh

2. **User Profiles**
   - Basic profile retrieval through Supabase
   - User metadata storage

3. **App Configuration**
   - Added settings management with SecureStore
   - Environment variable setup for Supabase credentials

## Setup Instructions

1. **Create a Supabase Project**
   - Sign up at [supabase.com](https://supabase.com)
   - Create a new project
   - Note your project URL and anon key

2. **Local Setup**
   - Copy `.env.example` to `.env`
   - Fill in your Supabase URL and anon key
   ```
   EXPO_PUBLIC_SUPABASE_URL=your_supabase_url_here
   EXPO_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key_here
   ```

3. **Database Setup in Supabase**
   - Create a `profiles` table with the SQL below:

   ```sql
   create table public.profiles (
     id uuid references auth.users not null primary key,
     username text,
     avatar_url text,
     created_at timestamp with time zone default now(),
     updated_at timestamp with time zone default now()
   );

   -- Enable RLS
   alter table public.profiles enable row level security;

   -- Create a policy that allows users to read all profiles
   create policy "Profiles are viewable by everyone" on profiles
     for select using (true);

   -- Create a policy that allows users to update only their own profile
   create policy "Users can update their own profile" on profiles
     for update using (auth.uid() = id);

   -- Function to create a profile when a user signs up
   create or replace function public.handle_new_user()
   returns trigger as $$
   begin
     insert into public.profiles (id, username, avatar_url)
     values (new.id, new.raw_user_meta_data->>'username', null);
     return new;
   end;
   $$ language plpgsql security definer;

   -- Trigger to create a profile when a user signs up
   create trigger on_auth_user_created
     after insert on auth.users
     for each row execute procedure public.handle_new_user();
   ```

## Next Steps

1. **Real-time Data Sync**
   - Set up Supabase Realtime for subscriptions
   - Implement data sync with React Query + Supabase

2. **Storage**
   - Implement Supabase Storage for file uploads (profile pictures, attachments)

3. **Offline Support**
   - Implement offline queue for mutations
   - Set up background sync

4. **Testing**
   - Create a test project in Supabase for CI/CD environments

## Implementation Details

### Authentication Flow

1. User enters credentials in login/register screen
2. Supabase SDK handles authentication
3. Supabase stores tokens in SecureStore
4. Authentication state is managed in _layout.tsx
5. Pages use authentication state to redirect as needed

### Profile Management

The `getUserProfile` function demonstrates how to:
1. Get the current authenticated user
2. Query their profile information from the database
3. Handle cases where the profile hasn't been created yet

### Logout Flow

The logout function:
1. Calls Supabase signOut
2. Clears session state
3. Redirects to login 

## Offline Support

We've implemented a comprehensive offline-first architecture using:

1. **React Query Persistence**
   - Queries are cached in AsyncStorage
   - Mutations are paused when offline and resumed when online
   - Cache is rehydrated on app restart

2. **Visual Indicators**
   - OfflineIndicator component shows network status
   - Pending items are marked with a visual badge

3. **Custom Offline Sync System**
   - Mutations are stored in AsyncStorage when offline
   - Automatic sync when the device reconnects
   - Support for create, update, and delete operations

### Using Offline Sync in Components

```tsx
import { useOfflineSync } from '@/hooks/useOfflineSync';

// In your component
function TaskList() {
  // Set up offline sync for the 'tasks' entity
  const { 
    isOnline, 
    pendingItems, 
    createItem, 
    updateItem, 
    deleteItem, 
    isItemPending 
  } = useOfflineSync<Task>('tasks');

  // Create a new task (works offline)
  const handleAddTask = async () => {
    const { id, isOffline } = await createItem({ 
      title: 'New Task',
      completed: false
    });
    
    // The task is created with a temporary ID if offline
    console.log(`Task created with ID: ${id}, offline: ${isOffline}`);
  };

  // In your render function, show pending state
  return (
    <View>
      {tasks.map(task => (
        <View key={task.id}>
          <Text>{task.title}</Text>
          {isItemPending(task.id) && (
            <Badge>Pending Sync</Badge>
          )}
        </View>
      ))}
    </View>
  );
}
``` ```


# __tests__

### HabitCheckItem.test.tsx
**Path:** __tests__/components/dashboard/HabitCheckItem.test.tsx
**Size:** 4800 bytes

```typescript
import React from 'react';
import { render, fireEvent, act } from '../test-utils';
import HabitCheckItem from '@/components/dashboard/HabitCheckItem';
import { trpc } from '@/utils/trpc';

// Mock the trpc hook
jest.mock('@/utils/trpc', () => ({
  trpc: {
    habit: {
      createHabitEntry: {
        useMutation: jest.fn().mockReturnValue({
          mutate: jest.fn(),
          isLoading: false,
          isError: false,
          error: null,
        }),
      },
      deleteHabitEntry: {
        useMutation: jest.fn().mockReturnValue({
          mutate: jest.fn(),
          isLoading: false,
          isError: false,
          error: null,
        }),
      },
    },
  },
}));

// Mock Haptics
jest.mock('expo-haptics', () => ({
  impactAsync: jest.fn(),
  ImpactFeedbackStyle: {
    Light: 'light',
  },
}));

describe('HabitCheckItem', () => {
  const mockHabit = {
    id: 'habit-1',
    title: 'Morning Run',
    streak: 3,
    completedToday: false,
    best_streak: 5,
    user_id: 'user-1',
    cue: 'Wake up',
    routine: 'Run 5k',
    reward: 'Coffee',
    habit_type: 'do',
    frequency_period: 'daily',
    goal_frequency: 1,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders correctly with uncompleted habit', () => {
    const { getByText } = render(<HabitCheckItem habit={mockHabit} />);
    
    expect(getByText('Morning Run')).toBeTruthy();
    expect(getByText(' 3 day streak')).toBeTruthy();
    expect(getByText('Check-in')).toBeTruthy();
  });

  it('renders correctly with completed habit for today', () => {
    const completedHabit = { ...mockHabit, completedToday: true };
    const { getByText } = render(<HabitCheckItem habit={completedHabit} />);
    
    expect(getByText('Morning Run')).toBeTruthy();
    expect(getByText(' 3 day streak')).toBeTruthy();
    expect(getByText('Done')).toBeTruthy();
  });

  it('calls createHabitEntry mutation when checking in', () => {
    const mockOnToggle = jest.fn();
    const mockCreateMutate = jest.fn();

    // Setup the mock create mutation
    (trpc.habit.createHabitEntry.useMutation as jest.Mock).mockReturnValue({
      mutate: mockCreateMutate,
      isLoading: false,
      isError: false,
      error: null,
    });

    const { getByText } = render(
      <HabitCheckItem habit={{...mockHabit, completedToday: false}} onToggle={mockOnToggle} />
    );

    // Press the check-in button
    fireEvent.press(getByText('Check-in'));

    // Verify the create mutation was called
    expect(mockCreateMutate).toHaveBeenCalledWith(expect.objectContaining({
      habitId: 'habit-1',
      date: expect.any(String),
      completed: true,
    }));

    // Verify the onToggle prop was called if provided
    expect(mockOnToggle).toHaveBeenCalledWith('habit-1', true);
  });

  it('calls deleteHabitEntry mutation when unchecking', () => {
    const mockOnToggle = jest.fn();
    const mockDeleteMutate = jest.fn();

    // Setup the mock delete mutation
    (trpc.habit.deleteHabitEntry.useMutation as jest.Mock).mockReturnValue({
      mutate: mockDeleteMutate,
      isLoading: false,
      isError: false,
      error: null,
    });

    const { getByText } = render(
      <HabitCheckItem habit={{...mockHabit, completedToday: true}} onToggle={mockOnToggle} />
    );

    // Press the done button
    fireEvent.press(getByText('Done'));

    // Verify the delete mutation was called
    expect(mockDeleteMutate).toHaveBeenCalledWith(expect.objectContaining({
      habitId: 'habit-1',
      date: expect.any(String),
    }));

    // Verify the onToggle prop was called if provided
    expect(mockOnToggle).toHaveBeenCalledWith('habit-1', false);
  });

  it('handles error state from mutation', async () => {
    // Mock console.error to prevent test output noise
    const originalConsoleError = console.error;
    console.error = jest.fn();

    // Assume createHabitEntry for error testing, could be delete too
    let errorCallback: (error: any) => void = () => {};
    
    (trpc.habit.createHabitEntry.useMutation as jest.Mock).mockImplementation(({ onError }) => {
      errorCallback = onError;
      return {
        mutate: jest.fn(),
        isLoading: false,
        isError: true,
      };
    });

    const { getByText } = render(<HabitCheckItem habit={mockHabit} />);

    // Press the check-in button (assuming initial state is not completed)
    fireEvent.press(getByText('Check-in'));

    // Simulate an error from the server
    await act(async () => {
      errorCallback(new Error('Network error'));
    });

    // Check that error was logged
    expect(console.error).toHaveBeenCalled();

    // Restore console.error
    console.error = originalConsoleError;
  });
});
```

### GoalList.test.tsx
**Path:** __tests__/components/lists/GoalList.test.tsx
**Size:** 4020 bytes

```typescript
import React from 'react';
import { render, fireEvent } from '../test-utils';
import { GoalList, GoalCard } from '@/components/lists/GoalList';
import { router } from 'expo-router';

// Mock router.push
jest.mock('expo-router', () => ({
  router: {
    push: jest.fn(),
  },
}));

// Define sample mock data that matches our Supabase schema via tRPC
const mockGoals = [
  {
    id: 'goal-1',
    title: 'Complete Project',
    description: 'Finish the Aether app refactoring',
    progress: 75,
    target_date: '2025-05-15',
    user_id: 'user-123',
  },
  {
    id: 'goal-2',
    title: 'Learn TypeScript',
    description: 'Master advanced TypeScript concepts',
    progress: 30,
    target_date: '2025-06-30',
    user_id: 'user-123',
  },
];

describe('GoalCard Component', () => {
  it('renders goal information correctly', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <GoalCard goal={mockGoals[0]} onPress={onPressMock} />
    );
    
    expect(getByText('Complete Project')).toBeTruthy();
    expect(getByText('Finish the Aether app refactoring')).toBeTruthy();
    expect(getByText('75%')).toBeTruthy();
    expect(getByText('May 15')).toBeTruthy();
  });
  
  it('handles press events', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <GoalCard goal={mockGoals[0]} onPress={onPressMock} />
    );
    
    // Find the card and press it
    const card = getByText('Complete Project').parent.parent.parent;
    fireEvent.press(card);
    
    expect(onPressMock).toHaveBeenCalledTimes(1);
  });
});

describe('GoalList Component', () => {
  it('renders loading state correctly', () => {
    const { getByTestId } = render(
      <GoalList isLoading={true} refetch={jest.fn()} />
    );
    
    expect(getByTestId('skeleton-loader')).toBeTruthy();
  });
  
  it('renders error state correctly', () => {
    const refetchMock = jest.fn();
    const { getByText } = render(
      <GoalList isLoading={false} isError={true} refetch={refetchMock} />
    );
    
    expect(getByText('Unable to load goals')).toBeTruthy();
    
    // Test retry functionality
    fireEvent.press(getByText('Retry'));
    expect(refetchMock).toHaveBeenCalledTimes(1);
  });
  
  it('renders empty state correctly', () => {
    const { getByText } = render(
      <GoalList isLoading={false} goals={[]} refetch={jest.fn()} />
    );
    
    expect(getByText('No goals yet')).toBeTruthy();
    
    // Test create action
    fireEvent.press(getByText('Create a goal'));
    expect(router.push).toHaveBeenCalledWith('/planner/add-goal');
  });
  
  it('renders goals correctly', () => {
    const { getAllByText } = render(
      <GoalList isLoading={false} goals={mockGoals} refetch={jest.fn()} />
    );
    
    // Should render both goals
    expect(getAllByText(/Complete Project|Learn TypeScript/).length).toBe(2);
  });
  
  it('navigates to goal detail on press', () => {
    const { getByText } = render(
      <GoalList isLoading={false} goals={mockGoals} refetch={jest.fn()} />
    );
    
    // Press the first goal
    const goalTitle = getByText('Complete Project');
    fireEvent.press(goalTitle.parent.parent.parent);
    
    // Should navigate to the goal detail page
    expect(router.push).toHaveBeenCalledWith({
      pathname: '/planner/goal/[id]',
      params: { id: 'goal-1' }
    });
  });
  
  it('calls onSelectGoal when provided', () => {
    const onSelectMock = jest.fn();
    const { getByText } = render(
      <GoalList 
        isLoading={false} 
        goals={mockGoals} 
        refetch={jest.fn()} 
        onSelectGoal={onSelectMock} 
      />
    );
    
    // Press the first goal
    const goalTitle = getByText('Complete Project');
    fireEvent.press(goalTitle.parent.parent.parent);
    
    // Should call the onSelectGoal callback
    expect(onSelectMock).toHaveBeenCalledWith(mockGoals[0]);
    // Should not navigate (router.push should not be called)
    expect(router.push).not.toHaveBeenCalled();
  });
});
```

### HabitList.test.tsx
**Path:** __tests__/components/lists/HabitList.test.tsx
**Size:** 3738 bytes

```typescript
import React from 'react';
import { render, fireEvent } from '../test-utils';
import { HabitList, HabitCard } from '@/components/lists/HabitList';
import { router } from 'expo-router';

// Mock router.push
jest.mock('expo-router', () => ({
  router: {
    push: jest.fn(),
  },
}));

// Define sample mock data that matches our Supabase schema via tRPC
const mockHabits = [
  {
    id: 'habit-1',
    title: 'Morning Meditation',
    streak: 5,
    best_streak: 21,
    cue: 'After waking up',
    routine: 'Meditate for 10 minutes',
    reward: 'Feel centered and calm',
    user_id: 'user-123',
  },
  {
    id: 'habit-2',
    title: 'Code Review',
    streak: 12,
    best_streak: 30,
    cue: 'After lunch',
    routine: 'Review code for 20 minutes',
    reward: 'Learn new patterns',
    user_id: 'user-123',
  },
];

describe('HabitCard Component', () => {
  it('renders habit information correctly', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <HabitCard habit={mockHabits[0]} onPress={onPressMock} />
    );
    
    expect(getByText('Morning Meditation')).toBeTruthy();
    expect(getByText('Current: 5 days')).toBeTruthy();
    expect(getByText('Best: 21 days')).toBeTruthy();
  });
  
  it('handles toggle correctly', () => {
    const onPressMock = jest.fn();
    const onToggleMock = jest.fn();
    const { getByTestId } = render(
      <HabitCard 
        habit={mockHabits[0]} 
        onPress={onPressMock} 
        onToggle={onToggleMock} 
      />
    );
    
    // Find the toggle button (checkmark)
    const toggleButton = getByTestId('icon-checkmark-circle-outline');
    fireEvent.press(toggleButton.parent);
    
    // Should call onToggle with true (completed)
    expect(onToggleMock).toHaveBeenCalledWith(true);
  });
});

describe('HabitList Component', () => {
  it('renders loading state correctly', () => {
    const { getByTestId } = render(
      <HabitList isLoading={true} refetch={jest.fn()} />
    );
    
    expect(getByTestId('skeleton-loader')).toBeTruthy();
  });
  
  it('renders error state correctly', () => {
    const refetchMock = jest.fn();
    const { getByText } = render(
      <HabitList isLoading={false} isError={true} refetch={refetchMock} />
    );
    
    expect(getByText('Unable to load habits')).toBeTruthy();
    
    // Test retry functionality
    fireEvent.press(getByText('Retry'));
    expect(refetchMock).toHaveBeenCalledTimes(1);
  });
  
  it('renders empty state correctly', () => {
    const { getByText } = render(
      <HabitList isLoading={false} habits={[]} refetch={jest.fn()} />
    );
    
    expect(getByText('No habits yet')).toBeTruthy();
    
    // Test create action
    fireEvent.press(getByText('Create a habit'));
    expect(router.push).toHaveBeenCalledWith('/planner/add-habit');
  });
  
  it('renders habits correctly', () => {
    const { getAllByText } = render(
      <HabitList isLoading={false} habits={mockHabits} refetch={jest.fn()} />
    );
    
    // Should render both habits
    expect(getAllByText(/Morning Meditation|Code Review/).length).toBe(2);
  });
  
  it('calls onToggleHabit when provided', () => {
    const onToggleHabitMock = jest.fn();
    const { getByText, getAllByTestId } = render(
      <HabitList 
        isLoading={false} 
        habits={mockHabits} 
        refetch={jest.fn()} 
        onToggleHabit={onToggleHabitMock} 
      />
    );
    
    // Find the first habit's toggle button
    const toggleButtons = getAllByTestId('icon-checkmark-circle-outline');
    fireEvent.press(toggleButtons[0].parent);
    
    // Should call onToggleHabit with the habit ID and completion status
    expect(onToggleHabitMock).toHaveBeenCalledWith('habit-1', true);
  });
});
```

### TaskList.test.tsx
**Path:** __tests__/components/lists/TaskList.test.tsx
**Size:** 4600 bytes

```typescript
import React from 'react';
import { render, fireEvent } from '../test-utils';
import { TaskList, TaskCard } from '@/components/lists/TaskList';
import { router } from 'expo-router';

// Mock router.push
jest.mock('expo-router', () => ({
  router: {
    push: jest.fn(),
  },
}));

// Define sample mock data that matches our Supabase schema via tRPC
const mockTasks = [
  {
    id: 'task-1',
    title: 'Create UI components',
    notes: 'Focus on reusable design patterns',
    due: '2025-05-01',
    completed: false,
    goal_id: 'goal-1',
    goal: { title: 'App Refactoring' },
    user_id: 'user-123',
  },
  {
    id: 'task-2',
    title: 'Write tests',
    notes: 'Ensure good coverage of components',
    due: '2025-05-03',
    completed: true,
    goal_id: null,
    goal: null,
    user_id: 'user-123',
  },
];

describe('TaskCard Component', () => {
  it('renders task information correctly', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <TaskCard task={mockTasks[0]} onPress={onPressMock} />
    );
    
    expect(getByText('Create UI components')).toBeTruthy();
    expect(getByText('Focus on reusable design patterns')).toBeTruthy();
    expect(getByText('May 1')).toBeTruthy();
    expect(getByText('App Refactoring')).toBeTruthy();
  });
  
  it('handles completion toggle correctly', () => {
    const onPressMock = jest.fn();
    const onCompleteMock = jest.fn();
    const { getByTestId } = render(
      <TaskCard 
        task={mockTasks[0]} 
        onPress={onPressMock} 
        onComplete={onCompleteMock} 
      />
    );
    
    // Find the toggle button (checkmark)
    const toggleButton = getByTestId('icon-checkmark-circle-outline');
    fireEvent.press(toggleButton.parent);
    
    // Should call onComplete with true (completed)
    expect(onCompleteMock).toHaveBeenCalledWith(true);
  });
  
  it('displays completed task with line-through', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <TaskCard task={mockTasks[1]} onPress={onPressMock} />
    );
    
    const titleElement = getByText('Write tests');
    // Text should have line-through style
    expect(titleElement.props.style).toBeDefined();
    // Would check for textDecorationLine: 'line-through' here, but we're mocking styles
  });
  
  it('shows overdue status for past due tasks', () => {
    const pastDueTask = {
      ...mockTasks[0],
      due: '2025-04-01', // Past date
    };
    
    const { getByText } = render(
      <TaskCard task={pastDueTask} onPress={jest.fn()} />
    );
    
    // Should show "Overdue" text
    expect(getByText(/Overdue:/)).toBeTruthy();
  });
});

describe('TaskList Component', () => {
  it('renders loading state correctly', () => {
    const { getByTestId } = render(
      <TaskList isLoading={true} refetch={jest.fn()} />
    );
    
    expect(getByTestId('skeleton-loader')).toBeTruthy();
  });
  
  it('renders error state correctly', () => {
    const refetchMock = jest.fn();
    const { getByText } = render(
      <TaskList isLoading={false} isError={true} refetch={refetchMock} />
    );
    
    expect(getByText('Unable to load tasks')).toBeTruthy();
    
    // Test retry functionality
    fireEvent.press(getByText('Retry'));
    expect(refetchMock).toHaveBeenCalledTimes(1);
  });
  
  it('renders empty state correctly', () => {
    const { getByText } = render(
      <TaskList isLoading={false} tasks={[]} refetch={jest.fn()} />
    );
    
    expect(getByText('No tasks yet')).toBeTruthy();
    
    // Test create action
    fireEvent.press(getByText('Create a task'));
    expect(router.push).toHaveBeenCalledWith('/planner/add-task');
  });
  
  it('renders tasks correctly', () => {
    const { getAllByText } = render(
      <TaskList isLoading={false} tasks={mockTasks} refetch={jest.fn()} />
    );
    
    // Should render both tasks
    expect(getAllByText(/Create UI components|Write tests/).length).toBe(2);
  });
  
  it('calls onCompleteTask when provided', () => {
    const onCompleteTaskMock = jest.fn();
    const { getByText, getAllByTestId } = render(
      <TaskList 
        isLoading={false} 
        tasks={mockTasks} 
        refetch={jest.fn()} 
        onCompleteTask={onCompleteTaskMock} 
      />
    );
    
    // Find the first task's toggle button
    const toggleButtons = getAllByTestId('icon-checkmark-circle-outline');
    fireEvent.press(toggleButtons[0].parent);
    
    // Should call onCompleteTask with the task ID and completion status
    expect(onCompleteTaskMock).toHaveBeenCalledWith('task-1', true);
  });
});
```

### AetherCard.test.tsx
**Path:** __tests__/components/ui/primitives/AetherCard.test.tsx
**Size:** 1733 bytes

```typescript
import React from 'react';
import { Text } from 'tamagui';
import { AetherCard } from '@/components/ui/primitives/AetherCard';
import { render, fireEvent } from '../../../test-utils';

describe('AetherCard Component', () => {
  it('renders correctly with default props', () => {
    const { getByText } = render(
      <AetherCard>
        <Text>Test Card Content</Text>
      </AetherCard>
    );
    
    expect(getByText('Test Card Content')).toBeTruthy();
  });
  
  it('applies the correct variant styles', () => {
    const { rerender, getByTestId } = render(
      <AetherCard testID="test-card" variant="default">
        <Text>Default Variant</Text>
      </AetherCard>
    );
    
    // Test default variant
    let card = getByTestId('test-card');
    expect(card.props.style).toBeDefined();
    
    // Test elevated variant
    rerender(
      <AetherCard testID="test-card" variant="elevated">
        <Text>Elevated Variant</Text>
      </AetherCard>
    );
    card = getByTestId('test-card');
    expect(card.props.style).toBeDefined();
    
    // Test outlined variant
    rerender(
      <AetherCard testID="test-card" variant="outlined">
        <Text>Outlined Variant</Text>
      </AetherCard>
    );
    card = getByTestId('test-card');
    expect(card.props.style).toBeDefined();
  });
  
  it('handles press events when interactive', () => {
    const onPressMock = jest.fn();
    const { getByTestId } = render(
      <AetherCard testID="interactive-card" isInteractive onPress={onPressMock}>
        <Text>Interactive Card</Text>
      </AetherCard>
    );
    
    const card = getByTestId('interactive-card');
    fireEvent.press(card);
    
    expect(onPressMock).toHaveBeenCalledTimes(1);
  });
});
```

### AetherListItem.test.tsx
**Path:** __tests__/components/ui/primitives/AetherListItem.test.tsx
**Size:** 2056 bytes

```typescript
import React from 'react';
import { render, fireEvent } from '@testing-library/react-native';
import { AetherListItem } from '@/components/ui/primitives/AetherListItem';

describe('AetherListItem Component', () => {
  it('renders with required props', () => {
    const { getByText } = render(
      <AetherListItem title="Test Item" />
    );
    
    expect(getByText('Test Item')).toBeTruthy();
  });
  
  it('renders with subtitle', () => {
    const { getByText } = render(
      <AetherListItem 
        title="Test Item" 
        subtitle="This is a subtitle" 
      />
    );
    
    expect(getByText('Test Item')).toBeTruthy();
    expect(getByText('This is a subtitle')).toBeTruthy();
  });
  
  it('renders with badge', () => {
    const { getByText } = render(
      <AetherListItem 
        title="Test Item" 
        badge="5" 
      />
    );
    
    expect(getByText('Test Item')).toBeTruthy();
    expect(getByText('5')).toBeTruthy();
  });
  
  it('renders with chevron when showChevron is true', () => {
    const { getByTestId } = render(
      <AetherListItem 
        title="Test Item" 
        showChevron 
      />
    );
    
    expect(getByTestId('icon-chevron-forward')).toBeTruthy();
  });
  
  it('handles press events', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <AetherListItem 
        title="Test Item" 
        onPress={onPressMock}
      />
    );
    
    const item = getByText('Test Item').parent.parent;
    fireEvent.press(item);
    
    expect(onPressMock).toHaveBeenCalledTimes(1);
  });
  
  it('applies the correct styles for the last item', () => {
    const { getByText, rerender } = render(
      <AetherListItem title="Regular Item" />
    );
    
    // Check regular item
    let item = getByText('Regular Item').parent.parent;
    expect(item.props.style).toBeDefined();
    
    // Check last item
    rerender(<AetherListItem title="Last Item" isLast />);
    item = getByText('Last Item').parent.parent;
    expect(item.props.style).toBeDefined();
  });
});
```

### dashboardRouter.getWeeklyProgress.test.ts
**Path:** __tests__/server/routers/dashboardRouter.getWeeklyProgress.test.ts
**Size:** 9354 bytes

```typescript
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { createInnerTRPCContext, mockSupabaseAdmin, MockableTableOperations } from '../test-helpers';
import { DeepMockProxy, mockDeep } from 'jest-mock-extended';
import { appRouter } from '../../../server/src/router';
import { TRPCError } from '@trpc/server';

// Type for database table names to avoid 'any' parameter type errors
type TableName = 'tasks' | 'goals' | 'habits' | 'habit_entries' | 'goal_progress_snapshots' | string;

// Using mockSupabaseAdmin from test-helpers

// Helper function to create test context
function createTestContext(userId: string | null = 'test-user-id') {
  return createInnerTRPCContext({
    userId,
    supabase: mockSupabaseAdmin,
  });
}

// Create test caller with context
function createTestCaller(userId: string | null = 'test-user-id') {
  const ctx = createTestContext(userId);
  return appRouter.createCaller(ctx);
}

describe('dashboardRouter.getWeeklyProgress', () => {
  beforeEach(() => {
    // Reset mocks before each test
    jest.clearAllMocks();
  });

  it('should fetch weekly progress with default parameters', async () => {
    // Setup mock data
    const habits = [
      { id: 'habit-1', name: 'Morning Run', frequency: 'daily', streak: 5, best_streak: 10 },
      { id: 'habit-2', name: 'Meditation', frequency: 'daily', streak: 3, best_streak: 7 },
    ];

    const habitEntries = [
      { id: 'entry-1', habit_id: 'habit-1', date: '2025-04-25', completed: true, habits: { id: 'habit-1', name: 'Morning Run', frequency: 'daily' } },
      { id: 'entry-2', habit_id: 'habit-1', date: '2025-04-26', completed: true, habits: { id: 'habit-1', name: 'Morning Run', frequency: 'daily' } },
      { id: 'entry-3', habit_id: 'habit-2', date: '2025-04-25', completed: false, habits: { id: 'habit-2', name: 'Meditation', frequency: 'daily' } },
    ];

    const completedTasks = [
      { id: 'task-1', title: 'Complete report', status: 'completed', updated_at: '2025-04-25T10:00:00Z', goal_id: 'goal-1' },
      { id: 'task-2', title: 'Send email', status: 'completed', updated_at: '2025-04-26T14:30:00Z', goal_id: null },
    ];

    const goalSnapshots = [
      { goal_id: 'goal-1', progress: 0.3, created_at: '2025-04-21T08:00:00Z' },
      { goal_id: 'goal-1', progress: 0.5, created_at: '2025-04-27T08:00:00Z' },
    ];

    // Create typed mock objects for each table
    const habitsTableMock = mockDeep<MockableTableOperations>();
    const habitEntriesTableMock = mockDeep<MockableTableOperations>();
    const tasksTableMock = mockDeep<MockableTableOperations>();
    const goalSnapshotsTableMock = mockDeep<MockableTableOperations>();

    // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
    mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
      if (table === 'habits') return habitsTableMock;
      if (table === 'habit_entries') return habitEntriesTableMock;
      if (table === 'tasks') return tasksTableMock;
      if (table === 'goal_progress_snapshots') return goalSnapshotsTableMock;
      
      // Default case - should not happen in this test
      return mockDeep<MockableTableOperations>();
    });

    // Configure each table mock's behavior
    // Habits table
    habitsTableMock.select.mockReturnThis();
    habitsTableMock.eq.mockReturnThis();
    habitsTableMock.order.mockReturnThis();
    habitsTableMock.limit.mockResolvedValue({ data: habits, error: null });

    // Habit entries table
    habitEntriesTableMock.select.mockReturnThis();
    habitEntriesTableMock.eq.mockReturnThis();
    habitEntriesTableMock.gte.mockReturnThis();
    habitEntriesTableMock.lte.mockReturnThis();
    habitEntriesTableMock.order.mockResolvedValue({ data: habitEntries, error: null });

    // Tasks table
    tasksTableMock.select.mockReturnThis();
    tasksTableMock.eq.mockReturnThis();
    tasksTableMock.gte.mockReturnThis();
    tasksTableMock.lte.mockReturnThis();
    // Add count method mock
    tasksTableMock.count.mockResolvedValue({ count: 10, error: null });
    tasksTableMock.order.mockResolvedValue({ data: completedTasks, error: null });

    // Goal progress snapshots table
    goalSnapshotsTableMock.select.mockReturnThis();
    goalSnapshotsTableMock.eq.mockReturnThis();
    goalSnapshotsTableMock.gte.mockReturnThis();
    goalSnapshotsTableMock.lte.mockReturnThis();
    goalSnapshotsTableMock.order.mockResolvedValue({ data: goalSnapshots, error: null });

    const caller = createTestCaller();
    const result = await caller.dashboard.getWeeklyProgress();

    // Verify structure of response
    expect(result).toHaveProperty('dailyProgress');
    expect(result).toHaveProperty('overallMetrics');
    expect(result).toHaveProperty('habitStreaks');
    expect(result).toHaveProperty('goalProgress');
    expect(result).toHaveProperty('dateRange');

    // Verify dates are processed correctly
    expect(result.dateRange.days.length).toBe(7); // Default is 7 days

    // Verify habit data is formatted correctly
    expect(result.habitStreaks).toContainEqual({
      id: 'habit-1',
      name: 'Morning Run',
      currentStreak: 5,
      bestStreak: 10,
    });

    // Verify goal progress is calculated correctly
    expect(result.goalProgress).toContainEqual(expect.objectContaining({
      goalId: 'goal-1',
      progressChange: 0.2, // 0.5 - 0.3
    }));
  });

  it('should handle custom date ranges', async () => {
    // Create typed mock objects for each table
    const tableMock = mockDeep<MockableTableOperations>();
    
    // Configure mockSupabaseAdmin.from to return the mock for any table
    mockSupabaseAdmin.from.mockImplementation(() => tableMock);
    
    // Configure basic behavior
    tableMock.select.mockReturnThis();
    tableMock.eq.mockReturnThis();
    tableMock.gte.mockReturnThis();
    tableMock.lte.mockReturnThis();
    tableMock.order.mockResolvedValue({ data: [], error: null });

    const caller = createTestCaller();
    const result = await caller.dashboard.getWeeklyProgress({ daysToInclude: 14 });

    // Verify date range is correct
    expect(result.dateRange.days.length).toBe(14);
  });

  it('should handle raw data inclusion when requested', async () => {
    // Setup minimal mock data
    const habitEntries = [
      { id: 'entry-1', habit_id: 'habit-1', date: '2025-04-25', completed: true },
    ];

    // Helper function to create mock table with data and thenable capability
    function createTableMockWithData<T>(data: T) {
      const mock = mockDeep<MockableTableOperations>();
      
      // Configure chainable methods to return this (for method chaining)
      mock.select.mockReturnThis();
      mock.eq.mockReturnThis();
      mock.gte.mockReturnThis();
      mock.lte.mockReturnThis();
      mock.order.mockReturnThis();
      
      // Make the mock awaitable with the provided data
      // Using a proper Promise interface implementation
      const response = { data, error: null, status: 200 };
      const mockPromise = Promise.resolve(response);
      
      // Add then/catch/finally methods to make the mock awaitable
      (mock as any).then = mockPromise.then.bind(mockPromise);
      (mock as any).catch = mockPromise.catch.bind(mockPromise);
      (mock as any).finally = mockPromise.finally.bind(mockPromise);
      
      return mock;
    }
    
    // Create typed mock objects with proper data
    const habitEntriesTableMock = createTableMockWithData(habitEntries);
    const defaultTableMock = createTableMockWithData([]);
    
    // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
    mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
      if (table === 'habit_entries') return habitEntriesTableMock;
      return defaultTableMock;
    });

    const caller = createTestCaller();
    const result = await caller.dashboard.getWeeklyProgress({ includeRawData: true });

    // Find the day that should have entries
    const dayWithData = result.dailyProgress.find(day => day.date === '2025-04-25');
    
    // Verify raw data is included
    expect(dayWithData).toHaveProperty('habitEntries');
    expect(dayWithData?.habitEntries).toHaveLength(1);
  });

  it('should handle database errors properly', async () => {
    // Create typed mock object for tables that will return an error
    const errorTableMock = mockDeep<MockableTableOperations>();
    
    // Configure mockSupabaseAdmin.from to return the error mock
    mockSupabaseAdmin.from.mockImplementation(() => errorTableMock);
    
    // Configure the mocked behavior to return an error
    errorTableMock.select.mockReturnThis();
    errorTableMock.eq.mockReturnThis();
    errorTableMock.gte.mockReturnThis();
    errorTableMock.lte.mockReturnThis();
    errorTableMock.order.mockResolvedValue({ 
      data: null, 
      error: { message: 'Database error', code: '42P01' } 
    });

    const caller = createTestCaller();
    
    // Expect the proper error to be thrown
    await expect(caller.dashboard.getWeeklyProgress()).rejects.toThrow(TRPCError);
  });

  it('should throw an error when user is not authenticated', async () => {
    const caller = createTestCaller(null);
    
    // Expect an unauthorized error
    await expect(caller.dashboard.getWeeklyProgress()).rejects.toThrow(TRPCError);
  });
});
```

### dashboardRouter.test.ts
**Path:** __tests__/server/routers/dashboardRouter.test.ts
**Size:** 8713 bytes

```typescript
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { createInnerTRPCContext, mockSupabaseAdmin, MockableTableOperations } from '../test-helpers';
import { DeepMockProxy, mockDeep } from 'jest-mock-extended';
import { appRouter } from '../../../server/src/router';
import { TRPCError } from '@trpc/server';

// Using mockSupabaseAdmin from test-helpers

// Type for database table names to avoid 'any' parameter type errors
type TableName = 'tasks' | 'goals' | 'habits' | 'habit_entries' | 'tracked_state_defs' | string;

/**
 * Create a test tRPC caller with proper context
 */
function createTestCaller(userId: string | null = 'test-user-id') {
  const ctx = createInnerTRPCContext({
    userId,
    supabase: mockSupabaseAdmin,
  });
  return appRouter.createCaller(ctx);
}

describe('dashboardRouter', () => {
  beforeEach(() => {
    // Reset all mocks before each test
    jest.clearAllMocks();
  });

  describe('getDashboardData', () => {
    it('should fetch dashboard data with default limits', async () => {
      // Mock data for habits aligned with updated schema
      const mockHabits = [
        {
          id: 'habit-1',
          user_id: 'test-user-id',
          title: 'Morning Run',
          cue: 'Wake up',
          routine: 'Go for a jog',
          reward: 'Coffee',
          streak: 3,
          best_streak: 5,
          created_at: '2024-04-20T12:00:00Z',
          updated_at: '2024-04-20T12:00:00Z'
        }
      ];

      // Mock data for goals aligned with updated schema
      const mockGoals = [
        {
          id: 'goal-1',
          user_id: 'test-user-id',
          title: 'Learn TypeScript',
          description: 'Master TypeScript for web development',
          progress: 0.5,
          target_date: '2024-06-01T00:00:00Z',
          created_at: '2024-04-15T10:00:00Z',
          updated_at: '2024-04-15T10:00:00Z'
        }
      ];

      // Mock data for tasks aligned with updated schema
      const mockTasks = [
        {
          id: 'task-1',
          user_id: 'test-user-id',
          title: 'Complete TypeScript course',
          notes: 'Focus on advanced types',
          status: 'in-progress',
          priority: 2,
          due: '2024-05-01T00:00:00Z',
          goal_id: 'goal-1',
          created_at: '2024-04-20T12:00:00Z',
          updated_at: '2024-04-20T12:00:00Z'
        }
      ];

      // Mock data for tracked states
      const mockTrackedStates: any[] = [];

      // Mock habit entries
      const mockHabitEntries = [
        {
          habit_id: 'habit-1',
          completed: true
        }
      ];

      // Create typed mock objects for each table, using our helper from test-helpers.ts
      function createTableMockWithData<T>(data: T) {
        const mock = mockDeep<MockableTableOperations>();
        
        // Configure chainable methods to return this (for method chaining)
        mock.select.mockReturnThis();
        mock.eq.mockReturnThis();
        mock.is.mockReturnThis();
        mock.neq.mockReturnThis();
        mock.or.mockReturnThis();
        mock.in.mockReturnThis();
        mock.order.mockReturnThis();
        mock.limit.mockReturnThis();
        
        // Make the mock awaitable with the provided data
        // Using a proper Promise interface implementation
        const response = { data, error: null, status: 200 };
        const mockPromise = Promise.resolve(response);
        
        // Add then/catch/finally methods to make the mock awaitable
        (mock as any).then = mockPromise.then.bind(mockPromise);
        (mock as any).catch = mockPromise.catch.bind(mockPromise);
        (mock as any).finally = mockPromise.finally.bind(mockPromise);
        
        return mock;
      }
      
      // Create mocks with the appropriate data
      const habitsTableMock = createTableMockWithData(mockHabits);
      const goalsTableMock = createTableMockWithData(mockGoals);
      const tasksTableMock = createTableMockWithData(mockTasks);
      const trackedStatesTableMock = createTableMockWithData(mockTrackedStates);
      const habitEntriesTableMock = createTableMockWithData(mockHabitEntries);

      // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
      mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
        if (table === 'habits') return habitsTableMock;
        if (table === 'goals') return goalsTableMock;
        if (table === 'tasks') return tasksTableMock;
        if (table === 'tracked_state_defs') return trackedStatesTableMock;
        if (table === 'habit_entries') return habitEntriesTableMock;
        
        // Default fallback - empty result mock
        return createTableMockWithData([]);
      });

      const caller = createTestCaller();
      const result = await caller.dashboard.getDashboardData();

      // Verify the result structure
      expect(result).toHaveProperty('habits');
      expect(result).toHaveProperty('goals');
      expect(result).toHaveProperty('tasks');
      expect(result).toHaveProperty('trackedStates');

      // Verify habits were formatted correctly
      expect(result.habits[0]).toEqual(expect.objectContaining({
        id: 'habit-1',
        title: 'Morning Run',
        streak: 3,
        completed: true
      }));

      // Verify goals were formatted correctly
      expect(result.goals[0]).toEqual(expect.objectContaining({
        id: 'goal-1',
        title: 'Learn TypeScript',
        progress: 0.5
      }));

      // Verify limits were passed correctly - now targeting the specific table mocks
      expect(habitsTableMock.limit).toHaveBeenCalledWith(5); // Default habit limit
      expect(tasksTableMock.limit).toHaveBeenCalledWith(10); // Default task limit
    });

    it('should fetch dashboard data with custom limits', async () => {
      // Create typed mock objects for each table
      const habitsTableMock = mockDeep<MockableTableOperations>();
      const goalsTableMock = mockDeep<MockableTableOperations>();
      const tasksTableMock = mockDeep<MockableTableOperations>();
      const trackedStatesTableMock = mockDeep<MockableTableOperations>();
      const habitEntriesTableMock = mockDeep<MockableTableOperations>();

      // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
      mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
        if (table === 'habits') return habitsTableMock;
        if (table === 'goals') return goalsTableMock;
        if (table === 'tasks') return tasksTableMock;
        if (table === 'tracked_state_defs') return trackedStatesTableMock;
        if (table === 'habit_entries') return habitEntriesTableMock;
        
        // Default case - should not happen in this test
        return mockDeep<MockableTableOperations>();
      });

      // No need to configure these mocks further - they already have their Promise behavior set
      // through the createTableMockWithData function with proper awaitable responses

      // Add specific behaviors needed for tasks
      tasksTableMock.neq.mockReturnThis();
      tasksTableMock.or.mockReturnThis();

      const caller = createTestCaller();
      await caller.dashboard.getDashboardData({
        habitLimit: 10,
        goalLimit: 15,
        taskLimit: 20
      });

      // Verify the custom limits were passed
      expect(mockSupabaseAdmin.limit).toHaveBeenCalledWith(10); // Custom habit limit
      expect(mockSupabaseAdmin.limit).toHaveBeenCalledWith(15); // Custom goal limit
      expect(mockSupabaseAdmin.limit).toHaveBeenCalledWith(20); // Custom task limit
    });

    it('should handle database errors properly', async () => {
      // Setup mock to simulate a database error
      mockSupabaseAdmin.from.mockImplementation(() => {
        return {
          ...mockSupabaseAdmin,
          select: jest.fn().mockReturnThis(),
          eq: jest.fn().mockReturnThis(),
          order: jest.fn().mockReturnThis(),
          limit: jest.fn().mockReturnValue({ 
            data: null, 
            error: { 
              message: 'Database error', 
              code: '42P01' // Table doesn't exist
            } 
          }),
        };
      });

      const caller = createTestCaller();
      
      // Expect the call to throw an INTERNAL_SERVER_ERROR
      await expect(caller.dashboard.getDashboardData()).rejects.toThrow(TRPCError);
    });

    it('should throw unauthorized error if no user is authenticated', async () => {
      const caller = createTestCaller(null);
      
      // Expect the call to throw an UNAUTHORIZED error
      await expect(caller.dashboard.getDashboardData()).rejects.toThrow(TRPCError);
    });
  });
});
```

### habitRouter.test.ts
**Path:** __tests__/server/routers/habitRouter.test.ts
**Size:** 32291 bytes

```typescript
import { describe, it, expect, beforeEach, jest, afterEach } from '@jest/globals';
import { createInnerTRPCContext, mockSupabaseAdmin, resetSupabaseMocks } from '../test-helpers'; 
import { appRouter } from '../../../server/src/router';
import { TRPCError } from '@trpc/server';
import { Habit } from '../../../server/src/types/trpc-types'; 

/**
 * Helper function to create a test context
 * This mimics how the tRPC context would be created in a real request
 */
function createTestContext(userId: string | null = 'test-user-id') {
  return createInnerTRPCContext({
    userId,
    supabase: mockSupabaseAdmin,
  });
}

/**
 * Create a test tRPC caller with proper context
 * @param userId Optional user ID for authenticated routes
 * @returns A tRPC caller that can be used to call procedures
 */
function createTestCaller(userId: string | null = 'test-user-id') {
  const ctx = createTestContext(userId);
  return appRouter.createCaller(ctx);
}

// Helper function to create a properly awaitable mock with data
function createTableMockWithData<T>(data: T) {
  const mock = mockDeep<MockableTableOperations>();
  
  // Configure chainable methods to return this (for method chaining)
  mock.select.mockReturnThis();
  mock.eq.mockReturnThis();
  mock.order.mockReturnThis();
  mock.limit.mockReturnThis();
  mock.in.mockReturnThis();
  mock.update.mockReturnThis();
  mock.is.mockReturnThis();
  mock.isNull.mockReturnThis();
  mock.neq.mockReturnThis();
  mock.or.mockReturnThis();
  mock.filter.mockReturnThis();
  mock.delete.mockReturnThis();
  mock.upsert.mockReturnThis();
  mock.insert.mockReturnThis();
  
  // Add proper promise handling for awaitable operations
  const response = { data, error: null, status: 200, count: Array.isArray(data) ? data.length : undefined };
  const mockPromise = Promise.resolve(response);
  
  // Add then/catch/finally methods to make the mock awaitable
  (mock as any).then = mockPromise.then.bind(mockPromise);
  (mock as any).catch = mockPromise.catch.bind(mockPromise);
  (mock as any).finally = mockPromise.finally.bind(mockPromise);
  
  return mock;
}

describe('habitRouter', () => {
  beforeEach(() => {
    resetSupabaseMocks();
  });

  describe('getHabits', () => {
    it('should fetch active habits for the user with completion status', async () => {
      // --- Arrange --- 
      const userId = 'test-user-id';
      const todayStr = new Date().toISOString().split('T')[0];
      const mockHabits: Habit[] = [
        { id: 'habit-1', user_id: userId, title: 'Habit 1', cue: 'Morning', routine: 'Exercise', reward: 'Coffee', habit_type: 'boolean', goal_quantity: null, goal_unit: null, frequency_period: 'day', goal_frequency: 1, recurrence_rule: 'RRULE:FREQ=DAILY', recurrence_end_date: null, archived_at: null, streak: 5, best_streak: 10, created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
        { id: 'habit-2', user_id: userId, title: 'Habit 2', cue: 'Evening', routine: 'Read', reward: 'Relax', habit_type: 'quantity', goal_quantity: 30, goal_unit: 'minutes', frequency_period: 'week', goal_frequency: 3, recurrence_rule: 'RRULE:FREQ=WEEKLY;BYDAY=MO,WE,FR', recurrence_end_date: null, archived_at: null, streak: 2, best_streak: 2, created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
      ];
      const mockEntriesToday = [
        { habit_id: 'habit-1' }, // Only habit 1 is completed today
      ];

      // Create properly awaitable mocks with the test data
      const habitsMock = createTableMockWithData(mockHabits);
      const entriesMock = createTableMockWithData(mockEntriesToday);

      // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
      mockSupabaseAdmin.from.mockImplementation((table: string) => {
        if (table === 'habits') return habitsMock;
        if (table === 'habit_entries') return entriesMock;
        return createTableMockWithData([]); // Default empty result for other tables
      });
      
      // --- Act --- 
      const caller = createTestCaller(userId);
      const result = await caller.habit.getHabits();

      // --- Assert --- 
      expect(result).toHaveLength(2);
      // Check all fields, including new ones and completedToday
      expect(result[0]).toMatchObject({ 
        ...mockHabits[0], 
        frequency_period: 'day', 
        goal_frequency: 1,
        completedToday: true 
      });
      expect(result[1]).toMatchObject({ 
        ...mockHabits[1], 
        frequency_period: 'week',
        goal_frequency: 3,
        completedToday: false 
      });

      // Verify mocks - Check if specific methods were called
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(1, 'habits');
      expect(selectHabitsMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(eqHabitsMock).toHaveBeenCalledWith('user_id', userId);
      expect(isNullHabitsMock).toHaveBeenCalledWith('archived_at', null); // Check is call
      expect(habitsFilterMock).toHaveBeenCalledTimes(1); // Ensure filter was called

      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(2, 'habit_entries');
      expect(selectEntriesMock).toHaveBeenCalledWith('habit_id');
      expect(eqUserEntriesMock).toHaveBeenCalledWith('user_id', userId);
      expect(eqDateEntriesMock).toHaveBeenCalledWith('date', todayStr);
      // Check the final resolving mock was called correctly
      expect(entriesFilterMock).toHaveBeenCalledWith('habit_id', expect.arrayContaining([mockHabits[0].id, mockHabits[1].id]));
    });

    it('should return an empty array if no habits exist', async () => {
        // --- Arrange ---
      const userId = 'test-user-id';

      const habitsFilterMock = jest.fn<() => Promise<{ data: Habit[] | null; error: any }>>();
      habitsFilterMock.mockResolvedValue({ data: [], error: null }); // Resolve empty
      const isNullHabitsMock = jest.fn().mockReturnValue({ filter: habitsFilterMock });
      const eqHabitsMock = jest.fn().mockReturnValue({ isNull: isNullHabitsMock });
      const selectHabitsMock = jest.fn().mockReturnValue({ eq: eqHabitsMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectHabitsMock,
      } as any);

      // --- Act ---
      const caller = createTestCaller(userId);
      const result = await caller.habit.getHabits();

      // --- Assert ---
      expect(result).toEqual([]);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      // Ensure habit_entries was NOT called because the initial habit fetch was empty
      expect(mockSupabaseAdmin.from).toHaveBeenCalledTimes(1); 
      expect(habitsFilterMock).toHaveBeenCalledTimes(1); // Check filter was still called before resolving
    });

    it('should throw TRPCError on database error during habit fetch', async () => {
      // --- Arrange ---
      const userId = 'test-user-id';
      const dbError = { message: 'DB error fetching habits', code: '500' };
      
      const habitsFilterMock = jest.fn<() => Promise<{ data: Habit[] | null; error: any }>>();
      habitsFilterMock.mockResolvedValue({ data: null, error: dbError }); // Simulate error
      const isNullHabitsMock = jest.fn().mockReturnValue({ filter: habitsFilterMock });
      const eqHabitsMock = jest.fn().mockReturnValue({ isNull: isNullHabitsMock });
      const selectHabitsMock = jest.fn().mockReturnValue({ eq: eqHabitsMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectHabitsMock,
      } as any);
      
      // --- Act & Assert ---
      const caller = createTestCaller(userId);
      await expect(caller.habit.getHabits()).rejects.toThrowError(
        new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message })
      );
      expect(habitsFilterMock).toHaveBeenCalledTimes(1);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledTimes(1);
    });

    it('should throw TRPCError on database error during entry fetch', async () => {
        // --- Arrange ---
      const userId = 'test-user-id';
      const todayStr = new Date().toISOString().split('T')[0];
      const mockHabits: Habit[] = [
        { id: 'habit-1', user_id: userId, title: 'Habit 1', cue: 'Morning', routine: 'Exercise', reward: 'Coffee', habit_type: 'boolean', goal_quantity: null, goal_unit: null, frequency_period: 'day', goal_frequency: 1, recurrence_rule: 'RRULE:FREQ=DAILY', recurrence_end_date: null, archived_at: null, streak: 5, best_streak: 10, created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
      ];
      const dbError = { message: 'DB error fetching entries', code: '500' };

      // Mock successful habit fetch
      const habitsFilterMock = jest.fn<() => Promise<{ data: Habit[] | null; error: any }>>();
      habitsFilterMock.mockResolvedValue({ data: mockHabits, error: null });
      const isNullHabitsMock = jest.fn().mockReturnValue({ filter: habitsFilterMock });
      const eqHabitsMock = jest.fn().mockReturnValue({ isNull: isNullHabitsMock });
      const selectHabitsMock = jest.fn().mockReturnValue({ eq: eqHabitsMock });

      // Mock failing entry fetch
      const entriesFilterMock = jest.fn<() => Promise<{ data: any[] | null; error: any }>>();
      entriesFilterMock.mockResolvedValue({ data: null, error: dbError });
      const eqDateEntriesMock = jest.fn().mockReturnValue({ filter: entriesFilterMock });
      const eqUserEntriesMock = jest.fn().mockReturnValue({ eq: eqDateEntriesMock });
      const selectEntriesMock = jest.fn().mockReturnValue({ eq: eqUserEntriesMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectHabitsMock,
      } as any).mockReturnValueOnce({ // Mock for 'habit_entries'
        select: selectEntriesMock,
      } as any);
      
      // --- Act & Assert ---
      const caller = createTestCaller(userId);
      await expect(caller.habit.getHabits()).rejects.toThrowError(
        new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message })
      );
      expect(habitsFilterMock).toHaveBeenCalledTimes(1);
      expect(entriesFilterMock).toHaveBeenCalledTimes(1); // Ensure entry fetch was attempted
    });
  });

  describe('getHabitById', () => {
    it('should fetch a specific habit by ID', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-abc';
      const mockHabit: Habit = { id: habitId, user_id: userId, title: 'Test Habit', cue: null, routine: null, reward: null, habit_type: 'boolean', goal_quantity: null, goal_unit: null, frequency_period: 'day', goal_frequency: 1, recurrence_rule: null, recurrence_end_date: null, archived_at: null, streak: 0, best_streak: 0, created_at: new Date().toISOString(), updated_at: new Date().toISOString() };

      // Corrected mock structure for chained eq calls
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: mockHabit, error: null });
      const userEqMock = jest.fn().mockReturnValue({ single: singleMock });
      const idEqMock = jest.fn().mockReturnValue({ eq: userEqMock });
      const selectMock = jest.fn().mockReturnValue({ eq: idEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectMock
      } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      const result = await caller.habit.getHabitById({ id: habitId });
      expect(result).toEqual(mockHabit);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(selectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at'); // Check select fields
      expect(idEqMock).toHaveBeenCalledWith('id', habitId);
      expect(userEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(singleMock).toHaveBeenCalled();
    });

    it('should throw NOT_FOUND error if habit doesnt exist or belongs to another user', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-abc';
      // Router now throws specific error, not just Supabase error
      const expectedError = new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied' });

      // Corrected mock structure for failing call
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: null, error: { message: 'Row not found', code: 'PGRST116' } });
      const userEqMock = jest.fn().mockReturnValue({ single: singleMock });
      const idEqMock = jest.fn().mockReturnValue({ eq: userEqMock });
      const selectMock = jest.fn().mockReturnValue({ eq: idEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectMock
      } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.getHabitById({ id: habitId })).rejects.toThrowError(
        expectedError
      );
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(selectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(idEqMock).toHaveBeenCalledWith('id', habitId);
      expect(userEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(singleMock).toHaveBeenCalled();
    });

     it('should throw INTERNAL_SERVER_ERROR on other database errors', async () => {
       // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-db-error';
      const dbError = { message: 'Generic DB Error', code: '500' };
      const expectedError = new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message });

      // Corrected mock structure for generic error
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: null, error: dbError });
      const userEqMock = jest.fn().mockReturnValue({ single: singleMock });
      const idEqMock = jest.fn().mockReturnValue({ eq: userEqMock });
      const selectMock = jest.fn().mockReturnValue({ eq: idEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectMock
      } as any);

       // Act
      const caller = createTestCaller(userId);
       // Assert
      await expect(caller.habit.getHabitById({ id: habitId })).rejects.toThrowError(
        expectedError
      );
       expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
       expect(selectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
       expect(idEqMock).toHaveBeenCalledWith('id', habitId);
       expect(userEqMock).toHaveBeenCalledWith('user_id', userId);
       expect(singleMock).toHaveBeenCalled();
     });
   });

  describe('createHabit', () => { 
    it('should create a new habit with default streaks', async () => {
      // Arrange
      const userId = 'test-user-id';
      const inputData = { title: 'New Habit', habit_type: 'boolean' as const, frequency_period: 'day' as const, goal_frequency: 1 };
      const expectedOutput: Habit = { id: 'new-id', user_id: userId, ...inputData, streak: 0, best_streak: 0, created_at: new Date().toISOString(), updated_at: new Date().toISOString(), cue: null, routine: null, reward: null, goal_quantity: null, goal_unit: null, recurrence_rule: null, recurrence_end_date: null, archived_at: null };

      // Correct mock structure for insert -> select -> single
      // Explicitly type the mock function to help with type inference
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: expectedOutput, error: null }); 
      const selectMock = jest.fn().mockReturnValue({ single: singleMock });
      const insertMock = jest.fn().mockReturnValue({ select: selectMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        insert: insertMock
      } as any);

      // Act
      const caller = createTestCaller(userId);
      const result = await caller.habit.createHabit(inputData);

      // Assert
      expect(result).toEqual(expectedOutput);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      // Check insert arguments carefully
      expect(insertMock).toHaveBeenCalledWith(expect.objectContaining({ 
          ...inputData,
          user_id: userId, 
          streak: 0, 
          best_streak: 0 
      }));
      expect(selectMock).toHaveBeenCalled(); // Check select was called after insert
      expect(singleMock).toHaveBeenCalled(); // Check single was called after select
    });

    it('should throw TRPCError on database error', async () => {
      // Arrange
      const userId = 'test-user-id';
      const inputData = { title: 'Fail Habit', habit_type: 'boolean' as const, frequency_period: 'day' as const, goal_frequency: 1 };
      const dbError = { message: 'Insert failed', code: '500' };
      const expectedError = new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message });

      // Correct mock structure for failing insert
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: null, error: dbError });
      const selectMock = jest.fn().mockReturnValue({ single: singleMock });
      const insertMock = jest.fn().mockReturnValue({ select: selectMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
         insert: insertMock
      } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.createHabit(inputData)).rejects.toThrowError(
        expectedError
      );
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      // Check insert arguments
       expect(insertMock).toHaveBeenCalledWith(expect.objectContaining({ 
          ...inputData,
          user_id: userId, 
          streak: 0, 
          best_streak: 0 
      }));
      expect(selectMock).toHaveBeenCalled();
      expect(singleMock).toHaveBeenCalled();
    });
  });

  describe('updateHabit', () => { 
    it('should update an existing habit', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-to-update';
      const updateData = { title: 'Updated Title' };
      // Define the full initial and updated habit objects (need all fields for Habit type)
      const baseHabit = { id: habitId, user_id: userId, cue: null, routine: null, reward: null, habit_type: 'boolean' as const, goal_quantity: null, goal_unit: null, frequency_period: 'day' as const, goal_frequency: 1, recurrence_rule: null, recurrence_end_date: null, archived_at: null, streak: 5, best_streak: 10, created_at: new Date(Date.now() - 100000).toISOString(), updated_at: new Date(Date.now() - 50000).toISOString() }; 
      const initialHabit: Habit = { ...baseHabit, title: 'Old Title' };
      const updatedHabit: Habit = { ...initialHabit, ...updateData, updated_at: new Date().toISOString(), id: habitId, user_id: userId, cue: null, routine: null, reward: null, habit_type: 'boolean', goal_quantity: null, goal_unit: null, frequency_period: 'day', goal_frequency: 1, recurrence_rule: null, recurrence_end_date: null, archived_at: null, streak: 0, best_streak: 0, created_at: new Date().toISOString() };

      // Mock 1: Initial fetch for ownership check (getHabitById logic)
      const fetchSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      fetchSingleMock.mockResolvedValue({ data: initialHabit, error: null });
      const fetchUserEqMock = jest.fn().mockReturnValue({ single: fetchSingleMock });
      const fetchIdEqMock = jest.fn().mockReturnValue({ eq: fetchUserEqMock });
      const fetchSelectMock = jest.fn().mockReturnValue({ eq: fetchIdEqMock });

      // Mock 2: Update operation
      const updateSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      updateSingleMock.mockResolvedValue({ data: updatedHabit, error: null });
      const updateSelectMock = jest.fn().mockReturnValue({ single: updateSingleMock });
      const updateUserEqMock = jest.fn().mockReturnValue({ select: updateSelectMock });
      const updateIdEqMock = jest.fn().mockReturnValue({ eq: updateUserEqMock });
      const updateMock = jest.fn().mockReturnValue({ eq: updateIdEqMock });

      // Chain the mocks: from('habits') -> select (for fetch) -> update 
      mockSupabaseAdmin.from.mockReturnValueOnce({ select: fetchSelectMock } as any)
                             .mockReturnValueOnce({ update: updateMock } as any); // Second call to from('habits') is for update

      // Act
      const caller = createTestCaller(userId);
      const result = await caller.habit.updateHabit({ id: habitId, ...updateData });

      // Assert
      expect(result).toEqual(updatedHabit);

      // Assert fetch mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(1, 'habits');
      expect(fetchSelectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(fetchIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(fetchUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(fetchSingleMock).toHaveBeenCalled();

      // Assert update mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(2, 'habits');
      expect(updateMock).toHaveBeenCalledWith(expect.objectContaining(updateData));
      expect(updateIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(updateUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(updateSelectMock).toHaveBeenCalled();
      expect(updateSingleMock).toHaveBeenCalled();
    });

    it('should throw NOT_FOUND error if habit doesnt exist or belongs to another user during initial fetch', async () => { // Renamed for clarity
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'non-existent-habit';
      const updateData = { title: 'Wont Update' };
      const expectedError = new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied' });

      // Mock only the initial fetch, have it return not found
      const fetchSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      fetchSingleMock.mockResolvedValue({ data: null, error: { message: 'Row not found', code: 'PGRST116' } });
      const fetchUserEqMock = jest.fn().mockReturnValue({ single: fetchSingleMock });
      const fetchIdEqMock = jest.fn().mockReturnValue({ eq: fetchUserEqMock });
      const fetchSelectMock = jest.fn().mockReturnValue({ eq: fetchIdEqMock });

      // Only mock 'from' once for the fetch
      mockSupabaseAdmin.from.mockReturnValueOnce({ select: fetchSelectMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.updateHabit({ id: habitId, ...updateData })).rejects.toThrowError(expectedError);
      // Verify fetch mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenCalledTimes(1);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(fetchSelectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(fetchIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(fetchUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(fetchSingleMock).toHaveBeenCalled();
      // Crucially, ensure no update mock was ever created or called
    });

    it('should throw TRPCError on database error during update operation', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-to-update';
      const updateData = { title: 'Updated Title' };
      // Reuse initial habit definition
      const baseHabit = { id: habitId, user_id: userId, cue: null, routine: null, reward: null, habit_type: 'boolean' as const, goal_quantity: null, goal_unit: null, frequency_period: 'day' as const, goal_frequency: 1, recurrence_rule: null, recurrence_end_date: null, archived_at: null, streak: 5, best_streak: 10, created_at: new Date(Date.now() - 100000).toISOString(), updated_at: new Date(Date.now() - 50000).toISOString() }; 
      const initialHabit: Habit = { ...baseHabit, title: 'Old Title' };
      const dbError = { message: 'Update failed', code: '500' };
      const expectedError = new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message });

      // Mock 1: Initial fetch for ownership check (success)
      const fetchSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      fetchSingleMock.mockResolvedValue({ data: initialHabit, error: null });
      const fetchUserEqMock = jest.fn().mockReturnValue({ single: fetchSingleMock });
      const fetchIdEqMock = jest.fn().mockReturnValue({ eq: fetchUserEqMock });
      const fetchSelectMock = jest.fn().mockReturnValue({ eq: fetchIdEqMock });

      // Mock 2: Update operation (failure)
      const updateSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      updateSingleMock.mockResolvedValue({ data: null, error: dbError }); // Make the update return the error
      const updateSelectMock = jest.fn().mockReturnValue({ single: updateSingleMock });
      const updateUserEqMock = jest.fn().mockReturnValue({ select: updateSelectMock });
      const updateIdEqMock = jest.fn().mockReturnValue({ eq: updateUserEqMock });
      const updateMock = jest.fn().mockReturnValue({ eq: updateIdEqMock });

       // Chain the mocks: from('habits') -> select (for fetch) -> update (fails)
      mockSupabaseAdmin.from.mockReturnValueOnce({ select: fetchSelectMock } as any)
                             .mockReturnValueOnce({ update: updateMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.updateHabit({ id: habitId, ...updateData })).rejects.toThrowError(expectedError);

      // Assert fetch mock calls (should have succeeded)
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(1, 'habits');
      expect(fetchSelectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(fetchIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(fetchUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(fetchSingleMock).toHaveBeenCalled();

      // Assert update mock calls (should have been called but failed)
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(2, 'habits');
      expect(updateMock).toHaveBeenCalledWith(expect.objectContaining(updateData));
      expect(updateIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(updateUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(updateSelectMock).toHaveBeenCalled();
      expect(updateSingleMock).toHaveBeenCalled();
    });
  });

  describe('deleteHabit', () => { 
    it('should delete an existing habit and return true', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-to-delete';

      // Mock delete -> eq(id) -> eq(user_id) -> resolves successfully
      // Explicitly type the mock function to help with type inference
      const deleteUserEqMock = jest.fn<() => Promise<{ data: null; error: any }>>();
      deleteUserEqMock.mockResolvedValue({ data: null, error: null }); // Success is indicated by no error
      const deleteIdEqMock = jest.fn().mockReturnValue({ eq: deleteUserEqMock });
      const deleteMock = jest.fn().mockReturnValue({ eq: deleteIdEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ delete: deleteMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.deleteHabit({ id: habitId })).resolves.toBe(true);
      // Verify mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(deleteMock).toHaveBeenCalled();
      expect(deleteIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(deleteUserEqMock).toHaveBeenCalledWith('user_id', userId);
    });

    it('should throw NOT_FOUND error if habit to delete doesnt exist or belongs to another user', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'non-existent-habit';
      const expectedError = new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or cannot be deleted' });

      // Mock delete -> eq(id) -> eq(user_id) -> resolves with error (or indicates 0 rows affected)
      // Simulate a 'not found' scenario, Supabase might return an error or just indicate 0 rows affected.
      // Let's mock returning an error that the router interprets as NOT_FOUND.
      const dbError = { message: 'Row not found', code: 'PGRST116' }; // Example error
      const deleteUserEqMock = jest.fn<() => Promise<{ data: null; error: any }>>();
      deleteUserEqMock.mockResolvedValue({ data: null, error: dbError });
      const deleteIdEqMock = jest.fn().mockReturnValue({ eq: deleteUserEqMock });
      const deleteMock = jest.fn().mockReturnValue({ eq: deleteIdEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ delete: deleteMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.deleteHabit({ id: habitId })).rejects.toThrowError(expectedError);
      // Verify mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(deleteMock).toHaveBeenCalled();
      expect(deleteIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(deleteUserEqMock).toHaveBeenCalledWith('user_id', userId);
    });

    it('should throw TRPCError on database error during delete operation', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-delete-error';
      const dbError = { message: 'Internal DB Error', code: '500' };
      const expectedError = new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message });

      // Mock delete -> eq(id) -> eq(user_id) -> resolves with a generic error
      const deleteUserEqMock = jest.fn<() => Promise<{ data: null; error: any }>>();
      deleteUserEqMock.mockResolvedValue({ data: null, error: dbError });
      const deleteIdEqMock = jest.fn().mockReturnValue({ eq: deleteUserEqMock });
      const deleteMock = jest.fn().mockReturnValue({ eq: deleteIdEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ delete: deleteMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.deleteHabit({ id: habitId })).rejects.toThrowError(expectedError);
      // Verify mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(deleteMock).toHaveBeenCalled();
      expect(deleteIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(deleteUserEqMock).toHaveBeenCalledWith('user_id', userId);
    });
  });

  // TODO: Add describe blocks for archive/unarchive and habit entry procedures
});
```

### taskRouter.toggleTask.test.ts
**Path:** __tests__/server/routers/taskRouter.toggleTask.test.ts
**Size:** 14286 bytes

```typescript
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { 
  createInnerTRPCContext, 
  mockSupabaseAdmin, 
  MockableTableOperations, 
  resetSupabaseMocks, 
  MockablePostgrestResponse 
} from '../test-helpers';
import { DeepMockProxy, mockDeep } from 'jest-mock-extended';
import { appRouter } from '../../../server/src/router';
import { TRPCError } from '@trpc/server';

// Type for database table names to avoid 'any' parameter type errors
type TableName = 'tasks' | 'goals' | 'habits' | string;

// Helper function to create test context
function createTestContext(userId: string | null = 'test-user-id') {
  return createInnerTRPCContext({
    userId,
    supabase: mockSupabaseAdmin,
  });
}

// Create test caller with context
function createTestCaller(userId: string | null = 'test-user-id') {
  const ctx = createTestContext(userId);
  return appRouter.createCaller(ctx);
}

describe('taskRouter.toggleTask', () => {
  beforeEach(() => {
    // Reset mocks before each test
    resetSupabaseMocks();
  });

  it('should toggle a task from incomplete to complete', async () => {
    const taskId = 'task-1';
    const userId = 'test-user-id';
    const initialTaskData = {
      id: taskId,
      user_id: userId,
      title: 'Test Task',
      notes: null,
      status: 'in-progress',
      priority: 2,
      due: null,
      goal_id: null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };
    const updatedTaskData = {
      id: taskId,
      user_id: userId,
      title: 'Test Task',
      notes: null,
      status: 'completed', // This is the expected final status
      priority: 2,
      due: null,
      goal_id: null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(), // Include fields returned by select
    };

    // Mock setup for 'tasks' table operations
    const fetchMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(fetchMock); // Consistently return fetchMock for 'tasks'

    // Configure chainable methods to return the mock itself
    fetchMock.select.mockReturnValue(fetchMock);
    fetchMock.eq.mockReturnValue(fetchMock);
    fetchMock.update.mockReturnValue(fetchMock);

    // Configure .single() to resolve differently for fetch vs update
    fetchMock.single
      .mockResolvedValueOnce({ data: initialTaskData, error: null }) // First call (fetch)
      .mockResolvedValueOnce({ data: updatedTaskData, error: null }); // Second call (update confirmation)

    const caller = createTestCaller(userId);
    const result = await caller.task.toggleTask({
      taskId: taskId,
    });

    // Verify the result
    expect(result.status).toBe('completed');

    // Verify calls
    expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('tasks');
    expect(fetchMock.select).toHaveBeenCalledWith('id, status, goal_id, title');
    expect(fetchMock.update).toHaveBeenCalledWith(expect.objectContaining({ status: 'completed' }));
    expect(fetchMock.eq).toHaveBeenCalledWith('id', taskId);
    expect(fetchMock.eq).toHaveBeenCalledWith('user_id', userId);
    expect(fetchMock.select).toHaveBeenCalledWith('id, title, status, goal_id, updated_at');
    expect(fetchMock.single).toHaveBeenCalledTimes(2); // Called for fetch and update
  });

  it('should toggle a task from complete to incomplete', async () => {
    const taskId = 'task-1';
    const userId = 'test-user-id';
    const initialTaskData = {
      id: taskId,
      title: 'Test Task',
      status: 'completed', // Starting completed
      goal_id: null,
    };
    const updatedTaskData = {
      id: taskId,
      title: 'Test Task',
      status: 'in-progress', // Expected final status
      goal_id: null,
      updated_at: new Date().toISOString(),
    };

    // Mock setup for 'tasks' table operations
    const fetchMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(fetchMock); // Consistently return fetchMock

    // Configure chainable methods
    fetchMock.select.mockReturnValue(fetchMock);
    fetchMock.eq.mockReturnValue(fetchMock);
    fetchMock.update.mockReturnValue(fetchMock);

    // Configure .single() resolutions
    fetchMock.single
      .mockResolvedValueOnce({ data: initialTaskData, error: null }) // First call (fetch)
      .mockResolvedValueOnce({ data: updatedTaskData, error: null }); // Second call (update confirmation)

    const caller = createTestCaller(userId);
    const result = await caller.task.toggleTask({
      taskId: taskId,
    });

    // Verify the result
    expect(result.status).toBe('in-progress');

    // Verify calls
    expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('tasks');
    expect(fetchMock.select).toHaveBeenCalledWith('id, status, goal_id, title');
    expect(fetchMock.update).toHaveBeenCalledWith(expect.objectContaining({ status: 'in-progress' }));
    expect(fetchMock.eq).toHaveBeenCalledWith('id', taskId);
    expect(fetchMock.eq).toHaveBeenCalledWith('user_id', userId);
    expect(fetchMock.select).toHaveBeenCalledWith('id, title, status, goal_id, updated_at');
    expect(fetchMock.single).toHaveBeenCalledTimes(2); // Called for fetch and update
  });

  it('should update goal progress when toggling a task with goal association', async () => {
    const taskId = 'task-1';
    const goalId = 'goal-1';
    const userId = 'test-user-id';

    // --- Task Mocks --- 
    const taskFetchMock = mockDeep<MockableTableOperations>();
    const initialTaskData = { id: taskId, title: 'Goal Task', status: 'in-progress', goal_id: goalId };
    const updatedTaskData = { ...initialTaskData, status: 'completed', updated_at: new Date().toISOString() };
    
    taskFetchMock.select.mockReturnValue(taskFetchMock);
    taskFetchMock.eq.mockReturnValue(taskFetchMock);
    taskFetchMock.update.mockReturnValue(taskFetchMock);
    taskFetchMock.single
      .mockResolvedValueOnce({ data: initialTaskData, error: null }) // Fetch task
      .mockResolvedValueOnce({ data: updatedTaskData, error: null }); // Update task

    // Helper function to create a properly awaitable mock with data
    function createTableMockWithData<T>(data: T) {
      const mock = mockDeep<MockableTableOperations>();
      
      // Configure chainable methods to return this (for method chaining)
      mock.select.mockReturnThis();
      mock.eq.mockReturnThis();
      mock.order.mockReturnThis();
      mock.limit.mockReturnThis();
      mock.in.mockReturnThis();
      mock.update.mockReturnThis();
      mock.is.mockReturnThis();
      mock.neq.mockReturnThis();
      mock.or.mockReturnThis();
      
      // Add proper promise handling for awaitable operations
      const response = { data, error: null, status: 200, count: Array.isArray(data) ? data.length : undefined };
      const mockPromise = Promise.resolve(response);
      
      // Add then/catch/finally methods to make the mock awaitable
      (mock as any).then = mockPromise.then.bind(mockPromise);
      (mock as any).catch = mockPromise.catch.bind(mockPromise);
      (mock as any).finally = mockPromise.finally.bind(mockPromise);
      
      return mock;
    }
    
    // --- Goal Task List Mock --- 
    // Create a properly awaitable mock with the goal tasks data
    const goalTasksData = [
        { id: taskId, status: 'completed' }, // The toggled task
        { id: 'task-2', status: 'in-progress' },
    ];
    const goalTasksListMock = createTableMockWithData(goalTasksData);

    // --- Goal Update Mock --- 
    const updatedGoalData = { id: goalId, name: 'Test Goal', progress: 0.5, /* other fields */ updated_at: new Date().toISOString() }; // Example with 50% progress
    
    // Create an awaitable mock with the goal update data
    const goalUpdateMock = createTableMockWithData(updatedGoalData);
    // Make sure single() returns a properly typed response
    goalUpdateMock.single.mockResolvedValue({ data: updatedGoalData, error: null });


    // --- Configure from() to return the right mock based on table --- 
    mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
      if (table === 'tasks') {
        // First call to 'tasks' is for the initial fetch/update of the specific task
        // Second call is to get all tasks for the goal
        // Need a way to differentiate... maybe check chained methods?
        // For now, let's assume the first call structure uses single(), the second doesn't directly
        // A more robust way might involve mockFn.mock.calls inspection or clearer separation.
        // Let's try returning taskFetchMock first, then goalTasksListMock.
        if (mockSupabaseAdmin.from.mock.calls.filter(c => c[0] === 'tasks').length <= 1) {
            return taskFetchMock;
        } else {
            return goalTasksListMock;
        }
      }
      if (table === 'goals') {
        return goalUpdateMock; // Only call to 'goals' is for the update
      }
      // Fallback for any other table calls in the test setup (if any)
      const defaultMock = mockDeep<MockableTableOperations>();
      defaultMock.select.mockReturnValue(defaultMock);
      defaultMock.eq.mockReturnValue(defaultMock);
      defaultMock.single.mockResolvedValue({ data: null, error: { message: 'Default mock', code: 'MOCK_ERR' } });
      return defaultMock;
    });

    const caller = createTestCaller(userId);
    const result = await caller.task.toggleTask({
      taskId: taskId,
    });

    // Assertions
    expect(result.status).toBe('completed');
    expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('tasks'); // Called multiple times
    expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('goals');
    
    // Verify task update
    expect(taskFetchMock.update).toHaveBeenCalledWith(expect.objectContaining({ status: 'completed' }));
    expect(taskFetchMock.single).toHaveBeenCalledTimes(2); // Fetch + Update task

    // Verify fetching goal tasks
    expect(goalTasksListMock.select).toHaveBeenCalledWith('id, status');
    expect(goalTasksListMock.eq).toHaveBeenCalledWith('goal_id', goalId);

    // Verify goal update
    expect(goalUpdateMock.update).toHaveBeenCalledWith({ progress: 0.5 }); // 1 out of 2 tasks complete
    expect(goalUpdateMock.eq).toHaveBeenCalledWith('id', goalId);
    expect(goalUpdateMock.select).toHaveBeenCalledWith('id, name, progress, updated_at');
    expect(goalUpdateMock.single).toHaveBeenCalledTimes(1);

    // Reset implementation for next tests if needed (though beforeEach should handle it)
    // mockSupabaseAdmin.from.mockRestore(); // Or reset in beforeEach

  });

  it('should not change status if already in the target state', async () => {
    const taskId = 'task-1';
    const userId = 'test-user-id';
    const existingTask = {
      id: taskId,
      title: 'Test Task',
      status: 'completed',
      goal_id: null,
    };

    // --- Configure from() for tasks table --- 
    const tasksTableMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(tasksTableMock);
    tasksTableMock.select.mockReturnValue(tasksTableMock);
    tasksTableMock.eq.mockReturnValue(tasksTableMock);
    tasksTableMock.single.mockResolvedValue({ data: existingTask, error: null });

    // --- Configure from() for goals table (should not be called) ---
    const goalsTableMock = mockDeep<MockableTableOperations>();
    // ... setup mocks for goals table ...
    // This setup is complex, let's simplify if goal logic isn't tested here
    // goalsTableMock.update.mockReturnValue(goalsTableMock);
    // goalsTableMock.eq.mockReturnValue(goalsTableMock);
    // goalsTableMock.select.mockReturnValue(goalsTableMock);
    // goalsTableMock.single.mockResolvedValue({ data: null, error: null });
    // mockSupabaseAdmin.from('goals').mockReturnValue(goalsTableMock);
    const caller = createTestCaller(userId);
    const result = await caller.task.toggleTask({
      taskId: taskId,
    });

    // Verify the result
    expect(result.status).toBe('completed');

    // Verify no update was performed
    expect(mockSupabaseAdmin.from('tasks').update).not.toHaveBeenCalled();
    expect(mockSupabaseAdmin.from('goals').update).not.toHaveBeenCalled(); // Ensure goal not updated
  });

  it('should throw NOT_FOUND error if task does not exist', async () => {
    // Mock the initial fetch to return no data
    const fetchMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(fetchMock);
    fetchMock.select.mockReturnValue(fetchMock);
    fetchMock.eq.mockReturnValue(fetchMock);
    fetchMock.single.mockResolvedValue({ data: null, error: null }); // Simulate task not found

    const caller = createTestCaller();
    await expect(caller.task.toggleTask({ taskId: 'nonexistent-task' }))
      .rejects.toMatchObject({ code: 'NOT_FOUND' });

    // Ensure update was not called
    expect(fetchMock.update).not.toHaveBeenCalled();
  });

  it('should throw an error if the database update fails', async () => {
    const taskId = 'task-1';
    const userId = 'test-user-id';
    const initialTaskData = { id: taskId, status: 'in-progress', goal_id: null, title: 'Test' };
    const dbError = { message: 'Update failed', code: 'DB_ERROR' };

    // Mock the initial fetch
    const fetchMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(fetchMock);
    fetchMock.select.mockReturnValue(fetchMock);
    fetchMock.eq.mockReturnValue(fetchMock);
    fetchMock.update.mockReturnValue(fetchMock); // Update returns mock for chaining

    // Mock .single() for initial fetch (success) and update (failure)
    fetchMock.single
      .mockResolvedValueOnce({ data: initialTaskData, error: null }) // Fetch succeeds
      .mockResolvedValueOnce({ data: null, error: dbError });       // Update fails

    const caller = createTestCaller(userId);
    await expect(caller.task.toggleTask({ taskId: taskId }))
      .rejects.toMatchObject({ message: 'Update failed', code: 'DB_ERROR' });

    // Verify update was attempted
    expect(fetchMock.update).toHaveBeenCalledWith(expect.objectContaining({ status: 'completed' }));
    expect(fetchMock.single).toHaveBeenCalledTimes(2); // Fetch + Update attempt
  });

});
```

### test-helpers.ts
**Path:** __tests__/server/test-helpers.ts
**Size:** 10364 bytes

```typescript
import { mockDeep, mockReset, DeepMockProxy } from 'jest-mock-extended';
import { User, AuthError } from '@supabase/supabase-js';
import { type Context } from '@/server/src/context';
import { TRPCError } from '@trpc/server';

// --- Common Response Type --- 
// Represents the core structure of Supabase Postgrest responses
export type MockablePostgrestResponse<T> = Promise<{
  data: T | null;
  error: any;
  count?: number | null; 
  status?: number;
  statusText?: string;
}>;

// --- Interface for CHAINABLE Query Builder methods --- 
// These methods return the builder itself to allow chaining.
export interface MockableQueryBuilder {
  select: (query?: string, options?: { head?: boolean; count?: 'exact' | 'planned' | 'estimated' }) => MockableQueryBuilder;
  eq: (column: string, value: any) => MockableQueryBuilder;
  neq: (column: string, value: any) => MockableQueryBuilder;
  gt: (column: string, value: any) => MockableQueryBuilder;
  gte: (column: string, value: any) => MockableQueryBuilder;
  lt: (column: string, value: any) => MockableQueryBuilder;
  lte: (column: string, value: any) => MockableQueryBuilder;
  like: (column: string, pattern: string) => MockableQueryBuilder;
  ilike: (column: string, pattern: string) => MockableQueryBuilder;
  is: (column: string, value: boolean | null) => MockableQueryBuilder;
  in: (column: string, values: any[]) => MockableQueryBuilder;
  contains: (column: string, value: any) => MockableQueryBuilder;
  containedBy: (column: string, value: any) => MockableQueryBuilder;
  rangeGt: (column: string, range: string) => MockableQueryBuilder;
  rangeGte: (column: string, range: string) => MockableQueryBuilder;
  rangeLt: (column: string, range: string) => MockableQueryBuilder;
  rangeLte: (column: string, range: string) => MockableQueryBuilder;
  rangeAdjacent: (column: string, range: string) => MockableQueryBuilder;
  overlaps: (column: string, value: any) => MockableQueryBuilder;
  textSearch: (column: string, query: string, options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }) => MockableQueryBuilder;
  match: (query: Record<string, unknown>) => MockableQueryBuilder;
  not: (column: string, operator: string, value: any) => MockableQueryBuilder;
  or: (filters: string, options?: { referencedTable?: string }) => MockableQueryBuilder;
  filter: (column: string, operator: string, value: any) => MockableQueryBuilder;
  limit: (count: number, options?: { referencedTable?: string }) => MockableQueryBuilder;
  range: (from: number, to: number, options?: { referencedTable?: string }) => MockableQueryBuilder;
  order: (column: string, options?: { ascending?: boolean; nullsFirst?: boolean; referencedTable?: string }) => MockableQueryBuilder;
}

// --- Interface for Operations on a Table (after .from()) --- 
// Inherits chainable methods AND adds terminal methods returning Promises.
export interface MockableTableOperations extends MockableQueryBuilder {
  // Terminal methods (return Promises)
  single: <T = any>() => MockablePostgrestResponse<T>;
  maybeSingle: <T = any>() => MockablePostgrestResponse<T>;
  // Note: Insert/Update/Upsert often return arrays in Supabase v2, but the *methods* return the builder
  insert: <T = any>(values: any | any[], options?: any) => MockableTableOperations; 
  upsert: <T = any>(values: any | any[], options?: any) => MockableTableOperations; 
  update: <T = any>(values: any, options?: any) => MockableTableOperations; 
  delete: (options?: any) => MockableTableOperations; 
}

// --- Interface for the Supabase Client itself --- 
/**
 * Represents the structure of the Supabase client that we need to mock.
 * `from` returns an object combining chainable and terminal methods.
 */
export interface MockableSupabaseClient {
  // `from` now returns the object with both chainable and terminal methods
  from: (relation: string) => MockableTableOperations;

  // Top-level client methods
  auth: {
    getUser: (
      jwt?: string
    ) => Promise<{ data: { user: User | null }; error: AuthError | null }>;
    // Add other auth methods here if needed by tests (e.g., signUp, signInWithPassword)
  };
  rpc: <T = any>(fn: string, params?: object, options?: { head?: boolean; count?: 'exact' | 'planned' | 'estimated' }) => MockablePostgrestResponse<T>;
  // Add storage interface here if needed by tests
  // storage: { ... };
}

// --- Mock Implementation --- 

// Create a deep mock instance conforming to the refined interface
export const mockSupabaseAdmin = mockDeep<MockableSupabaseClient>();

// Helper to reset mocks
export function resetSupabaseMocks() {
  // Use mockReset for better compatibility with jest-mock-extended
  mockReset(mockSupabaseAdmin);

  // --- Re-apply default implementations after reset --- 

  // Default: Successful authentication
  mockSupabaseAdmin.auth.getUser.mockResolvedValue({
    data: { user: { id: 'test-user-id', /* other user props */ } as User },
    error: null,
  });

  // Default: Successful RPC call returning null data
  mockSupabaseAdmin.rpc.mockResolvedValue({ 
      data: null, 
      error: null, 
      count: 0, 
      status: 200, 
      statusText: 'OK' 
  });

  // Helper type to create Promise-like chain-terminating objects
  type AsyncResult<T> = Promise<{ data: T | null; error: any; count?: number; status?: number; statusText?: string; }>;

  // Helper function to create a proper mock that handles both chaining AND awaiting
  function createMockWithPromiseCapability<T>(defaultData: T | null = null): any {
    const mockObj = mockDeep<MockableTableOperations>();
    
    // Add an implicit then handler that allows awaiting the mock directly
    // This is what Supabase's actual Query Builder does
    const defaultResponse = { 
      data: defaultData, 
      error: null, 
      count: defaultData && Array.isArray(defaultData) ? defaultData.length : 0,
      status: 200, 
      statusText: 'OK' 
    };
    
    // Allow the mock to be awaited directly
    (mockObj as any).then = jest.fn((onFulfill, onReject) => {
      return Promise.resolve(defaultResponse).then(onFulfill, onReject);
    });
    
    return mockObj;
  }

  // Default behavior for 'from': Return a mock that handles chaining and terminal methods
  mockSupabaseAdmin.from.mockImplementation((relation: string) => {
    // This inner mock needs to satisfy MockableTableOperations
    // AND be awaitable like a promise for terminal operations
    const innerMock = createMockWithPromiseCapability<any[]>([]);

    // --- Configure Default CHAINABLE Methods (Return Self) --- 
    innerMock.select.mockReturnValue(innerMock);
    innerMock.eq.mockReturnValue(innerMock);
    innerMock.neq.mockReturnValue(innerMock);
    innerMock.gt.mockReturnValue(innerMock);
    innerMock.gte.mockReturnValue(innerMock);
    innerMock.lt.mockReturnValue(innerMock);
    innerMock.lte.mockReturnValue(innerMock);
    innerMock.like.mockReturnValue(innerMock);
    innerMock.ilike.mockReturnValue(innerMock);
    innerMock.is.mockReturnValue(innerMock);
    innerMock.in.mockReturnValue(innerMock);
    innerMock.contains.mockReturnValue(innerMock);
    innerMock.containedBy.mockReturnValue(innerMock);
    innerMock.rangeGt.mockReturnValue(innerMock);
    innerMock.rangeGte.mockReturnValue(innerMock);
    innerMock.rangeLt.mockReturnValue(innerMock);
    innerMock.rangeLte.mockReturnValue(innerMock);
    innerMock.rangeAdjacent.mockReturnValue(innerMock);
    innerMock.overlaps.mockReturnValue(innerMock);
    innerMock.textSearch.mockReturnValue(innerMock);
    innerMock.match.mockReturnValue(innerMock);
    innerMock.not.mockReturnValue(innerMock);
    innerMock.or.mockReturnValue(innerMock);
    innerMock.filter.mockReturnValue(innerMock);
    innerMock.limit.mockReturnValue(innerMock);
    innerMock.range.mockReturnValue(innerMock);
    innerMock.order.mockReturnValue(innerMock);

    // --- Configure Default TERMINAL Methods --- 
    // For single-returning methods, default to null
    const singleResponse = { 
      data: null, 
      error: null, 
      status: 200, 
      statusText: 'OK' 
    };
    
    innerMock.single.mockResolvedValue(singleResponse);
    innerMock.maybeSingle.mockResolvedValue(singleResponse);
    
    // For insert/update/upsert operations, return the builder that can be chained further or awaited
    innerMock.insert.mockImplementation(() => {
      const insertMock = createMockWithPromiseCapability();
      insertMock.select.mockReturnValue(insertMock);
      return insertMock;
    });
    
    innerMock.upsert.mockImplementation(() => {
      const upsertMock = createMockWithPromiseCapability();
      upsertMock.select.mockReturnValue(upsertMock);
      return upsertMock;
    });
    
    innerMock.update.mockImplementation(() => {
      const updateMock = createMockWithPromiseCapability();
      updateMock.select.mockReturnValue(updateMock);
      return updateMock;
    });
    
    innerMock.delete.mockImplementation(() => {
      const deleteMock = createMockWithPromiseCapability();
      deleteMock.select.mockReturnValue(deleteMock);
      return deleteMock;
    });

    return innerMock;
  });
}

// Initialize mocks on first load
resetSupabaseMocks();

// --- Context Creation --- 

// Expand this type as more tables are tested
export type TableName = 
  | 'users' 
  | 'user_profiles' 
  | 'user_settings'
  | 'values'
  | 'principles'
  | 'goals' 
  | 'tasks'
  | 'habits'
  | 'habit_entries'
  | 'tracked_state_defs' 
  | 'state_entries'     
  | 'reminders'         
  | 'goal_progress_notes'
  | 'rewards'           
  | 'user_badges';       

/**
 * Creates a TRPC context with a mocked Supabase client.
 * Ensures the user is authenticated unless explicitly bypassed.
 */
export function createInnerTRPCContext(opts: {
  userId: string | null;
  supabase?: any; // Keep as any for simplicity
}): Context {
  if (!opts.userId) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
      message: 'User must be authenticated to access this resource',
    });
  }

  return {
    userId: opts.userId,
    supabaseAdmin: opts.supabase || mockSupabaseAdmin,
  };
}

export function createTestContext(userId: string | null = 'test-user-id', supabase?: any) {
  return createInnerTRPCContext({
    userId,
    supabase,
  });
}

// Export mockDeep so it can be used directly in tests if needed
export { mockDeep };
```

### test-utils.tsx
**Path:** __tests__/test-utils.tsx
**Size:** 928 bytes

```typescript
// __tests__/test-utils.tsx
import React, { ReactElement } from 'react';
import { render, RenderOptions } from '@testing-library/react-native';
import { TamaguiProvider } from 'tamagui';
// Ensure the path to your config is correct
// It might be '../tamagui.config' or './tamagui.config' depending on your structure
import config from '../tamagui.config';

const AllTheProviders = ({ children }: { children: React.ReactNode }) => {
  // Ensure you're providing the correct defaultTheme if your app uses one
  return (
    <TamaguiProvider config={config} defaultTheme="light">
      {children}
    </TamaguiProvider>
  );
};

const customRender = (
  ui: ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>,
) => render(ui, { wrapper: AllTheProviders, ...options });

// Re-export everything from testing-library
export * from '@testing-library/react-native';

// Override render method
export { customRender as render };
```


# (root files)

### aether_styling_context.txt
**Path:** aether_styling_context.txt
**Size:** 72144 bytes

```
========================================
 AETHERIPHONE STYLING CONTEXT DUMP 
========================================

Date: 2025-04-30T04:20:08.847Z
Purpose: Provide full file context for styling analysis and enhancement suggestions.

========================================
FILE: tamagui.config.ts
----------------------------------------

// tamagui.config.ts
import { createAnimations } from '@tamagui/animations-react-native';
import { createFont, createTamagui, createTokens } from 'tamagui';
import { Platform } from 'react-native';
import * as MotionConstants from '@/constants/motion'; // Import motion constants

// Font definitions - Zelda Theme
// Assumes 'CalamitySans' and 'HyliaSerif' are loaded via useFonts or similar
const headingFont = createFont({
  family: 'HyliaSerif', // Zelda Display Font
  size: {
    // Mapped closer to iOS Dynamic Type: https://developer.apple.com/design/human-interface-guidelines/typography
    1: 13,  // Caption 2
    2: 15,  // Subheadline
    3: 17,  // Body (true default)
    4: 20,  // Title 3
    5: 22,  // Title 2
    6: 28,  // Title 1
    7: 34,  // Large Title
    8: 40,  // Extra Large Title (custom)
    true: 17, // Default size (Body)
  },
  lineHeight: {
    // Approximate line heights based on new sizes
    1: 18, 2: 20, 3: 22, 4: 25, 5: 28, 6: 34, 7: 41, 8: 50, 
    true: 22,
  },
  weight: {
    // Prompt 2 asks for 400-700
    4: '400', // Normal
    6: '600', // Semi-bold/Bold
    7: '700', // Extra-bold/Black
    true: '400',
  },
  letterSpacing: {
    1: 0, 2: 0, 3: -0.5, 4: -0.5, 5: -1, 6: -1, 7: -1.5, 8: -1.5,
    true: 0,
  },
  // Required: Map weights to specific font faces if needed (e.g., 'HyliaSerif-Bold')
  // face: {
  //   400: { normal: 'HyliaSerif-Regular' },
  //   700: { normal: 'HyliaSerif-Bold' },
  // },
});

const bodyFont = createFont({
  family: 'CalamitySans', // Zelda Body Font
  size: {
    // Mapped closer to iOS Dynamic Type
    1: 11,  // Footnote
    2: 12,  // Caption 1
    3: 13,  // Caption 2
    4: 15,  // Subheadline
    5: 17,  // Body (true default)
    6: 20,  // Title 3 (matching headingFont.$4)
    true: 17, // Default body size
  },
  lineHeight: {
    // Approximate line heights
    1: 13, 2: 16, 3: 18, 4: 20, 5: 22, 6: 25,
    true: 22, // Default body line height
  },
  weight: {
    4: '400', // Regular
    5: '500', // Medium (if available)
    7: '700', // Bold (if needed/available)
    true: '400',
  },
  letterSpacing: {
    1: 0.1, 2: 0.1, 3: 0, 4: 0, 5: -0.1, 6: -0.1,
    true: 0,
  },
  // Required: Map weights to specific font faces if needed (e.g., 'CalamitySans-Medium')
  // face: {
  //   400: { normal: 'CalamitySans-Regular' },
  //   500: { normal: 'CalamitySans-Medium' },
  // },
});

const monoFont = createFont({
  family: Platform.select({ web: 'monospace', default: 'SpaceMono' }), // Keep SpaceMono for code
  size: {
    1: 12, 2: 14, 3: 15, 4: 16, 5: 18, 6: 20, true: 15,
  },
  lineHeight: {
    1: 18, 2: 22, 3: 24, 4: 26, 5: 28, 6: 32, true: 24,
  },
  weight: {
    4: '400', // Normal weight
    true: '400',
  },
  letterSpacing: {
    4: 0,
    true: 0,
  },
  face: {
    400: { normal: 'SpaceMono' }, // Map weight 400 to the loaded SpaceMono font
  },
});

// Animation driver using reanimated
const animations = createAnimations({
  fast: {
    type: 'timing',
    duration: MotionConstants.durations.standard,
    // easing: MotionConstants.easings.standard, // Removed as createAnimations defaults work well
  },
  medium: {
    type: 'timing',
    duration: MotionConstants.durations.modal,
  },
  slow: {
    type: 'timing',
    duration: MotionConstants.durations.long,
  },
  bouncy: {
    type: 'spring',
    damping: 9,
    mass: 0.9,
    stiffness: 150,
  },
  lazy: {
    type: 'spring',
    damping: 18,
    stiffness: 50,
  },
  quick: {
    type: 'spring',
    damping: 20,
    mass: 1.2,
    stiffness: 250,
  },
});

// Standard Radix Gray scale (light theme)
const gray = {
  gray1: '#fcfcfc', gray2: '#f8f8f8', gray3: '#f3f3f3', gray4: '#ededed', gray5: '#e8e8e8', gray6: '#e2e2e2', gray7: '#dbdbdb', gray8: '#c7c7c7', gray9: '#8f8f8f', gray10: '#858585', gray11: '#6f6f6f', gray12: '#171717',
};

// Standard Radix Gray scale (dark theme)
const grayDark = {
  gray1: '#191919', gray2: '#212121', gray3: '#282828', gray4: '#303030', gray5: '#393939', gray6: '#424242', gray7: '#4f4f4f', gray8: '#626262', gray9: '#737373', gray10: '#838383', gray11: '#ababab', gray12: '#ededed',
};

// Tokens (refined based on your existing config)
const tokens = createTokens({
  size: {
    0: 0, 1: 4, 2: 8, 3: 12, 4: 16, 5: 20, 6: 24, 7: 28, 8: 32, 9: 36, 10: 40, 11: 44, 12: 48, 13: 52, 14: 56, 15: 60, 16: 64, true: 16,
  },
  space: {
    0: 0, 1: 4, 2: 8, 3: 12, 4: 16, 5: 20, 6: 24, 7: 28, 8: 32, 9: 36, 10: 40, 11: 44, 12: 48, 13: 52, 14: 56, 15: 60, 16: 64, true: 16, '-1': -4, '-2': -8, '-3': -12, '-4': -16,
  },
  radius: {
    0: 0, 1: 3, 2: 5, 3: 8, 4: 10, 5: 14, 6: 16, 7: 20, 8: 24, 9: 28, 10: 32, true: 10, // Updated radius.5 to 14
  },
  zIndex: { 0: 0, 1: 100, 2: 200, 3: 300, 4: 400, 5: 500 },
  color: {
    // Zelda Palette (Prompt 1)
    ...gray, // Add light greys
    ...grayDark, // Add dark greys (will be overridden in dark theme definition)
    parchment: '#FDFFE0',
    sheikahCyan: '#86A5A9',
    korokGreen: '#92C582',
    darkText: '#536F50',
    guardianOrange: '#FF9F0A',
    darkTealBg: '#1A2E3A',
    darkCyanGlow: '#64FFDA',

    // Shadow Colors (Prompt 5)
    shadowColorLight: 'rgba(83, 111, 80, 1)', // dark desaturated text color
    shadowColorDark: 'rgba(0, 0, 0, 1)', // Black base
    white: '#FFFFFF',
    black: '#000000',
  },
});

// Define themes using Zelda Palette
const lightTheme = {
  // Base Colors
  background: tokens.color.parchment,      // Light bg
  backgroundStrong: tokens.color.white,     // Keep white for strong contrast areas if needed
  backgroundTransparent: 'rgba(253, 255, 224, 0)', // Fully transparent parchment
  color: tokens.color.darkText,             // Dark desaturated text
  colorSecondary: tokens.color.darkText,      // Use main text color, maybe slightly lighter if needed later
  colorTertiary: tokens.color.sheikahCyan,    // Use accent for tertiary info?
  borderColor: tokens.color.sheikahCyan,      // Use accent for borders
  borderColorHover: tokens.color.korokGreen,  // Korok green on hover?

  // Theme-specific states (can refine later)
  backgroundHover: tokens.color.parchment,    // Keep parchment, maybe slightly darker/lighter
  backgroundPress: tokens.color.parchment,    // Keep parchment
  backgroundFocus: tokens.color.parchment,    // Keep parchment
  colorHover: tokens.color.korokGreen,        // Korok green text on hover?
  colorPress: tokens.color.korokGreen,
  colorFocus: tokens.color.sheikahCyan,
  borderColorPress: tokens.color.korokGreen,
  borderColorFocus: tokens.color.sheikahCyan,

  // Semantic Tokens (Prompt 4)
  accent: tokens.color.sheikahCyan,
  surfaceSubtle: tokens.color.parchment,    // Base color, apply opacity in component (e.g., rgba(253,255,224,0.8))
  destructive: tokens.color.guardianOrange,

  // Standard Semantic Mapping (can use Zelda colors)
  primary: tokens.color.sheikahCyan,        // Map primary to accent
  secondary: tokens.color.korokGreen,       // Map secondary to korok green?
  success: tokens.color.korokGreen,
  warning: tokens.color.guardianOrange,     // Use guardian orange for warning
  error: tokens.color.guardianOrange,       // Use guardian orange for error
  info: tokens.color.sheikahCyan,

  // Semantic Aliases (Playbook 1.1)
  surface: tokens.color.parchment, // Maps to background
  onSurface: tokens.color.darkText,  // Maps to color
  outline: tokens.color.sheikahCyan, // Maps to borderColor

  // Shadows (Playbook 1.1 & Prompt 5)
  shadowColor: tokens.color.shadowColorLight, // Use darkText color base for shadow
  shadowColorHover: 'rgba(83, 111, 80, 0.15)',
  shadowSm: 'rgba(83, 111, 80, 0.10)', // 10% opacity
  shadowMd: 'rgba(83, 111, 80, 0.15)', // 15% opacity
  shadowLg: 'rgba(83, 111, 80, 0.20)', // 20% opacity

  // Toast Themes (Report Item 6)
  toast_success_background: tokens.color.korokGreen,
  toast_success_color: tokens.color.parchment,
  toast_error_background: tokens.color.guardianOrange,
  toast_error_color: tokens.color.parchment,
  toast_warning_background: tokens.color.guardianOrange, // Often same as error
  toast_warning_color: tokens.color.parchment,
  toast_info_background: tokens.color.sheikahCyan,
  toast_info_color: tokens.color.parchment,
};

const darkTheme: typeof lightTheme = {
  // Base Colors
  ...grayDark, // Override light greys with dark greys
  background: tokens.color.darkTealBg,      // Dark-mode bg
  backgroundStrong: tokens.color.black,       // Black for contrast?
  backgroundTransparent: 'rgba(26, 46, 58, 0)', // Fully transparent dark teal
  color: tokens.color.parchment,          // Use light parchment for text
  colorSecondary: tokens.color.sheikahCyan,   // Sheikah cyan for secondary text
  colorTertiary: tokens.color.korokGreen,     // Korok green for tertiary
  borderColor: tokens.color.sheikahCyan,      // Sheikah cyan borders
  borderColorHover: tokens.color.darkCyanGlow, // Glow cyan on hover?

  // Theme-specific states
  backgroundHover: tokens.color.darkTealBg,   // Keep bg, maybe slightly lighter
  backgroundPress: tokens.color.darkTealBg,
  backgroundFocus: tokens.color.darkTealBg,
  colorHover: tokens.color.darkCyanGlow,
  colorPress: tokens.color.darkCyanGlow,
  colorFocus: tokens.color.darkCyanGlow,
  borderColorPress: tokens.color.darkCyanGlow,
  borderColorFocus: tokens.color.darkCyanGlow,

  // Semantic Tokens (Prompt 4)
  accent: tokens.color.sheikahCyan,
  surfaceSubtle: tokens.color.darkTealBg, // Use dark bg, apply opacity in component
  destructive: tokens.color.guardianOrange,

  // Standard Semantic Mapping
  primary: tokens.color.darkCyanGlow,       // Use glow cyan for primary actions
  secondary: tokens.color.korokGreen,
  success: tokens.color.korokGreen,
  warning: tokens.color.guardianOrange,
  error: tokens.color.guardianOrange,
  info: tokens.color.sheikahCyan,

  // Semantic Aliases (Playbook 1.1)
  surface: tokens.color.darkTealBg,   // Maps to background
  onSurface: tokens.color.parchment,  // Maps to color
  outline: tokens.color.sheikahCyan, // Maps to borderColor

  // Shadows (Playbook 1.1 & Prompt 5)
  shadowColor: tokens.color.shadowColorDark, // Darker shadow for dark mode
  shadowColorHover: 'rgba(0, 0, 0, 0.30)',
  shadowSm: 'rgba(0, 0, 0, 0.20)', // 20% opacity
  shadowMd: 'rgba(0, 0, 0, 0.30)', // 30% opacity
  shadowLg: 'rgba(0, 0, 0, 0.40)', // 40% opacity

  // Toast Themes (Report Item 6)
  toast_success_background: tokens.color.korokGreen,
  toast_success_color: tokens.color.darkTealBg,
  toast_error_background: tokens.color.guardianOrange,
  toast_error_color: tokens.color.darkTealBg,
  toast_warning_background: tokens.color.guardianOrange, // Often same as error
  toast_warning_color: tokens.color.darkTealBg,
  toast_info_background: tokens.color.sheikahCyan,
  toast_info_color: tokens.color.darkTealBg,
};

// Create the Tamagui config
const config = createTamagui({
  animations,
  shouldAddPrefersColorThemes: true,
  themeClassNameOnRoot: true,
  shorthands: {
    // Keep your existing shorthands
    m: 'margin', mt: 'marginTop', mr: 'marginRight', mb: 'marginBottom', ml: 'marginLeft', mx: 'marginHorizontal', my: 'marginVertical',
    p: 'padding', pt: 'paddingTop', pr: 'paddingRight', pb: 'paddingBottom', pl: 'paddingLeft', px: 'paddingHorizontal', py: 'paddingVertical',
    bg: 'backgroundColor', br: 'borderRadius', bw: 'borderWidth', bc: 'borderColor',
    f: 'flex', fd: 'flexDirection', ai: 'alignItems', jc: 'justifyContent', w: 'width', h: 'height',
    ac: 'alignContent',
    als: 'alignSelf',
    btc: 'borderTopColor',
    bbc: 'borderBottomColor',
    blc: 'borderLeftColor',
    brc: 'borderRightColor',
    boc: 'borderColor',
    bs: 'borderStyle',
    dsp: 'display',
    fb: 'flexBasis',
    fg: 'flexGrow',
    fs: 'flexShrink',
    fw: 'flexWrap',
    mah: 'maxHeight',
    maw: 'maxWidth',
    mih: 'minHeight',
    miw: 'minWidth',
    op: 'opacity',
    ov: 'overflow',
    r: 'right',
    shac: 'shadowColor',
    shar: 'shadowRadius',
    shof: 'shadowOffset',
    shop: 'shadowOpacity',
    t: 'top',
    ta: 'textAlign',
    tt: 'textTransform',
    va: 'verticalAlign',
    zi: 'zIndex',
  },
  fonts: {
    // Use Zelda fonts
    heading: headingFont,
    body: bodyFont,
    mono: monoFont, // Keep mono
  },
  themes: {
    light: lightTheme,
    dark: darkTheme,
  },
  tokens,
  media: { // Keep standard media queries
    xs: { maxWidth: 660 }, sm: { maxWidth: 800 }, md: { maxWidth: 1020 }, lg: { maxWidth: 1280 }, xl: { maxWidth: 1420 }, xxl: { maxWidth: 1600 },
    gtXs: { minWidth: 661 }, gtSm: { minWidth: 801 }, gtMd: { minWidth: 1021 }, gtLg: { minWidth: 1281 },
    short: { maxHeight: 820 }, tall: { minHeight: 820 },
    hoverNone: { hover: 'none' }, pointerCoarse: { pointer: 'coarse' },
  },
  settings: {
      allowedStyleValues: 'somewhat-strict',
      autocompleteSpecificTokens: 'except-special',
  },
});

type AppConfig = typeof config;

// Augment Tamagui interface - this is crucial!
declare module '@tamagui/core' {
  // If AppConfig is defined and exported:
  interface TamaguiCustomConfig extends AppConfig {}
}

export default config;

[EOF: tamagui.config.ts]

========================================
FILE: providers/Providers.tsx
----------------------------------------

// providers/Providers.tsx
import { QueryClientProvider } from '@tanstack/react-query';
import { persistQueryClient } from '@tanstack/react-query-persist-client';
import { TamaguiProvider, type TamaguiProviderProps } from 'tamagui';
import { ToastProvider, ToastViewport } from '@tamagui/toast'; // Import from Tamagui Toast
import React, { useEffect, useState, type ReactNode } from 'react';
import { Platform } from 'react-native'; // Import Platform

import config from '../tamagui.config'; // Import your config
import { trpc } from '../utils/trpc'; // Your tRPC hook setup
import { queryClient, persister, initializeNetworkMonitoring, resumeMutationsAndInvalidate } from '@/utils/query-client';
import { useUiStore } from '@/stores/uiStore';
import { supabase } from '@/utils/supabase'; // Needed for auth link
import { createTRPCClient, httpBatchLink, TRPCLink, TRPCClientError } from '@trpc/client'; // Import TRPC Client utils
import { observable } from '@trpc/server/observable';
import type { AppRouter } from '../server/src/router'; // Adjust path if needed
import type { Session } from '@supabase/supabase-js';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

// Setup query client persistence
persistQueryClient({
  queryClient,
  persister,
  maxAge: 1000 * 60 * 60 * 24, // 24 hours
  dehydrateOptions: {
    shouldDehydrateMutation: () => false, // Usually don't dehydrate mutations
  },
});

// New component for the viewport using safe area
const CurrentToastViewport = () => {
  const { top, bottom, left, right } = useSafeAreaInsets();
  return (
    <>
      {/* Adjust positioning based on your desired toast location */}
      <ToastViewport
        name="global_top"
        flexDirection="column" // Stack new toasts below older ones
        top={top + 10} // Add padding below status bar
        left={left + 10} // Add padding from sides
        right={right + 10}
      />
      <ToastViewport
        name="global_bottom"
        flexDirection="column-reverse"
        bottom={bottom + 10}
        left={left + 10}
        right={right + 10}
      />
    </>
  );
};

// Extract tRPC links setup
function getTRPCLinks(getSession: () => Promise<Session | null>): TRPCLink<AppRouter>[] {
  const apiBaseUrl = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api/trpc'; // Default to localhost
  console.log('Using tRPC API URL:', apiBaseUrl);

  return [
    // Link to handle auth token injection and refresh
    (runtime) => {
      return ({ op, next }) => {
        return observable((observer) => {
          getSession().then(session => {
            const headers = (op.context?.headers || {}) as Record<string, string>;
            if (session?.access_token) {
              headers['Authorization'] = `Bearer ${session.access_token}`;
            }

            // Proceed with the request, ensuring context is passed correctly
            next({ ...op, context: { ...op.context, headers } })
              .subscribe({
                next: (value) => observer.next(value),
                error: async (err) => {
                  if (err instanceof TRPCClientError && err.data?.httpStatus === 401) {
                    console.log('tRPC: Token expired or invalid, attempting refresh...');
                    try {
                      // Supabase handles refresh internally if needed when getSession is called
                      const { data, error: refreshError } = await supabase.auth.refreshSession();
                      if (refreshError) throw refreshError;

                      if (data.session) {
                        console.log('tRPC: Session refreshed successfully, retrying request.');
                        const refreshedHeaders = { ...headers, Authorization: `Bearer ${data.session.access_token}` };
                        // Retry with new headers in context
                        next({ ...op, context: { ...op.context, headers: refreshedHeaders } }).subscribe(observer);
                      } else {
                        console.error('tRPC: Session refresh failed, no session returned.');
                        observer.error(err); // Propagate original error if no new session
                        // Optionally trigger logout here
                        supabase.auth.signOut();
                      }
                    } catch (refreshCatchError) {
                      console.error('tRPC: Session refresh catch error:', refreshCatchError);
                      observer.error(err); // Propagate original error
                      supabase.auth.signOut();
                    }
                  } else {
                    observer.error(err); // Propagate non-auth errors
                  }
                },
                complete: () => observer.complete(),
              });
          }).catch(err => {
             console.error('tRPC: Error getting session for headers:', err);
             observer.error(new TRPCClientError('Failed to get session')); // Use TRPCClientError
          });

          // Return cleanup function if needed
          return () => {};
        });
      };
    },
    // The terminating HTTP link
    httpBatchLink({
      url: apiBaseUrl,
       headers() {
         // Headers are injected by the middleware link above
         return {};
       },
      // Add superjson transformer here if you use one
      // transformer: superjson,
    }),
  ];
}

export function Providers({ children }: { children: ReactNode }) {
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';

  // Initialize network monitoring and query client persistence
  useEffect(() => {
    const unsubscribeNetworkMonitoring = initializeNetworkMonitoring();
    resumeMutationsAndInvalidate(); // Try resuming mutations on app load
    return () => {
      unsubscribeNetworkMonitoring();
    };
  }, []);

  // Memoize tRPC client creation
  const [trpcClient] = useState(() =>
    trpc.createClient({
      links: getTRPCLinks(async () => { // Pass session getter to links setup
        const { data } = await supabase.auth.getSession();
        return data.session;
      }),
    })
  );

  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <TamaguiProvider
            config={config}
            defaultTheme={currentTheme}
            // disableInjectCSS // May not be needed depending on setup
        >
          {/* Use Tamagui's ToastProvider */}
          <ToastProvider
            // burntOptions={{ from: 'top' }} // Disabled until native module 'Burnt' is installed
            swipeDirection="horizontal"
            duration={4000}
            native={[]}
          >
            {children}
            {/* Add the safe-area aware ToastViewport */}
            <CurrentToastViewport />
          </ToastProvider>
        </TamaguiProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
}

[EOF: providers/Providers.tsx]

========================================
FILE: stores/uiStore.ts
----------------------------------------

import { create } from 'zustand';

interface UiState {
  isDarkMode: boolean;
  toggleTheme: () => void;
}

// Simple Zustand store for UI state (e.g., theme)
export const useUiStore = create<UiState>((set) => ({
  isDarkMode: false, // Default to light mode
  toggleTheme: () => set((state) => ({ isDarkMode: !state.isDarkMode })),
})); 

[EOF: stores/uiStore.ts]

========================================
FILE: constants/motion.ts
----------------------------------------

import { Easing } from 'react-native-reanimated';

/**
 * Standard animation durations (in milliseconds)
 */
export const durations = {
  /** Ultra-fast for micro-interactions */
  micro: 80,
  /** Tap/press feedback */
  tap: 120,
  /** Default animation speed for most UI transitions */
  standard: 200,
  /** For more noticeable animations */
  medium: 250,
  /** Modal entrances/exits, complex transitions */
  modal: 300,
  /** Full screen transitions */
  screen: 350,
  /** Extended animations for emphasis */
  long: 450,
};

/**
 * Standard easing curves
 */
export const easings = {
  /** Quick acceleration, gradual deceleration - for elements entering the screen */
  enter: Easing.bezier(0.25, 0.1, 0.25, 1.0),
  /** Gradual acceleration, quick deceleration - for elements exiting the screen */
  exit: Easing.bezier(0.25, 0.0, 0.2, 1.0),
  /** For transitions between UI states */
  standard: Easing.bezier(0.4, 0.0, 0.2, 1.0),
  /** Quick in, quick out - for emphasis */
  energetic: Easing.bezier(0.55, 0.0, 0.1, 1.0),
  /** Linear - consistent motion with no acceleration/deceleration */
  linear: Easing.linear,
  /** Slow start, fast finish */
  accelerate: Easing.in(Easing.quad),
  /** Fast start, slow finish */
  decelerate: Easing.out(Easing.quad),
  /** Fast start and end, slower in the middle */
  emphasize: Easing.inOut(Easing.quad),
};

/**
 * Animation presets for common UI patterns
 */
export const presets = {
  fadeIn: {
    duration: durations.standard,
    easing: easings.enter,
  },
  fadeOut: {
    duration: durations.standard,
    easing: easings.exit,
  },
  slideIn: {
    duration: durations.modal,
    easing: easings.enter,
  },
  slideOut: {
    duration: durations.modal,
    easing: easings.exit,
  },
  scaleIn: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  scaleOut: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  tapFeedback: {
    duration: durations.tap,
    easing: easings.emphasize,
  },
  skeleton: {
    duration: durations.long * 2,
    easing: easings.linear,
  },
};

/**
 * Animation values for specific components
 */
export const componentAnimations = {
  toast: {
    show: {
      duration: durations.modal,
      easing: easings.enter,
    },
    hide: {
      duration: durations.standard,
      easing: easings.exit,
    },
  },
  modal: {
    overlay: {
      show: {
        duration: durations.modal,
        easing: easings.standard,
      },
      hide: {
        duration: durations.modal,
        easing: easings.standard,
      },
    },
    content: {
      show: {
        duration: durations.modal,
        easing: easings.enter,
      },
      hide: {
        duration: durations.standard,
        easing: easings.exit,
      },
    },
  },
  button: {
    press: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
    release: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
  },
  navigation: {
    screen: {
      duration: durations.screen,
      easing: easings.standard,
    },
    tab: {
      duration: durations.standard,
      easing: easings.standard,
    },
  },
}; 

[EOF: constants/motion.ts]

========================================
FILE: app/(tabs)/_layout.tsx
----------------------------------------

// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/_layout.tsx
import React from 'react';
import { Tabs } from 'expo-router';
import { Ionicons } from '@expo/vector-icons'; // Example icon library
import { useThemeColor } from '@/hooks/useThemeColor'; // Assuming path alias is set

export default function TabLayout() {
  const tabBarActiveTintColor = useThemeColor({}, 'tabIconSelected');
  const tabBarInactiveTintColor = useThemeColor({}, 'tabIconDefault');
  const backgroundColor = useThemeColor({}, 'background'); // Use standard background color

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: tabBarActiveTintColor,
        tabBarInactiveTintColor: tabBarInactiveTintColor,
        tabBarStyle: {
          backgroundColor: backgroundColor,
          // Add other styles like borderTopColor if needed
        },
        headerShown: false, // We might handle headers inside each screen or using Stack
      }}
    >
      <Tabs.Screen
        name="home/index"
        options={{
          title: 'Home',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="home-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="planner/index"
        options={{
          title: 'Planner',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="calendar-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="compass/index"
        options={{
          title: 'Compass',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="compass-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="rewards/index"
        options={{
          title: 'Rewards',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="gift-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="settings/index"
        options={{
          title: 'Settings',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="settings-outline" size={size} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}


[EOF: app/(tabs)/_layout.tsx]

========================================
FILE: app/(tabs)/home/index.tsx
----------------------------------------

// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/home/index.tsx
import React, { useCallback, useMemo } from 'react';
import { YStack, H1, Text, XStack, Button, ScrollView, Spinner } from 'tamagui';
import { SafeAreaView, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc, RouterOutputs } from '@/utils/trpc';
import DashboardSection from '@/components/dashboard/DashboardSection';
import GoalSummaryCard from '@/components/dashboard/GoalSummaryCard';
import HabitCheckItem from '@/components/dashboard/HabitCheckItem';
import TaskItem from '@/components/dashboard/TaskItem';
import StateIndicator from '@/components/dashboard/StateIndicator';
import DailyProgressBanner from '@/components/dashboard/DailyProgressBanner'; // Import Banner
import EmptyOrSkeleton from '@/components/ui/EmptyOrSkeleton';
import { SkeletonCard, SkeletonRow } from '@/components/ui/Skeleton';
import { useSkeleton } from '@/hooks/useSkeleton';
import { useColorScheme } from '@/hooks/useColorScheme';
import { useToastController } from '@tamagui/toast';
import { BlurView } from 'expo-blur';
import { Plus } from '@tamagui/lucide-icons';
import LottieView from 'lottie-react-native';
import SwipeableRow from '@/components/ui/SwipeableRow'; // Import SwipeableRow

// Types inferred from tRPC Router
type RouterOutput = RouterOutputs['dashboard']['getDashboardData'];
// --- Define types for the STRUCTURE AFTER mapping in useMemo ---
export type DashboardGoal = {
  id: string;
  title: string;
  progress: number;
  tasks: { completed: number; total: number };
  // Include other relevant fields if needed by GoalSummaryCard
  status?: string | null; 
  priority?: number | null;
};
export type DashboardHabit = {
  id: string;
  name: string;
  description?: string | null;
  completed: boolean; // Mapped from completedToday
  streak: number;
  last_entry_id?: string; // Mapped from habit.last_entry_id (null -> undefined)
  habit_type?: string | null;
};
export type DashboardTask = {
  id: string;
  name: string;
  status: string | null; // Allow null
  due_date?: Date | string | null;
  // Include other relevant fields if needed by TaskItem
};
export type DashboardState = {
  id: string;
  name: string | null;
  unit: string | null;
  currentValue: number | string | null;
  lastUpdated: string | null;
  lastEntry: { value: number | null; created_at: Date | string } | null; // Explicitly include lastEntry
};
// --- End mapped type definitions ---

export default function HomeScreen() {
  const colorScheme = useColorScheme();
  const toast = useToastController();
  const utils = trpc.useUtils(); // Get tRPC utils for mutations
  
  // Define types using RouterOutputs for clarity and safety
  // type DashboardGoal = RouterOutputs['dashboard']['getDashboardData']['goals'][number];
  // type DashboardHabit = RouterOutputs['dashboard']['getDashboardData']['habits'][number];
  // type DashboardTask = RouterOutputs['dashboard']['getDashboardData']['tasks'][number];

  // Use tRPC hooks to fetch data - Types are inferred but can be explicitly used
  const { 
    data: dashboardData, 
    isLoading, 
    error, 
    refetch,
    isRefetching 
  } = trpc.dashboard.getDashboardData.useQuery();

  // Define the habit entry mutation hook
  const createHabitEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: () => {
      refetch(); // Refresh data after successful mutation
      // Optional: Add success toast
      // toast.show('Habit updated!', { type: 'success' });
    },
    onError: (error) => {
      // Handle tRPC client error
      toast.show(error.message || 'Failed to update habit', { type: 'error' });
    }
  });

  // Handle errors
  React.useEffect(() => {
    if (error) {
      toast.show(error.message || 'Failed to load dashboard data', { type: 'error' });
    }
  }, [error, toast]);

  // Set up pull-to-refresh
  const onRefresh = useCallback(() => {
    refetch();
  }, [refetch]);

  // Custom skeleton states from your hooks
  const { isLoading: skeletonsLoading, count: skeletonCount = 3 } = {
    isLoading,
    count: 3 // Number of skeleton items to show
  };
  
  // Generate skeleton UI based on loading state
  const renderSkeletons = () => {
    return Array.from({ length: skeletonCount }).map((_, index) => (
      <SkeletonCard key={`skeleton-${index}`} />
    ));
  };

  // Get current date and greeting
  const greeting = getGreeting();
  const currentDate = new Date().toLocaleDateString('en-US', { 
    weekday: 'long', 
    month: 'long', 
    day: 'numeric' 
  });

  const dashboardDataMemo = useMemo(() => {
    // Fix: Add check to ensure dashboardData exists before accessing properties
    if (!dashboardData) {
      return null; // Or return default structure: { goals: [], habits: [], tasks: [], trackedStates: [] }
    }

    // Map and filter data, ensuring structure matches exported types
    return {
      // Filter goals to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      goals: (dashboardData.goals ?? [])
        .filter((goal): goal is typeof goal & { id: string } => !!goal?.id)
        .map((goal) => ({
        // Map to DashboardGoal structure
        id: goal.id, 
        title: goal.title ?? 'Untitled Goal', // Provide default for title
        progress: goal.progress ?? 0, 
        tasks: goal.tasks ?? { completed: 0, total: 0 }, 
        status: goal.status,
        priority: goal.priority,
      })),
      // Filter habits to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      habits: (dashboardData.habits ?? [])
        .filter((habit): habit is typeof habit & { id: string } => !!habit?.id)
        .map((habit) => ({
        // Map to DashboardHabit structure
        id: habit.id, 
        name: habit.name ?? 'Unnamed Habit', // Provide default for name
        description: habit.description,
        completed: habit.completedToday ?? false, // Map completedToday to completed
        streak: habit.streak ?? 0, 
        last_entry_id: habit.last_entry_id ?? undefined, // Map null to undefined
        habit_type: habit.habit_type,
      })),
      // Filter tasks to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      tasks: (dashboardData.tasks ?? [])
        .filter((task): task is typeof task & { id: string } => !!task?.id)
        .map((task) => ({
        // Map to DashboardTask structure
        id: task.id,
        name: task.name ?? 'Untitled Task', // Provide default name
        status: task.status,
        due_date: task.due_date,
      })),
      // Map trackedStates, ensuring lastEntry is preserved
      // Fix: Use nullish coalescing and optional chaining
      trackedStates: (dashboardData.trackedStates ?? [])
        .filter((state): state is typeof state & { id: string } => !!state?.id)
        .map((trackedState) => ({
        // Map to DashboardState structure
        id: trackedState.id,
        name: trackedState.name,
        unit: trackedState.unit,
        currentValue: trackedState.currentValue,
        lastUpdated: trackedState.lastUpdated,
        // Ensure lastEntry structure matches definition or is null
        lastEntry: trackedState.lastEntry ?? null, 
      })),
    };
  }, [dashboardData]);

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <ScrollView 
        showsVerticalScrollIndicator={false}
        contentContainerStyle={{ paddingBottom: 100 }}
        refreshControl={
          <RefreshControl
            refreshing={isRefetching}
            onRefresh={onRefresh}
            tintColor="transparent" // Hide default spinner
            colors={['transparent']} // Hide default spinner (Android)
            progressBackgroundColor="transparent" // Hide default bg (Android)
            refreshingComponent={
              <LottieView
                source={require('@/assets/refresh-sheikah.json')} // ASSUMES this file exists
                autoPlay
                loop
                style={{ width: 48, height: 48, alignSelf: 'center' }} // Center the animation
              />
            }
          />
        }
      >
        <YStack space="$4" paddingHorizontal="$4">
          {/* Header */}
          <YStack space="$1">
            <H1>{greeting}</H1>
            <Text color="$gray10">{currentDate}</Text>
          </YStack>

          {/* Daily Progress Banner */}
          <DailyProgressBanner 
            // tasksCompleted={...} 
            // totalTasks={...} 
            // habitsChecked={...} 
            // totalHabits={...} 
          />

          {/* Goals Section */}
          <DashboardSection 
            title="Goals"
            onSeeAll={() => router.push('/planner')}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load goals"
              />
            ) : !dashboardDataMemo?.goals || dashboardDataMemo.goals.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No goals yet"
                actionText="Create a goal"
                onAction={() => router.push('/planner/add-goal')}
              />
            ) : (
              <YStack space="$3">
                {dashboardDataMemo.goals.slice(0, 3).map((goal) => (
                  <SwipeableRow
                    key={goal.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.goal.delete.mutate({ id: goal.id })
                      console.log('Attempting to delete goal:', goal.id); // Placeholder
                      // utils.goal.delete.mutate({ id: goal.id });
                    }}
                  >
                    <GoalSummaryCard
                      goal={goal}
                      onPress={() => router.push(`/planner/goal/${goal.id}`)}
                    />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>

          {/* Today's Habits */}
          <DashboardSection 
            title="Today's Habits"
            onSeeAll={() => router.push('/planner?tab=habits')}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load habits"
              />
            ) : !dashboardDataMemo?.habits || dashboardDataMemo.habits.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No habits for today"
                actionText="Create a habit"
                onAction={() => router.push('/planner/add-habit')}
              />
            ) : (
              <YStack space="$2">
                {dashboardDataMemo.habits.slice(0, 4).map((habit) => (
                  <SwipeableRow
                    key={habit.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.habit.delete.mutate({ id: habit.id })
                      console.log('Attempting to delete habit:', habit.id); // Placeholder
                      // utils.habit.delete.mutate({ id: habit.id });
                    }}
                  >
                    <HabitCheckItem habit={habit} />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>

          {/* Today's State */}
          <DashboardSection
            title="Today's State"
            // TODO: Add navigation to a dedicated state tracking screen
            onSeeAll={() => console.log('Navigate to State Tracking screen')}
          >
            {isLoading ? (
              renderSkeletons() // Use generic skeletons or specific state skeletons
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load state"
              />
            ) : !dashboardDataMemo?.trackedStates || dashboardDataMemo.trackedStates.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No states being tracked"
                actionText="Track a state"
                // TODO: Navigate to state definition creation screen
                onAction={() => console.log('Navigate to Add State screen')}
              />
            ) : (
              <XStack space="$3" flexWrap="wrap"> 
                {dashboardDataMemo.trackedStates.map((stateData) => (
                  <StateIndicator
                    key={stateData.id}
                    state={stateData} // Pass the whole state object which includes lastEntry
                    lastEntry={stateData.lastEntry} // Pass lastEntry explicitly
                    // TODO: Handle interaction - e.g., navigate to state detail/entry screen
                    onPress={() => console.log('State pressed:', stateData.id)}
                  />
                ))}
              </XStack>
            )}
          </DashboardSection>

          {/* Upcoming Tasks */}
          <DashboardSection 
            title="Upcoming Tasks"
            onSeeAll={() => {/* Navigate to tasks list */}}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load tasks"
              />
            ) : !dashboardDataMemo?.tasks || dashboardDataMemo.tasks.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No upcoming tasks"
                actionText="Create a task"
                onAction={() => {/* Navigate to create task */}}
              />
            ) : (
              <YStack space="$2">
                {dashboardDataMemo.tasks.slice(0, 5).map((task) => (
                  <SwipeableRow
                    key={task.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.task.delete.mutate({ id: task.id })
                      console.log('Attempting to delete task:', task.id); // Placeholder
                      // utils.task.delete.mutate({ id: task.id });
                    }}
                  >
                    <TaskItem
                      task={{
                        // Explicitly pass props matching DashboardTask type
                        id: task.id, // Ensure id is passed
                        name: task.name, // Already defaulted in map
                        status: task.status, // Pass status
                        due_date: task.due_date, // Pass due_date
                      }}
                      isLast={false} // Adjust if needed for styling
                      onPress={() => console.log('Task Item Pressed:', task.id)}
                    />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>
        </YStack>
      </ScrollView>
      <QuickAddFAB />
    </SafeAreaView>
  );
}

// Helper function for greeting
function getGreeting() {
  const hour = new Date().getHours();
  if (hour < 12) return 'Good Morning';
  if (hour < 18) return 'Good Afternoon';
  return 'Good evening';
}

// Quick Add FAB Component
function QuickAddFAB() {
  return (
    <BlurView intensity={40} tint="default" style={{ position:'absolute', bottom:24, right:24, borderRadius:32, overflow: 'hidden' }}>
      <Button
        circular
        size="$5"
        backgroundColor="$accent"
        icon={Plus}
        elevate
        shadowColor="$shadowColor"
        shadowRadius={5}
        shadowOffset={{ width: 0, height: 2 }}
        pressStyle={{ scale: 0.95, opacity: 0.9 }}
        onPress={() => {
          router.push('/planner/add-task');
        }}
      />
    </BlurView>
  );
}


[EOF: app/(tabs)/home/index.tsx]

========================================
FILE: utils/trpc.ts
----------------------------------------

import { createTRPCReact } from '@trpc/react-query';
import { type inferRouterInputs, type inferRouterOutputs } from '@trpc/server';

// Import the real AppRouter type from our server
import { type AppRouter } from '../server/src/router';

// Import types using the updated path
import { RouterInputs as TypedRouterInputs, RouterOutputs as TypedRouterOutputs } from '../server/src/types/trpc-types';

/**
 * tRPC React client
 * The client for consuming your tRPC API from React components
 */
export const trpc = createTRPCReact<AppRouter>();

/**
 * Inference helpers for input/output types
 * Use the pre-defined types from trpc-types.ts
 */
export type RouterInputs = TypedRouterInputs;
export type RouterOutputs = TypedRouterOutputs; 

[EOF: utils/trpc.ts]

========================================
FILE: utils/query-client.ts
----------------------------------------

import { QueryClient } from '@tanstack/react-query';
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister';
import AsyncStorage from '@react-native-async-storage/async-storage';
import NetInfo from '@react-native-community/netinfo';
import { onlineManager } from '@tanstack/react-query';

// Create a client
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // Default stale time of 5 minutes
      staleTime: 1000 * 60 * 5,
      // When offline, keep data fresh for 24 hours (cacheTime was renamed to gcTime)
      gcTime: 1000 * 60 * 60 * 24,
      // Retry failed queries 3 times
      retry: 3,
      // Retry with exponential backoff
      retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
      // Don't refetch on window focus for mobile
      refetchOnWindowFocus: false,
      // Show stale data while fetching new data (renamed from keepPreviousData)
      placeholderData: 'keepPrevious',
    },
    mutations: {
      // Retry failed mutations 3 times
      retry: 3,
      // Enable offline mutations
      networkMode: 'offlineFirst',
    },
  },
});

// Create a persister
export const persister = createAsyncStoragePersister({
  storage: AsyncStorage,
  key: 'aether-query-cache-v1',
  // Only persist queries with a longer cacheTime
  throttleTime: 1000,
  // SerDe for serializing/deserializing the data
  serialize: data => JSON.stringify(data),
  deserialize: data => JSON.parse(data),
});

/**
 * Initialize network monitoring for the query client
 * Call this on app startup to enable online/offline detection
 */
export function initializeNetworkMonitoring(): () => void {
  // Subscribe to network status changes
  const unsubscribe = NetInfo.addEventListener(state => {
    onlineManager.setOnline(
      state.isConnected != null && 
      state.isConnected && 
      Boolean(state.isInternetReachable)
    );
  });

  // Initialize once at startup - check if online
  NetInfo.fetch().then(state => {
    onlineManager.setOnline(
      state.isConnected != null && 
      state.isConnected && 
      Boolean(state.isInternetReachable)
    );
  });

  return unsubscribe;
}

/**
 * Resume any paused mutations when the app comes back online
 * 
 * @returns A promise that resolves when mutations are resumed
 */
export async function resumeMutationsAndInvalidate(): Promise<void> {
  try {
    await queryClient.resumePausedMutations();
    queryClient.invalidateQueries();
  } catch (error) {
    console.error('Error resuming mutations:', error);
  }
} 

[EOF: utils/query-client.ts]

========================================
FILE: components/dashboard/DashboardSection.tsx
----------------------------------------

import React, { ReactNode } from 'react';
import { Text, YStack, XStack, Button, Anchor, H4 } from 'tamagui';
import { router } from 'expo-router';
import { SkeletonRow } from '@/components/ui/Skeleton';
import { SectionError } from '@/components/ui/ErrorBanner';
import { BlurView } from 'expo-blur'; // Import BlurView

interface DashboardSectionProps<T> {
  title: string;
  data?: T[];
  isLoading?: boolean;
  emptyMessage?: string;
  seeAllRoute?: string;
  renderItem?: (item: T) => ReactNode;
  skeletonCount?: number;
  error?: string;
  onRetry?(): void;
  children?: ReactNode;
  onSeeAll?(): void;
}

export default function DashboardSection<T>({ 
  title, 
  data, 
  isLoading, 
  emptyMessage,
  seeAllRoute,
  renderItem,
  skeletonCount = 2,
  error,
  onRetry,
  children,
  onSeeAll
}: DashboardSectionProps<T>) {
  return (
    <YStack space="$2">
      <XStack justifyContent="space-between" alignItems="center" marginBottom="$2" paddingHorizontal="$2">
        <H4>{title}</H4>
        {((data && data.length > 0 && seeAllRoute) || onSeeAll) && (
          <Button 
            chromeless 
            size="$2" 
            onPress={() => {
              if (onSeeAll) {
                onSeeAll();
              } else if (seeAllRoute) {
                // Navigate to route using type assertions
                // Safe because the route will be a tab/screen name within the app
                router.push(seeAllRoute as any);
              }
            }}
          >
            See All
          </Button>
        )}
      </XStack>
      
      {/* Wrap content in BlurView */}
      <BlurView 
        intensity={50} 
        tint="default" 
        style={{ borderRadius: 12, overflow: 'hidden' }} 
      >
        <YStack padding="$3">
          {/* If children are provided, render them */}
          {children ? (
            children
          ) : isLoading ? (
            <SkeletonRow lines={skeletonCount} />
          ) : error ? (
            <SectionError message={error ? String(error) : 'An error occurred'} onRetry={onRetry} />
          ) : data && data.length === 0 ? (
            <YStack alignItems="center" padding="$4">
              <Text color="$gray10">{emptyMessage ?? 'No items found'}</Text>
            </YStack>
          ) : (
            data && renderItem && data.map(renderItem)
          )}
        </YStack>
      </BlurView>
    </YStack>
  );
} 

[EOF: components/dashboard/DashboardSection.tsx]

========================================
FILE: components/dashboard/GoalSummaryCard.tsx
----------------------------------------

import React from 'react';
import { Text, XStack, Button } from 'tamagui';
import ProgressRing from '@/components/aether/ProgressRing';
import { RouterOutputs } from '@/utils/trpc';
import { BlurView } from 'expo-blur'; // Import BlurView

// Define a custom type that includes everything we need
type DashboardGoal = {
  id: string;
  title: string;
  status?: string;
  priority?: number;
  progress: number;
  tasks?: {
    total: number;
    completed: number;
  };
};

interface GoalSummaryCardProps {
  goal: DashboardGoal;
  onPress: () => void;
}

export default function GoalSummaryCard({ goal, onPress }: GoalSummaryCardProps) {
  return (
    <BlurView 
      intensity={50} 
      tint="default" 
      style={{ borderRadius: 12, overflow: 'hidden' }}
    >
      <Button 
        chromeless // Remove default button styling
        padding="$3" 
        onPress={onPress}
        width="100%" // Ensure it fills the BlurView
      >
        <XStack alignItems="center" space="$3" flex={1}> 
          <ProgressRing
            progress={goal.progress}
            size={40}
            primaryColor="$primary"
          />
          <XStack flex={1} flexDirection="column">
            <Text fontSize="$4" fontWeight="500" color="$color">
              {goal.title}
            </Text>
            {goal.tasks && (
              <Text color="$gray9" fontSize="$2">
                {goal.tasks.completed}/{goal.tasks.total} tasks completed
              </Text>
            )}
          </XStack>
        </XStack>
      </Button>
    </BlurView>
  );
}

[EOF: components/dashboard/GoalSummaryCard.tsx]

========================================
FILE: components/dashboard/HabitCheckItem.tsx
----------------------------------------

import React, { useState, useEffect } from 'react';
import { Text, XStack, Button, YStack, useTheme } from 'tamagui';
import * as Haptics from 'expo-haptics';
import { trpc, RouterOutputs } from '@/utils/trpc';

// Custom types that match the backend expectations
type DashboardHabit = {
  id: string;
  name: string;  // Backend returns 'name'
  description?: string;
  habit_type?: string;
  streak?: number;
  completed: boolean; // Backend returns 'completed'
  duration_minutes?: number;
  last_entry_id?: string; // Add last_entry_id property
};

// Types for habit entry mutations
type CreateHabitEntryInput = {
  habit_id: string;
  date: string;
  completed?: boolean;
  quantity_value?: number | null;
  notes?: string | null;
};

type DeleteHabitEntryInput = {
  id: string; // Update property name
};

interface HabitCheckItemProps {
  habit: DashboardHabit;
  onToggle?: (habitId: string, completedToday: boolean) => void; 
}

export default function HabitCheckItem({ habit, onToggle }: HabitCheckItemProps) {
  const [checked, setChecked] = useState(habit.completed);
  const [isUpdating, setIsUpdating] = useState(false);
  const theme = useTheme(); 
  const utils = trpc.useUtils(); 

  // Define specific theme colors with safe access and fallbacks to theme variables
  const green10 = theme?.green10?.val ?? '$green10'; 
  const gray10 = theme?.gray10?.val ?? '$gray10'; 
  const orange10 = theme?.orange10?.val ?? '$orange10'; 


  const createEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: (updatedHabit) => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error creating habit entry:', error);
    }
  });

  const deleteEntryMutation = trpc.habit.deleteHabitEntry.useMutation({
    onSuccess: () => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error deleting habit entry:', error);
    }
  });

  useEffect(() => {
    setChecked(habit.completed);
  }, [habit.completed]);

  const handleToggle = () => {
    const newValue = !checked;
    setChecked(newValue); 
    setIsUpdating(true);

    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);

    const todayDateString = new Date().toISOString().split('T')[0];

    if (newValue) {
      const createInput: CreateHabitEntryInput = {
        habit_id: habit.id,
        date: todayDateString,
        completed: true, 
        quantity_value: null, 
        notes: null, 
      };
      createEntryMutation.mutate(createInput);
    } else {
      if (habit.last_entry_id) { 
        const deleteInput: DeleteHabitEntryInput = {
          id: habit.last_entry_id, 
        };
        deleteEntryMutation.mutate(deleteInput);
      } else {
        console.warn("Attempted to delete habit entry, but last_entry_id is missing.");
      }
    }

    if (onToggle) {
      onToggle(habit.id, newValue);
    }
  };

  const streakColor = checked ? green10 : gray10; // Use safe theme value
  const habitTypeColor = orange10; // Use safe theme value

  return (
    <XStack 
      backgroundColor="$backgroundStrong" // Use theme variable
      padding="$3"
      borderRadius="$4"
      alignItems="center"
      justifyContent="space-between"
      space="$3"
    >
      <YStack flex={1} gap="$1">
        <Text fontSize="$4" fontWeight="500" color="$color"> // Use theme variable
          {habit.name}
        </Text>
        
        {habit.streak != null && habit.streak > 0 && ( // Add null check
          <Text fontSize="$2" color={streakColor}> 
            Streak: {habit.streak ?? 0}
          </Text>
        )}
        {habit.habit_type && (
          <Text fontSize="$2" color={habitTypeColor}> // Use safe theme value
            ({habit.habit_type})
          </Text>
        )}
      </YStack>
      
      <Button
        size="$3"
        variant={checked ? undefined : 'outlined'} // Let variant handle appearance
        // Remove explicit colors - rely on theme/variant
        theme={checked ? 'green' : undefined} // Apply green theme when checked
        onPress={handleToggle}
        disabled={isUpdating} 
        iconAfter={checked ? <Text>✓</Text> : undefined}
      >
        {checked ? "Done" : "Check-in"}
      </Button>
    </XStack>
  );
}

[EOF: components/dashboard/HabitCheckItem.tsx]

========================================
FILE: components/dashboard/StateIndicator.tsx
----------------------------------------

import React from 'react';
// Use Tamagui components
import { Text, XStack, YStack, Card } from 'tamagui'; 
// Import RouterOutputs for inferred types
import { RouterOutputs } from '@/utils/trpc';

// Define prop type using inferred type from router
type DashboardTrackedState = RouterOutputs['dashboard']['getDashboardData']['trackedStates'][number];

interface StateIndicatorProps {
  state: DashboardTrackedState; // Use the inferred type
  onPress: () => void;
  lastEntry: any;
}

export default function StateIndicator({ state, onPress, lastEntry }: StateIndicatorProps) {
  // Format the last updated time
  const formattedTime = state.lastUpdated 
    ? new Date(state.lastUpdated).toLocaleTimeString([], { 
        hour: '2-digit', 
        minute: '2-digit' 
      })
    : 'N/A';
  
  // Use Tamagui Card component
  return (
    <Card 
      onPress={onPress} 
      pressStyle={{ opacity: 0.8 }}
      padding="$3"
      // No explicit background, will use default Card background from theme
    >
      <YStack space="$1"> {/* Main container for text */}
        <XStack flex={1} alignItems="center">
          <Text fontSize="$4" fontWeight="500">{state.name}</Text>
          {lastEntry && (
            <Text fontSize="$2" color="$gray10" marginLeft="$2">
              ({formattedTime})
            </Text>
          )}
        </XStack>
        <XStack alignItems="baseline" space="$2"> {/* Align text by baseline, add space */}
          <Text fontSize="$5" fontWeight="600" color="$color"> {/* Use tokens */}
            {state.currentValue}
          </Text>
        </XStack>
        {!lastEntry && (
          <Text fontSize="$2" color="$gray10" marginTop="$1">
            No data recorded yet.
          </Text>
        )}
      </YStack>
    </Card>
  );
} 

[EOF: components/dashboard/StateIndicator.tsx]

========================================
FILE: components/dashboard/TaskItem.tsx
----------------------------------------

import React from 'react';
// Use Tamagui components
import { Text, XStack, YStack, Checkbox, Spinner } from 'tamagui'; 
import { trpc, RouterOutputs, RouterInputs } from '@/utils/trpc';
import { Check } from '@tamagui/lucide-icons';

// Custom Task type that matches the actual format returned from the backend
type Task = {
  id: string;
  name: string;  // Backend returns 'name' not 'title'
  status: string;
  priority?: number;
  due_date?: string; // Backend returns 'due_date' not 'due'
  notes?: string;
  goal_id?: string;
  // Include other fields as needed
};

interface TaskItemProps {
  task: Task;
  onPress: () => void;
}

export default function TaskItem({ task, onPress }: TaskItemProps) {
  
  // Setup toggleTask mutation with optimistic updates
  const utils = trpc.useContext();
  // Setup mutation for task toggling
  const toggleTaskMutation = trpc.task.toggleTask.useMutation({
    // Optimistically update the UI
    onMutate: async ({ taskId, completed }: { taskId: string; completed?: boolean }) => {
      // Default to toggling the current state if completed is not provided
      const newCompleted = completed !== undefined ? completed : !isCompleted;
      // Cancel outgoing fetches that might overwrite our optimistic update
      await utils.task.getTasks.cancel();
      await utils.dashboard.getDashboardData.cancel();
      
      // Get previous data for potential rollback
      const prevTasksData = utils.task.getTasks.getData();
      const prevDashboardData = utils.dashboard.getDashboardData.getData();
      
      // Optimistically update tasks data if present
      if (prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return old.map((t: any) => {
            if (t.id === taskId) {
              return {
                ...t,
                status: completed ? 'completed' : 'in-progress'
              };
            }
            return t;
          });
        });
      }
      
      // Optimistically update dashboard data if present
      if (prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return {
            ...old,
            tasks: old.tasks.map((t: any) => {
              if (t.id === taskId) {
                return {
                  ...t,
                  status: newCompleted ? 'completed' : 'in-progress'
                };
              }
              return t;
            }),
          };
        });
      }
      
      // Return previous data for rollback
      return { prevTasksData, prevDashboardData };
    },
    
    // If something goes wrong, rollback optimistic updates
    onError: (err: any, variables: any, context: any) => {
      if (context?.prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, context.prevTasksData);
      }
      if (context?.prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, context.prevDashboardData);
      }
      console.error('Error toggling task:', err);
    },
    
    // Always refetch after error or success
    onSettled: () => {
      utils.task.getTasks.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    }
  });

  // Handle checkbox toggle
  const handleToggle = () => {
    toggleTaskMutation.mutate({
      taskId: task.id, // Using taskId as expected by the backend
      completed: !isCompleted
    });
  };

  // Map priority to color
  const priorityColor = task.priority === 1 ? '$brandRed' : 
                        task.priority === 2 ? '$brandYellow' : 
                        '$brandGreen';
  
  // Format due date
  const formattedDate = task.due_date 
    ? new Date(task.due_date).toLocaleDateString(undefined, { 
        month: 'short', 
        day: 'numeric' 
      })
    : null;
    
  // Determine task completion status
  const isCompleted = task.status === 'completed';
  // No need for text style object since we use Tamagui props directly

  
  // Use YStack as the base component
  return (
    <YStack 
      backgroundColor="$backgroundStrong"
      padding="$3"
      borderRadius="$4"
      space="$1" // Add space between XStack and Date Text
    >
      <XStack alignItems="center" space="$2"> {/* Use XStack for horizontal layout */}
        {/* Checkbox for task completion */}
        <Checkbox
          size="$4"
          checked={isCompleted}
          onCheckedChange={handleToggle}
          disabled={toggleTaskMutation.isPending}
        >
          {toggleTaskMutation.isPending ? (
            <Spinner size="small" color="$brandPrimary" />
          ) : (
            <Checkbox.Indicator>
              <Check size={16} />
            </Checkbox.Indicator>
          )}
        </Checkbox>

        {/* Container for task details (clickable) */}
        <XStack flex={1} tag="pressable" onPress={onPress} pressStyle={{ opacity: 0.7 }}>
          {/* Priority Dot using YStack */}
          <YStack 
            width="$2" // Use size token for width
            height="$2" // Use size token for height
            borderRadius="$10" // Use a large radius token
            backgroundColor={priorityColor} 
            marginRight="$2" // Use space token for margin
          />
          <Text 
            fontSize="$4" // Use font size token
            fontWeight={task.priority === 1 ? '600' : '400'} // Keep fontWeight
            color="$color"
            flex={1} // Allow text to take remaining space
            opacity={isCompleted ? 0.7 : 1}
            textDecorationLine={isCompleted ? 'line-through' : undefined} // Proper Tamagui text decoration
          >
            {task.name}
          </Text>
        </XStack>
      </XStack>
      
      {formattedDate && (
        // Removed explicit margin, rely on outer YStack space
        <Text color="$gray9" fontSize="$2">
          Due: {formattedDate}
        </Text>
      )}
    </YStack>
  );
} 

[EOF: components/dashboard/TaskItem.tsx]

========================================
FILE: components/ui/primitives/AetherCard.tsx
----------------------------------------

import React from 'react';
import { Card, CardProps, YStack, styled } from 'tamagui';

type AetherCardVariant = 'default' | 'elevated' | 'outlined';

interface AetherCardProps extends CardProps {
  variant?: AetherCardVariant;
  // Additional props specific to AetherCard
  isInteractive?: boolean;
}

// Create a styled Card component that uses our custom Tamagui theme variables
const StyledCard = styled(Card, {
  name: 'AetherCard',
  backgroundColor: '$cardBackground',
  borderRadius: '$4',
  padding: '$4',
  elevate: true,

  variants: {
    variant: {
      default: {
        // Using our theme tokens
        shadowColor: '$shadowColor',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 3,
        elevation: 2,
      },
      elevated: {
        shadowColor: '$shadowColor',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 6,
        elevation: 4,
      },
      outlined: {
        backgroundColor: 'transparent',
        borderWidth: 1,
        borderColor: '$borderColor',
        shadowOpacity: 0,
        elevation: 0,
      },
    },
    isInteractive: {
      true: {
        pressStyle: {
          backgroundColor: '$cardBackgroundPress',
          opacity: 0.9,
        },
        hoverStyle: {
          backgroundColor: '$cardBackgroundHover',
        },
      },
    },
  } as const,

  defaultVariants: {
    variant: 'default',
    isInteractive: false,
  },
});

/**
 * AetherCard - A stylized card component following Aether design system
 *
 * @param variant - The visual style variant: 'default', 'elevated', or 'outlined'
 * @param isInteractive - Whether the card responds to press/hover states
 */
export function AetherCard({ children, variant, isInteractive, ...props }: AetherCardProps) {
  return (
    <StyledCard variant={variant} isInteractive={isInteractive} {...props}>
      {children}
    </StyledCard>
  );
}


[EOF: components/ui/primitives/AetherCard.tsx]

========================================
FILE: components/ui/primitives/AetherListItem.tsx
----------------------------------------

import React from 'react';
import { XStack, YStack, Text, styled, GetProps, Stack } from 'tamagui';
import { Ionicons } from '@expo/vector-icons';

// Base ListItem container
const ListItemContainer = styled(XStack, {
  name: 'ListItemContainer',
  backgroundColor: '$cardBackground',
  paddingVertical: '$3',
  paddingHorizontal: '$4',
  borderRadius: '$3',
  alignItems: 'center',
  justifyContent: 'space-between',
  borderBottomWidth: 1,
  borderBottomColor: '$borderColor',
  minHeight: 60,
  
  variants: {
    isLast: {
      true: {
        borderBottomWidth: 0,
      },
    },
    interactive: {
      true: {
        pressStyle: {
          backgroundColor: '$backgroundPress',
          opacity: 0.9,
        },
        hoverStyle: {
          backgroundColor: '$backgroundHover',
        },
      },
    },
    variant: {
      default: {},
      header: {
        backgroundColor: '$backgroundStrong',
        borderBottomColor: '$borderColor',
        paddingVertical: '$2',
      },
    },
  } as const,
  
  defaultVariants: {
    isLast: false,
    interactive: true,
    variant: 'default',
  },
});

type ListItemContainerProps = GetProps<typeof ListItemContainer>;

export interface AetherListItemProps extends ListItemContainerProps {
  title: string;
  subtitle?: string;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  showChevron?: boolean;
  badge?: string | number;
}

/**
 * AetherListItem - A consistent list item component for use in lists, menus, and settings
 *
 * @param title - The primary text
 * @param subtitle - Optional secondary text shown below the title
 * @param leftIcon - Optional icon component to show on the left side
 * @param rightIcon - Optional icon component to show on the right side
 * @param showChevron - Whether to show a right chevron (useful for navigation items)
 * @param badge - Optional badge text/number to display
 * @param isLast - Whether this is the last item in a list (removes bottom border)
 * @param interactive - Whether the item should visually respond to touch
 */
export function AetherListItem({
  title,
  subtitle,
  leftIcon,
  rightIcon,
  showChevron = false,
  badge,
  isLast,
  interactive,
  ...props
}: AetherListItemProps) {
  return (
    <ListItemContainer isLast={isLast} interactive={interactive} {...props}>
      {/* Left section with icon and text */}
      <XStack space="$3" flex={1} alignItems="center">
        {leftIcon && (
          <Stack marginRight="$2">{leftIcon}</Stack>
        )}
        
        <YStack>
          <Text fontWeight="500" fontSize="$4">{title}</Text>
          {subtitle && (
            <Text fontSize="$2" color="$gray10">{subtitle}</Text>
          )}
        </YStack>
      </XStack>
      
      {/* Right section with badge, custom icon or chevron */}
      <XStack space="$2" alignItems="center">
        {badge && (
          <XStack 
            backgroundColor="$primary"
            paddingHorizontal="$2"
            paddingVertical="$1"
            borderRadius="$2"
          >
            <Text color="white" fontSize="$1" fontWeight="bold">{badge}</Text>
          </XStack>
        )}
        
        {rightIcon && rightIcon}
        
        {showChevron && (
          <Ionicons name="chevron-forward" size={16} color="$gray10" />
        )}
      </XStack>
    </ListItemContainer>
  );
}


[EOF: components/ui/primitives/AetherListItem.tsx]

========================================
FILE: components/ui/EmptyOrSkeleton.tsx
----------------------------------------

import React from 'react';
import { YStack, Text, Button } from 'tamagui';
import { SkeletonCard, SkeletonRow, SkeletonCircle } from './Skeleton';
import { SectionError } from './ErrorBanner';

export interface EmptyOrSkeletonProps {
  // Loading state
  isLoading?: boolean;
  count?: number;
  type?: 'card' | 'row' | 'circle';
  
  // Empty state
  isEmpty?: boolean;
  text?: string;
  actionText?: string;
  onAction?: () => void;
  
  // Error state
  isError?: boolean;
  onRetry?: () => void;
  
  // Children to render when not in any special state
  children?: React.ReactNode;
}

export const EmptyOrSkeleton = ({
  isLoading = false,
  count = 3,
  type = 'row',
  isEmpty = false,
  text = 'No items found',
  actionText = 'Add New',
  onAction,
  isError = false,
  onRetry,
  children
}: EmptyOrSkeletonProps) => {
  // Generate skeleton based on type
  const renderSkeletons = () => {
    const skeletons = [];
    for (let i = 0; i < count; i++) {
      if (type === 'card') {
        skeletons.push(<SkeletonCard key={i} />);
      } else if (type === 'circle') {
        skeletons.push(<SkeletonCircle key={i} />);
      } else {
        skeletons.push(<SkeletonRow key={i} />);
      }
    }
    return skeletons;
  };

  // Show skeleton if loading
  if (isLoading) {
    return (
      <YStack space="$3">
        {renderSkeletons()}
      </YStack>
    );
  }
  
  // Show error state if there's an error
  if (isError) {
    return (
      <SectionError 
        message={text} 
        onRetry={onRetry} 
      />
    );
  }
  
  // Show empty state if empty
  if (isEmpty) {
    return (
      <YStack
        padding="$4"
        alignItems="center"
        justifyContent="center"
        space="$3"
      >
        <Text textAlign="center" color="$gray11">
          {text}
        </Text>
        {onAction && (
          <Button size="$3" onPress={onAction}>
            {actionText}
          </Button>
        )}
      </YStack>
    );
  }
  
  // Default: return children
  return <>{children}</>;
};


[EOF: components/ui/EmptyOrSkeleton.tsx]

```

### app.json
**Path:** app.json
**Size:** 1393 bytes

```json
{
  "expo": {
    "name": "AetherIphone",
    "slug": "AetherIphone",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "aether",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.tybed7.AetherIphone",
      "infoPlist": {
        "ITSAppUsesNonExemptEncryption": false
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.tybed7.AetherIphone"
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff"
        }
      ]
    ],
    "runtimeVersion": {
      "policy": "appVersion"
    },
    "updates": {
      "url": "https://u.expo.dev/d25504b5-1869-4dca-bfe0-9aaf6e86923b"
    },
    "experiments": {
      "typedRoutes": true
    },
    "extra": {
      "router": {
        "origin": false
      },
      "eas": {
        "projectId": "d25504b5-1869-4dca-bfe0-9aaf6e86923b"
      }
    }
  }
}
```


# app

### _layout.tsx
**Path:** app/(auth)/_layout.tsx
**Size:** 618 bytes

```typescript
// Auth Stack Layout
import React from 'react';
import { Stack } from 'expo-router';

export default function AuthLayout() {
  return (
    <Stack>
      <Stack.Screen 
        name="login" 
        options={{ 
          title: 'Sign In',
          headerShown: false
        }} 
      />
      <Stack.Screen 
        name="register" 
        options={{ 
          title: 'Create Account',
          headerShown: false
        }} 
      />
      <Stack.Screen 
        name="forgot-password" 
        options={{ 
          title: 'Reset Password',
          headerShown: false
        }} 
      />
    </Stack>
  );
}
```

### forgot-password.tsx
**Path:** app/(auth)/forgot-password.tsx
**Size:** 2663 bytes

```typescript
// Forgot Password Screen
import React, { useState } from 'react';
import { Link } from 'expo-router';
import { YStack, H1, Input, Button, Text, Spinner, Image } from 'tamagui';
import { supabase } from '@/utils/supabase';
import { useToastController } from '@tamagui/toast';

export default function ForgotPasswordScreen() {
  const [email, setEmail] = useState('');
  const [loading, setLoading] = useState(false);
  const [success, setSuccess] = useState(false);
  const toast = useToastController();

  // Send password reset email via Supabase
  const handleResetPassword = async () => {
    if (!email) {
      toast.show('Please enter your email', { type: 'error' });
      return;
    }

    setLoading(true);

    try {
      const { error } = await supabase.auth.resetPasswordForEmail(email, {
        redirectTo: window?.location?.origin ? `${window.location.origin}/update-password` : undefined,
      });

      if (error) throw error;

      setSuccess(true);
      toast.show('Password reset email sent!', { type: 'success' });
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to send reset email';
      toast.show(errorMessage, { type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <YStack flex={1} padding="$4" justifyContent="center" space="$4" backgroundColor="$background">
      <YStack alignItems="center" marginBottom="$6">
        {/* Replace with your app logo */}
        <Image 
          source={require('@/assets/images/icon.png')} 
          width={100} 
          height={100} 
          marginBottom="$6" 
          resizeMode="contain"
        />
        <H1>Reset Password</H1>
        <Text color="$gray10" textAlign="center">
          {success 
            ? 'Check your email for reset instructions' 
            : 'Enter your email to receive reset instructions'}
        </Text>
      </YStack>

      {!success ? (
        <>
          <Input
            placeholder="Email"
            value={email}
            onChangeText={setEmail}
            autoCapitalize="none"
            keyboardType="email-address"
          />

          <Button
            onPress={handleResetPassword}
            disabled={loading}
            backgroundColor="$blue10"
            color="white"
            size="$5"
          >
            {loading ? <Spinner color="white" /> : 'Send Reset Link'}
          </Button>
        </>
      ) : null}

      <YStack paddingTop="$6" alignItems="center">
        <Link href="/(auth)/login">
          <Text color="$blue10">Back to Sign In</Text>
        </Link>
      </YStack>
    </YStack>
  );
}
```

### login.tsx
**Path:** app/(auth)/login.tsx
**Size:** 2566 bytes

```typescript
// Login Screen
import React, { useState } from 'react';
import { Link, router } from 'expo-router';
import { YStack, H1, Input, Button, Text, XStack, Spinner, Image } from 'tamagui';
import { supabase } from '@/utils/supabase';
import { useToastController } from '@tamagui/toast';

export default function LoginScreen() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const toast = useToastController();

  // Sign in with Supabase authentication
  const handleLogin = async () => {
    if (!email || !password) {
      toast.show('Please enter both email and password', { type: 'error' });
      return;
    }

    setLoading(true);

    try {
      const { error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (error) throw error;

      // Navigate to home screen on successful login
      router.replace('/(tabs)/home');
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Login failed';
      toast.show(errorMessage, { type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <YStack flex={1} padding="$4" justifyContent="center" space="$4" backgroundColor="$background">
      <YStack alignItems="center" marginBottom="$6">
        {/* Replace with your app logo */}
        <Image 
          source={require('@/assets/images/icon.png')} 
          width={100} 
          height={100} 
          marginBottom="$6" 
          resizeMode="contain"
        />
        <H1>Welcome to Aether</H1>
        <Text color="$gray10">Sign in to your account</Text>
      </YStack>

      <Input
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        autoCapitalize="none"
        keyboardType="email-address"
      />

      <Input
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <Button
        onPress={handleLogin}
        disabled={loading}
        backgroundColor="$blue10"
        color="white"
        size="$5"
      >
        {loading ? <Spinner color="white" /> : 'Sign In'}
      </Button>

      <XStack justifyContent="space-between" paddingTop="$2">
        <Link href="/(auth)/forgot-password">
          <Text color="$blue10">Forgot Password?</Text>
        </Link>

        <Link href="/(auth)/register">
          <Text color="$blue10">Create Account</Text>
        </Link>
      </XStack>
    </YStack>
  );
}
```

### register.tsx
**Path:** app/(auth)/register.tsx
**Size:** 3040 bytes

```typescript
// Register Screen
import React, { useState } from 'react';
import { Link, router } from 'expo-router';
import { YStack, H1, Input, Button, Text, XStack, Spinner, Image } from 'tamagui';
import { supabase } from '@/utils/supabase';
import { useToastController } from '@tamagui/toast';

export default function RegisterScreen() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const toast = useToastController();

  // Create new account with Supabase authentication
  const handleRegister = async () => {
    if (!email || !password) {
      toast.show('Please enter both email and password', { type: 'error' });
      return;
    }

    if (password !== confirmPassword) {
      toast.show('Passwords do not match', { type: 'error' });
      return;
    }

    setLoading(true);

    try {
      const { error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          emailRedirectTo: window?.location?.origin || undefined,
        }
      });

      if (error) throw error;

      // Navigate to home screen on successful registration
      toast.show('Account created successfully!', { type: 'success' });
      router.replace('/(tabs)/home');
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Registration failed';
      toast.show(errorMessage, { type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <YStack flex={1} padding="$4" justifyContent="center" space="$4" backgroundColor="$background">
      <YStack alignItems="center" marginBottom="$6">
        {/* Replace with your app logo */}
        <Image 
          source={require('@/assets/images/icon.png')} 
          width={100} 
          height={100} 
          marginBottom="$6" 
          resizeMode="contain"
        />
        <H1>Create Account</H1>
        <Text color="$gray10">Sign up to get started</Text>
      </YStack>

      <Input
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        autoCapitalize="none"
        keyboardType="email-address"
      />

      <Input
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />
      
      <Input
        placeholder="Confirm Password"
        value={confirmPassword}
        onChangeText={setConfirmPassword}
        secureTextEntry
      />

      <Button
        onPress={handleRegister}
        disabled={loading}
        backgroundColor="$blue10"
        color="white"
        size="$5"
      >
        {loading ? <Spinner color="white" /> : 'Create Account'}
      </Button>

      <XStack justifyContent="center" paddingTop="$2">
        <Text color="$gray10">Already have an account? </Text>
        <Link href="/(auth)/login">
          <Text color="$blue10">Sign In</Text>
        </Link>
      </XStack>
    </YStack>
  );
}
```

### _layout.tsx
**Path:** app/(tabs)/_layout.tsx
**Size:** 2123 bytes

```typescript
/* app/(tabs)/_layout.tsx */
import React from 'react';
import { Tabs } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import { useColorMode } from '@gluestack-ui/themed';

export default function TabsLayout() {
  // Zelda palette tokens from glueTheme / Tailwind
  const { colorMode } = useColorMode();
  const active = colorMode === 'light' ? '#86A5A9' : '#64FFDA';     // sheikahCyan / cyanGlow
  const inactive = colorMode === 'light' ? '#8e8e93' : '#626262';
  const bg = colorMode === 'light' ? '#FDFFE0' : '#1A2E3A';
  const border = colorMode === 'light' ? '#E5E5EA' : '#2C2C2E';

  return (
    <Tabs
      screenOptions={{
        headerShown: false,
        tabBarActiveTintColor: active,
        tabBarInactiveTintColor: inactive,
        tabBarStyle: {
          backgroundColor: bg,
          borderTopColor: border,
          height: 60,
        },
      }}
    >
      <Tabs.Screen
        name="home"
        options={{
          title: 'Home',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="home-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="planner"
        options={{
          title: 'Planner',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="calendar-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="compass"
        options={{
          title: 'Compass',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="stats-chart-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="rewards"
        options={{
          title: 'Rewards',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="sparkles-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="settings"
        options={{
          title: 'Settings',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="settings-outline" size={size} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}
```

### index.tsx
**Path:** app/(tabs)/compass/index.tsx
**Size:** 5050 bytes

```typescript
// Compass screen with Principles and States tabs
import React, { useState } from 'react';
import { YStack, XStack, Text, Tabs, Button, ScrollView } from 'tamagui'; 
import { SafeAreaView } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc, type RouterOutputs } from '@/utils/trpc'; 
import { useColorScheme } from '@/hooks/useColorScheme'; 
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { router, type Href } from 'expo-router'; 
import { PrincipleCard } from '@/components/compass/PrincipleCard';
import PrinciplesTab from '@/components/compass/PrinciplesTab';
import { StateDefinitionCard } from '@/components/compass/StateDefinitionCard'; 

interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'principles',
    title: 'Principles',
    icon: <Ionicons name="compass-outline" size={18} color="currentColor" />
  },
  {
    key: 'states',
    title: 'States',
    icon: <Ionicons name="pulse-outline" size={18} color="currentColor" />
  }
];

export default function CompassScreen() {
  const [activeTab, setActiveTab] = useState<string>('principles');
  const colorScheme = useColorScheme();

  const handleAddPress = () => {
    const route = `/compose?type=${activeTab === 'principles' ? 'value' : 'state'}` as Href;
    router.push(route);
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Compass</Text>
          <Button
            size="$3"
            circular
            onPress={handleAddPress} 
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>

        {/* Tabs */}
        <Tabs
          defaultValue="principles"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {React.cloneElement(tab.icon as React.ReactElement, { color: activeTab === tab.key ? '$colorFocus' : '$color' })}
                  <Text color={activeTab === tab.key ? '$colorFocus' : '$color'}>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>

          {/* Tab Content */}
          <Tabs.Content value="principles" flex={1} key="principles-content">
            <ScrollView>
              <PrinciplesTab />
            </ScrollView>
          </Tabs.Content>

          <Tabs.Content value="states" flex={1} key="states-content">
            <ScrollView>
              <StatesTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Define the specific types from RouterOutputs
// Types are now defined in the PrinciplesTab component
type StateDefinition = RouterOutputs['state']['getDefinitions'][number]; 

// Principles Tab Component is now imported from '@/components/compass/PrinciplesTab'

// States Tab Component (manages data fetching and list rendering)
function StatesTab() {
  const { data: states, isLoading, error, refetch } = trpc.state.getDefinitions.useQuery(); 

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }

  if (error) {
    return (
      <EmptyOrSkeleton
        isEmpty={false}
        isError={true}
        onRetry={refetch}
        text="Failed to load tracked state definitions"
      />
    );
  }

  if (!states || states.length === 0) {
    return (
      <EmptyOrSkeleton
        isEmpty={true}
        text="No state definitions found"
        actionText="Define Your First State"
        onAction={() => router.push('/compose?type=state' as Href)}
      />
    );
  }

  return (
    <YStack space="$3"> 
      {states.map((state: StateDefinition) => (
        <StateDefinitionCard
          key={state.id}
          state={state}
          onPress={() => router.push(`/states/${state.id}` as Href)}
        />
      ))}
    </YStack>
  );
}

// 
// Removed inline PrincipleCard definition (extracted to components/compass/PrincipleCard.tsx)
// 

// 
// Removed inline StateDefinitionCard definition (extracted to components/compass/StateDefinitionCard.tsx)
// 
```

### index.gluestack.tsx
**Path:** app/(tabs)/home/index.gluestack.tsx
**Size:** 0 bytes
*(file listed in source control but not found locally)*

### index.tsx
**Path:** app/(tabs)/home/index.tsx
**Size:** 2240 bytes

```typescript
/* app/(tabs)/home/index.tsx */
import React from 'react';
import { RefreshControl } from 'react-native';
import { Stack, Text, ScrollView, Button } from '@/design-system/Primitives';
import { useDashboardQuery } from '@/app/lib/useDashboardQuery';
import { useToggleTaskStatus } from '@/app/lib/useToggleTaskStatus';
import { SwipeableRow } from '@/app/components/SwipeableRow';
import { TaskRow } from '@/app/components/TaskRow';
import { SectionCard } from '@/app/components/SectionCard';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { useColorModeValue } from '@gluestack-ui/themed';

export default function HomeScreen() {
  const router = useRouter();
  const { data, isLoading, isRefetching, refetch } = useDashboardQuery();
  const toggleTask = useToggleTaskStatus();

  const parchment = useColorModeValue('#FDFFE0', '#1A2E3A');

  return (
    <ScrollView
      className="flex-1 px-4"
      style={{ backgroundColor: parchment }}
      refreshControl={<RefreshControl refreshing={isRefetching} onRefresh={refetch} />}
    >
      <Text className="text-2xl font-heading text-darkText mt-6 mb-4">
        Good morning, Link!
      </Text>

      {/* Tasks Section */}
      <SectionCard
        title="Tasks for today"
        action={
          <Button
            className="flex-row items-center"
            onPress={() => router.push('/(tabs)/planner/add-task')}
          >
            <Ionicons name="add" size={18} color="#86A5A9" />
            <Text className="ml-1 text-sheikahCyan">New</Text>
          </Button>
        }
      >
        {isLoading && <Text>Loading…</Text>}
        {!isLoading && (!data?.tasks?.length ? (
          <Text className="text-ios-gray-3">No tasks 🎉</Text>
        ) : (
          data.tasks.map((task) => (
            <SwipeableRow
              key={task.id}
              onComplete={() =>
                toggleTask.mutate({ taskId: task.id, completed: task.status !== 'done' })
              }
            >
              <TaskRow task={task} />
            </SwipeableRow>
          ))
        ))}
      </SectionCard>

      {/* You can add Habits / Goals sections here following the same pattern */}
    </ScrollView>
  );
}
```

### _layout.tsx
**Path:** app/(tabs)/planner/_layout.tsx
**Size:** 872 bytes

```typescript
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/planner/_layout.tsx
import { Stack } from 'expo-router';
import React from 'react';

export default function PlannerLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      {/* The index screen is the default for the planner tab */}
      <Stack.Screen name="index" />
      {/* Add screens for the sub-pages */}
      <Stack.Screen name="add-task" options={{ presentation: 'modal', title: 'Add Task' }} />
      <Stack.Screen name="add-habit" options={{ presentation: 'modal', title: 'Add Habit' }} />
      <Stack.Screen name="add-goal" options={{ presentation: 'modal', title: 'Add Goal' }} />
      <Stack.Screen name="goal/[id]" options={{ title: 'Goal Details' }} />
      <Stack.Screen name="habit/[id]" options={{ title: 'Habit Details' }} />
    </Stack>
  );
}
```

### add-goal.tsx
**Path:** app/(tabs)/planner/add-goal.tsx
**Size:** 682 bytes

```typescript
// Placeholder for Add Goal Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function AddGoalScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Add New Goal</H1>
        <Text>Goal details form will go here.</Text>
        <Button onPress={() => router.back()}>Cancel</Button>
      </YStack>
    </SafeAreaView>
  );
}
```

### add-habit.tsx
**Path:** app/(tabs)/planner/add-habit.tsx
**Size:** 686 bytes

```typescript
// Placeholder for Add Habit Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function AddHabitScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Add New Habit</H1>
        <Text>Habit details form will go here.</Text>
        <Button onPress={() => router.back()}>Cancel</Button>
      </YStack>
    </SafeAreaView>
  );
}
```

### add-task.tsx
**Path:** app/(tabs)/planner/add-task.tsx
**Size:** 682 bytes

```typescript
// Placeholder for Add Task Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function AddTaskScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Add New Task</H1>
        <Text>Task details form will go here.</Text>
        <Button onPress={() => router.back()}>Cancel</Button>
      </YStack>
    </SafeAreaView>
  );
}
```

### [id].tsx
**Path:** app/(tabs)/planner/goal/[id].tsx
**Size:** 847 bytes

```typescript
// Placeholder for Goal Detail Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router, useLocalSearchParams } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function GoalDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const colorScheme = useColorScheme();

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Goal Detail: {id}</H1>
        <Text>Details for goal {id} will be displayed here.</Text>
        {/* Add tRPC query to fetch goal data based on id */}
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
```

### [id].tsx
**Path:** app/(tabs)/planner/habit/[id].tsx
**Size:** 852 bytes

```typescript
// Placeholder for Habit Detail Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router, useLocalSearchParams } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function HabitDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const colorScheme = useColorScheme();

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Habit Detail: {id}</H1>
        <Text>Details for habit {id} will be displayed here.</Text>
        {/* Add tRPC query to fetch habit data based on id */}
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
```

### index.tsx
**Path:** app/(tabs)/planner/index.tsx
**Size:** 7739 bytes

```typescript
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/planner/index.tsx
import React, { useState, Suspense } from 'react';
import { YStack, XStack, Text, Tabs, Button, Spinner, Card, ScrollView } from 'tamagui';
import { SafeAreaView, FlatList, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { RouterOutputs } from '@/utils/api-types';
import { SectionError } from '@/components/ui/ErrorBanner';


interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'goals',
    title: 'Goals',
    icon: <Ionicons name="trophy-outline" size={18} color="currentColor" />
  },
  {
    key: 'habits',
    title: 'Habits',
    icon: <Ionicons name="repeat-outline" size={18} color="currentColor" />
  },
  {
    key: 'calendar',
    title: 'Calendar',
    icon: <Ionicons name="calendar-outline" size={18} color="currentColor" />
  }
];

export default function PlannerScreen() {
  const [activeTab, setActiveTab] = useState<string>('goals');
  const colorScheme = useColorScheme();
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Planner</Text>
          <Button
            size="$3"
            circular
            onPress={() => {/* Handle new item */}}
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>
        
        {/* Tabs */}
        <Tabs
          defaultValue="goals"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List 
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {tab.icon}
                  <Text>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>
          
          {/* Tab Content */}
          <Tabs.Content value="goals" flex={1}>
            <ScrollView>
              <GoalsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="habits" flex={1}>
            <ScrollView>
              <HabitsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="calendar" flex={1}>
            <ScrollView>
              <CalendarTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Goals Tab
function GoalsTab() {
  // Fetch goals using tRPC
  const { data: goals, isLoading, error, refetch } = trpc.goal.getGoals.useQuery();
  
  // Define the inferred type for a single goal
  type PlannerGoal = RouterOutputs['goal']['getGoals'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load goals" 
      />
    );
  }
  
  if (!goals || goals.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No goals yet" 
        actionText="Create a goal" 
        onAction={() => router.push('/planner/add-goal')} 
      />
    );
  }
  
  return (
    <YStack space="$4">
      {goals.map((goal: PlannerGoal) => (
        <Button 
          key={goal.id} 
          height="$12" 
          justifyContent="flex-start" 
          paddingHorizontal="$3"
          onPress={() => router.push({ pathname: '/planner/goal/[id]', params: { id: goal.id } })}
        >
          <YStack>
            <Text fontWeight="bold">{goal.title}</Text>
            <Text fontSize="$2" color="$gray10">
              {goal.dueDate ? new Date(goal.dueDate).toLocaleDateString() : 'No due date'}
            </Text>
          </YStack>
        </Button>
      ))}
    </YStack>
  );
}

// Habits Tab
function HabitsTab() {
  // Fetch habits using tRPC
  const { data: habits, isLoading, error, refetch } = trpc.habit.getHabits.useQuery();
  
  // Define the inferred type for a single habit
  type PlannerHabit = RouterOutputs['habit']['getHabits'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={isLoading} count={3} type="row" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load habits" 
      />
    );
  }
  
  if (!habits || habits.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No habits yet" 
        actionText="Create a habit" 
        onAction={() => router.push('/planner/add-habit')} 
      />
    );
  }
  
  return (
    <YStack space="$3">
      {habits.map((habit: PlannerHabit) => (
        <XStack 
          key={habit.id} 
          justifyContent="space-between" 
          alignItems="center" 
          paddingVertical="$3" 
          paddingHorizontal="$3" 
          borderBottomWidth={1} 
          borderColor="$gray5"
          pressStyle={{ opacity: 0.7 }}
          tag="pressable"
          onPress={() => router.push({ pathname: '/planner/habit/[id]', params: { id: habit.id } })}
        >
          <Text>{habit.title}</Text>
          <Button
            size="$2"
            circular
            backgroundColor={habit.completed ? '$green9' : '$gray9'}
            onPress={() => {
              // Use today's date for the habit entry
              const today = new Date().toISOString().split('T')[0];
              
              // Create a mutation to toggle habit completion
              const toggleHabit = trpc.habit.createHabitEntry.useMutation({
                onSuccess: () => {
                  refetch(); // Refresh data after toggling
                },
                onError: (error) => {
                  // Show error message
                  console.error('Failed to toggle habit:', error.message);
                }
              });
              
              // Toggle the habit completion status
              toggleHabit.mutate({
                habitId: habit.id,
                completed: !habit.completed,
                date: today
              });
            }}
            icon={<Ionicons name="checkmark" size={18} color="white" />}
          />
        </XStack>
      ))}
    </YStack>
  );
}

// Calendar Tab
function CalendarTab() {
  return (
    <YStack alignItems="center" justifyContent="center" padding="$8">
      <Text fontSize="$5" textAlign="center">
        Calendar integration coming soon
      </Text>
      <Text marginTop="$2" color="$gray10" textAlign="center">
        This tab will display task and habit schedules in a calendar view
      </Text>
    </YStack>
  );
}
```

### index.tsx
**Path:** app/(tabs)/rewards/index.tsx
**Size:** 9186 bytes

```typescript
// Rewards screen with grid/list toggle and claim functionality
import React, { useState, useCallback } from 'react';
import { YStack, XStack, Text, Button, ScrollView, Card, Checkbox, useTheme, H1 } from 'tamagui';
import { SafeAreaView, View, FlatList, ImageBackground, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { RouterOutputs } from '@/utils/trpc'; // Import RouterOutputs
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton'; // Import helper component

// Define inferred type for rewards
type RewardItem = RouterOutputs['rewards']['getAvailableRewards'][number];

enum ViewMode {
  Grid = 'grid',
  List = 'list'
}

export default function RewardsScreen() {
  const [viewMode, setViewMode] = useState<ViewMode>(ViewMode.Grid);
  const colorScheme = useColorScheme();
  const theme = useTheme();

  // Define fallback colors
  const blue2 = theme?.blue2?.val ?? '#eff6ff';
  const blue5 = theme?.blue5?.val ?? '#60a5fa';
  const blue10 = theme?.blue10?.val ?? '#1e40af';
  const blue11 = theme?.blue11?.val ?? '#1e3a8a';
  const green9 = theme?.green9?.val ?? '#16a34a';

  // Fetch available rewards from tRPC
  const { 
    data: rewards, 
    isLoading, 
    error, 
    refetch 
  } = trpc.rewards.getAvailableRewards.useQuery();

  // Mutation for claiming rewards
  const claimMutation = trpc.rewards.earnReward.useMutation({
    onSuccess: (data) => {
      console.log('Reward claimed successfully:', data);
      // Maybe show confetti?
      Alert.alert('Reward Claimed!', `You spent ${data.reward.points_spent} points. Remaining: ${data.remainingPoints}`);
      refetch(); // Refetch the list of available rewards
    },
    onError: (err) => {
      console.error('Failed to claim reward:', err);
      Alert.alert('Claim Failed', err.message || 'Could not claim reward.');
    }
  });
  
  const handleClaimReward = useCallback((rewardId: string) => {
    if (claimMutation.isPending) return; // Prevent double-clicks
    
    Alert.alert(
      'Confirm Claim',
      'Are you sure you want to spend points on this reward?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Claim', 
          onPress: () => {
            claimMutation.mutate({ rewardId });
          },
          style: 'default'
        }
      ]
    );
  }, [claimMutation]);
  
  const renderItem = ({ item }: { item: RewardItem }) => { // Use inferred type
    // Assuming backend field is image_url, map to imagePath
    const imagePath = item.image_url; 
    // All items from getAvailableRewards are considered claimable (not yet claimed)
    const claimed = false; 
    // Map required_points to pointCost
    const pointCost = item.required_points;

    if (viewMode === ViewMode.Grid) {
      return (
        <Card
          size="$4"
          bordered
          width={160}
          height={200}
          margin="$2"
          overflow="hidden"
          elevation="$2"
          opacity={claimed ? 0.7 : 1}
        >
          <ImageBackground
            source={{ uri: imagePath }}
            style={{ width: '100%', height: 100 }}
          >
            <View style={{ 
              position: 'absolute', 
              top: 5, 
              right: 5, 
              backgroundColor: blue5,
              borderRadius: 10,
              padding: 4
            }}>
              <Text color="white" fontSize="$2" fontWeight="bold">
                {pointCost} pts
              </Text>
            </View>
          </ImageBackground>
          
          <YStack padding="$2" flex={1} justifyContent="space-between">
            <Text fontSize="$4" fontWeight="bold" numberOfLines={1}>
              {item.name}
            </Text>
            
            <Button
              size="$2"
              themeInverse={claimed}
              backgroundColor={claimed ? undefined : blue10}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </YStack>
        </Card>
      );
    } else {
      return (
        <Card
          bordered
          margin="$2"
          padding="$3"
          opacity={claimed ? 0.7 : 1}
        >
          <XStack space="$3" alignItems="center">
            {imagePath && (
              <View style={{ 
                width: 60, 
                height: 60, 
                borderRadius: 8, 
                overflow: 'hidden',
                backgroundColor: theme.gray3.val
              }}>
                <ImageBackground
                  source={{ uri: imagePath }}
                  style={{ width: '100%', height: '100%' }}
                />
              </View>
            )}
            
            <YStack flex={1} space="$1">
              <Text fontSize="$5" fontWeight="bold">{item.name}</Text>
              <Text fontSize="$3" color="$gray11" numberOfLines={2}>{item.description}</Text>
              <Text fontSize="$3" color={blue10} fontWeight="500">{pointCost} points</Text>
            </YStack>
            
            <Button
              size="$3"
              backgroundColor={claimed ? undefined : blue10}
              themeInverse={claimed}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </XStack>
        </Card>
      );
    }
  };
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        <YStack space="$4">
          {/* Header */}
          <XStack justifyContent="space-between" alignItems="center">
            <H1>Rewards</H1>
            
            <XStack space="$2">
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.Grid ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.Grid)}
              >
                <Ionicons 
                  name="grid-outline" 
                  size={22} 
                  color={viewMode === ViewMode.Grid ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
              
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.List ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.List)}
              >
                <Ionicons 
                  name="list-outline" 
                  size={22} 
                  color={viewMode === ViewMode.List ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
            </XStack>
          </XStack>
          
          {/* Stats */}
          <Card padding="$3" backgroundColor={blue2}>
            <XStack justifyContent="space-between" alignItems="center">
              <Text fontSize="$5" fontWeight="bold" color={blue11}>Your Points</Text>
              <Text fontSize="$6" fontWeight="bold" color={blue10}>275</Text>
            </XStack>
          </Card>
        </YStack>
        
        {/* Content Area */} 
        <EmptyOrSkeleton 
          isLoading={isLoading}
          isEmpty={!isLoading && !error && (!rewards || rewards.length === 0)}
          isError={!!error}
          text={error ? error.message : 'No rewards available yet.'} // Use text for error OR empty msg
          onRetry={refetch}
          type={viewMode === ViewMode.Grid ? 'card' : 'row'}
          count={viewMode === ViewMode.Grid ? 6 : 3}
        >
          <FlatList
            key={viewMode} // Change key based on viewMode to force re-render
            data={rewards}
            renderItem={renderItem}
            keyExtractor={(item, index) =>
              `${item?.id ?? `tmp-${index}`}-${viewMode}`   // fall back to index if ID is missing
            }
            
            // Optional: Log corrupt data in development
            onLayout={() => {
              if (__DEV__) {
                const missing = (rewards ?? []).filter(r => !r?.id);
                if (missing.length) console.warn('Rewards missing id:', missing);
              }
            }}
            numColumns={viewMode === ViewMode.Grid ? 2 : 1}
            contentContainerStyle={{ paddingBottom: 50 }} // Add padding at the bottom
            // Optional Optimizations (Patch #6)
            initialNumToRender={8}
            removeClippedSubviews={true} // Note: Can have visual glitches on iOS sometimes
          />
        </EmptyOrSkeleton>

      </YStack>
    </SafeAreaView>
  );
}
```

### _layout.tsx
**Path:** app/(tabs)/settings/_layout.tsx
**Size:** 884 bytes

```typescript
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/settings/_layout.tsx
import { Stack } from 'expo-router';
import React from 'react';

export default function SettingsLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      {/* The index screen is the default for the settings tab */}
      <Stack.Screen name="index" />
      {/* Add screens for the sub-pages */}
      <Stack.Screen name="profile" options={{ title: 'Edit Profile' }} />
      <Stack.Screen name="security" options={{ title: 'Security' }} />
      <Stack.Screen name="privacy" options={{ title: 'Data & Privacy' }} />
      <Stack.Screen name="notifications" options={{ title: 'Notifications' }} />
      <Stack.Screen name="help" options={{ title: 'Help & Support' }} />
      <Stack.Screen name="about" options={{ title: 'About Aether' }} />
    </Stack>
  );
}
```

### about.tsx
**Path:** app/(tabs)/settings/about.tsx
**Size:** 688 bytes

```typescript
// Placeholder for About Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function AboutScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>About Aether</H1>
        <Text>App version, terms of service, credits, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
```

### help.tsx
**Path:** app/(tabs)/settings/help.tsx
**Size:** 675 bytes

```typescript
// Placeholder for Help Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function HelpScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Help & Support</H1>
        <Text>FAQ, contact support link, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
```

### index.tsx
**Path:** app/(tabs)/settings/index.tsx
**Size:** 9868 bytes

```typescript
// Settings screen with account, preferences, and app settings
import React, { useState } from 'react';
import { YStack, XStack, Text, Button, Switch, Separator, ScrollView, Card, H1 } from 'tamagui';
import { SafeAreaView, View, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { supabase } from '@/utils/supabase';
import { useColorScheme } from 'react-native';
import { useAccent } from '@/app/_layout'; // Import the useAccent hook

interface SettingsSectionProps {
  title: string;
  icon: React.ReactNode;
  children: React.ReactNode;
}

const SettingsSection = ({ title, icon, children }: SettingsSectionProps) => {
  return (
    <YStack marginVertical="$2">
      <XStack alignItems="center" space="$2" marginBottom="$2">
        {icon}
        <Text fontSize="$5" fontWeight="bold">{title}</Text>
      </XStack>
      <Card padding="$3" bordered>
        {children}
      </Card>
    </YStack>
  );
};

interface SettingsRowProps {
  label: string;
  icon?: React.ReactNode;
  rightElement?: React.ReactNode;
  onPress?: () => void;
  showChevron?: boolean;
}

const SettingsRow = ({ label, icon, rightElement, onPress, showChevron = false }: SettingsRowProps) => {
  return (
    <XStack
      paddingVertical="$3"
      justifyContent="space-between"
      alignItems="center"
      onPress={onPress}
      pressStyle={onPress ? { opacity: 0.7 } : undefined}
    >
      <XStack space="$3" alignItems="center" flex={1}>
        {icon}
        <Text fontSize="$4">{label}</Text>
      </XStack>
      <XStack space="$2" alignItems="center">
        {rightElement}
        {showChevron && <Ionicons name="chevron-forward" size={18} color="#A0A0A0" />}
      </XStack>
    </XStack>
  );
};

export default function SettingsScreen() {
  const colorScheme = useColorScheme();
  const [notificationsEnabled, setNotificationsEnabled] = useState(true);
  const [trackingEnabled, setTrackingEnabled] = useState(true);
  const { setAccent } = useAccent(); // Get the function to update accent color
  const [selectedAccent, setSelectedAccent] = useState('blue'); // Placeholder state for selected accent

  const handleLogout = async () => {
    Alert.alert(
      'Log Out',
      'Are you sure you want to log out?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Log Out', 
          style: 'destructive',
          onPress: async () => {
            await supabase.auth.signOut();
            router.replace('/(auth)/login');
          }
        }
      ]
    );
  };

  const AccentSelector = ({ currentAccent, onSelect }: { currentAccent: string, onSelect: (accent: string) => void }) => {
    const accents = ['blue', 'green', 'orange', 'red']; // Example accents corresponding to theme names
    return (
      <XStack space="$2">
        {accents.map((accent) => (
          <Button 
            key={accent} 
            onPress={() => {
              onSelect(accent);
              setAccent(accent); // Call setAccent with the selected accent
            }} 
            theme={accent as any} // Preview the theme (cast needed for demo)
            backgroundColor={accent === currentAccent ? '$backgroundStrong' : '$background'}
          >
            {accent.charAt(0).toUpperCase() + accent.slice(1)}
          </Button>
        ))}
      </XStack>
    );
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <ScrollView>
        <YStack flex={1} padding="$4">
          <H1 marginBottom="$4">Settings</H1>
          
          {/* Account Section */}
          <SettingsSection
            title="Account"
            icon={<Ionicons name="person-circle-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Edit Profile"
                icon={<Ionicons name="person-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/profile' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Security"
                icon={<Ionicons name="lock-closed-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/security' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Data & Privacy"
                icon={<Ionicons name="shield-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/privacy' as any)}
              />
            </YStack>
          </SettingsSection>
          
          {/* Appearance Section */}
          <SettingsSection
            title="Appearance"
            icon={<Ionicons name="color-palette-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Theme"
                icon={<Ionicons name="moon-outline" size={20} color="#A0A0A0" />}
                rightElement={<Text color="$gray10">{colorScheme === 'dark' ? 'Dark (System)' : 'Light (System)'}</Text>}
              />
              <SettingsRow
                label="Accent Color"
                icon={<Ionicons name="color-palette-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <AccentSelector 
                    currentAccent={selectedAccent} 
                    onSelect={(accent) => setSelectedAccent(accent)} 
                  />
                }
              />
            </YStack>
          </SettingsSection>
          
          {/* Notifications Section */}
          <SettingsSection
            title="Notifications"
            icon={<Ionicons name="notifications-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Push Notifications"
                icon={<Ionicons name="push-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={notificationsEnabled}
                    onCheckedChange={setNotificationsEnabled}
                  />
                }
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Notification Settings"
                icon={<Ionicons name="options-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/notifications' as any)}
              />
            </YStack>
          </SettingsSection>
          
          {/* Privacy Section */}
          <SettingsSection
            title="Privacy & Data"
            icon={<Ionicons name="analytics-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Analytics Tracking"
                icon={<Ionicons name="trending-up-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={trackingEnabled}
                    onCheckedChange={setTrackingEnabled}
                  />
                }
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Export Data"
                icon={<Ionicons name="download-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => {
                  Alert.alert(
                    'Export Data',
                    'Your data will be prepared for export and sent to your email address.',
                    [
                      { text: 'Cancel', style: 'cancel' },
                      { text: 'Export', onPress: () => {
                        // Would call an API endpoint to initiate export
                        Alert.alert('Export Initiated', 'Check your email for the export file.');
                      }}
                    ]
                  );
                }}
              />
            </YStack>
          </SettingsSection>
          
          {/* Support Section */}
          <SettingsSection
            title="Support & About"
            icon={<Ionicons name="help-circle-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Help Center"
                icon={<Ionicons name="help-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/help' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="About Aether"
                icon={<Ionicons name="information-circle-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/about' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="App Version"
                icon={<Ionicons name="code-outline" size={20} color="#A0A0A0" />}
                rightElement={<Text color="$gray10">1.0.0</Text>}
              />
            </YStack>
          </SettingsSection>
          
          {/* Logout Button */}
          <Button
            marginTop="$6"
            marginBottom="$8"
            size="$4"
            themeInverse
            onPress={handleLogout}
          >
            Log Out
          </Button>
        </YStack>
      </ScrollView>
    </SafeAreaView>
  );
}
```

### notifications.tsx
**Path:** app/(tabs)/settings/notifications.tsx
**Size:** 735 bytes

```typescript
// Placeholder for Notification Settings Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function NotificationSettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Notification Settings</H1>
        <Text>Granular controls for different notification types.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
```

### privacy.tsx
**Path:** app/(tabs)/settings/privacy.tsx
**Size:** 717 bytes

```typescript
// Placeholder for Privacy Settings Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function PrivacySettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Data & Privacy</H1>
        <Text>Data management options, privacy policy link, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
```

### profile.tsx
**Path:** app/(tabs)/settings/profile.tsx
**Size:** 699 bytes

```typescript
// Placeholder for Profile Settings Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function ProfileSettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Edit Profile</H1>
        <Text>Profile editing form will go here.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
```

### security.tsx
**Path:** app/(tabs)/settings/security.tsx
**Size:** 706 bytes

```typescript
// Placeholder for Security Settings Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function SecuritySettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Security Settings</H1>
        <Text>Password change, 2FA options, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
```

### _layout.tsx
**Path:** app/_layout.tsx
**Size:** 1044 bytes

```typescript
/* app/_layout.tsx */
import React from 'react';
import { Stack } from 'expo-router';
import { GluestackUIProvider } from '@gluestack-ui/themed';
import { glueTheme } from '@/design-system/theme.glue';
import { QueryClientProvider } from '@tanstack/react-query';
import { queryClient } from '@/utils/query-client';
import { TRPCProvider } from '@/providers/TRPCProvider';
import { SupabaseProvider } from '@/providers/SupabaseProvider';
import '@/global.css';                 // NativeWind classes

export default function RootLayout() {
  return (
    <GluestackUIProvider config={glueTheme}>
      <QueryClientProvider client={queryClient}>
        <SupabaseProvider>
          <TRPCProvider>
            {/* Expo-router top-level stack (auth gate handled in screens) */}
            <Stack
              screenOptions={{
                headerShown: false,
                animation: 'fade',
              }}
            />
          </TRPCProvider>
        </SupabaseProvider>
      </QueryClientProvider>
    </GluestackUIProvider>
  );
}
```

### SectionCard.tsx
**Path:** app/components/SectionCard.tsx
**Size:** 720 bytes

```typescript
// app/components/SectionCard.tsx
import React from 'react';
import { Stack, Text } from '@/design-system/Primitives';
import { BlurView } from 'expo-blur';

type SectionCardProps = {
  title: string;
  children: React.ReactNode;
};

export const SectionCard: React.FC<SectionCardProps> = ({ title, children }) => {
  return (
    <Stack className="mb-6 overflow-hidden rounded-2xl">
      <BlurView intensity={30} tint="light" className="overflow-hidden rounded-2xl">
        <Stack className="p-4 bg-parchment/50 dark:bg-sheikahCyan/10">
          <Text className="font-heading text-lg mb-2 text-darkText dark:text-parchment">{title}</Text>
          {children}
        </Stack>
      </BlurView>
    </Stack>
  );
};
```

### SwipeableRow.tsx
**Path:** app/components/SwipeableRow.tsx
**Size:** 1651 bytes

```typescript
// app/components/SwipeableRow.tsx
import React from 'react';
import { View } from 'react-native';
import Swipeable from 'react-native-gesture-handler/Swipeable';
import { Button } from '@/design-system/Primitives';
import { Ionicons } from '@expo/vector-icons';

type SwipeableRowProps = {
  children: React.ReactNode;
  onComplete?: () => void;
  onDelete?: () => void;
};

export const SwipeableRow = ({ children, onComplete, onDelete }: SwipeableRowProps) => {
  // Render left-swipe (complete) action
  const renderLeftActions = () => {
    if (!onComplete) return null;
    return (
      <View className="flex-row">
        <Button 
          className="w-20 h-full justify-center items-center bg-korokGreen" 
          onPress={onComplete}
          aria-label="Complete task"
        >
          <Ionicons name="checkmark-outline" size={20} color="#FDFFE0" /* parchment */ />
        </Button>
      </View>
    );
  };

  // Render right-swipe (delete) action
  const renderRightActions = () => {
    if (!onDelete) return null;
    return (
      <View className="flex-row justify-end">
        <Button 
          className="w-20 h-full justify-center items-center bg-guardianOrange" 
          onPress={onDelete}
          aria-label="Delete task"
        >
          <Ionicons name="trash-outline" size={20} color="#FDFFE0" /* parchment */ />
        </Button>
      </View>
    );
  };

  return (
    <Swipeable
      renderLeftActions={renderLeftActions}
      renderRightActions={renderRightActions}
      overshootFriction={8}
      containerStyle={{ backgroundColor: 'transparent' }}
    >
      {children}
    </Swipeable>
  );
};
```

### TaskRow.tsx
**Path:** app/components/TaskRow.tsx
**Size:** 1117 bytes

```typescript
// app/components/TaskRow.tsx
import React, { memo } from 'react';
import { Text, Stack } from '@/design-system/Primitives';
import { Ionicons } from '@expo/vector-icons';
import { RouterOutputs } from '@/utils/trpc';

// Use the existing task type from your tRPC output
type DashboardData = RouterOutputs['dashboard']['getDashboardData'];
type Task = DashboardData['tasks'][number];

export const TaskRow = memo(({ task }: { task: Task }) => (
  <Stack className="flex-row items-center py-3 px-4 bg-parchment/80 dark:bg-darkTealBg/50">
    {task.status === 'completed' && (
      <Ionicons 
        name="checkmark-circle" 
        size={18} 
        color="#92C582" // korokGreen
        style={{ marginRight: 8 }} 
      />
    )}
    <Text 
      className={`flex-1 ${task.status === 'completed' 
        ? 'text-darkText/50 line-through' 
        : 'text-darkText dark:text-parchment'}`}
    >
      {task.name}
    </Text>
    {task.due_date && (
      <Text className="text-xs text-darkText/70 dark:text-parchment/70">
        {new Date(task.due_date).toLocaleDateString()}
      </Text>
    )}
  </Stack>
));
```

### compose.tsx
**Path:** app/compose.tsx
**Size:** 10133 bytes

```typescript
// app/compose.tsx
import React from 'react';
import { ScrollView } from 'react-native'; // Using RN ScrollView directly
import { Stack, useRouter, useLocalSearchParams } from 'expo-router';
import { YStack, XStack, Form, Input, Label, TextArea, Button, Switch, Paragraph, Spinner } from 'tamagui';
import { useForm, Controller, ControllerRenderProps, FieldValues } from 'react-hook-form'; // Import ControllerRenderProps
import { zodResolver } from '@hookform/resolvers/zod';
import { useToastController } from '@tamagui/toast'; // Assuming ToastProvider is set up

import { trpc, type RouterInputs } from '@/utils/trpc'; // Assuming inputs are exported like this
import { haptics } from '@/utils/haptics'; // Assuming haptics helper exists

// Assuming your Zod schemas are exported like this. Adjust if necessary.
type CreateValueInput = RouterInputs['value']['createValue'];
type CreateStateInput = RouterInputs['state']['createDefinition'];

// 1️⃣ Define tagged types for discriminated union
type CreateValueInputTagged = CreateValueInput & { __type: 'value' };
type CreateStateInputTagged = CreateStateInput & { __type: 'state' };
type FormValues = CreateValueInputTagged | CreateStateInputTagged;

export default function ComposeModal() {
  const router = useRouter();
  const params = useLocalSearchParams<{ type: string }>();
  const type = params.type === 'value' || params.type === 'state' ? params.type : undefined;
  const toast = useToastController();
  const utils = trpc.useUtils();

  const isValue = type === 'value';

  // 2️⃣ Define stricter default values using tagged types
  const defaultValueValues: CreateValueInputTagged = {
    __type: 'value',
    title: '', // Use 'title' instead of 'name' - Patch #4
    description: ''
  };
  const defaultStateValues: CreateStateInputTagged = {
    __type: 'state',
    name: '',
    scale: '1-5',
    description: '',
    active: true,
    priority: 50
  };

  // --- Separate useMutation hooks ---
  const createValueMutation = trpc.value.createValue.useMutation({
    onSuccess: (data) => handleSuccess(data),
    onError: (error) => handleError(error),
  });
  const createStateDefMutation = trpc.state.createDefinition.useMutation({
    onSuccess: (data) => handleSuccess(data),
    onError: (error) => handleError(error),
  });

  // --- Form setup ---
  const { control, handleSubmit, formState: { errors }, reset } = useForm<FormValues>({
    // Note: ZodResolver might need specific configuration if schemas differ vastly
    // or consider not using it if relying solely on backend validation for this dynamic form.
    // Use the new stricter default value constants
    defaultValues: isValue ? defaultValueValues : defaultStateValues,
  });

  // Reset form if the type changes dynamically
  React.useEffect(() => {
    // Use the new stricter default value constants for reset
    reset(isValue ? defaultValueValues : defaultStateValues);
  }, [isValue, reset]);

  // --- Shared success/error handlers ---
  const handleSuccess = (data: any) => {
      toast.show('Created successfully!', { native: true });
      haptics.success();
      if (isValue) {
        utils.value.getValues.invalidate();
      } else {
        utils.state.getDefinitions.invalidate();
      }
      if (router.canGoBack()) {
        router.dismiss(); // Apply patch #5 - Use dismiss for modals
      } else {
        router.replace('/(tabs)/compass');
      }
  }

  const handleError = (error: any) => {
       toast.show(`Error: ${error.message}`, { type: 'error', native: true });
       haptics.error();
  }

  // --- Corrected onSubmit ---
  const onSubmit = (formData: FormValues) => {
    // 3️⃣ Use discriminant (__type) for type safety, remove casts
    if (formData.__type === 'value') {
      createValueMutation.mutate(formData);
    } else { // formData.__type === 'state'
      createStateDefMutation.mutate(formData);
    }
  };

  // Handle invalid type parameter gracefully
  if (!type) {
    return (
        <YStack flex={1} justifyContent="center" alignItems="center" padding="$4">
            <Paragraph color="$error">Invalid type specified.</Paragraph> {/* Use $error */}
            <Button onPress={() => router.back()} marginTop="$4">Go Back</Button>
        </YStack>
    );
  }

  // Determine current mutation state for button
  const isPending = isValue ? createValueMutation.isPending : createStateDefMutation.isPending;

  return (
    <ScrollView contentContainerStyle={{ flexGrow: 1 }}>
      <Form onSubmit={handleSubmit(onSubmit)} flex={1} padding="$4" space="$4" backgroundColor="$background">
        <Stack.Screen options={{ title: isValue ? 'Add Principle' : 'Define State' }} />

        {/* Conditionally render form fields */}
        {isValue ? (
          <>
            {/* --- Fields for Principle/Value --- */}
            <YStack space="$2">
              <Label htmlFor="title">Title</Label> {/* Patch #4: name -> title */}
              <Controller
                name="title" /* Patch #4: name -> title */
                control={control}
                rules={{ required: 'Title is required' }} /* Patch #4 */
                render={({ field }) => ( /* Use inferred types from FormValues */
                  <Input
                    id="title"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value}
                    placeholder="Principle Title"
                  />
                )}
              />
              {/* Use $error token */}
              {errors.title && <Paragraph color="$error">{errors.title?.message}</Paragraph>}
            </YStack>

            <YStack space="$2">
              <Label htmlFor="description">Description (Optional)</Label>
              <Controller
                name="description"
                control={control}
                render={({ field }) => ( // Use inferred types
                  <TextArea
                    id="description"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value ?? ''}
                    placeholder="Describe the principle..."
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && <Paragraph color="$error">{errors.description?.message}</Paragraph>}
            </YStack>
          </>
        ) : (
          <>
            {/* --- Fields for State Definition --- */}
            <YStack space="$2">
              <Label htmlFor="name">State Name</Label>
              <Controller
                name="name"
                control={control}
                rules={{ required: 'Name is required' }}
                render={({ field }) => ( // Use inferred types // Explicit type
                  <Input
                    id="name"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value}
                    placeholder="e.g., Energy Level, Mood" />
                )}
              />
              {errors.name && <Paragraph color="$error">{errors.name?.message}</Paragraph>}
            </YStack>

             <YStack space="$2">
               <Label htmlFor="scale">Scale</Label>
               <Controller
                 name="scale"
                 control={control}
                 rules={{ required: 'Scale is required' }}
                 render={({ field }) => ( // Use inferred types
                   <>
                    <Paragraph>Scale Selector Placeholder (Selected: {field.value})</Paragraph>
                    <XStack space="$2">
                      {/* Removed invalid theme prop */}
                      <Button size="$2" onPress={() => field.onChange('1-5')} theme={field.value === '1-5' ? 'active' : undefined}>1-5</Button>
                      <Button size="$2" onPress={() => field.onChange('1-10')} theme={field.value === '1-10' ? 'active' : undefined}>1-10</Button>
                    </XStack>
                   </>
                 )}
               />
                {errors.scale && <Paragraph color="$error">{errors.scale?.message}</Paragraph>}
             </YStack>

             <YStack space="$2">
              <Label htmlFor="description">Description (Optional)</Label>
              <Controller
                name="description"
                control={control}
                render={({ field }) => ( // Use inferred types
                  <TextArea
                    id="description"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value ?? ''}
                    placeholder="Describe when/how to track this state..."
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && <Paragraph color="$error">{errors.description?.message}</Paragraph>}
            </YStack>

            <XStack space="$4" alignItems="center">
               <Label htmlFor="active" flex={1}>Active</Label>
               <Controller
                 name="active"
                 control={control}
                 render={({ field }: { field: ControllerRenderProps<FieldValues, 'active'> }) => ( // Explicit type
                    <Switch
                      id="active"
                      checked={!!field.value} // Use checked
                      onCheckedChange={field.onChange} // Use onCheckedChange
                      size="$3"
                    >
                        <Switch.Thumb animation="quick" />
                    </Switch>
                 )}
               />
            </XStack>
          </>
        )}

        {/* Removed invalid theme prop */}
        <Form.Trigger asChild disabled={isPending}>
          <Button icon={isPending ? <Spinner /> : undefined}>
            {isPending ? 'Saving...' : 'Save'}
          </Button>
        </Form.Trigger>
      </Form>
    </ScrollView>
  );
}```

### index.tsx
**Path:** app/index.tsx
**Size:** 420 bytes

```typescript
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/index.tsx
import { Redirect } from 'expo-router';

export default function RootIndex() {
  // Redirect directly to a specific tab without causing infinite redirects
  // Use the path that matches how it's accessed in the proper format
  // TypeScript suggests this is the correct format for Expo Router
  return <Redirect href="/(tabs)/home" />;
}
```

### useDashboardQuery.ts
**Path:** app/lib/useDashboardQuery.ts
**Size:** 477 bytes

```typescript
// app/lib/useDashboardQuery.ts
import { trpc, RouterOutputs } from '@/utils/trpc';

// Export the dashboard data type for reuse
export type DashboardData = RouterOutputs['dashboard']['getDashboardData'];

/**
 * Hook to fetch dashboard data with caching
 */
export const useDashboardQuery = () =>
  trpc.dashboard.getDashboardData.useQuery(undefined, { 
    staleTime: 60_000, // 1 minute stale time
    refetchOnMount: 'always', // Always refetch when component mounts
  });
```

### useToggleTaskStatus.ts
**Path:** app/lib/useToggleTaskStatus.ts
**Size:** 1800 bytes

```typescript
// app/lib/useToggleTaskStatus.ts
import { trpc } from '@/utils/trpc';
// Import Alert from React Native instead of using a toast library for simplicity
import { Alert } from 'react-native';

/**
 * Hook for toggling task completion status with optimistic updates
 */
export const useToggleTaskStatus = () => {
  const utils = trpc.useUtils();
  
  return trpc.task.toggleTask.useMutation({
    // Optimistically update UI before server responds
    onMutate: async ({ taskId, completed }) => {
      // Cancel any outgoing refetches
      await utils.dashboard.getDashboardData.cancel();
      
      // Snapshot current data for potential rollback
      const previous = utils.dashboard.getDashboardData.getData();
      
      // Optimistically update to the new value
      utils.dashboard.getDashboardData.setData(undefined, (oldData) => {
        if (!oldData) return oldData;
        return {
          ...oldData,
          tasks: oldData.tasks.map((task) => 
            task.id === taskId ? { ...task, status: completed ? 'completed' : 'in-progress' } : task
          ),
        };
      });
      
      return { previous };
    },
    
    // On successful mutation, show success message (silent in production)
    onSuccess: () => {
      if (__DEV__) {
        Alert.alert('Success', 'Task status updated');
      }
    },
    
    // If mutation fails, roll back optimistic update
    onError: (error, variables, context) => {
      if (context?.previous) {
        utils.dashboard.getDashboardData.setData(undefined, context.previous);
      }
      Alert.alert('Error', error.message || 'Failed to update task');
    },
    
    // Regardless of outcome, invalidate queries to refetch data
    onSettled: () => {
      utils.dashboard.getDashboardData.invalidate();
    },
  });
};
```

### add-habit.tsx
**Path:** app/planner/add-habit.tsx
**Size:** 561 bytes

```typescript
import React from 'react';
import { YStack, H1, Text, Button, ScrollView } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';

export default function AddHabitScreen() {
  return (
    <SafeAreaView style={{ flex: 1 }}>
      <ScrollView>
        <YStack flex={1} padding="$4" space="$4">
          <H1>Add New Habit</H1>
          <Text>Form to add a new habit will go here.</Text>
          <Button onPress={() => router.back()}>Go Back</Button>
        </YStack>
      </ScrollView>
    </SafeAreaView>
  );
}
```

### index.tsx
**Path:** app/planner/index.tsx
**Size:** 159 bytes

```typescript
// app/planner/index.tsx
import { YStack, H2 } from 'tamagui'
export default () => <YStack f={1} jc="center" ai="center"><H2>Planner coming soon</H2></YStack>
```

### index.tsx
**Path:** app/settings/index.tsx
**Size:** 161 bytes

```typescript
// app/settings/index.tsx
import { YStack, H2 } from 'tamagui'
export default () => <YStack f={1} jc="center" ai="center"><H2>Settings coming soon</H2></YStack>
```

### [id].tsx
**Path:** app/states/[id].tsx
**Size:** 877 bytes

```typescript
// app/states/[id].tsx
import React from 'react';
import { YStack, Text, H2, Paragraph, Button } from 'tamagui';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useLocalSearchParams, useRouter } from 'expo-router';

export default function StateDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const router = useRouter();

  // TODO: Fetch state definition details using trpc.state.getDefinitionById.useQuery({ id })

  return (
    <SafeAreaView style={{ flex: 1 }}>
      <YStack flex={1} padding="$4" space="$4">
        <H2>State Definition Detail</H2>
        <Paragraph>Details for State Definition with ID: {id}</Paragraph>
        {/* TODO: Display actual state definition details and add edit functionality */}
        <Button onPress={() => router.back()}>Go Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
```

### api-types.ts
**Path:** app/utils/api-types.ts
**Size:** 598 bytes

```typescript
/**
 * This file was auto-generated by the generate-trpc-types script.
 * Do not edit manually! Instead, run the script again.
 */

import type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from '../../server/src/router';

/**
 * Inference helper for inputs.
 *
 * @example type HelloInput = RouterInputs['example']['hello']
 */
export type RouterInputs = inferRouterInputs<AppRouter>;

/**
 * Inference helper for outputs.
 *
 * @example type HelloOutput = RouterOutputs['example']['hello']
 */
export type RouterOutputs = inferRouterOutputs<AppRouter>;
```

### [id].tsx
**Path:** app/values/[id].tsx
**Size:** 844 bytes

```typescript
// app/values/[id].tsx
import React from 'react';
import { YStack, Text, H2, Paragraph, Button } from 'tamagui';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useLocalSearchParams, useRouter } from 'expo-router';

export default function ValueDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const router = useRouter();

  // TODO: Fetch value details using trpc.value.getValueById.useQuery({ id })

  return (
    <SafeAreaView style={{ flex: 1 }}>
      <YStack flex={1} padding="$4" space="$4">
        <H2>Principle Detail</H2>
        <Paragraph>Details for Principle (Value) with ID: {id}</Paragraph>
        {/* TODO: Display actual value details and add edit functionality */}
        <Button onPress={() => router.back()}>Go Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
```


# (root files)

### babel.config.js
**Path:** babel.config.js
**Size:** 420 bytes

```javascript
module.exports = function(api) {
  api.cache(true);
  return {
    presets: [
      ["babel-preset-expo", { jsxImportSource: "nativewind" }],
      "nativewind/babel"
    ],
    plugins: [
      // Expo Router v4 is included via expo-preset, no need for expo-router/babel
      // (Expo preset also auto-includes Reanimated for SDK>=50)
      // Add any other plugins (e.g. module-resolver) if needed here
    ]
  };
};
```


# components

### EmptyOrSkeleton.tsx
**Path:** components/EmptyOrSkeleton.tsx
**Size:** 5237 bytes

```typescript
import React, { ReactNode } from 'react';
import { StyleSheet, StyleProp, ViewStyle, TextStyle, ImageStyle, ImageSourcePropType, View, Image } from 'react-native';
import Animated from 'react-native-reanimated';
import { Text, YStack, StackProps } from 'tamagui';
import { useSkeleton, SkeletonOptions } from '@/hooks/useSkeleton';

export interface EmptyStateProps {
  /** Title text for the empty state */
  title?: string;
  /** Subtitle/description text for the empty state */
  message?: string;
  /** Optional image/illustration to display */
  image?: ImageSourcePropType;
  /** Optional custom component to render instead of default empty state */
  customEmptyComponent?: ReactNode;
  /** Style for the container */
  containerStyle?: StyleProp<ViewStyle>;
  /** Style for the title */
  titleStyle?: StyleProp<TextStyle>;
  /** Style for the message */
  messageStyle?: StyleProp<TextStyle>;
  /** Style for the image container */
  imageContainerStyle?: StyleProp<ViewStyle>;
  /** Style for the image */
  imageStyle?: StyleProp<ImageStyle>;
}

export interface EmptyOrSkeletonProps extends EmptyStateProps, StackProps {
  /** Whether data is loading */
  isLoading: boolean;
  /** Children to display when not loading and not empty */
  children: ReactNode;
  /** Whether the content is empty (no data) */
  isEmpty?: boolean;
  /** Number of skeleton placeholders to display when loading */
  skeletonCount?: number;
  /** Height of each skeleton item */
  skeletonHeight?: number;
  /** Width of each skeleton item (default: 100%) */
  skeletonWidth?: number | string;
  /** Gap between skeleton items */
  skeletonGap?: number;
  /** Border radius for skeleton items */
  skeletonBorderRadius?: number;
  /** Custom skeleton component */
  customSkeletonComponent?: ReactNode;
  /** Options for the skeleton animation */
  skeletonOptions?: SkeletonOptions;
}

/**
 * Placeholder component for the skeleton loading state
 */
const SkeletonPlaceholder = ({
  height, 
  width = '100%',
  borderRadius = 8,
  options
}: {
  height: number;
  width?: number | string;
  borderRadius?: number;
  options?: SkeletonOptions;
}) => {
  const { shimmerStyle, styles } = useSkeleton(options);
  
  return (
    <Animated.View 
      style={[
        styles.container, 
        { 
          height,
          width: typeof width === 'string' ? width : width,
          borderRadius
        } as ViewStyle
      ]}
    >
      <Animated.View style={[styles.shimmer, shimmerStyle]} />
    </Animated.View>
  );
};

/**
 * Default empty state component
 */
const EmptyState = ({
  title = 'No data found',
  message = 'There is nothing to display at the moment.',
  image,
  containerStyle,
  titleStyle,
  messageStyle,
  imageContainerStyle,
  imageStyle
}: EmptyStateProps) => {
  return (
    <YStack
      alignItems="center"
      justifyContent="center"
      padding="$4"
      space="$3"
      style={containerStyle}
    >
      {image && (
        <View style={[styles.imageContainer, imageContainerStyle]}>
          <Image source={image} style={[styles.image, imageStyle]} />
        </View>
      )}
      <Text 
        fontSize="$6" 
        fontWeight="bold" 
        textAlign="center"
        style={titleStyle}
      >
        {title}
      </Text>
      <Text 
        fontSize="$4" 
        color="$gray10" 
        textAlign="center"
        style={messageStyle}
      >
        {message}
      </Text>
    </YStack>
  );
};

/**
 * A component that conditionally renders skeleton, empty state, or content
 * based on loading and data states.
 */
export default function EmptyOrSkeleton({
  isLoading,
  isEmpty = false,
  children,
  skeletonCount = 3,
  skeletonHeight = 80,
  skeletonWidth = '100%',
  skeletonGap = 12,
  skeletonBorderRadius = 8,
  customSkeletonComponent,
  customEmptyComponent,
  skeletonOptions,
  title,
  message,
  image,
  containerStyle,
  titleStyle,
  messageStyle,
  imageContainerStyle,
  imageStyle,
  ...stackProps
}: EmptyOrSkeletonProps) {
  // If loading, show skeleton
  if (isLoading) {
    if (customSkeletonComponent) {
      return <>{customSkeletonComponent}</>;
    }
    
    return (
      <YStack space={skeletonGap} width="100%" {...stackProps}>
        {Array.from({ length: skeletonCount }).map((_, index) => (
          <SkeletonPlaceholder
            key={`skeleton-${index}`}
            height={skeletonHeight}
            width={skeletonWidth}
            borderRadius={skeletonBorderRadius}
            options={skeletonOptions}
          />
        ))}
      </YStack>
    );
  }
  
  // If empty, show empty state
  if (isEmpty) {
    if (customEmptyComponent) {
      return <>{customEmptyComponent}</>;
    }
    
    return (
      <EmptyState
        title={title}
        message={message}
        image={image}
        containerStyle={containerStyle}
        titleStyle={titleStyle}
        messageStyle={messageStyle}
        imageContainerStyle={imageContainerStyle}
        imageStyle={imageStyle}
      />
    );
  }
  
  // Otherwise, show children
  return <>{children}</>;
}

const styles = StyleSheet.create({
  imageContainer: {
    marginBottom: 20,
  },
  image: {
    width: 150,
    height: 150,
    resizeMode: 'contain',
  },
}); ```

### ProgressRing.tsx
**Path:** components/aether/ProgressRing.tsx
**Size:** 1987 bytes

```typescript
import React from 'react';
import { Stack, useTheme, ColorTokens } from 'tamagui';
import Svg, { Circle } from 'react-native-svg';

interface ProgressRingProps {
  progress: number;  // 0 to 1 (or 0 to 100 as percentage)
  size?: number;     // Diameter of the circle
  strokeWidth?: number;
  primaryColor?: string;
  secondaryColor?: string;
  backgroundColor?: ColorTokens | 'transparent' | undefined;
}

/**
 * A circular progress indicator component
 */
export default function ProgressRing({
  progress: rawProgress,
  size = 60,
  strokeWidth = 6,
  primaryColor,
  secondaryColor,
  backgroundColor = 'transparent',
}: ProgressRingProps) {
  const theme = useTheme();
  
  // Normalize progress to 0-1 range
  const progress = rawProgress > 1 ? rawProgress / 100 : rawProgress;
  
  // Calculate radius and other dimensions
  const radius = (size - strokeWidth) / 2;
  const circumference = radius * 2 * Math.PI;
  const strokeDashoffset = circumference - progress * circumference;

  // Use theme colors if not explicitly provided
  const primary = primaryColor || theme.blue10.val;
  const secondary = secondaryColor || theme.gray4.val;

  return (
    <Stack width={size} height={size} backgroundColor={backgroundColor} alignItems="center" justifyContent="center">
      <Svg width={size} height={size}>
        {/* Background circle */}
        <Circle
          stroke={secondary}
          fill="none"
          cx={size / 2}
          cy={size / 2}
          r={radius}
          strokeWidth={strokeWidth}
        />
        
        {/* Progress circle */}
        <Circle
          stroke={primary}
          fill="none"
          cx={size / 2}
          cy={size / 2}
          r={radius}
          strokeWidth={strokeWidth}
          strokeDasharray={circumference}
          strokeDashoffset={strokeDashoffset}
          strokeLinecap="round"
          transform={`rotate(-90, ${size / 2}, ${size / 2})`} // Start from top
        />
      </Svg>
    </Stack>
  );
}
```

### FloatingInput.tsx
**Path:** components/auth/FloatingInput.tsx
**Size:** 5785 bytes

```typescript
import React, { useState, useRef, useEffect } from 'react';
import { StyleSheet, TextInput as RNTextInput, View, TextInputProps as RNTextInputProps } from 'react-native';
import { Text, InputProps, getTokens, useTheme } from 'tamagui';
import Animated, { useSharedValue, withTiming, useAnimatedStyle, Easing } from 'react-native-reanimated';
import { durations } from '@/constants/motion';

export interface FloatingInputProps extends RNTextInputProps {
  /** Label for the input */
  label: string;
  /** Error message to display */
  error?: string;
  /** Container style */
  containerStyle?: object;
  /** Label style */
  labelStyle?: object;
  /** Error style */
  errorStyle?: object;
  /** Tamagui tokens for theming */
  tokens?: ReturnType<typeof getTokens>;
  /** Called when focus changes */
  onFocusChange?: (focused: boolean) => void;
  /** Left icon to display */
  leftIcon?: React.ReactNode;
  /** Right icon to display */
  rightIcon?: React.ReactNode;
  /** Whether to adjust label position */
  adjustLabel?: boolean;
}

/**
 * Input component with animated floating label
 */
export default function FloatingInput({
  label,
  value,
  error,
  containerStyle,
  labelStyle,
  errorStyle,
  onFocusChange,
  leftIcon,
  rightIcon,
  adjustLabel = true,
  style,
  ...props
}: FloatingInputProps) {
  const [isFocused, setIsFocused] = useState(false);
  const inputRef = useRef<RNTextInput | null>(null);
  const animatedLabelValue = useSharedValue(value ? 1 : 0);
  const theme = useTheme();
  
  // Handle label animation when focus or value changes
  useEffect(() => {
    animatedLabelValue.value = withTiming(
      (isFocused || !!value) ? 1 : 0,
      {
        duration: 200, // Match durations.standard
        easing: Easing.bezier(0.4, 0.0, 0.2, 1.0),
      }
    );
  }, [isFocused, value, animatedLabelValue]);
  
  // Get dynamic colors from theme
  const colors = {
    input: {
      background: theme.inputBackground?.get() || theme.backgroundHover?.get() || '#F3F4F6',
      text: theme.color?.get() || '#111827',
      border: theme.borderColor?.get() || '#E5E7EB',
      focusBorder: theme.borderColorFocus?.get() || '#93C5FD',
      placeholderText: theme.colorTransparent?.get() || '#6B7280',
    },
    error: theme.red10?.get() || '#EF4444',
  };
  
  // Determine text color based on disabled state
  const textColor = props.editable === false 
    ? theme.colorTransparent?.get() || '#9CA3AF'
    : colors.input.text;
  
  // Handle focus changes
  const handleFocus = (event: any) => {
    setIsFocused(true);
    if (onFocusChange) onFocusChange(true);
    if (props.onFocus) props.onFocus(event);
  };
  
  const handleBlur = (event: any) => {
    setIsFocused(false);
    if (onFocusChange) onFocusChange(false);
    if (props.onBlur) props.onBlur(event);
  };
  
  // Animated styles
  const animatedLabelStyle = useAnimatedStyle(() => {
    return {
      position: 'absolute',
      left: leftIcon ? 40 : 16,
      top: adjustLabel ? 
        (16 + (-24 * animatedLabelValue.value)) : 
        (12 + (-20 * animatedLabelValue.value)),
      fontSize: 16 - (4 * animatedLabelValue.value),
      color: error ? colors.error : 
        animatedLabelValue.value > 0 ? 
          (isFocused ? colors.input.focusBorder : colors.input.placeholderText) : 
          colors.input.placeholderText,
      backgroundColor: animatedLabelValue.value > 0 ? 
        (theme.background?.get() || '#FFFFFF') : 'transparent',
      paddingHorizontal: 4 * animatedLabelValue.value,
      zIndex: 10,
    };
  });
  
  // Focus the input when the component is tapped
  const handleContainerPress = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };
  
  // Prepare input styles - flatten the array and provide default
  const inputStyles = StyleSheet.flatten([
    styles.input, 
    { color: textColor },
    leftIcon && { paddingLeft: 40 },
    rightIcon && { paddingRight: 40 },
    style // Style prop from component props
  ]) || {}; // Provide default empty style object
  
  return (
    <View style={[styles.container, containerStyle]}>
      <View 
        style={[
          styles.inputContainer, 
          { backgroundColor: colors.input.background },
          { borderColor: isFocused ? colors.input.focusBorder : colors.input.border },
          error && { borderColor: colors.error },
        ]} 
        onTouchStart={handleContainerPress}
      >
        {leftIcon && <View style={styles.leftIcon}>{leftIcon}</View>}
        
        <RNTextInput
          ref={inputRef}
          style={inputStyles}
          value={value}
          onFocus={handleFocus}
          onBlur={handleBlur}
          placeholderTextColor={colors.input.placeholderText}
          {...props}
        />
        
        {rightIcon && <View style={styles.rightIcon}>{rightIcon}</View>}
        
        <Animated.Text style={[animatedLabelStyle, labelStyle]}>
          {label}
        </Animated.Text>
      </View>
      
      {error && (
        <Text
          style={[styles.errorText, { color: colors.error }, errorStyle]}
          fontSize="$3"
          marginTop="$1"
        >
          {error}
        </Text>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    marginBottom: 16,
    width: '100%',
  },
  inputContainer: {
    borderWidth: 1,
    borderRadius: 8,
    height: 56,
    position: 'relative',
    justifyContent: 'center',
  },
  input: {
    height: 56,
    paddingHorizontal: 16,
    fontSize: 16,
    flex: 1,
  },
  label: {
    zIndex: 10,
  },
  errorText: {
    marginLeft: 4,
  },
  leftIcon: {
    position: 'absolute',
    left: 12,
    top: 16,
    zIndex: 2,
  },
  rightIcon: {
    position: 'absolute',
    right: 12,
    top: 16,
    zIndex: 2,
  },
}); ```

### PrincipleCard.tsx
**Path:** components/compass/PrincipleCard.tsx
**Size:** 1116 bytes

```typescript
// components/compass/PrincipleCard.tsx
import React from 'react';
import { Card, Text, YStack } from 'tamagui';
import { type RouterOutputs } from '@/utils/trpc';

// Use the correct type based on the query in PrinciplesTab
type Principle = RouterOutputs['value']['getValues'][number];

interface PrincipleCardProps {
  principle: Principle;
  onPress?: () => void; // Make onPress optional if not always needed
}

export function PrincipleCard({ principle, onPress }: PrincipleCardProps) {
  return (
    <Card
      bordered
      padding="$4"
      elevation="$1"
      pressTheme
      hoverTheme
      onPress={onPress}
      animation="bouncy"
      scale={onPress ? 0.98 : 1} // Only apply scale if pressable
      hoverStyle={onPress ? { scale: 0.99 } : {}}
      pressStyle={onPress ? { scale: 0.96 } : {}}
    >
      <YStack>
        <Text fontSize="$5" fontWeight="bold">
          {principle.name}
        </Text>
        {principle.description && (
          <Text color="$colorFocus" marginTop="$2">
            {principle.description}
          </Text>
        )}
      </YStack>
    </Card>
  );
}
```

### PrinciplesTab.tsx
**Path:** components/compass/PrinciplesTab.tsx
**Size:** 1214 bytes

```typescript
import React from 'react';
import { YStack } from 'tamagui';
import { router, type Href } from 'expo-router';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { trpc, type RouterOutputs } from '@/utils/trpc';
import { PrincipleCard } from './PrincipleCard';

type Principle = RouterOutputs['value']['getValues'][number];

export default function PrinciplesTab() {
  const { data, isLoading, error, refetch } =
    trpc.value.getValues.useQuery();

  if (isLoading) return <EmptyOrSkeleton isLoading count={3} type="card" />;

  if (error)
    return (
      <EmptyOrSkeleton
        isError
        onRetry={refetch}
        text={error.message ?? 'Failed to load principles'}
      />
    );

  if (!Array.isArray(data) || !data.length)
    return (
      <EmptyOrSkeleton
        isEmpty
        text="No principles yet"
        actionText="Add Principle"
        onAction={() => router.push('/compose?type=value' as Href)}
      />
    );

  return (
    <YStack space="$3">
      {data.map((p: Principle) => (
        <PrincipleCard
          key={p.id}
          principle={p}
          onPress={() => router.push(`/values/${p.id}` as Href)}
        />
      ))}
    </YStack>
  );
}
```

### StateDefinitionCard.tsx
**Path:** components/compass/StateDefinitionCard.tsx
**Size:** 1375 bytes

```typescript
// components/compass/StateDefinitionCard.tsx
import React from 'react';
import { Card, Text, XStack, YStack } from 'tamagui';
import { type RouterOutputs } from '@/utils/trpc';

// Use the correct type based on the query in StatesTab (getDefinitions)
type StateDefinition = RouterOutputs['state']['getDefinitions'][number];

interface StateDefinitionCardProps {
  state: StateDefinition;
  onPress?: () => void; // Make onPress optional
}

export function StateDefinitionCard({ state, onPress }: StateDefinitionCardProps) {
  return (
    <Card
      bordered
      padding="$4"
      elevation="$1"
      pressTheme
      hoverTheme
      onPress={onPress}
      animation="bouncy"
      scale={onPress ? 0.98 : 1} // Only apply scale if pressable
      hoverStyle={onPress ? { scale: 0.99 } : {}}
      pressStyle={onPress ? { scale: 0.96 } : {}}
    >
      <YStack>
        <XStack alignItems="center" space="$3">
          <Text fontSize="$5" fontWeight="bold">
            {state.name}
          </Text>
          {/* Display scale type if available */}
          {state.scale && (
            <Text color="$colorFocus" fontSize="$2">({state.scale})</Text>
          )}
        </XStack>
        {state.description && (
          <Text color="$colorFocus" marginTop="$2">
            {state.description}
          </Text>
        )}
      </YStack>
    </Card>
  );
}
```

### DailyProgressBanner.tsx
**Path:** components/dashboard/DailyProgressBanner.tsx
**Size:** 2377 bytes

```typescript
import React from 'react';
import { XStack, YStack, Text, Progress, useTheme } from 'tamagui';
import { BlurView } from 'expo-blur';
import { CheckSquare, Target } from '@tamagui/lucide-icons'; // Example icons

type DailyProgressBannerProps = {
  tasksCompleted: number;
  totalTasks: number; // Needed for progress calculation
  habitsChecked: number;
  totalHabits: number; // Needed for progress calculation
};

export default function DailyProgressBanner({ 
  tasksCompleted = 3, // Placeholder
  totalTasks = 5, // Placeholder
  habitsChecked = 2, // Placeholder
  totalHabits = 4 // Placeholder
}: DailyProgressBannerProps) {
  const theme = useTheme();
  const taskProgress = totalTasks > 0 ? (tasksCompleted / totalTasks) * 100 : 0;
  const habitProgress = totalHabits > 0 ? (habitsChecked / totalHabits) * 100 : 0;

  return (
    <BlurView intensity={50} tint="default" style={{ borderRadius: 12, overflow: 'hidden', marginBottom: 16 }}>
      <XStack 
        padding="$3"
        space="$4"
        alignItems="center" 
        backgroundColor="$surfaceSubtle" // Use subtle background from theme
      >
        {/* Tasks Progress */}
        <YStack flex={1} space="$1">
          <XStack space="$2" alignItems="center">
            <CheckSquare size={16} color={theme.accent?.get()} />
            <Text fontSize="$3" fontWeight="bold" color="$onSurface">
              Tasks
            </Text>
          </XStack>
          <Progress size="$1" value={taskProgress}>
            <Progress.Indicator animation="bouncy" backgroundColor="$accent" />
          </Progress>
          <Text fontSize="$1" color="$onSurfaceSubtle">
            {tasksCompleted} / {totalTasks} done
          </Text>
        </YStack>

        {/* Habits Progress */}
        <YStack flex={1} space="$1">
          <XStack space="$2" alignItems="center">
            <Target size={16} color={theme.accent?.get()} />
            <Text fontSize="$3" fontWeight="bold" color="$onSurface">
              Habits
            </Text>
          </XStack>
          <Progress size="$1" value={habitProgress}>
            <Progress.Indicator animation="bouncy" backgroundColor="$accent" />
          </Progress>
          <Text fontSize="$1" color="$onSurfaceSubtle">
            {habitsChecked} / {totalHabits} checked
          </Text>
        </YStack>
      </XStack>
    </BlurView>
  );
}
```

### DashboardSection.tsx
**Path:** components/dashboard/DashboardSection.tsx
**Size:** 2413 bytes

```typescript
import React, { ReactNode } from 'react';
import { Text, YStack, XStack, Button, Anchor, H4 } from 'tamagui';
import { router } from 'expo-router';
import { SkeletonRow } from '@/components/ui/Skeleton';
import { SectionError } from '@/components/ui/ErrorBanner';
import { BlurView } from 'expo-blur'; // Import BlurView

interface DashboardSectionProps<T> {
  title: string;
  data?: T[];
  isLoading?: boolean;
  emptyMessage?: string;
  seeAllRoute?: string;
  renderItem?: (item: T) => ReactNode;
  skeletonCount?: number;
  error?: string;
  onRetry?(): void;
  children?: ReactNode;
  onSeeAll?(): void;
}

export default function DashboardSection<T>({ 
  title, 
  data, 
  isLoading, 
  emptyMessage,
  seeAllRoute,
  renderItem,
  skeletonCount = 2,
  error,
  onRetry,
  children,
  onSeeAll
}: DashboardSectionProps<T>) {
  return (
    <YStack space="$2">
      <XStack justifyContent="space-between" alignItems="center" marginBottom="$2" paddingHorizontal="$2">
        <H4>{title}</H4>
        {((data && data.length > 0 && seeAllRoute) || onSeeAll) && (
          <Button 
            chromeless 
            size="$2" 
            onPress={() => {
              if (onSeeAll) {
                onSeeAll();
              } else if (seeAllRoute) {
                // Navigate to route using type assertions
                // Safe because the route will be a tab/screen name within the app
                router.push(seeAllRoute as any);
              }
            }}
          >
            See All
          </Button>
        )}
      </XStack>
      
      {/* Wrap content in BlurView */}
      <BlurView 
        intensity={50} 
        tint="default" 
        style={{ borderRadius: 12, overflow: 'hidden' }} 
      >
        <YStack padding="$3">
          {/* If children are provided, render them */}
          {children ? (
            children
          ) : isLoading ? (
            <SkeletonRow lines={skeletonCount} />
          ) : error ? (
            <SectionError message={error ? String(error) : 'An error occurred'} onRetry={onRetry} />
          ) : data && data.length === 0 ? (
            <YStack alignItems="center" padding="$4">
              <Text color="$gray10">{emptyMessage ?? 'No items found'}</Text>
            </YStack>
          ) : (
            data && renderItem && data.map(renderItem)
          )}
        </YStack>
      </BlurView>
    </YStack>
  );
} ```

### GoalSummaryCard.tsx
**Path:** components/dashboard/GoalSummaryCard.tsx
**Size:** 1565 bytes

```typescript
import React from 'react';
import { Text, XStack, Button } from 'tamagui';
import ProgressRing from '@/components/aether/ProgressRing';
import { RouterOutputs } from '@/utils/trpc';
import { BlurView } from 'expo-blur'; // Import BlurView

// Define a custom type that includes everything we need
type DashboardGoal = {
  id: string;
  title: string;
  status?: string;
  priority?: number;
  progress: number;
  tasks?: {
    total: number;
    completed: number;
  };
};

interface GoalSummaryCardProps {
  goal: DashboardGoal;
  onPress: () => void;
}

export default function GoalSummaryCard({ goal, onPress }: GoalSummaryCardProps) {
  return (
    <BlurView 
      intensity={50} 
      tint="default" 
      style={{ borderRadius: 12, overflow: 'hidden' }}
    >
      <Button 
        chromeless // Remove default button styling
        padding="$3" 
        onPress={onPress}
        width="100%" // Ensure it fills the BlurView
      >
        <XStack alignItems="center" space="$3" flex={1}> 
          <ProgressRing
            progress={goal.progress}
            size={40}
            primaryColor="$primary"
          />
          <XStack flex={1} flexDirection="column">
            <Text fontSize="$4" fontWeight="500" color="$color">
              {goal.title}
            </Text>
            {goal.tasks && (
              <Text color="$gray9" fontSize="$2">
                {goal.tasks.completed}/{goal.tasks.total} tasks completed
              </Text>
            )}
          </XStack>
        </XStack>
      </Button>
    </BlurView>
  );
}```

### HabitCheckItem.tsx
**Path:** components/dashboard/HabitCheckItem.tsx
**Size:** 4552 bytes

```typescript
import React, { useState, useEffect } from 'react';
import { Text, XStack, Button, YStack, useTheme } from 'tamagui';
import * as Haptics from 'expo-haptics';
import { trpc, RouterOutputs } from '@/utils/trpc';

// Custom types that match the backend expectations
type DashboardHabit = {
  id: string;
  name: string;  // Backend returns 'name'
  description?: string;
  habit_type?: string;
  streak?: number;
  completed: boolean; // Backend returns 'completed'
  duration_minutes?: number;
  last_entry_id?: string; // Add last_entry_id property
};

// Types for habit entry mutations
type CreateHabitEntryInput = {
  habit_id: string;
  date: string;
  completed?: boolean;
  quantity_value?: number | null;
  notes?: string | null;
};

type DeleteHabitEntryInput = {
  id: string; // Update property name
};

interface HabitCheckItemProps {
  habit: DashboardHabit;
  onToggle?: (habitId: string, completedToday: boolean) => void; 
}

export default function HabitCheckItem({ habit, onToggle }: HabitCheckItemProps) {
  const [checked, setChecked] = useState(habit.completed);
  const [isUpdating, setIsUpdating] = useState(false);
  const theme = useTheme(); 
  const utils = trpc.useUtils(); 

  // Define specific theme colors with safe access and fallbacks to theme variables
  const green10 = theme?.green10?.val ?? '$green10'; 
  const gray10 = theme?.gray10?.val ?? '$gray10'; 
  const orange10 = theme?.orange10?.val ?? '$orange10'; 


  const createEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: (updatedHabit) => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error creating habit entry:', error);
    }
  });

  const deleteEntryMutation = trpc.habit.deleteHabitEntry.useMutation({
    onSuccess: () => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error deleting habit entry:', error);
    }
  });

  useEffect(() => {
    setChecked(habit.completed);
  }, [habit.completed]);

  const handleToggle = () => {
    const newValue = !checked;
    setChecked(newValue); 
    setIsUpdating(true);

    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);

    const todayDateString = new Date().toISOString().split('T')[0];

    if (newValue) {
      const createInput: CreateHabitEntryInput = {
        habit_id: habit.id,
        date: todayDateString,
        completed: true, 
        quantity_value: null, 
        notes: null, 
      };
      createEntryMutation.mutate(createInput);
    } else {
      if (habit.last_entry_id) { 
        const deleteInput: DeleteHabitEntryInput = {
          id: habit.last_entry_id, 
        };
        deleteEntryMutation.mutate(deleteInput);
      } else {
        console.warn("Attempted to delete habit entry, but last_entry_id is missing.");
      }
    }

    if (onToggle) {
      onToggle(habit.id, newValue);
    }
  };

  const streakColor = checked ? green10 : gray10; // Use safe theme value
  const habitTypeColor = orange10; // Use safe theme value

  return (
    <XStack 
      backgroundColor="$backgroundStrong" // Use theme variable
      padding="$3"
      borderRadius="$4"
      alignItems="center"
      justifyContent="space-between"
      space="$3"
    >
      <YStack flex={1} gap="$1">
        <Text fontSize="$4" fontWeight="500" color="$color"> // Use theme variable
          {habit.name}
        </Text>
        
        {habit.streak != null && habit.streak > 0 && ( // Add null check
          <Text fontSize="$2" color={streakColor}> 
            Streak: {habit.streak ?? 0}
          </Text>
        )}
        {habit.habit_type && (
          <Text fontSize="$2" color={habitTypeColor}> // Use safe theme value
            ({habit.habit_type})
          </Text>
        )}
      </YStack>
      
      <Button
        size="$3"
        variant={checked ? undefined : 'outlined'} // Let variant handle appearance
        // Remove explicit colors - rely on theme/variant
        theme={checked ? 'green' : undefined} // Apply green theme when checked
        onPress={handleToggle}
        disabled={isUpdating} 
        iconAfter={checked ? <Text>✓</Text> : undefined}
      >
        {checked ? "Done" : "Check-in"}
      </Button>
    </XStack>
  );
}```

### StateIndicator.tsx
**Path:** components/dashboard/StateIndicator.tsx
**Size:** 1784 bytes

```typescript
import React from 'react';
// Use Tamagui components
import { Text, XStack, YStack, Card } from 'tamagui'; 
// Import RouterOutputs for inferred types
import { RouterOutputs } from '@/utils/trpc';

// Define prop type using inferred type from router
type DashboardTrackedState = RouterOutputs['dashboard']['getDashboardData']['trackedStates'][number];

interface StateIndicatorProps {
  state: DashboardTrackedState; // Use the inferred type
  onPress: () => void;
  lastEntry: any;
}

export default function StateIndicator({ state, onPress, lastEntry }: StateIndicatorProps) {
  // Format the last updated time
  const formattedTime = state.lastUpdated 
    ? new Date(state.lastUpdated).toLocaleTimeString([], { 
        hour: '2-digit', 
        minute: '2-digit' 
      })
    : 'N/A';
  
  // Use Tamagui Card component
  return (
    <Card 
      onPress={onPress} 
      pressStyle={{ opacity: 0.8 }}
      padding="$3"
      // No explicit background, will use default Card background from theme
    >
      <YStack space="$1"> {/* Main container for text */}
        <XStack flex={1} alignItems="center">
          <Text fontSize="$4" fontWeight="500">{state.name}</Text>
          {lastEntry && (
            <Text fontSize="$2" color="$gray10" marginLeft="$2">
              ({formattedTime})
            </Text>
          )}
        </XStack>
        <XStack alignItems="baseline" space="$2"> {/* Align text by baseline, add space */}
          <Text fontSize="$5" fontWeight="600" color="$color"> {/* Use tokens */}
            {state.currentValue}
          </Text>
        </XStack>
        {!lastEntry && (
          <Text fontSize="$2" color="$gray10" marginTop="$1">
            No data recorded yet.
          </Text>
        )}
      </YStack>
    </Card>
  );
} ```

### TaskItem.tsx
**Path:** components/dashboard/TaskItem.tsx
**Size:** 6051 bytes

```typescript
import React from 'react';
// Use Tamagui components
import { Text, XStack, YStack, Checkbox, Spinner } from 'tamagui'; 
import { trpc, RouterOutputs, RouterInputs } from '@/utils/trpc';
import { Check } from '@tamagui/lucide-icons';

// Custom Task type that matches the actual format returned from the backend
type Task = {
  id: string;
  name: string;  // Backend returns 'name' not 'title'
  status: string;
  priority?: number;
  due_date?: string; // Backend returns 'due_date' not 'due'
  notes?: string;
  goal_id?: string;
  // Include other fields as needed
};

interface TaskItemProps {
  task: Task;
  onPress: () => void;
}

export default function TaskItem({ task, onPress }: TaskItemProps) {
  
  // Setup toggleTask mutation with optimistic updates
  const utils = trpc.useContext();
  // Setup mutation for task toggling
  const toggleTaskMutation = trpc.task.toggleTask.useMutation({
    // Optimistically update the UI
    onMutate: async ({ taskId, completed }: { taskId: string; completed?: boolean }) => {
      // Default to toggling the current state if completed is not provided
      const newCompleted = completed !== undefined ? completed : !isCompleted;
      // Cancel outgoing fetches that might overwrite our optimistic update
      await utils.task.getTasks.cancel();
      await utils.dashboard.getDashboardData.cancel();
      
      // Get previous data for potential rollback
      const prevTasksData = utils.task.getTasks.getData();
      const prevDashboardData = utils.dashboard.getDashboardData.getData();
      
      // Optimistically update tasks data if present
      if (prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return old.map((t: any) => {
            if (t.id === taskId) {
              return {
                ...t,
                status: completed ? 'completed' : 'in-progress'
              };
            }
            return t;
          });
        });
      }
      
      // Optimistically update dashboard data if present
      if (prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return {
            ...old,
            tasks: old.tasks.map((t: any) => {
              if (t.id === taskId) {
                return {
                  ...t,
                  status: newCompleted ? 'completed' : 'in-progress'
                };
              }
              return t;
            }),
          };
        });
      }
      
      // Return previous data for rollback
      return { prevTasksData, prevDashboardData };
    },
    
    // If something goes wrong, rollback optimistic updates
    onError: (err: any, variables: any, context: any) => {
      if (context?.prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, context.prevTasksData);
      }
      if (context?.prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, context.prevDashboardData);
      }
      console.error('Error toggling task:', err);
    },
    
    // Always refetch after error or success
    onSettled: () => {
      utils.task.getTasks.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    }
  });

  // Handle checkbox toggle
  const handleToggle = () => {
    toggleTaskMutation.mutate({
      taskId: task.id, // Using taskId as expected by the backend
      completed: !isCompleted
    });
  };

  // Map priority to color
  const priorityColor = task.priority === 1 ? '$brandRed' : 
                        task.priority === 2 ? '$brandYellow' : 
                        '$brandGreen';
  
  // Format due date
  const formattedDate = task.due_date 
    ? new Date(task.due_date).toLocaleDateString(undefined, { 
        month: 'short', 
        day: 'numeric' 
      })
    : null;
    
  // Determine task completion status
  const isCompleted = task.status === 'completed';
  // No need for text style object since we use Tamagui props directly

  
  // Use YStack as the base component
  return (
    <YStack 
      backgroundColor="$backgroundStrong"
      padding="$3"
      borderRadius="$4"
      space="$1" // Add space between XStack and Date Text
    >
      <XStack alignItems="center" space="$2"> {/* Use XStack for horizontal layout */}
        {/* Checkbox for task completion */}
        <Checkbox
          size="$4"
          checked={isCompleted}
          onCheckedChange={handleToggle}
          disabled={toggleTaskMutation.isPending}
        >
          {toggleTaskMutation.isPending ? (
            <Spinner size="small" color="$brandPrimary" />
          ) : (
            <Checkbox.Indicator>
              <Check size={16} />
            </Checkbox.Indicator>
          )}
        </Checkbox>

        {/* Container for task details (clickable) */}
        <XStack flex={1} tag="pressable" onPress={onPress} pressStyle={{ opacity: 0.7 }}>
          {/* Priority Dot using YStack */}
          <YStack 
            width="$2" // Use size token for width
            height="$2" // Use size token for height
            borderRadius="$10" // Use a large radius token
            backgroundColor={priorityColor} 
            marginRight="$2" // Use space token for margin
          />
          <Text 
            fontSize="$4" // Use font size token
            fontWeight={task.priority === 1 ? '600' : '400'} // Keep fontWeight
            color="$color"
            flex={1} // Allow text to take remaining space
            opacity={isCompleted ? 0.7 : 1}
            textDecorationLine={isCompleted ? 'line-through' : undefined} // Proper Tamagui text decoration
          >
            {task.name}
          </Text>
        </XStack>
      </XStack>
      
      {formattedDate && (
        // Removed explicit margin, rely on outer YStack space
        <Text color="$gray9" fontSize="$2">
          Due: {formattedDate}
        </Text>
      )}
    </YStack>
  );
} ```

### GoalList.tsx
**Path:** components/lists/GoalList.tsx
**Size:** 4741 bytes

```typescript
import React from 'react';
import { FlatList, RefreshControl, ListRenderItem } from 'react-native';
import { YStack, Spinner, XStack, Text } from 'tamagui';
import { router } from 'expo-router';
import { RouterOutputs } from '@/utils/api-types';
import { AetherCard } from '@/components/ui/primitives';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { Ionicons } from '@expo/vector-icons';

type Goal = RouterOutputs['goal']['list'][number];

interface GoalListProps {
  goals?: Goal[];
  isLoading: boolean;
  isError?: boolean;
  refetch: () => void;
  onSelectGoal?: (goal: Goal) => void;
}

/**
 * GoalCard - Individual goal card component
 */
export function GoalCard({ goal, onPress }: { goal: Goal; onPress: () => void }) {
  // Calculate progress percentage for the progress ring
  const progressPercent = goal.progress ? goal.progress : 0;
  
  // Format the target date
  const formattedDate = goal.target_date
    ? new Date(goal.target_date).toLocaleDateString(undefined, {
        month: 'short',
        day: 'numeric',
      })
    : 'No due date';

  return (
    <AetherCard 
      isInteractive 
      variant="default"
      onPress={onPress}
    >
      <YStack space="$2">
        {/* Title */}
        <YStack>
          <XStack space="$2" alignItems="center">
            <Ionicons name="trophy-outline" size={18} color="$primary" />
            <Text fontSize="$5" fontWeight="bold" color="$color">
              {goal.title}
            </Text>
          </XStack>
        </YStack>
        
        {/* Description if available */}
        {goal.description && (
          <Text color="$colorMuted" fontSize="$3" numberOfLines={2}>
            {goal.description}
          </Text>
        )}
        
        {/* Footer with date and progress */}
        <XStack justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center">
            <Ionicons name="calendar-outline" size={16} color="$colorMuted" />
            <Text fontSize="$2" color="$colorMuted">
              {formattedDate}
            </Text>
          </XStack>
          
          {/* Progress display */}
          <XStack backgroundColor="$background" paddingHorizontal="$2" paddingVertical="$1" borderRadius="$2">
            <Text fontSize="$2" fontWeight="bold" color={progressPercent >= 75 ? '$success' : '$primary'}>
              {progressPercent}%
            </Text>
          </XStack>
        </XStack>
      </YStack>
    </AetherCard>
  );
}

/**
 * GoalList - List component for displaying goals
 */
export function GoalList({ goals, isLoading, isError, refetch, onSelectGoal }: GoalListProps) {
  const renderGoalItem: ListRenderItem<Goal> = ({ item }) => (
    <GoalCard 
      goal={item} 
      onPress={() => {
        if (onSelectGoal) {
          onSelectGoal(item);
        } else {
          // Default navigation
          router.push({ 
            pathname: '/planner/goal/[id]', 
            params: { id: item.id } 
          });
        }
      }} 
    />
  );

  if (isLoading) {
    return <EmptyOrSkeleton isLoading count={3} type="card" />;
  }

  if (isError) {
    return (
      <YStack padding="$4" space="$4" alignItems="center" justifyContent="center">
        <Ionicons name="alert-circle-outline" size={48} color="$error" />
        <YStack>
          <YStack alignItems="center">
            <Text fontSize="$5" fontWeight="bold" color="$color" textAlign="center">
              Unable to load goals
            </Text>
            <Text fontSize="$3" color="$colorMuted" textAlign="center" marginTop="$2">
              Please check your connection and try again
            </Text>
          </YStack>
        </YStack>
        <AetherCard onPress={refetch} isInteractive padding="$3" paddingHorizontal="$5">
          <XStack alignItems="center" space="$2">
            <Ionicons name="refresh-outline" size={18} color="$primary" />
            <Text fontSize="$4" fontWeight="500" color="$primary">
              Retry
            </Text>
          </XStack>
        </AetherCard>
      </YStack>
    );
  }

  if (!goals || goals.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty 
        text="No goals yet" 
        actionText="Create a goal" 
        onAction={() => router.push('/planner/add-goal')} 
      />
    );
  }

  return (
    <FlatList
      data={goals}
      keyExtractor={(item) => item.id}
      renderItem={renderGoalItem}
      contentContainerStyle={{ padding: 16, paddingBottom: 32 }}
      ItemSeparatorComponent={() => <YStack height="$4" />}
      refreshControl={
        <RefreshControl 
          refreshing={isLoading} 
          onRefresh={refetch} 
        />
      }
    />
  );
}
```

### HabitList.tsx
**Path:** components/lists/HabitList.tsx
**Size:** 5510 bytes

```typescript
import React from 'react';
import { FlatList, RefreshControl, ListRenderItem } from 'react-native';
import { YStack, XStack, Text, Stack } from 'tamagui';
import { router } from 'expo-router';
import { RouterOutputs } from '@/utils/api-types';
import { AetherCard } from '@/components/ui/primitives';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { Ionicons } from '@expo/vector-icons';

type Habit = RouterOutputs['habit']['list'][number];

interface HabitListProps {
  habits?: Habit[];
  isLoading: boolean;
  isError?: boolean;
  refetch: () => void;
  onSelectHabit?: (habit: Habit) => void;
  onToggleHabit?: (habitId: string, completed: boolean) => void;
}

/**
 * HabitCard - Individual habit card component
 */
export function HabitCard({ 
  habit, 
  onPress, 
  onToggle 
}: { 
  habit: Habit; 
  onPress: () => void; 
  onToggle?: (completed: boolean) => void;
}) {
  // Calculate progress streak display
  const streakText = habit.streak === 1 
    ? '1 day'
    : `${habit.streak} days`;

  const bestStreakText = habit.best_streak === 1
    ? '1 day'
    : `${habit.best_streak} days`;

  // Check if the habit has been completed today
  const [isCompleted, setIsCompleted] = React.useState(false); // This would come from habit entries

  const handleToggle = () => {
    const newStatus = !isCompleted;
    setIsCompleted(newStatus);
    if (onToggle) {
      onToggle(newStatus);
    }
  };

  return (
    <AetherCard 
      isInteractive 
      variant="default"
      onPress={onPress}
    >
      <YStack space="$2">
        {/* Title with completion toggle */}
        <XStack space="$3" justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center" flex={1}>
            <Ionicons name="repeat-outline" size={18} color="$primary" />
            <Text fontSize="$5" fontWeight="bold" color="$color" numberOfLines={1} flex={1}>
              {habit.title}
            </Text>
          </XStack>
          
          {/* Toggle button for completing today's habit */}
          <Stack 
            onPress={handleToggle}
            pressStyle={{ opacity: 0.8 }}
          >
            <Ionicons 
              name={isCompleted ? "checkmark-circle" : "checkmark-circle-outline"} 
              size={26} 
              color={isCompleted ? "$success" : "$colorMuted"} 
            />
          </Stack>
        </XStack>
        
        {/* Streak information */}
        <XStack justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center">
            <Ionicons name="flame-outline" size={16} color="$colorMuted" />
            <Text fontSize="$2" color="$colorMuted">
              Current: {streakText}
            </Text>
          </XStack>
          
          <XStack space="$2" alignItems="center">
            <Ionicons name="trophy-outline" size={16} color="$colorMuted" />
            <Text fontSize="$2" color="$colorMuted">
              Best: {bestStreakText}
            </Text>
          </XStack>
        </XStack>
      </YStack>
    </AetherCard>
  );
}

/**
 * HabitList - List component for displaying habits
 */
export function HabitList({ 
  habits, 
  isLoading, 
  isError, 
  refetch, 
  onSelectHabit,
  onToggleHabit 
}: HabitListProps) {
  const renderHabitItem: ListRenderItem<Habit> = ({ item }) => (
    <HabitCard 
      habit={item} 
      onPress={() => {
        if (onSelectHabit) {
          onSelectHabit(item);
        } else {
          // Default navigation
          router.push({ 
            pathname: '/planner/habit/[id]', 
            params: { id: item.id } 
          });
        }
      }}
      onToggle={(completed) => {
        if (onToggleHabit) {
          onToggleHabit(item.id, completed);
        }
      }}
    />
  );

  if (isLoading) {
    return <EmptyOrSkeleton isLoading count={3} type="card" />;
  }

  if (isError) {
    return (
      <YStack padding="$4" space="$4" alignItems="center" justifyContent="center">
        <Ionicons name="alert-circle-outline" size={48} color="$error" />
        <YStack>
          <YStack alignItems="center">
            <Text fontSize="$5" fontWeight="bold" color="$color" textAlign="center">
              Unable to load habits
            </Text>
            <Text fontSize="$3" color="$colorMuted" textAlign="center" marginTop="$2">
              Please check your connection and try again
            </Text>
          </YStack>
        </YStack>
        <AetherCard onPress={refetch} isInteractive padding="$3" paddingHorizontal="$5">
          <XStack alignItems="center" space="$2">
            <Ionicons name="refresh-outline" size={18} color="$primary" />
            <Text fontSize="$4" fontWeight="500" color="$primary">
              Retry
            </Text>
          </XStack>
        </AetherCard>
      </YStack>
    );
  }

  if (!habits || habits.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty 
        text="No habits yet" 
        actionText="Create a habit" 
        onAction={() => router.push('/planner/add-habit')} 
      />
    );
  }

  return (
    <FlatList
      data={habits}
      keyExtractor={(item) => item.id}
      renderItem={renderHabitItem}
      contentContainerStyle={{ padding: 16, paddingBottom: 32 }}
      ItemSeparatorComponent={() => <YStack height="$4" />}
      refreshControl={
        <RefreshControl 
          refreshing={isLoading} 
          onRefresh={refetch} 
        />
      }
    />
  );
}
```

### TaskList.tsx
**Path:** components/lists/TaskList.tsx
**Size:** 6303 bytes

```typescript
import React from 'react';
import { FlatList, RefreshControl, ListRenderItem } from 'react-native';
import { YStack, XStack, Text, Stack } from 'tamagui';
import { router } from 'expo-router';
import { RouterOutputs } from '@/utils/api-types';
import { AetherCard } from '@/components/ui/primitives';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { Ionicons } from '@expo/vector-icons';

type Task = RouterOutputs['task']['list'][number];

interface TaskListProps {
  tasks?: Task[];
  isLoading: boolean;
  isError?: boolean;
  refetch: () => void;
  onSelectTask?: (task: Task) => void;
  onCompleteTask?: (taskId: string, completed: boolean) => void;
}

/**
 * TaskCard - Individual task card component
 */
export function TaskCard({ 
  task, 
  onPress, 
  onComplete 
}: { 
  task: Task; 
  onPress: () => void; 
  onComplete?: (completed: boolean) => void;
}) {
  // Get the completion status of the task
  const [isCompleted, setIsCompleted] = React.useState(Boolean(task.completed));
  
  // Format the due date
  const formattedDate = task.due
    ? new Date(task.due).toLocaleDateString(undefined, {
        month: 'short',
        day: 'numeric',
      })
    : 'No due date';
    
  // Check if task is overdue
  const isOverdue = task.due && new Date(task.due) < new Date() && !isCompleted;

  const handleToggle = () => {
    const newStatus = !isCompleted;
    setIsCompleted(newStatus);
    if (onComplete) {
      onComplete(newStatus);
    }
  };

  return (
    <AetherCard 
      isInteractive 
      variant="default"
      onPress={onPress}
    >
      <YStack space="$2">
        {/* Title with completion toggle */}
        <XStack space="$3" justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center" flex={1}>
            <Stack 
              onPress={handleToggle}
              pressStyle={{ opacity: 0.8 }}
            >
              <Ionicons 
                name={isCompleted ? "checkmark-circle" : "checkmark-circle-outline"} 
                size={26} 
                color={isCompleted ? "$success" : "$colorMuted"} 
              />
            </Stack>
            <Text 
              fontSize="$5" 
              fontWeight="bold" 
              color={isCompleted ? "$colorMuted" : "$color"} 
              numberOfLines={1} 
              flex={1}
              textDecorationLine={isCompleted ? 'line-through' : 'none'}
            >
              {task.title}
            </Text>
          </XStack>
        </XStack>
        
        {/* Notes if available */}
        {task.notes && !isCompleted && (
          <Text color="$colorMuted" fontSize="$3" numberOfLines={2} paddingLeft="$7">
            {task.notes}
          </Text>
        )}
        
        {/* Footer with due date and goal information */}
        <XStack justifyContent="space-between" alignItems="center" paddingLeft="$7">
          <XStack space="$2" alignItems="center">
            <Ionicons 
              name="calendar-outline" 
              size={16} 
              color={isOverdue ? "$error" : "$colorMuted"} 
            />
            <Text 
              fontSize="$2" 
              color={isOverdue ? "$error" : "$colorMuted"}
              fontWeight={isOverdue ? "bold" : "normal"}
            >
              {isOverdue ? "Overdue: " : ""}{formattedDate}
            </Text>
          </XStack>
          
          {/* If task is linked to a goal, show goal name */}
          {task.goal_id && (
            <XStack 
              backgroundColor="$backgroundStrong" 
              paddingHorizontal="$2" 
              paddingVertical="$1" 
              borderRadius="$2"
            >
              <Text fontSize="$2" color="$primary">
                {task.goal?.title || 'Linked goal'}
              </Text>
            </XStack>
          )}
        </XStack>
      </YStack>
    </AetherCard>
  );
}

/**
 * TaskList - List component for displaying tasks
 */
export function TaskList({ 
  tasks, 
  isLoading, 
  isError, 
  refetch, 
  onSelectTask,
  onCompleteTask 
}: TaskListProps) {
  const renderTaskItem: ListRenderItem<Task> = ({ item }) => (
    <TaskCard 
      task={item} 
      onPress={() => {
        if (onSelectTask) {
          onSelectTask(item);
        } else {
          // Default navigation
          router.push({ 
            pathname: '/planner/task/[id]', 
            params: { id: item.id } 
          });
        }
      }}
      onComplete={(completed) => {
        if (onCompleteTask) {
          onCompleteTask(item.id, completed);
        }
      }}
    />
  );

  if (isLoading) {
    return <EmptyOrSkeleton isLoading count={3} type="card" />;
  }

  if (isError) {
    return (
      <YStack padding="$4" space="$4" alignItems="center" justifyContent="center">
        <Ionicons name="alert-circle-outline" size={48} color="$error" />
        <YStack>
          <YStack alignItems="center">
            <Text fontSize="$5" fontWeight="bold" color="$color" textAlign="center">
              Unable to load tasks
            </Text>
            <Text fontSize="$3" color="$colorMuted" textAlign="center" marginTop="$2">
              Please check your connection and try again
            </Text>
          </YStack>
        </YStack>
        <AetherCard onPress={refetch} isInteractive padding="$3" paddingHorizontal="$5">
          <XStack alignItems="center" space="$2">
            <Ionicons name="refresh-outline" size={18} color="$primary" />
            <Text fontSize="$4" fontWeight="500" color="$primary">
              Retry
            </Text>
          </XStack>
        </AetherCard>
      </YStack>
    );
  }

  if (!tasks || tasks.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty 
        text="No tasks yet" 
        actionText="Create a task" 
        onAction={() => router.push('/planner/add-task')} 
      />
    );
  }

  return (
    <FlatList
      data={tasks}
      keyExtractor={(item) => item.id}
      renderItem={renderTaskItem}
      contentContainerStyle={{ padding: 16, paddingBottom: 32 }}
      ItemSeparatorComponent={() => <YStack height="$4" />}
      refreshControl={
        <RefreshControl 
          refreshing={isLoading} 
          onRefresh={refetch} 
        />
      }
    />
  );
}
```

### index.ts
**Path:** components/lists/index.ts
**Size:** 270 bytes

```typescript
// Export all list components from a single file for easier imports
export { GoalList, GoalCard } from './GoalList';
export { HabitList, HabitCard } from './HabitList';
export { TaskList, TaskCard } from './TaskList';

// Add additional list exports as they are created
```

### GoalsList.tsx
**Path:** components/planner/GoalsList.tsx
**Size:** 5412 bytes

```typescript
import React from 'react';
import { StyleSheet, Pressable, ViewStyle, StyleProp } from 'react-native';
import { FlashList } from '@shopify/flash-list';
import { YStack, XStack, Text, View, Progress, ProgressIndicator } from 'tamagui';
import { useColors } from '@/utils/colors';
import EmptyOrSkeleton from '@/components/EmptyOrSkeleton';

// Goal interface - this should match your API schema
export interface Goal {
  id: string;
  title: string;
  description?: string;
  progress: number; // 0 to 1
  deadline?: string; // ISO date string
  userId: string;
  createdAt: string;
  updatedAt: string;
}

export interface GoalsListProps {
  /** List of goals to display */
  goals?: Goal[];
  /** Whether the data is loading */
  isLoading?: boolean;
  /** Called when a goal is pressed */
  onGoalPress?: (goal: Goal) => void;
  /** Called when the add button is pressed */
  onAddPress?: () => void;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}

/**
 * Component to render a goal card with progress bar
 */
function GoalCard({
  goal,
  onPress,
}: {
  goal: Goal;
  onPress?: (goal: Goal) => void;
}) {
  const colors = useColors();
  
  // Calculate remaining days if deadline is set
  const daysLeft = goal.deadline 
    ? Math.ceil((new Date(goal.deadline).getTime() - Date.now()) / (1000 * 60 * 60 * 24))
    : null;
  
  // Determine progress status color
  const getProgressColor = () => {
    if (goal.progress >= 1) return colors.status.success;
    if (daysLeft !== null && daysLeft < 3) return colors.status.error;
    if (daysLeft !== null && daysLeft < 7) return colors.status.warning;
    return colors.status.info;
  };
  
  const progressColor = getProgressColor();
  
  return (
    <Pressable
      onPress={() => onPress?.(goal)}
      style={({ pressed }) => [
        styles.card,
        {
          backgroundColor: colors.background.card,
          borderColor: colors.border.default,
          transform: [{ scale: pressed ? 0.98 : 1 }],
        },
      ]}
    >
      <YStack space="$2" padding="$4">
        <Text fontSize="$5" fontWeight="$2" color={colors.content.primary}>
          {goal.title}
        </Text>
        
        {goal.description && (
          <Text fontSize="$3" color={colors.content.secondary} numberOfLines={2}>
            {goal.description}
          </Text>
        )}
        
        <YStack space="$1" marginTop="$2">
          <XStack justifyContent="space-between" alignItems="center">
            <Text fontSize="$3" fontWeight="$2" color={colors.content.secondary}>
              Progress
            </Text>
            <Text fontSize="$3" color={colors.content.subtle}>
              {Math.round(goal.progress * 100)}%
            </Text>
          </XStack>
          
          <Progress value={goal.progress * 100} backgroundColor={colors.background.secondary}>
            <ProgressIndicator backgroundColor={progressColor} />
          </Progress>
        </YStack>
        
        {daysLeft !== null && (
          <XStack justifyContent="flex-end" marginTop="$1">
            <Text 
              fontSize="$2" 
              color={daysLeft < 0 ? colors.status.error : colors.content.subtle}
            >
              {daysLeft < 0 
                ? `Overdue by ${Math.abs(daysLeft)} days` 
                : daysLeft === 0 
                  ? "Due today" 
                  : `${daysLeft} days left`}
            </Text>
          </XStack>
        )}
      </YStack>
    </Pressable>
  );
}

/**
 * Component to display a list of goals with progress indicators
 */
export default function GoalsList({
  goals = [],
  isLoading = false,
  onGoalPress,
  onAddPress,
  style,
}: GoalsListProps) {
  const colors = useColors();
  
  return (
    <YStack flex={1} style={style}>
      <EmptyOrSkeleton
        isLoading={isLoading}
        isEmpty={goals.length === 0}
        skeletonCount={3}
        skeletonHeight={160}
        skeletonBorderRadius={12}
        title="No goals yet"
        message="Create a new goal to track your progress"
      >
        <FlashList
          data={goals}
          renderItem={({ item }) => (
            <GoalCard goal={item} onPress={onGoalPress} />
          )}
          estimatedItemSize={180}
          contentContainerStyle={styles.listContent}
          ItemSeparatorComponent={() => <View style={styles.separator} />}
        />
      </EmptyOrSkeleton>
      
      {onAddPress && (
        <Pressable
          onPress={onAddPress}
          style={({ pressed }) => [
            styles.addButton,
            {
              backgroundColor: colors.brand.primary,
              opacity: pressed ? 0.9 : 1,
              transform: [{ scale: pressed ? 0.97 : 1 }],
            }
          ]}
        >
          <Text fontSize="$4" fontWeight="$3" color="white">
            + Add Goal
          </Text>
        </Pressable>
      )}
    </YStack>
  );
}

const styles = StyleSheet.create({
  card: {
    borderRadius: 12,
    borderWidth: 1,
    overflow: 'hidden',
  },
  listContent: {
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  separator: {
    height: 12,
  },
  addButton: {
    position: 'absolute',
    bottom: 24,
    right: 24,
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 30,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 4,
  },
}); ```

### HabitTracker.tsx
**Path:** components/planner/HabitTracker.tsx
**Size:** 3450 bytes

```typescript
import React, { useState } from "react";
import { View, StyleSheet } from "react-native";
import { XStack, YStack, Text, Button, H4, Separator } from "tamagui";
import StreakCalendar from './StreakCalendar';
import { Plus, Check } from "@tamagui/lucide-icons";
import { format } from "date-fns";

interface Habit {
  id: string;
  name: string;
  description?: string;
  completedDates: string[]; // ISO date strings
}

interface HabitTrackerProps {
  habits: Habit[];
  onAddHabit?: () => void;
  onToggleHabit?: (habitId: string, date: string, completed: boolean) => void;
  onHabitPress?: (habit: Habit) => void;
}

export function HabitTracker({
  habits = [],
  onAddHabit,
  onToggleHabit,
  onHabitPress,
}: HabitTrackerProps) {
  const today = format(new Date(), "yyyy-MM-dd");

  const handleToggleHabit = (habit: Habit) => {
    if (!onToggleHabit) return;
    
    const isCompleted = habit.completedDates.includes(today);
    onToggleHabit(habit.id, today, !isCompleted);
  };

  return (
    <YStack space="$4">
      <XStack justifyContent="space-between" alignItems="center">
        <H4>Habits</H4>
        <Button 
          size="$2" 
          circular 
          icon={<Plus size={16} />} 
          onPress={onAddHabit}
        />
      </XStack>

      {habits.length === 0 ? (
        <YStack 
          p="$4"
          alignItems="center" 
          justifyContent="center" 
          backgroundColor="$gray2" 
          borderRadius="$4"
        >
          <Text color="$gray11" textAlign="center">
            No habits yet. Add your first habit to start tracking.
          </Text>
        </YStack>
      ) : (
        <YStack space="$3">
          {habits.map((habit, index) => (
            <YStack key={habit.id} space="$2">
              {index > 0 && <Separator />}
              <HabitItem 
                habit={habit} 
                onToggle={() => handleToggleHabit(habit)}
                onPress={() => onHabitPress?.(habit)} 
              />
            </YStack>
          ))}
        </YStack>
      )}
    </YStack>
  );
}

interface HabitItemProps {
  habit: Habit;
  onToggle: () => void;
  onPress: () => void;
}

function HabitItem({ habit, onToggle, onPress }: HabitItemProps) {
  const today = format(new Date(), "yyyy-MM-dd");
  const isCompletedToday = habit.completedDates.includes(today);

  return (
    <XStack 
      p="$3"
      borderRadius="$4" 
      backgroundColor="$gray2"
      justifyContent="space-between"
      alignItems="center"
      pressStyle={{ opacity: 0.8 }}
      onPress={onPress}
    >
      <YStack space="$1" flex={1}>
        <Text fontSize="$3" fontWeight="$5">
          {habit.name}
        </Text>
        {habit.description && (
          <Text fontSize="$2" color="$gray11">
            {habit.description}
          </Text>
        )}
        
        <YStack mt="$2">
          <StreakCalendar
            completedDates={habit.completedDates}
          />
        </YStack>
      </YStack>

      <Button
        size="$3"
        circular
        backgroundColor={isCompletedToday ? "$primary9" : "$gray4"}
        onPress={(e) => {
          e.stopPropagation();
          onToggle();
        }}
        pressStyle={{
          backgroundColor: isCompletedToday ? "$primary8" : "$gray5",
        }}
      >
        <Check 
          size={18} 
          color={isCompletedToday ? "$gray1" : "$gray11"} 
        />
      </Button>
    </XStack>
  );
} ```

### HabitsList.tsx
**Path:** components/planner/HabitsList.tsx
**Size:** 5794 bytes

```typescript
import React, { useState } from 'react';
import { StyleSheet, Pressable, ViewStyle, StyleProp } from 'react-native';
import { YStack, XStack, Text, View, Checkbox } from 'tamagui';
import { useColors } from '@/utils/colors';
import EmptyOrSkeleton from '@/components/EmptyOrSkeleton';
import * as Haptics from 'expo-haptics';

// Habit interface - this should match your API schema
export interface Habit {
  id: string;
  title: string;
  description?: string;
  frequency: 'daily' | 'weekly' | 'monthly';
  completedToday: boolean;
  streak: number;
  userId: string;
  createdAt: string;
  updatedAt: string;
}

export interface HabitsListProps {
  /** List of habits to display */
  habits?: Habit[];
  /** Whether the data is loading */
  isLoading?: boolean;
  /** Called when a habit's completion status is toggled */
  onToggleHabit?: (habitId: string, completed: boolean) => Promise<void>;
  /** Called when a habit item is pressed */
  onHabitPress?: (habit: Habit) => void;
  /** Called when the add button is pressed */
  onAddPress?: () => void;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}

/**
 * Component to render a habit item with checkbox
 */
function HabitItem({
  habit,
  onToggle,
  onPress,
}: {
  habit: Habit;
  onToggle?: (habitId: string, completed: boolean) => Promise<void>;
  onPress?: (habit: Habit) => void;
}) {
  const colors = useColors();
  const [isChecked, setIsChecked] = useState(habit.completedToday);
  const [isUpdating, setIsUpdating] = useState(false);
  
  const handleToggle = async () => {
    if (isUpdating || !onToggle) return;
    
    // Optimistic update
    const newValue = !isChecked;
    setIsChecked(newValue);
    
    // Provide haptic feedback
    if (newValue) {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    } else {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    
    try {
      setIsUpdating(true);
      await onToggle(habit.id, newValue);
    } catch (error) {
      // Revert on error
      setIsChecked(!newValue);
      console.error('Failed to update habit:', error);
    } finally {
      setIsUpdating(false);
    }
  };
  
  // Get frequency text
  const getFrequencyText = () => {
    switch (habit.frequency) {
      case 'daily': return 'Daily';
      case 'weekly': return 'Weekly';
      case 'monthly': return 'Monthly';
      default: return '';
    }
  };
  
  return (
    <Pressable
      onPress={() => onPress?.(habit)}
      style={({ pressed }) => [
        styles.habitItem,
        {
          backgroundColor: colors.background.card,
          borderColor: colors.border.default,
          opacity: isUpdating ? 0.7 : 1,
          transform: [{ scale: pressed ? 0.98 : 1 }],
        },
      ]}
      disabled={isUpdating}
    >
      <XStack space="$3" flex={1} alignItems="center">
        <Checkbox
          checked={isChecked}
          onCheckedChange={handleToggle}
          disabled={isUpdating}
          borderColor="$gray8"
          backgroundColor={isChecked ? "green" : undefined}
          opacity={isUpdating ? 0.5 : 1}
          size="$5"
        />
        
        <YStack flex={1} space="$1">
          <Text 
            fontSize="$4" 
            fontWeight="$2" 
            color="$color"
            textDecorationLine={isChecked ? 'line-through' : 'none'}
            opacity={isChecked ? 0.8 : 1}
          >
            {habit.title}
          </Text>
          
          <XStack space="$3" alignItems="center">
            <Text fontSize="$2" color="$gray10">
              {getFrequencyText()}
            </Text>
            
            {habit.streak > 0 && (
              <XStack space="$1" alignItems="center">
                <Text fontSize="$2" color={colors.status.success} fontWeight="$2">
                  {habit.streak} day streak 🔥
                </Text>
              </XStack>
            )}
          </XStack>
        </YStack>
      </XStack>
    </Pressable>
  );
}

/**
 * Component to display a list of habits with checkboxes
 */
export default function HabitsList({
  habits = [],
  isLoading = false,
  onToggleHabit,
  onHabitPress,
  onAddPress,
  style,
}: HabitsListProps) {
  const colors = useColors();
  
  return (
    <YStack flex={1} style={style}>
      <EmptyOrSkeleton
        isLoading={isLoading}
        isEmpty={habits.length === 0}
        skeletonCount={4}
        skeletonHeight={80}
        skeletonBorderRadius={12}
        title="No habits yet"
        message="Create a habit to track your daily progress"
      >
        <YStack space="$2" padding="$4">
          {habits.map((habit) => (
            <HabitItem
              key={habit.id}
              habit={habit}
              onToggle={onToggleHabit}
              onPress={onHabitPress}
            />
          ))}
        </YStack>
      </EmptyOrSkeleton>
      
      {onAddPress && (
        <Pressable
          onPress={onAddPress}
          style={({ pressed }) => [
            styles.addButton,
            {
              backgroundColor: colors.brand.primary,
              opacity: pressed ? 0.9 : 1,
              transform: [{ scale: pressed ? 0.97 : 1 }],
            }
          ]}
        >
          <Text fontSize="$4" fontWeight="$3" color="white">
            + Add Habit
          </Text>
        </Pressable>
      )}
    </YStack>
  );
}

const styles = StyleSheet.create({
  habitItem: {
    borderRadius: 12,
    borderWidth: 1,
    padding: 16,
    marginBottom: 8,
  },
  addButton: {
    position: 'absolute',
    bottom: 24,
    right: 24,
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 30,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 4,
  },
}); ```

### StreakCalendar.tsx
**Path:** components/planner/StreakCalendar.tsx
**Size:** 5134 bytes

```typescript
import React, { useMemo } from 'react';
import { StyleSheet, ViewStyle, StyleProp } from 'react-native';
import { View, XStack, YStack, Text, Circle } from 'tamagui';
import { useColors } from '@/utils/colors';
import { format, startOfWeek, addDays, isSameDay, subWeeks, addWeeks } from 'date-fns';

export interface StreakCalendarProps {
  /** Array of dates (ISO strings) when the habit was completed */
  completedDates: string[];
  /** Number of weeks to display (default: 4) */
  weekCount?: number;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}

/**
 * Component that displays a habit completion calendar with dots for each day
 */
export default function StreakCalendar({
  completedDates = [],
  weekCount = 4,
  style,
}: StreakCalendarProps) {
  const today = new Date();

  const completedDatesObjects = useMemo(() => {
    return completedDates.map(dateStr => new Date(dateStr));
  }, [completedDates]);

  // Generate weeks from the current week backwards
  const weeks = useMemo(() => {
    const result = [];
    const day = startOfWeek(today, { weekStartsOn: 0 }); // Sunday as first day

    // Get current week
    const currentWeek = Array(7)
      .fill(null)
      .map((_, i) => {
        const date = addDays(day, i);
        return {
          date,
          completed: completedDatesObjects.some((d) => isSameDay(d, date)),
          isToday: isSameDay(date, today),
          isPast: date < today,
          isFuture: date > today,
        };
      });
    result.push(currentWeek);

    // Get previous weeks
    for (let i = 1; i < weekCount; i++) {
      const startDay = subWeeks(day, i);
      const week = Array(7)
        .fill(null)
        .map((_, j) => {
          const date = addDays(startDay, j);
          return {
            date,
            completed: completedDatesObjects.some((d) => isSameDay(d, date)),
            isToday: false,
            isPast: date < today,
            isFuture: date > today,
          };
        });
      result.push(week);
    }

    // Reverse so most recent week is at the bottom
    return result.reverse();
  }, [completedDatesObjects, weekCount, today]);

  const dayNames = useMemo(() => {
    const firstDayOfWeek = startOfWeek(new Date(), { weekStartsOn: 0 });
    return Array(7)
      .fill(null)
      .map((_, i) => {
        return format(addDays(firstDayOfWeek, i), "EEE").charAt(0);
      });
  }, []);

  return (
    <YStack space="$3" style={style}>
      <Text fontSize="$3" fontWeight="$3" color="$content.primary">
        Activity
      </Text>
      
      <XStack justifyContent="space-between">
        {dayNames.map((day, index) => (
          <Text key={index} color="$gray11" textAlign="center" fontSize="$1">
            {day}
          </Text>
        ))}
      </XStack>
      
      <YStack space="$3">
        {weeks.map((week, weekIndex) => (
          <XStack key={`week-${weekIndex}`} justifyContent="space-between">
            {week.map((day, dayIndex) => (
              <YStack key={`day-${weekIndex}-${dayIndex}`} alignItems="center" space="$1">
                <Text 
                  fontSize="$1" 
                  color={day.isToday ? "$brand.primary" : "$content.subtle"}
                  fontWeight={day.isToday ? '$3' : '$2'}
                >
                  {day.date.getDate()}
                </Text>
                
                {/* Day circle */}
                <DayCircle 
                  completed={day.completed}
                  isToday={day.isToday}
                  isPast={day.isPast}
                  isFuture={day.isFuture}
                />
              </YStack>
            ))}
          </XStack>
        ))}
      </YStack>
      
      {/* Legend */}
      <XStack space="$4" justifyContent="center" marginTop="$2">
        <XStack space="$1" alignItems="center">
          <View
            style={{
              width: 8,
              height: 8,
              borderRadius: 4,
              backgroundColor: "$gray6",
            }}
          />
          <Text fontSize="$2" color="$content.subtle">Not completed</Text>
        </XStack>
        
        <XStack space="$1" alignItems="center">
          <View
            style={{
              width: 8,
              height: 8,
              borderRadius: 4,
              backgroundColor: "$primary9",
            }}
          />
          <Text fontSize="$2" color="$content.subtle">Completed</Text>
        </XStack>
      </XStack>
    </YStack>
  );
}

function DayCircle({ 
  completed, 
  isToday, 
  isPast, 
  isFuture 
}: { 
  completed: boolean; 
  isToday: boolean;
  isPast: boolean;
  isFuture: boolean;
}) {
  let backgroundColor = completed 
    ? "$primary9" 
    : "transparent";
  
  // Future dates should be more faded
  if (isFuture) {
    backgroundColor = "transparent";
  }
  
  return (
    <View style={[
      styles.dayCircle,
      {
        backgroundColor,
        borderWidth: isToday ? 1 : 0,
        borderColor: "$primary9",
      }
    ]} />
  );
}

const styles = StyleSheet.create({
  dayCircle: {
    width: 32,
    height: 32,
    borderRadius: 16,
  },
}); ```

### ConfettiBurst.tsx
**Path:** components/rewards/ConfettiBurst.tsx
**Size:** 5489 bytes

```typescript
import React, { useEffect } from 'react';
import { StyleSheet, Dimensions } from 'react-native';
import { View } from 'tamagui';
import Animated, {
  useSharedValue,
  withDelay,
  withTiming,
  useAnimatedStyle,
  withSequence,
  runOnJS,
  Easing,
} from 'react-native-reanimated';
import { durations, easings } from '@/constants/motion';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

// Define confetti piece colors
const COLORS = [
  '#FF5252', // Red
  '#FFD740', // Amber
  '#64FFDA', // Teal
  '#448AFF', // Blue
  '#B388FF', // Deep Purple
  '#FF80AB', // Pink
  '#1DE9B6', // Green
  '#F48FB1', // Light Pink
];

// Number of confetti pieces
const CONFETTI_COUNT = 50;

// Confetti piece configuration
interface ConfettiPiece {
  id: number;
  x: number;
  y: number;
  size: number;
  color: string;
  rotation: number;
  delay: number;
  duration: number;
}

interface ConfettiBurstProps {
  /** Whether to show the confetti */
  isVisible: boolean;
  /** Called when animation completes */
  onComplete?: () => void;
  /** Number of confetti pieces to display (default: 50) */
  count?: number;
  /** Custom colors to use for confetti pieces */
  colors?: string[];
  /** Duration of the animation in ms (default: 2000) */
  duration?: number;
}

/**
 * A component that displays a burst of confetti animation
 */
export default function ConfettiBurst({
  isVisible,
  onComplete,
  count = CONFETTI_COUNT,
  colors = COLORS,
  duration = 2000,
}: ConfettiBurstProps) {
  // Create confetti pieces
  const pieces = React.useMemo(() => {
    const result: ConfettiPiece[] = [];
    
    for (let i = 0; i < count; i++) {
      result.push({
        id: i,
        x: Math.random() * SCREEN_WIDTH,
        y: -20, // Start above the screen
        size: Math.random() * 8 + 4, // Size between 4-12
        color: colors[Math.floor(Math.random() * colors.length)],
        rotation: Math.random() * 360,
        delay: Math.random() * 500, // Random delay up to 500ms
        duration: Math.random() * 1000 + 1500, // Duration between 1.5-2.5s
      });
    }
    
    return result;
  }, [count, colors]);
  
  // Trigger animation complete callback
  const animationComplete = () => {
    if (onComplete) {
      onComplete();
    }
  };
  
  return (
    <>
      {isVisible && (
        <View style={styles.container} pointerEvents="none">
          {pieces.map((piece) => (
            <ConfettiPiece
              key={piece.id}
              piece={piece}
              animationDuration={duration}
              onComplete={animationComplete}
            />
          ))}
        </View>
      )}
    </>
  );
}

// Individual confetti piece component
function ConfettiPiece({
  piece,
  animationDuration,
  onComplete,
}: {
  piece: ConfettiPiece;
  animationDuration: number;
  onComplete: () => void;
}) {
  const translateY = useSharedValue(piece.y);
  const translateX = useSharedValue(piece.x);
  const rotate = useSharedValue(piece.rotation);
  const opacity = useSharedValue(1);
  
  // Track if this is the last piece to complete
  const wasLastPiece = React.useRef(false);
  
  useEffect(() => {
    // Last piece will trigger onComplete
    if (piece.id === CONFETTI_COUNT - 1) {
      wasLastPiece.current = true;
    }
    
    // Start Y animation (falling down)
    translateY.value = withDelay(
      piece.delay,
      withTiming(
        SCREEN_HEIGHT + 50, // End below the screen
        {
          duration: piece.duration,
          easing: easings.accelerate,
        },
        () => {
          if (wasLastPiece.current) {
            runOnJS(onComplete)();
          }
        }
      )
    );
    
    // Swaying horizontal movement
    translateX.value = withDelay(
      piece.delay,
      withSequence(
        withTiming(piece.x - 50 + Math.random() * 100, {
          duration: piece.duration * 0.3,
          easing: easings.standard,
        }),
        withTiming(piece.x + 50 + Math.random() * 100, {
          duration: piece.duration * 0.3,
          easing: easings.standard,
        }),
        withTiming(piece.x - 25 + Math.random() * 50, {
          duration: piece.duration * 0.4,
          easing: easings.standard,
        })
      )
    );
    
    // Rotation animation
    rotate.value = withDelay(
      piece.delay,
      withTiming(piece.rotation + Math.random() * 720, {
        duration: piece.duration,
        easing: easings.standard,
      })
    );
    
    // Fade out toward the end
    opacity.value = withDelay(
      piece.delay + (piece.duration * 0.7),
      withTiming(0, {
        duration: piece.duration * 0.3,
        easing: easings.standard,
      })
    );
  }, []);
  
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: translateX.value },
        { translateY: translateY.value },
        { rotate: `${rotate.value}deg` },
      ],
      opacity: opacity.value,
    };
  });
  
  return (
    <Animated.View
      style={[
        {
          position: 'absolute',
          width: piece.size,
          height: piece.size * (Math.random() * 0.8 + 0.2), // Varying heights
          backgroundColor: piece.color,
          borderRadius: Math.random() > 0.5 ? piece.size / 2 : 0, // Some round, some square
        },
        animatedStyle,
      ]}
    />
  );
}

const styles = StyleSheet.create({
  container: {
    ...StyleSheet.absoluteFillObject,
    zIndex: 999,
    pointerEvents: 'none',
  },
}); ```

### NotificationRow.tsx
**Path:** components/settings/NotificationRow.tsx
**Size:** 2280 bytes

```typescript
import React, { ReactNode } from 'react';
import { StyleSheet, ViewStyle, StyleProp } from 'react-native';
import { XStack, Text, Switch, SwitchProps, YStack } from 'tamagui';
import { useColors } from '@/utils/colors';

export interface NotificationRowProps {
  /** Title of the notification setting */
  title: string;
  /** Optional description */
  description?: string;
  /** Whether the notification is turned on */
  enabled: boolean;
  /** Called when the switch is toggled */
  onToggle: (value: boolean) => void;
  /** Icon to display in the row */
  icon?: ReactNode;
  /** Whether the control is in loading state */
  isLoading?: boolean;
  /** Switch props */
  switchProps?: Omit<SwitchProps, 'checked' | 'onCheckedChange'>;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}

/**
 * A component for displaying a notification setting row with toggle switch
 */
export default function NotificationRow({
  title,
  description,
  enabled,
  onToggle,
  icon,
  isLoading,
  switchProps,
  style,
}: NotificationRowProps) {
  const colors = useColors();
  
  const handleToggle = (value: boolean) => {
    if (!isLoading) {
      onToggle(value);
    }
  };
  
  return (
    <XStack
      style={[styles.container, style]}
      alignItems="center"
      justifyContent="space-between"
      padding="$4"
      backgroundColor={colors.background.card}
      borderRadius="$4"
    >
      <XStack alignItems="center" space="$3" flex={1}>
        {icon && <XStack opacity={isLoading ? 0.5 : 1}>{icon}</XStack>}
        
        <YStack space="$1" flex={1} opacity={isLoading ? 0.5 : 1}>
          <Text
            fontSize="$4"
            fontWeight="$2"
            color={colors.content.primary}
          >
            {title}
          </Text>
          
          {description && (
            <Text
              fontSize="$3"
              color={colors.content.secondary}
            >
              {description}
            </Text>
          )}
        </YStack>
      </XStack>
      
      <Switch
        size="$2"
        checked={enabled}
        onCheckedChange={handleToggle}
        disabled={isLoading}
        {...switchProps}
      />
    </XStack>
  );
}

const styles = StyleSheet.create({
  container: {
    marginBottom: 12,
  },
}); ```

### ThemePreview.tsx
**Path:** components/settings/ThemePreview.tsx
**Size:** 3674 bytes

```typescript
import React from 'react';
import { StyleSheet, ViewStyle, StyleProp, Pressable } from 'react-native';
import { View, Stack, YStack, Text, XStack, Theme } from 'tamagui';
import { useTheme } from 'tamagui';
import { useColors } from '@/utils/colors';
import { Check } from '@tamagui/lucide-icons';

export interface ThemePreviewProps {
  /** The theme name to display */
  themeName: string;
  /** Whether this theme is currently selected */
  isSelected: boolean;
  /** Called when this theme is selected */
  onSelect: () => void;
  /** Whether to force dark mode for this preview */
  forceDark?: boolean;
  /** Whether to force light mode for this preview */
  forceLight?: boolean;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}

/**
 * A component that displays a preview of a theme with sample UI elements
 */
export default function ThemePreview({
  themeName,
  isSelected,
  onSelect,
  forceDark,
  forceLight,
  style,
}: ThemePreviewProps) {
  const currentTheme = useTheme();
  const previewTheme = forceDark ? 'dark' : forceLight ? 'light' : undefined;
  const colors = useColors();
  
  return (
    <Pressable 
      onPress={onSelect}
      style={({ pressed }) => [
        styles.container,
        {
          transform: [{ scale: pressed ? 0.97 : 1 }],
          borderColor: isSelected ? colors.border.focus : colors.border.default,
          borderWidth: isSelected ? 2 : 1,
        },
        style,
      ]}
    >
      <YStack space="$2">
        <Text
          fontSize="$4"
          fontWeight="$2"
          color={colors.content.primary}
          marginBottom="$1"
        >
          {themeName}
        </Text>
        
        <Theme name={previewTheme}>
          <YStack
            backgroundColor="$cardBackground"
            borderRadius="$3"
            padding="$2"
            space="$2"
          >
            {/* Header Preview */}
            <View 
              style={styles.header}
              backgroundColor="$primary"
            />
            
            {/* Content Preview */}
            <YStack space="$1">
              <View style={styles.textLine} backgroundColor="$color" opacity={0.9} />
              <View style={styles.textLine} backgroundColor="$color" opacity={0.7} width="80%" />
              <View style={styles.textLine} backgroundColor="$color" opacity={0.5} width="60%" />
            </YStack>
            
            {/* Button Preview */}
            <XStack space="$2">
              <View
                style={styles.button}
                backgroundColor="$primary"
              />
              <View
                style={styles.button}
                backgroundColor="$backgroundPress"
              />
            </XStack>
          </YStack>
        </Theme>
        
        {isSelected && (
          <View style={styles.checkContainer}>
            <XStack
              backgroundColor={colors.status.success}
              borderRadius={999}
              alignItems="center"
              justifyContent="center"
              width={24}
              height={24}
            >
              <Check color="white" size={16} />
            </XStack>
          </View>
        )}
      </YStack>
    </Pressable>
  );
}

const styles = StyleSheet.create({
  container: {
    borderRadius: 12,
    padding: 12,
    backgroundColor: 'transparent',
    overflow: 'hidden',
    position: 'relative',
  },
  header: {
    height: 24,
    borderRadius: 4,
  },
  textLine: {
    height: 8,
    borderRadius: 4,
  },
  button: {
    height: 20,
    flex: 1,
    borderRadius: 4,
  },
  checkContainer: {
    position: 'absolute',
    top: 8,
    right: 8,
  },
}); ```

### Container.tsx
**Path:** components/ui/Container.tsx
**Size:** 692 bytes

```typescript
import React, { ReactNode } from 'react';
import { SafeAreaView, SafeAreaViewProps } from 'react-native';
import { styled, useTheme, YStack } from 'tamagui';

interface ContainerProps extends SafeAreaViewProps {
  children: ReactNode;
}

const StyledSafeArea = styled(SafeAreaView, {
  name: 'StyledSafeArea',
  flex: 1,
});

export const Container: React.FC<ContainerProps> = ({ style, children, ...props }) => {
  const theme = useTheme();
  return (
    <StyledSafeArea
      style={[
        { backgroundColor: theme.background.val },
        style as any
      ]}
      {...props}
    >
      <YStack flex={1}>{children}</YStack>
    </StyledSafeArea>
  );
};

export default Container;
```

### EmptyOrSkeleton.tsx
**Path:** components/ui/EmptyOrSkeleton.tsx
**Size:** 2035 bytes

```typescript
import React from 'react';
import { YStack, Text, Button } from 'tamagui';
import { SkeletonCard, SkeletonRow, SkeletonCircle } from './Skeleton';
import { SectionError } from './ErrorBanner';

export interface EmptyOrSkeletonProps {
  // Loading state
  isLoading?: boolean;
  count?: number;
  type?: 'card' | 'row' | 'circle';
  
  // Empty state
  isEmpty?: boolean;
  text?: string;
  actionText?: string;
  onAction?: () => void;
  
  // Error state
  isError?: boolean;
  onRetry?: () => void;
  
  // Children to render when not in any special state
  children?: React.ReactNode;
}

export const EmptyOrSkeleton = ({
  isLoading = false,
  count = 3,
  type = 'row',
  isEmpty = false,
  text = 'No items found',
  actionText = 'Add New',
  onAction,
  isError = false,
  onRetry,
  children
}: EmptyOrSkeletonProps) => {
  // Generate skeleton based on type
  const renderSkeletons = () => {
    const skeletons = [];
    for (let i = 0; i < count; i++) {
      if (type === 'card') {
        skeletons.push(<SkeletonCard key={i} />);
      } else if (type === 'circle') {
        skeletons.push(<SkeletonCircle key={i} />);
      } else {
        skeletons.push(<SkeletonRow key={i} />);
      }
    }
    return skeletons;
  };

  // Show skeleton if loading
  if (isLoading) {
    return (
      <YStack space="$3">
        {renderSkeletons()}
      </YStack>
    );
  }
  
  // Show error state if there's an error
  if (isError) {
    return (
      <SectionError 
        message={text} 
        onRetry={onRetry} 
      />
    );
  }
  
  // Show empty state if empty
  if (isEmpty) {
    return (
      <YStack
        padding="$4"
        alignItems="center"
        justifyContent="center"
        space="$3"
      >
        <Text textAlign="center" color="$gray11">
          {text}
        </Text>
        {onAction && (
          <Button size="$3" onPress={onAction}>
            {actionText}
          </Button>
        )}
      </YStack>
    );
  }
  
  // Default: return children
  return <>{children}</>;
};
```

### ErrorBanner.tsx
**Path:** components/ui/ErrorBanner.tsx
**Size:** 2811 bytes

```typescript
import React from 'react';
import { YStack, Text, Button, XStack, H4, useTheme } from 'tamagui';
import { Ionicons } from '@expo/vector-icons';

interface ErrorBannerProps {
  title?: string;
  message: string;
  onRetry?: () => void;
}

export function ErrorBanner({ title, message, onRetry }: ErrorBannerProps) {
  const theme = useTheme();

  const red3 = theme?.red3?.val ?? '#fee2e2';
  const red5 = theme?.red5?.val ?? '#f87171';
  const red6 = theme?.red6?.val ?? '#ef4444';
  const red7 = theme?.red7?.val ?? '#dc2626';
  const red10 = theme?.red10?.val ?? '#991b1b';
  const red11 = theme?.red11?.val ?? '#7f1d1d';

  return (
    <YStack 
      backgroundColor={red3} 
      borderColor={red7} 
      borderWidth={1} 
      borderRadius="$3"
      padding="$3"
      space="$2"
      alignItems="center"
    >
      <XStack width="100%" justifyContent="space-between" alignItems="center">
        <H4 color={red11}>{title || 'Error'}</H4> 
        {/* Optional: Add an icon */} 
        {/* <Ionicons name="alert-circle-outline" size={20} color={red10} /> */} 
      </XStack>
      <Text color={red11}>{message}</Text> 
      {onRetry && (
        <Button 
          // theme="red" 
          icon={<Ionicons name="refresh" size={16} color={red11} />} 
          onPress={onRetry}
          size="$2"
          backgroundColor={red5} 
          borderColor={red7} 
          borderWidth={1}
          pressStyle={{ backgroundColor: red6 }}
        >
          <Text color={red11}>Retry</Text>
        </Button>
      )}
    </YStack>
  );
}

interface SectionErrorProps {
  message: string;
  onRetry?: () => void;
}

export function SectionError({ message, onRetry }: SectionErrorProps) {
  const theme = useTheme();

  const red3 = theme?.red3?.val ?? '#fee2e2';
  const red5 = theme?.red5?.val ?? '#f87171';
  const red6 = theme?.red6?.val ?? '#ef4444';
  const red7 = theme?.red7?.val ?? '#dc2626';
  const red10 = theme?.red10?.val ?? '#991b1b';
  const red11 = theme?.red11?.val ?? '#7f1d1d';

  return (
    <YStack 
      padding="$3" 
      borderRadius="$3" 
      borderWidth={1} 
      borderColor={red7} 
      backgroundColor={red3} 
      alignItems="center" 
      space="$2"
    >
      <Ionicons name="warning-outline" size={24} color={red10} /> 
      <Text color={red11} textAlign="center"> 
        {message || 'Failed to load this section.'}
      </Text>
      {onRetry && (
        <Button 
          size="$2" 
          // theme="red"
          backgroundColor={red5} 
          icon={<Ionicons name="refresh" size={16} color={red11} />} 
          onPress={onRetry}
          pressStyle={{ backgroundColor: red6 }}
          borderColor={red7} 
          borderWidth={1} 
        >
          <Text color={red11}>Retry</Text>
        </Button>
      )}
    </YStack>
  );
}
```

### InteractiveCard.tsx
**Path:** components/ui/InteractiveCard.tsx
**Size:** 594 bytes

```typescript
import { Card, styled } from 'tamagui';

const InteractiveCard = styled(Card, {
  name: 'InteractiveCard',
  // default props
  elevate: true,
  bordered: true,
  animation: 'bouncy',
  padding: '$4',

  hoverStyle: {
    y: -2,
    shadowColor: '$color.transparent',
    backgroundColor: '$backgroundHover',
  },
  pressStyle: {
    scale: 0.97,
    backgroundColor: '$backgroundPress',
  },
  focusStyle: {
    backgroundColor: '$backgroundFocus',
    outlineColor: '$borderColorFocus',
  },
  shadowOffset: { width: 0, height: 2 },
  shadowOpacity: 0.1,
});

export default InteractiveCard;
```

### Section.tsx
**Path:** components/ui/Section.tsx
**Size:** 501 bytes

```typescript
import React, { ReactNode } from 'react';
import { YStack, Text } from 'tamagui';

interface SectionProps {
  title?: string;
  children: ReactNode;
}

/**
 * Semantic section wrapper with optional title and consistent spacing.
 */
const Section: React.FC<SectionProps> = ({ title, children }) => (
  <YStack marginVertical="$4">
    {title && (
      <Text fontSize="$6" fontWeight="bold" marginBottom="$2">
        {title}
      </Text>
    )}
    {children}
  </YStack>
);

export default Section;
```

### Skeleton.tsx
**Path:** components/ui/Skeleton.tsx
**Size:** 2642 bytes

```typescript
import React from 'react';
import { DimensionValue } from 'react-native';
import { YStack, XStack, styled, Stack } from 'tamagui';
import { useColorScheme } from '@/hooks/useColorScheme';

const SkeletonBase = styled(Stack, {
  name: 'SkeletonBase',
  backgroundColor: '$gray5',
  overflow: 'hidden',
  position: 'relative',
  variants: {
    colorMode: {
      light: { backgroundColor: '$gray5' },
      dark: { backgroundColor: '$gray9' },
    },
  } as const,
});

const SkeletonShimmer = styled(Stack, {
  name: 'SkeletonShimmer',
  position: 'absolute',
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  opacity: 0.5,
});

interface SkeletonProps {
  width?: DimensionValue;
  height?: DimensionValue;
  borderRadius?: number;
}

export function Skeleton({ width = '100%', height = 20, borderRadius = 4 }: SkeletonProps) {
  const colorScheme = useColorScheme();
  
  return (
    <SkeletonBase
      colorMode={colorScheme === 'dark' ? 'dark' : 'light'}
      width={width}
      height={height}
      borderRadius={borderRadius}
    />
  );
}

interface SkeletonRowProps {
  height?: DimensionValue;
  width?: DimensionValue;
  lines?: number;
  spacing?: number;
}

export function SkeletonRow({ height = 20, width = '100%', lines = 3, spacing = 10 }: SkeletonRowProps) {
  return (
    <YStack space={spacing}>
      {Array.from({ length: lines }).map((_, i) => (
        <Skeleton 
          key={i}
          height={height}
          width={i === lines - 1 && typeof width === 'string' ? '70%' : width}
        />
      ))}
    </YStack>
  );
}

interface SkeletonCardProps {
  height?: DimensionValue;
  width?: DimensionValue;
}

export function SkeletonCard({ height = 100, width = '100%' }: SkeletonCardProps) {
  return (
    <YStack space="$2">
      <Skeleton height={height} width={width} borderRadius={8} />
    </YStack>
  );
}

interface SkeletonAvatarProps {
  size?: number;
}

export function SkeletonAvatar({ size = 40 }: SkeletonAvatarProps) {
  return <Skeleton width={size} height={size} borderRadius={size / 2} />;
}

interface SkeletonProfileProps {
  avatarSize?: number;
}

export function SkeletonProfile({ avatarSize = 40 }: SkeletonProfileProps) {
  return (
    <XStack space="$3" alignItems="center">
      <SkeletonAvatar size={avatarSize} />
      <YStack space="$1" flex={1}>
        <Skeleton width="60%" height={16} />
        <Skeleton width="40%" height={12} />
      </YStack>
    </XStack>
  );
}

interface SkeletonCircleProps {
  size?: number;
}

export function SkeletonCircle({ size = 60 }: SkeletonCircleProps) {
  return <Skeleton width={size} height={size} borderRadius={size / 2} />;
}
```

### SwipeableRow.tsx
**Path:** components/ui/SwipeableRow.tsx
**Size:** 2281 bytes

```typescript
import React from 'react';
import { Swipeable } from 'react-native-gesture-handler';
import { XStack, Button, useTheme } from 'tamagui';
import { Trash, Check } from '@tamagui/lucide-icons';
import * as Haptics from 'expo-haptics';

type SwipeableRowProps = {
  children: React.ReactNode;
  onDelete?: () => void;
  onComplete?: () => void;
  // Add any other props needed, like unique key for Swipeable instance management
};

export default function SwipeableRow({ children, onDelete, onComplete }: SwipeableRowProps) {
  const theme = useTheme();

  const renderRightActions = () => {
    if (!onDelete) return null;
    return (
      <XStack flex={1} justifyContent="flex-end">
        <Button
          // size="$3" // Match ListItem size?
          backgroundColor="$destructive"
          borderTopRightRadius="$0" // Flatten edges
          borderBottomRightRadius="$0"
          icon={<Trash color={theme.color?.get()} />} // Use theme color for icon
          onPress={() => {
            Haptics.selectionAsync();
            onDelete();
            // Consider closing the Swipeable here if needed
          }}
          width={80} // Fixed width for the action button
          height="100%" // Fill height
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  const renderLeftActions = () => {
    if (!onComplete) return null;
    return (
      <XStack flex={1} justifyContent="flex-start">
        <Button
          // size="$3"
          backgroundColor="$success"
          borderTopLeftRadius="$0"
          borderBottomLeftRadius="$0"
          icon={<Check color={theme.color?.get()} />}
          onPress={() => {
            Haptics.selectionAsync();
            onComplete();
            // Consider closing the Swipeable here if needed
          }}
          width={80}
          height="100%"
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  return (
    <Swipeable
      renderRightActions={renderRightActions}
      renderLeftActions={renderLeftActions}
      overshootFriction={8} // Standard friction
      containerStyle={{ backgroundColor: '$background' }} // Ensure background matches item
    >
      {children}
    </Swipeable>
  );
}
```

### AetherCard.tsx
**Path:** components/ui/primitives/AetherCard.tsx
**Size:** 1953 bytes

```typescript
import React from 'react';
import { Card, CardProps, YStack, styled } from 'tamagui';

type AetherCardVariant = 'default' | 'elevated' | 'outlined';

interface AetherCardProps extends CardProps {
  variant?: AetherCardVariant;
  // Additional props specific to AetherCard
  isInteractive?: boolean;
}

// Create a styled Card component that uses our custom Tamagui theme variables
const StyledCard = styled(Card, {
  name: 'AetherCard',
  backgroundColor: '$cardBackground',
  borderRadius: '$4',
  padding: '$4',
  elevate: true,

  variants: {
    variant: {
      default: {
        // Using our theme tokens
        shadowColor: '$shadowColor',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 3,
        elevation: 2,
      },
      elevated: {
        shadowColor: '$shadowColor',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 6,
        elevation: 4,
      },
      outlined: {
        backgroundColor: 'transparent',
        borderWidth: 1,
        borderColor: '$borderColor',
        shadowOpacity: 0,
        elevation: 0,
      },
    },
    isInteractive: {
      true: {
        pressStyle: {
          backgroundColor: '$cardBackgroundPress',
          opacity: 0.9,
        },
        hoverStyle: {
          backgroundColor: '$cardBackgroundHover',
        },
      },
    },
  } as const,

  defaultVariants: {
    variant: 'default',
    isInteractive: false,
  },
});

/**
 * AetherCard - A stylized card component following Aether design system
 *
 * @param variant - The visual style variant: 'default', 'elevated', or 'outlined'
 * @param isInteractive - Whether the card responds to press/hover states
 */
export function AetherCard({ children, variant, isInteractive, ...props }: AetherCardProps) {
  return (
    <StyledCard variant={variant} isInteractive={isInteractive} {...props}>
      {children}
    </StyledCard>
  );
}
```

### AetherListItem.tsx
**Path:** components/ui/primitives/AetherListItem.tsx
**Size:** 3353 bytes

```typescript
import React from 'react';
import { XStack, YStack, Text, styled, GetProps, Stack } from 'tamagui';
import { Ionicons } from '@expo/vector-icons';

// Base ListItem container
const ListItemContainer = styled(XStack, {
  name: 'ListItemContainer',
  backgroundColor: '$cardBackground',
  paddingVertical: '$3',
  paddingHorizontal: '$4',
  borderRadius: '$3',
  alignItems: 'center',
  justifyContent: 'space-between',
  borderBottomWidth: 1,
  borderBottomColor: '$borderColor',
  minHeight: 60,
  
  variants: {
    isLast: {
      true: {
        borderBottomWidth: 0,
      },
    },
    interactive: {
      true: {
        pressStyle: {
          backgroundColor: '$backgroundPress',
          opacity: 0.9,
        },
        hoverStyle: {
          backgroundColor: '$backgroundHover',
        },
      },
    },
    variant: {
      default: {},
      header: {
        backgroundColor: '$backgroundStrong',
        borderBottomColor: '$borderColor',
        paddingVertical: '$2',
      },
    },
  } as const,
  
  defaultVariants: {
    isLast: false,
    interactive: true,
    variant: 'default',
  },
});

type ListItemContainerProps = GetProps<typeof ListItemContainer>;

export interface AetherListItemProps extends ListItemContainerProps {
  title: string;
  subtitle?: string;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  showChevron?: boolean;
  badge?: string | number;
}

/**
 * AetherListItem - A consistent list item component for use in lists, menus, and settings
 *
 * @param title - The primary text
 * @param subtitle - Optional secondary text shown below the title
 * @param leftIcon - Optional icon component to show on the left side
 * @param rightIcon - Optional icon component to show on the right side
 * @param showChevron - Whether to show a right chevron (useful for navigation items)
 * @param badge - Optional badge text/number to display
 * @param isLast - Whether this is the last item in a list (removes bottom border)
 * @param interactive - Whether the item should visually respond to touch
 */
export function AetherListItem({
  title,
  subtitle,
  leftIcon,
  rightIcon,
  showChevron = false,
  badge,
  isLast,
  interactive,
  ...props
}: AetherListItemProps) {
  return (
    <ListItemContainer isLast={isLast} interactive={interactive} {...props}>
      {/* Left section with icon and text */}
      <XStack space="$3" flex={1} alignItems="center">
        {leftIcon && (
          <Stack marginRight="$2">{leftIcon}</Stack>
        )}
        
        <YStack>
          <Text fontWeight="500" fontSize="$4">{title}</Text>
          {subtitle && (
            <Text fontSize="$2" color="$gray10">{subtitle}</Text>
          )}
        </YStack>
      </XStack>
      
      {/* Right section with badge, custom icon or chevron */}
      <XStack space="$2" alignItems="center">
        {badge && (
          <XStack 
            backgroundColor="$primary"
            paddingHorizontal="$2"
            paddingVertical="$1"
            borderRadius="$2"
          >
            <Text color="white" fontSize="$1" fontWeight="bold">{badge}</Text>
          </XStack>
        )}
        
        {rightIcon && rightIcon}
        
        {showChevron && (
          <Ionicons name="chevron-forward" size={16} color="$gray10" />
        )}
      </XStack>
    </ListItemContainer>
  );
}
```

### SectionHeader.tsx
**Path:** components/ui/primitives/SectionHeader.tsx
**Size:** 1456 bytes

```typescript
import React from 'react';
import { XStack, Text, styled, GetProps, Button } from 'tamagui';

const SectionContainer = styled(XStack, {
  name: 'SectionContainer',
  paddingVertical: '$2',
  paddingHorizontal: '$4',
  marginTop: '$4',
  marginBottom: '$2',
  justifyContent: 'space-between',
  alignItems: 'center',
});

type SectionContainerProps = GetProps<typeof SectionContainer>;

export interface SectionHeaderProps extends SectionContainerProps {
  title: string;
  actionLabel?: string;
  onAction?: () => void;
}

/**
 * SectionHeader - A consistent section header with optional action button
 * 
 * Used to separate content sections in screens like Home, Settings, etc.
 *
 * @param title - The section title
 * @param actionLabel - Optional label for the action button
 * @param onAction - Optional callback when action button is pressed
 */
export function SectionHeader({ 
  title, 
  actionLabel, 
  onAction, 
  ...props 
}: SectionHeaderProps) {
  return (
    <SectionContainer {...props}>
      <Text 
        fontSize="$5" 
        fontWeight="600" 
        color="$color"
      >
        {title}
      </Text>
      
      {actionLabel && onAction && (
        <Button
          onPress={onAction}
          fontSize="$2"
          backgroundColor="transparent"
          color="$primary"
          paddingHorizontal="$2"
          height="$5"
        >
          {actionLabel}
        </Button>
      )}
    </SectionContainer>
  );
}
```

### index.ts
**Path:** components/ui/primitives/index.ts
**Size:** 324 bytes

```typescript
// Export all primitive components from a single file for easier imports
export { AetherCard } from './AetherCard';
export { AetherListItem, type AetherListItemProps } from './AetherListItem';
export { SectionHeader, type SectionHeaderProps } from './SectionHeader';

// Add additional primitive exports as they are created
```


# constants

### Colors.ts
**Path:** constants/Colors.ts
**Size:** 750 bytes

```typescript
/**
 * Below are the colors that are used in the app. The colors are defined in the light and dark mode.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */

const tintColorLight = '#0a7ea4';
const tintColorDark = '#fff';

export const Colors = {
  light: {
    text: '#11181C',
    background: '#fff',
    tint: tintColorLight,
    icon: '#687076',
    tabIconDefault: '#687076',
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: '#ECEDEE',
    background: '#151718',
    tint: tintColorDark,
    icon: '#9BA1A6',
    tabIconDefault: '#9BA1A6',
    tabIconSelected: tintColorDark,
  },
};
```

### motion.ts
**Path:** constants/motion.ts
**Size:** 3163 bytes

```typescript
import { Easing } from 'react-native-reanimated';

/**
 * Standard animation durations (in milliseconds)
 */
export const durations = {
  /** Ultra-fast for micro-interactions */
  micro: 80,
  /** Tap/press feedback */
  tap: 120,
  /** Default animation speed for most UI transitions */
  standard: 200,
  /** For more noticeable animations */
  medium: 250,
  /** Modal entrances/exits, complex transitions */
  modal: 300,
  /** Full screen transitions */
  screen: 350,
  /** Extended animations for emphasis */
  long: 450,
};

/**
 * Standard easing curves
 */
export const easings = {
  /** Quick acceleration, gradual deceleration - for elements entering the screen */
  enter: Easing.bezier(0.25, 0.1, 0.25, 1.0),
  /** Gradual acceleration, quick deceleration - for elements exiting the screen */
  exit: Easing.bezier(0.25, 0.0, 0.2, 1.0),
  /** For transitions between UI states */
  standard: Easing.bezier(0.4, 0.0, 0.2, 1.0),
  /** Quick in, quick out - for emphasis */
  energetic: Easing.bezier(0.55, 0.0, 0.1, 1.0),
  /** Linear - consistent motion with no acceleration/deceleration */
  linear: Easing.linear,
  /** Slow start, fast finish */
  accelerate: Easing.in(Easing.quad),
  /** Fast start, slow finish */
  decelerate: Easing.out(Easing.quad),
  /** Fast start and end, slower in the middle */
  emphasize: Easing.inOut(Easing.quad),
};

/**
 * Animation presets for common UI patterns
 */
export const presets = {
  fadeIn: {
    duration: durations.standard,
    easing: easings.enter,
  },
  fadeOut: {
    duration: durations.standard,
    easing: easings.exit,
  },
  slideIn: {
    duration: durations.modal,
    easing: easings.enter,
  },
  slideOut: {
    duration: durations.modal,
    easing: easings.exit,
  },
  scaleIn: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  scaleOut: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  tapFeedback: {
    duration: durations.tap,
    easing: easings.emphasize,
  },
  skeleton: {
    duration: durations.long * 2,
    easing: easings.linear,
  },
};

/**
 * Animation values for specific components
 */
export const componentAnimations = {
  toast: {
    show: {
      duration: durations.modal,
      easing: easings.enter,
    },
    hide: {
      duration: durations.standard,
      easing: easings.exit,
    },
  },
  modal: {
    overlay: {
      show: {
        duration: durations.modal,
        easing: easings.standard,
      },
      hide: {
        duration: durations.modal,
        easing: easings.standard,
      },
    },
    content: {
      show: {
        duration: durations.modal,
        easing: easings.enter,
      },
      hide: {
        duration: durations.standard,
        easing: easings.exit,
      },
    },
  },
  button: {
    press: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
    release: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
  },
  navigation: {
    screen: {
      duration: durations.screen,
      easing: easings.standard,
    },
    tab: {
      duration: durations.standard,
      easing: easings.standard,
    },
  },
}; ```


# debug

### toast-test.tsx
**Path:** debug/toast-test.tsx
**Size:** 1708 bytes

```typescript
import React from 'react';
import { Button, YStack, XStack, Text, Theme } from 'tamagui';
import { useToast } from '@/providers/ToastProvider';
import { StatusBar } from 'expo-status-bar';
import { View } from 'react-native';

export default function ToastTestScreen() {
  const { showToast } = useToast();

  const testSuccessToast = () => {
    showToast({
      type: 'success',
      title: 'Success',
      message: 'This is a success toast message',
      duration: 3000,
    });
  };

  const testErrorToast = () => {
    showToast({
      type: 'error',
      title: 'Error',
      message: 'This is an error toast message',
      duration: 3000,
    });
  };

  const testInfoToast = () => {
    showToast({
      type: 'info',
      message: 'This is an info toast without a title',
      duration: 3000,
    });
  };

  return (
    <View style={{ flex: 1 }}>
      <StatusBar style="auto" />
      <YStack
        flex={1}
        padding={20}
        space={16}
        justifyContent="center"
        alignItems="center"
      >
        <Text fontSize={24} fontWeight="bold" marginBottom={20}>
          Toast Test Screen
        </Text>
        
        <Button 
          onPress={testSuccessToast} 
          backgroundColor="$green6" 
          size="$4"
        >
          Show Success Toast
        </Button>
        
        <Button 
          onPress={testErrorToast} 
          backgroundColor="$red6" 
          size="$4"
        >
          Show Error Toast
        </Button>
        
        <Button 
          onPress={testInfoToast} 
          backgroundColor="$blue6" 
          size="$4"
        >
          Show Info Toast
        </Button>
      </YStack>
    </View>
  );
} ```


# (root files)

### debug_context.txt
**Path:** debug_context.txt
**Size:** 36754 bytes

```
========================================
 AETHERIPHONE DEBUG CONTEXT DUMP     
========================================

Date: 2025-04-30T04:41:00.809Z

========================================
FILE: tamagui.config.ts
----------------------------------------

// tamagui.config.ts
import { createAnimations } from '@tamagui/animations-react-native';
import { createFont, createTamagui, createTokens } from 'tamagui';
import { Platform } from 'react-native';
import * as MotionConstants from '@/constants/motion'; // Import motion constants

// Font definitions - Zelda Theme
// Assumes 'CalamitySans' and 'HyliaSerif' are loaded via useFonts or similar
const headingFont = createFont({
  family: 'HyliaSerif', // Zelda Display Font
  size: {
    // Mapped closer to iOS Dynamic Type: https://developer.apple.com/design/human-interface-guidelines/typography
    1: 13,  // Caption 2
    2: 15,  // Subheadline
    3: 17,  // Body (true default)
    4: 20,  // Title 3
    5: 22,  // Title 2
    6: 28,  // Title 1
    7: 34,  // Large Title
    8: 40,  // Extra Large Title (custom)
    true: 17, // Default size (Body)
  },
  lineHeight: {
    // Approximate line heights based on new sizes
    1: 18, 2: 20, 3: 22, 4: 25, 5: 28, 6: 34, 7: 41, 8: 50, 
    true: 22,
  },
  weight: {
    // Prompt 2 asks for 400-700
    4: '400', // Normal
    6: '600', // Semi-bold/Bold
    7: '700', // Extra-bold/Black
    true: '400',
  },
  letterSpacing: {
    1: 0, 2: 0, 3: -0.5, 4: -0.5, 5: -1, 6: -1, 7: -1.5, 8: -1.5,
    true: 0,
  },
  // Required: Map weights to specific font faces if needed (e.g., 'HyliaSerif-Bold')
  // face: {
  //   400: { normal: 'HyliaSerif-Regular' },
  //   700: { normal: 'HyliaSerif-Bold' },
  // },
});

const bodyFont = createFont({
  family: 'CalamitySans', // Zelda Body Font
  size: {
    // Mapped closer to iOS Dynamic Type
    1: 11,  // Footnote
    2: 12,  // Caption 1
    3: 13,  // Caption 2
    4: 15,  // Subheadline
    5: 17,  // Body (true default)
    6: 20,  // Title 3 (matching headingFont.$4)
    true: 17, // Default body size
  },
  lineHeight: {
    // Approximate line heights
    1: 13, 2: 16, 3: 18, 4: 20, 5: 22, 6: 25,
    true: 22, // Default body line height
  },
  weight: {
    4: '400', // Regular
    5: '500', // Medium (if available)
    7: '700', // Bold (if needed/available)
    true: '400',
  },
  letterSpacing: {
    1: 0.1, 2: 0.1, 3: 0, 4: 0, 5: -0.1, 6: -0.1,
    true: 0,
  },
  // Required: Map weights to specific font faces if needed (e.g., 'CalamitySans-Medium')
  // face: {
  //   400: { normal: 'CalamitySans-Regular' },
  //   500: { normal: 'CalamitySans-Medium' },
  // },
});

const monoFont = createFont({
  family: Platform.select({ web: 'monospace', default: 'SpaceMono' }), // Keep SpaceMono for code
  size: {
    1: 12, 2: 14, 3: 15, 4: 16, 5: 18, 6: 20, true: 15,
  },
  lineHeight: {
    1: 18, 2: 22, 3: 24, 4: 26, 5: 28, 6: 32, true: 24,
  },
  weight: {
    4: '400', // Normal weight
    true: '400',
  },
  letterSpacing: {
    4: 0,
    true: 0,
  },
  face: {
    400: { normal: 'SpaceMono' }, // Map weight 400 to the loaded SpaceMono font
  },
});

// Animation driver using reanimated
const animations = createAnimations({
  fast: {
    type: 'timing',
    duration: MotionConstants.durations.standard,
    // easing: MotionConstants.easings.standard, // Removed as createAnimations defaults work well
  },
  medium: {
    type: 'timing',
    duration: MotionConstants.durations.modal,
  },
  slow: {
    type: 'timing',
    duration: MotionConstants.durations.long,
  },
  bouncy: {
    type: 'spring',
    damping: 9,
    mass: 0.9,
    stiffness: 150,
  },
  lazy: {
    type: 'spring',
    damping: 18,
    stiffness: 50,
  },
  quick: {
    type: 'spring',
    damping: 20,
    mass: 1.2,
    stiffness: 250,
  },
});

// Standard Radix Gray scale (light theme)
const gray = {
  gray1: '#fcfcfc', gray2: '#f8f8f8', gray3: '#f3f3f3', gray4: '#ededed', gray5: '#e8e8e8', gray6: '#e2e2e2', gray7: '#dbdbdb', gray8: '#c7c7c7', gray9: '#8f8f8f', gray10: '#858585', gray11: '#6f6f6f', gray12: '#171717',
};

// Standard Radix Gray scale (dark theme)
const grayDark = {
  gray1: '#191919', gray2: '#212121', gray3: '#282828', gray4: '#303030', gray5: '#393939', gray6: '#424242', gray7: '#4f4f4f', gray8: '#626262', gray9: '#737373', gray10: '#838383', gray11: '#ababab', gray12: '#ededed',
};

// Tokens (refined based on your existing config)
const tokens = createTokens({
  size: {
    0: 0, 1: 4, 2: 8, 3: 12, 4: 16, 5: 20, 6: 24, 7: 28, 8: 32, 9: 36, 10: 40, 11: 44, 12: 48, 13: 52, 14: 56, 15: 60, 16: 64, true: 16,
  },
  space: {
    0: 0, 1: 4, 2: 8, 3: 12, 4: 16, 5: 20, 6: 24, 7: 28, 8: 32, 9: 36, 10: 40, 11: 44, 12: 48, 13: 52, 14: 56, 15: 60, 16: 64, true: 16, '-1': -4, '-2': -8, '-3': -12, '-4': -16,
  },
  radius: {
    0: 0, 1: 3, 2: 5, 3: 8, 4: 10, 5: 14, 6: 16, 7: 20, 8: 24, 9: 28, 10: 32, true: 10, // Updated radius.5 to 14
  },
  zIndex: { 0: 0, 1: 100, 2: 200, 3: 300, 4: 400, 5: 500 },
  color: {
    // Zelda Palette (Prompt 1)
    ...gray, // Add light greys
    ...grayDark, // Add dark greys (will be overridden in dark theme definition)
    parchment: '#FDFFE0',
    sheikahCyan: '#86A5A9',
    korokGreen: '#92C582',
    darkText: '#536F50',
    guardianOrange: '#FF9F0A',
    darkTealBg: '#1A2E3A',
    darkCyanGlow: '#64FFDA',

    // Shadow Colors (Prompt 5)
    shadowColorLight: 'rgba(83, 111, 80, 1)', // dark desaturated text color
    shadowColorDark: 'rgba(0, 0, 0, 1)', // Black base
    white: '#FFFFFF',
    black: '#000000',
  },
});

// Define themes using Zelda Palette
const lightTheme = {
  // Base Colors
  background: tokens.color.parchment,      // Light bg
  backgroundStrong: tokens.color.white,     // Keep white for strong contrast areas if needed
  backgroundTransparent: 'rgba(253, 255, 224, 0)', // Fully transparent parchment
  color: tokens.color.darkText,             // Dark desaturated text
  colorSecondary: tokens.color.darkText,      // Use main text color, maybe slightly lighter if needed later
  colorTertiary: tokens.color.sheikahCyan,    // Use accent for tertiary info?
  borderColor: tokens.color.sheikahCyan,      // Use accent for borders
  borderColorHover: tokens.color.korokGreen,  // Korok green on hover?

  // Theme-specific states (can refine later)
  backgroundHover: tokens.color.parchment,    // Keep parchment, maybe slightly darker/lighter
  backgroundPress: tokens.color.parchment,    // Keep parchment
  backgroundFocus: tokens.color.parchment,    // Keep parchment
  colorHover: tokens.color.korokGreen,        // Korok green text on hover?
  colorPress: tokens.color.korokGreen,
  colorFocus: tokens.color.sheikahCyan,
  borderColorPress: tokens.color.korokGreen,
  borderColorFocus: tokens.color.sheikahCyan,

  // Semantic Tokens (Prompt 4)
  accent: tokens.color.sheikahCyan,
  surfaceSubtle: tokens.color.parchment,    // Base color, apply opacity in component (e.g., rgba(253,255,224,0.8))
  destructive: tokens.color.guardianOrange,

  // Standard Semantic Mapping (can use Zelda colors)
  primary: tokens.color.sheikahCyan,        // Map primary to accent
  secondary: tokens.color.korokGreen,       // Map secondary to korok green?
  success: tokens.color.korokGreen,
  warning: tokens.color.guardianOrange,     // Use guardian orange for warning
  error: tokens.color.guardianOrange,       // Use guardian orange for error
  info: tokens.color.sheikahCyan,

  // Semantic Aliases (Playbook 1.1)
  surface: tokens.color.parchment, // Maps to background
  onSurface: tokens.color.darkText,  // Maps to color
  outline: tokens.color.sheikahCyan, // Maps to borderColor

  // Shadows (Playbook 1.1 & Prompt 5)
  shadowColor: tokens.color.shadowColorLight, // Use darkText color base for shadow
  shadowColorHover: 'rgba(83, 111, 80, 0.15)',
  shadowSm: 'rgba(83, 111, 80, 0.10)', // 10% opacity
  shadowMd: 'rgba(83, 111, 80, 0.15)', // 15% opacity
  shadowLg: 'rgba(83, 111, 80, 0.20)', // 20% opacity

  // Toast Themes (Report Item 6)
  toast_success_background: tokens.color.korokGreen,
  toast_success_color: tokens.color.parchment,
  toast_error_background: tokens.color.guardianOrange,
  toast_error_color: tokens.color.parchment,
  toast_warning_background: tokens.color.guardianOrange, // Often same as error
  toast_warning_color: tokens.color.parchment,
  toast_info_background: tokens.color.sheikahCyan,
  toast_info_color: tokens.color.parchment,
};

const darkTheme: typeof lightTheme = {
  // Base Colors
  ...grayDark, // Override light greys with dark greys
  background: tokens.color.darkTealBg,      // Dark-mode bg
  backgroundStrong: tokens.color.black,       // Black for contrast?
  backgroundTransparent: 'rgba(26, 46, 58, 0)', // Fully transparent dark teal
  color: tokens.color.parchment,          // Use light parchment for text
  colorSecondary: tokens.color.sheikahCyan,   // Sheikah cyan for secondary text
  colorTertiary: tokens.color.korokGreen,     // Korok green for tertiary
  borderColor: tokens.color.sheikahCyan,      // Sheikah cyan borders
  borderColorHover: tokens.color.darkCyanGlow, // Glow cyan on hover?

  // Theme-specific states
  backgroundHover: tokens.color.darkTealBg,   // Keep bg, maybe slightly lighter
  backgroundPress: tokens.color.darkTealBg,
  backgroundFocus: tokens.color.darkTealBg,
  colorHover: tokens.color.darkCyanGlow,
  colorPress: tokens.color.darkCyanGlow,
  colorFocus: tokens.color.darkCyanGlow,
  borderColorPress: tokens.color.darkCyanGlow,
  borderColorFocus: tokens.color.darkCyanGlow,

  // Semantic Tokens (Prompt 4)
  accent: tokens.color.sheikahCyan,
  surfaceSubtle: tokens.color.darkTealBg, // Use dark bg, apply opacity in component
  destructive: tokens.color.guardianOrange,

  // Standard Semantic Mapping
  primary: tokens.color.darkCyanGlow,       // Use glow cyan for primary actions
  secondary: tokens.color.korokGreen,
  success: tokens.color.korokGreen,
  warning: tokens.color.guardianOrange,
  error: tokens.color.guardianOrange,
  info: tokens.color.sheikahCyan,

  // Semantic Aliases (Playbook 1.1)
  surface: tokens.color.darkTealBg,   // Maps to background
  onSurface: tokens.color.parchment,  // Maps to color
  outline: tokens.color.sheikahCyan, // Maps to borderColor

  // Shadows (Playbook 1.1 & Prompt 5)
  shadowColor: tokens.color.shadowColorDark, // Darker shadow for dark mode
  shadowColorHover: 'rgba(0, 0, 0, 0.30)',
  shadowSm: 'rgba(0, 0, 0, 0.20)', // 20% opacity
  shadowMd: 'rgba(0, 0, 0, 0.30)', // 30% opacity
  shadowLg: 'rgba(0, 0, 0, 0.40)', // 40% opacity

  // Toast Themes (Report Item 6)
  toast_success_background: tokens.color.korokGreen,
  toast_success_color: tokens.color.darkTealBg,
  toast_error_background: tokens.color.guardianOrange,
  toast_error_color: tokens.color.darkTealBg,
  toast_warning_background: tokens.color.guardianOrange, // Often same as error
  toast_warning_color: tokens.color.darkTealBg,
  toast_info_background: tokens.color.sheikahCyan,
  toast_info_color: tokens.color.darkTealBg,
};

// Create the Tamagui config
const config = createTamagui({
  animations,
  shouldAddPrefersColorThemes: true,
  themeClassNameOnRoot: true,
  shorthands: {
    // Keep your existing shorthands
    m: 'margin', mt: 'marginTop', mr: 'marginRight', mb: 'marginBottom', ml: 'marginLeft', mx: 'marginHorizontal', my: 'marginVertical',
    p: 'padding', pt: 'paddingTop', pr: 'paddingRight', pb: 'paddingBottom', pl: 'paddingLeft', px: 'paddingHorizontal', py: 'paddingVertical',
    bg: 'backgroundColor', br: 'borderRadius', bw: 'borderWidth', bc: 'borderColor',
    f: 'flex', fd: 'flexDirection', ai: 'alignItems', jc: 'justifyContent', w: 'width', h: 'height',
    ac: 'alignContent',
    als: 'alignSelf',
    btc: 'borderTopColor',
    bbc: 'borderBottomColor',
    blc: 'borderLeftColor',
    brc: 'borderRightColor',
    boc: 'borderColor',
    bs: 'borderStyle',
    dsp: 'display',
    fb: 'flexBasis',
    fg: 'flexGrow',
    fs: 'flexShrink',
    fw: 'flexWrap',
    mah: 'maxHeight',
    maw: 'maxWidth',
    mih: 'minHeight',
    miw: 'minWidth',
    op: 'opacity',
    ov: 'overflow',
    r: 'right',
    shac: 'shadowColor',
    shar: 'shadowRadius',
    shof: 'shadowOffset',
    shop: 'shadowOpacity',
    t: 'top',
    ta: 'textAlign',
    tt: 'textTransform',
    va: 'verticalAlign',
    zi: 'zIndex',
  },
  fonts: {
    // Use Zelda fonts
    heading: headingFont,
    body: bodyFont,
    mono: monoFont, // Keep mono
  },
  themes: {
    light: lightTheme,
    dark: darkTheme,
  },
  tokens,
  media: { // Keep standard media queries
    xs: { maxWidth: 660 }, sm: { maxWidth: 800 }, md: { maxWidth: 1020 }, lg: { maxWidth: 1280 }, xl: { maxWidth: 1420 }, xxl: { maxWidth: 1600 },
    gtXs: { minWidth: 661 }, gtSm: { minWidth: 801 }, gtMd: { minWidth: 1021 }, gtLg: { minWidth: 1281 },
    short: { maxHeight: 820 }, tall: { minHeight: 820 },
    hoverNone: { hover: 'none' }, pointerCoarse: { pointer: 'coarse' },
  },
  settings: {
      allowedStyleValues: 'somewhat-strict',
      autocompleteSpecificTokens: 'except-special',
  },
});

type AppConfig = typeof config;

// Augment Tamagui interface - this is crucial!
declare module '@tamagui/core' {
  // If AppConfig is defined and exported:
  interface TamaguiCustomConfig extends AppConfig {}
}

export default config;

[EOF: tamagui.config.ts]

========================================
FILE: babel.config.js
----------------------------------------

module.exports = function (api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      // Inline env variables for Tamagui
      [
        'transform-inline-environment-variables',
        {
          include: ['TAMAGUI_TARGET'],
        },
      ],
      
      // Tamagui plugin for optimized compilation
      [
        '@tamagui/babel-plugin',
        {
          components: ['tamagui'],
          config: './tamagui.config.ts',
          logTimings: true,
          disableExtraction: process.env.NODE_ENV === 'development',
        },
      ],
      
      // Reanimated plugin must be last
      'react-native-reanimated/plugin',
    ],
  };
}; 

[EOF: babel.config.js]

========================================
FILE: providers/Providers.tsx
----------------------------------------

// providers/Providers.tsx
import { QueryClientProvider } from '@tanstack/react-query';
import { persistQueryClient } from '@tanstack/react-query-persist-client';
import { TamaguiProvider, type TamaguiProviderProps } from 'tamagui';
import { ToastProvider, ToastViewport } from '@tamagui/toast'; // Import from Tamagui Toast
import React, { useEffect, useState, type ReactNode } from 'react';
import { Platform } from 'react-native'; // Import Platform

import config from '../tamagui.config'; // Import your config
import { trpc } from '../utils/trpc'; // Your tRPC hook setup
import { queryClient, persister, initializeNetworkMonitoring, resumeMutationsAndInvalidate } from '@/utils/query-client';
import { useUiStore } from '@/stores/uiStore';
import { supabase } from '@/utils/supabase'; // Needed for auth link
import { createTRPCClient, httpBatchLink, TRPCLink, TRPCClientError } from '@trpc/client'; // Import TRPC Client utils
import { observable } from '@trpc/server/observable';
import type { AppRouter } from '../server/src/router'; // Adjust path if needed
import type { Session } from '@supabase/supabase-js';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

// Setup query client persistence
persistQueryClient({
  queryClient,
  persister,
  maxAge: 1000 * 60 * 60 * 24, // 24 hours
  dehydrateOptions: {
    shouldDehydrateMutation: () => false, // Usually don't dehydrate mutations
  },
});

// New component for the viewport using safe area
const CurrentToastViewport = () => {
  const { top, bottom, left, right } = useSafeAreaInsets();
  return (
    <>
      {/* Adjust positioning based on your desired toast location */}
      <ToastViewport
        name="global_top"
        flexDirection="column" // Stack new toasts below older ones
        top={top + 10} // Add padding below status bar
        left={left + 10} // Add padding from sides
        right={right + 10}
      />
      <ToastViewport
        name="global_bottom"
        flexDirection="column-reverse"
        bottom={bottom + 10}
        left={left + 10}
        right={right + 10}
      />
    </>
  );
};

// Extract tRPC links setup
function getTRPCLinks(getSession: () => Promise<Session | null>): TRPCLink<AppRouter>[] {
  const apiBaseUrl = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api/trpc'; // Default to localhost
  console.log('Using tRPC API URL:', apiBaseUrl);

  return [
    // Link to handle auth token injection and refresh
    (runtime) => {
      return ({ op, next }) => {
        return observable((observer) => {
          getSession().then(session => {
            const headers = (op.context?.headers || {}) as Record<string, string>;
            if (session?.access_token) {
              headers['Authorization'] = `Bearer ${session.access_token}`;
            }

            // Proceed with the request, ensuring context is passed correctly
            next({ ...op, context: { ...op.context, headers } })
              .subscribe({
                next: (value) => observer.next(value),
                error: async (err) => {
                  if (err instanceof TRPCClientError && err.data?.httpStatus === 401) {
                    console.log('tRPC: Token expired or invalid, attempting refresh...');
                    try {
                      // Supabase handles refresh internally if needed when getSession is called
                      const { data, error: refreshError } = await supabase.auth.refreshSession();
                      if (refreshError) throw refreshError;

                      if (data.session) {
                        console.log('tRPC: Session refreshed successfully, retrying request.');
                        const refreshedHeaders = { ...headers, Authorization: `Bearer ${data.session.access_token}` };
                        // Retry with new headers in context
                        next({ ...op, context: { ...op.context, headers: refreshedHeaders } }).subscribe(observer);
                      } else {
                        console.error('tRPC: Session refresh failed, no session returned.');
                        observer.error(err); // Propagate original error if no new session
                        // Optionally trigger logout here
                        supabase.auth.signOut();
                      }
                    } catch (refreshCatchError) {
                      console.error('tRPC: Session refresh catch error:', refreshCatchError);
                      observer.error(err); // Propagate original error
                      supabase.auth.signOut();
                    }
                  } else {
                    observer.error(err); // Propagate non-auth errors
                  }
                },
                complete: () => observer.complete(),
              });
          }).catch(err => {
             console.error('tRPC: Error getting session for headers:', err);
             observer.error(new TRPCClientError('Failed to get session')); // Use TRPCClientError
          });

          // Return cleanup function if needed
          return () => {};
        });
      };
    },
    // The terminating HTTP link
    httpBatchLink({
      url: apiBaseUrl,
       headers() {
         // Headers are injected by the middleware link above
         return {};
       },
      // Add superjson transformer here if you use one
      // transformer: superjson,
    }),
  ];
}

export function Providers({ children }: { children: ReactNode }) {
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';

  // Initialize network monitoring and query client persistence
  useEffect(() => {
    const unsubscribeNetworkMonitoring = initializeNetworkMonitoring();
    resumeMutationsAndInvalidate(); // Try resuming mutations on app load
    return () => {
      unsubscribeNetworkMonitoring();
    };
  }, []);

  // Memoize tRPC client creation
  const [trpcClient] = useState(() =>
    trpc.createClient({
      links: getTRPCLinks(async () => { // Pass session getter to links setup
        const { data } = await supabase.auth.getSession();
        return data.session;
      }),
    })
  );

  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <TamaguiProvider
            config={config}
            defaultTheme={currentTheme}
            // disableInjectCSS // May not be needed depending on setup
        >
          {/* Use Tamagui's ToastProvider */}
          <ToastProvider
            // burntOptions={{ from: 'top' }} // Disabled until native module 'Burnt' is installed
            swipeDirection="horizontal"
            duration={4000}
            native={[]}
          >
            {children}
            {/* Add the safe-area aware ToastViewport */}
            <CurrentToastViewport />
          </ToastProvider>
        </TamaguiProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
}

[EOF: providers/Providers.tsx]

========================================
FILE: app/_layout.tsx
----------------------------------------

// app/_layout.tsx
import React, { useCallback, useEffect, useState, ReactNode, createContext, useContext } from 'react';
import { Slot, SplashScreen, useRouter, useSegments } from 'expo-router';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { StatusBar } from 'expo-status-bar';
import { View, ActivityIndicator, Platform } from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { useFonts } from 'expo-font';
import { useColorScheme } from 'react-native';
import { TamaguiProvider, Theme } from 'tamagui'; // Consolidate Tamagui imports
import tamaguiConfig from '../tamagui.config'; // Use default import
import type { ThemeName } from '@tamagui/core'; // Ensure ThemeName is imported from @tamagui/core
import * as SecureStore from 'expo-secure-store'; // Import SecureStore

import { supabase } from '@/utils/supabase';

import type { Session } from '@supabase/supabase-js';

// Prevent the splash screen from auto-hiding
SplashScreen.preventAutoHideAsync();

/* ------------------------------------------------------------------ */
/*  1. Simple Auth-aware context                                       */
/* ------------------------------------------------------------------ */
interface AuthCtx {
  session: Session | null;
  isLoading: boolean;
}
export const AuthContext = React.createContext<AuthCtx>({
  session: null,
  isLoading: true,
});
export const useAuth = () => React.useContext(AuthContext);

/* ------------------------------------------------------------------ */
/*  2. The actual Provider                                             */
/* ------------------------------------------------------------------ */
function AuthProvider({ children }: { children: ReactNode }) {
  const [session, setSession] = useState<Session | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Initial session check
  useEffect(() => {
    supabase.auth.getSession().then(({ data }) => {
      setSession(data.session ?? null);
      setIsLoading(false);
      console.log('Initial session check:', data.session ? 'Session found' : 'No session');
    }).catch(error => {
        console.error("Error getting initial session:", error);
        setIsLoading(false);
    });

    // Subscribe to auth changes (login / logout / token refresh)
    const { data: authListener } = supabase.auth.onAuthStateChange(
      (_event, newSession) => {
        console.log('Auth state changed:', _event, newSession ? 'New session' : 'No session');
        setSession(newSession ?? null);
        // If the event is SIGNED_IN or TOKEN_REFRESHED, loading might briefly be true again
        // depending on how you handle redirects, but usually setting session is enough.
        // If SIGNED_OUT, ensure loading is false.
        if (_event === 'SIGNED_OUT') {
          setIsLoading(false);
        }
      },
    );

    return () => {
      authListener?.subscription.unsubscribe();
    };
  }, []);

  return (
    <AuthContext.Provider value={{ session, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
}

/* ------------------------------------------------------------------ */
/*  3. Enforce splash-screen logic & route guarding                    */
/* ------------------------------------------------------------------ */
function Root() {
  const { session, isLoading } = useAuth();
  const router = useRouter();
  const segments = useSegments(); // e.g., ["(tabs)", "home"] or ["(auth)", "login"]

  /* Load Fonts ----------------------------------------------------- */
  const [fontsLoaded, fontError] = useFonts({
    // Ensure font names match those used in tamagui.config.ts
    Inter: require('@tamagui/font-inter/otf/Inter-Medium.otf'),
    InterBold: require('@tamagui/font-inter/otf/Inter-Bold.otf'),
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
  });

  /* Handle Font Loading & Errors ----------------------------------- */
  useEffect(() => {
    if (fontError) {
      console.error("Font loading error:", fontError);
      // Decide how to handle font errors - maybe show an error message?
      // For now, we still need to hide splash eventually.
      SplashScreen.hideAsync();
    }
  }, [fontError]);

  /* Redirect Logic ------------------------------------------------- */
  useEffect(() => {
    // Wait until auth state is confirmed AND fonts are potentially loaded
    if (isLoading || !fontsLoaded && !fontError) return;

    const inAuthGroup = segments[0] === '(auth)';

    console.log(`Auth State: isLoading=${isLoading}, session=${!!session}, inAuthGroup=${inAuthGroup}, segments=${segments.join('/')}`);

    if (!session && !inAuthGroup) {
      console.log('Redirecting to login...');
      router.replace('/(auth)/login');
    } else if (session && inAuthGroup) {
      console.log('Redirecting to home...');
      router.replace('/(tabs)/home');
    } else {
        console.log('No redirect needed.');
    }
  }, [isLoading, session, segments, router, fontsLoaded, fontError]);

  /* Hide splash only when fonts loaded/error AND auth check done ---- */
  useEffect(() => {
    if ((fontsLoaded || fontError) && !isLoading) {
        console.log('Hiding SplashScreen...');
      SplashScreen.hideAsync();
    }
  }, [fontsLoaded, fontError, isLoading]);

  /* Show loading indicator until ready ----------------------------- */
  if (!fontsLoaded && !fontError || isLoading) {
    // Optionally, return the Splash Screen component itself or a custom loading view
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#1C1C1E' /* Approx dark bg */ }}>
        <ActivityIndicator size="large" color="#FFFFFF" />
      </View>
    );
  }

  // Once loaded and auth checked, render the content based on route
  return (
    <>
      <StatusBar style={Platform.OS === 'ios' ? 'light' : 'auto'} />
      <Slot />
    </>
  );
}

/* ------------------------------------------------------------------ */
/*  4. Wrap everything with SafeArea, Providers, etc.                  */
/* ------------------------------------------------------------------ */
import { ToastProvider, Toast, useToastState, ToastViewport } from '@tamagui/toast';
import { CheckCircle, AlertCircle, AlertTriangle, Info } from '@tamagui/lucide-icons';
import { YStack, XStack } from 'tamagui';
import { ThemeProvider, DarkTheme, DefaultTheme } from '@react-navigation/native';

const ACCENT_COLOR_KEY = 'userAccentColor';
const DEFAULT_ACCENT = 'blue'; // Set your default accent color theme name here

// Context to provide accent update function down the tree
const AccentContext = createContext({
  setAccent: (color: string) => {},
});
export const useAccent = () => useContext(AccentContext);

function RootLayoutNav() {
  const colorScheme = useColorScheme();
  const themeMode = colorScheme === 'dark' ? 'dark' : 'light';

  return (
    <ToastProvider swipeDirection="horizontal" duration={6000}>
      <Slot />
      <CurrentToast />
      <ToastViewport name="DefaultViewport" top={40} left={0} right={0} /> 
    </ToastProvider>
  );
}

function CurrentToast() {
  const currentToast = useToastState();

  if (!currentToast || currentToast.isHandledNatively) {
    return null;
  }

  const toastType = currentToast.customData?.type || 'info'; // Default to 'info'
  let themeName = 'toast_info'; // Default theme
  let IconComponent = Info;

  switch (toastType) {
    case 'success':
      themeName = 'toast_success';
      IconComponent = CheckCircle;
      break;
    case 'error':
      themeName = 'toast_error';
      IconComponent = AlertCircle;
      break;
    case 'warning':
      themeName = 'toast_warning';
      IconComponent = AlertTriangle;
      break;
  }

  return (
    <Theme name={themeName as ThemeName}> {/* Cast themeName to ThemeName */}
      <Toast
        key={currentToast.id}
        duration={currentToast.duration}
        enterStyle={{ opacity: 0, scale: 0.5, y: -25 }}
        exitStyle={{ opacity: 0, scale: 0.95, y: -10 }} // Adjusted exit style slightly
        y={0}
        opacity={1}
        scale={1}
        animation="bouncy" // Apply bouncy animation
        viewportName={currentToast.viewportName ?? 'DefaultViewport'}
        backgroundColor="$background" // Use background from the wrapped theme
        padding="$3"
        borderRadius="$4"
        marginHorizontal="$4"
        elevate
        shadowColor="$shadowColor"
      >
        <YStack space="$1">
          <XStack space="$2" alignItems="center">
            <IconComponent size={18} color="$color" /> {/* Use color from the wrapped theme */}
            <Toast.Title color="$color">{currentToast.title}</Toast.Title> {/* Use color from the wrapped theme */}
          </XStack>
          {!!currentToast.message && (
            <Toast.Description color="$color"> {/* Use color from the wrapped theme */}
              {currentToast.message}
            </Toast.Description>
          )}
        </YStack>
      </Toast>
    </Theme>
  );
}

function Providers({ children }: { children: React.ReactNode }) {
  const colorScheme = useColorScheme();
  const [accentColor, setAccentColor] = useState(DEFAULT_ACCENT);

  // Load accent color on mount
  useEffect(() => {
    const loadAccent = async () => {
      try {
        const savedAccent = await SecureStore.getItemAsync(ACCENT_COLOR_KEY);
        if (savedAccent) {
          setAccentColor(savedAccent);
        }
      } catch (error) {
        console.error('Failed to load accent color:', error);
      }
    };
    loadAccent();
  }, []);

  // Function to update and save accent color
  const handleSetAccent = useCallback(async (newColor: string) => {
    try {
      await SecureStore.setItemAsync(ACCENT_COLOR_KEY, newColor);
      setAccentColor(newColor);
    } catch (error) {
      console.error('Failed to save accent color:', error);
    }
  }, []);

  return (
    <AccentContext.Provider value={{ setAccent: handleSetAccent }}>
      <Theme name={accentColor as ThemeName}> {/* Cast accentColor to ThemeName */}
        {children}
      </Theme>
    </AccentContext.Provider>
  );
}

export default function RootLayout() {
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        {/* Core Providers (Tamagui, QueryClient, tRPC) */}
        <Providers>
          {/* Auth Provider manages session state */}
          <AuthProvider>
            {/* Root handles splash, font loading, and redirects */}
            <RootLayoutNav />
          </AuthProvider>
        </Providers>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}


[EOF: app/_layout.tsx]

========================================
FILE: package.json
----------------------------------------

{
  "name": "aetheriphone",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "test": "yarn test:ui && yarn test:server",
    "test:ui": "./node_modules/.bin/jest --config jest.config.ui.js",
    "test:server": "jest --config jest.config.server.js",
    "test:ui:watch": "./node_modules/.bin/jest --config jest.config.ui.js --watchAll",
    "test:server:watch": "jest --config jest.config.server.js --watchAll",
    "test:ci": "yarn test:ui --ci --silent && yarn test:server --ci --silent",
    "test:coverage": "jest --config jest.config.ui.js --coverage",
    "test:update": "jest --config jest.config.ui.js --updateSnapshot",
    "lint": "expo lint",
    "generate-types": "node ./scripts/generate-trpc-types.js",
    "generate-hooks": "node ./scripts/generate-trpc-client.js",
    "generate": "node ./scripts/generate-all.js",
    "dev": "npm run generate && expo start"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.2",
    "@hookform/resolvers": "^5.0.1",
    "@react-native-async-storage/async-storage": "1.23.1",
    "@react-native-community/netinfo": "^11.4.1",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "@shopify/flash-list": "^1.8.0",
    "@supabase/supabase-js": "^2.49.4",
    "@tamagui/animations-react-native": "1.126.1", 
    "@tamagui/config": "1.126.1", 
    "@tamagui/core": "1.126.1", 
    "@tamagui/font-inter": "1.126.1", 
    "@tamagui/lucide-icons": "1.126.1", 
    "@tamagui/react-native-media-driver": "1.126.1", 
    "@tamagui/shorthands": "1.126.1",
    "@tamagui/stacks": "1.126.1",
    "@tamagui/themes": "1.126.1",
    "@tamagui/toast": "1.126.1",
    "@tanstack/query-async-storage-persister": "^5.74.4",
    "@tanstack/react-query": "^5.74.4",
    "@tanstack/react-query-persist-client": "^5.74.4",
    "@testing-library/react-native": "^13.2.0",
    "@trpc/client": "^11.1.0",
    "@trpc/react-query": "^11.1.0",
    "@trpc/server": "^11.1.0",
    "burnt": "^0.13.0",
    "date-fns": "^4.1.0",
    "expo": "~52.0.46",
    "expo-blur": "~14.0.3",
    "expo-constants": "~17.0.8",
    "expo-dev-client": "~5.0.20",
    "expo-font": "~13.0.4",
    "expo-haptics": "~14.0.1",
    "expo-linking": "~7.0.5",
    "expo-router": "~4.0.20",
    "expo-secure-store": "^14.0.1",
    "expo-splash-screen": "~0.29.24",
    "expo-status-bar": "~2.0.1",
    "expo-symbols": "~0.2.2",
    "expo-system-ui": "~4.0.9",
    "expo-web-browser": "~14.0.2",
    "lottie-react-native": "7.1.0",
    "nativewind": "^4.1.19",
    "nats.ws": "^1.30.3",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-hook-form": "^7.56.1",
    "react-native": "0.76.9",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-reanimated": "^3.17.4",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-svg": "15.8.0",
    "react-native-url-polyfill": "^2.0.0",
    "react-native-web": "~0.19.13",
    "react-native-webview": "13.12.5",
    "tamagui": "1.126.1",
    "text-encoding": "^0.7.0",
    "zod": "^3.24.3",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@tamagui/babel-plugin": "1.126.1", 
    "@testing-library/jest-native": "^5.4.3",
    "@types/jest": "^29.5.12",
    "@types/react": "~18.3.12",
    "@types/react-test-renderer": "^18.3.0",
    "autoprefixer": "^10.4.21",
    "babel-plugin-transform-inline-environment-variables": "^0.4.4",
    "eslint": "^8.57.0",
    "eslint-config-expo": "~8.0.1",
    "jest": "^29.2.1",
    "jest-expo": "~52.0.6",
    "jest-mock-extended": "^4.0.0-beta1",
    "msw": "^2.1.5",
    "postcss": "^8.5.3",
    "react-test-renderer": "18.3.1",
    "supabase": "^2.22.4",
    "tailwindcss": "^3.4.17",
    "ts-jest": "^29.3.2",
    "typescript": "^5.3.3"
  },
  "private": true
}

[EOF: package.json]

========================================
FILE: tsconfig.json
----------------------------------------

{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "baseUrl": ".",
    "jsx": "react-native",
    "paths": {
      "@/*": [
        "./*"
      ],
      "server/*": [
        "./server/*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts",
    "server/**/*.ts"
  ]
}


[EOF: tsconfig.json]

```


# design-system

### Animations.ts
**Path:** design-system/Animations.ts
**Size:** 1221 bytes

```typescript
// design-system/Animations.ts
// Moti animation presets for consistent effects across the app

// Fade in from bottom
export const fadeInUp = {
  from: { opacity: 0, translateY: 16 },
  animate: { opacity: 1, translateY: 0 },
  exit: { opacity: 0, translateY: 16 },
  transition: { type: 'timing', duration: 350 },
};

// Slide out to left (for swipe to complete)
export const slideOutLeft = {
  from: { translateX: 0 },
  animate: { translateX: -100 },
  exit: { translateX: -100 },
  transition: { type: 'spring', dampingRatio: 0.7 },
};

// Zelda-themed glowing effect
export const sheikahGlow = {
  from: { opacity: 0.4, scale: 0.95 },
  animate: { opacity: 1, scale: 1 },
  exit: { opacity: 0.4, scale: 0.95 },
  transition: { type: 'timing', duration: 800, loop: true },
};

// Task completion animation
export const taskComplete = {
  from: { opacity: 1, translateX: 0 },
  animate: { opacity: 0.6, translateX: -5 },
  transition: { type: 'spring', dampingRatio: 0.8 },
};

// Korok reveal animation (for success states)
export const korokReveal = {
  from: { opacity: 0, scale: 0.7, rotate: '-10deg' },
  animate: { opacity: 1, scale: 1, rotate: '0deg' },
  transition: { type: 'spring', dampingRatio: 0.6 },
};
```

### Primitives.tsx
**Path:** design-system/Primitives.tsx
**Size:** 774 bytes

```typescript
// design-system/Primitives.tsx
import React from 'react';
import { styled } from 'nativewind';
import * as gs from '@gluestack-ui/themed';

// Styled components that accept className prop for NativeWind
export const Stack = styled(gs.View);
export const Text = styled(gs.Text);
export const Button = styled(gs.Button);
export const Pressable = styled(gs.Pressable);

// Re-export other Gluestack components that might be needed
export const HStack = styled(gs.HStack);
export const VStack = styled(gs.VStack);
export const Center = styled(gs.Center);
export const ScrollView = styled(gs.ScrollView);

// Forward gluestack hooks
export const useToast = gs.useToast;
export const useColorMode = gs.useColorMode;

// Export all other Gluestack components as-is
export { gs };
```

### theme.glue.ts
**Path:** design-system/theme.glue.ts
**Size:** 896 bytes

```typescript
// design-system/theme.glue.ts
import { config } from '@gluestack-ui/themed';
import tokens from './tokens';

// Convert our tokens to Gluestack theme config
export const glueTheme = config({
  tokens: {
    colors: tokens.colors,
    space: tokens.space,
    radii: tokens.radii,
    fonts: tokens.fonts,
  },
  aliases: {
    // Map our tokens to Gluestack's expected properties
    bg: 'backgroundColor',
    h: 'height',
    w: 'width',
    p: 'padding',
    px: 'paddingHorizontal',
    py: 'paddingVertical',
    m: 'margin',
    mx: 'marginHorizontal',
    my: 'marginVertical',
    rounded: 'borderRadius',
  },
  globalStyle: {
    variants: {
      light: {
        backgroundColor: tokens.colors.parchment,
        color: tokens.colors.darkText,
      },
      dark: {
        backgroundColor: tokens.colors.darkTealBg,
        color: tokens.colors.parchment,
      },
    },
  },
});
```

### tokens.ts
**Path:** design-system/tokens.ts
**Size:** 1325 bytes

```typescript
// design-system/tokens.ts
// Shared tokens used by both NativeWind and Gluestack UI

export const colors = {
  // Zelda theme colors from memories
  'parchment': '#FDFFE0',
  'sheikahCyan': '#86A5A9',
  'korokGreen': '#92C582',
  'darkText': '#536F50',
  'guardianOrange': '#FF9F0A',
  'darkTealBg': '#1A2E3A',
  'cyanGlow': '#64FFDA',
  
  // Semantic aliases
  'surface': '#FDFFE0', // parchment in light mode
  'onSurface': '#536F50', // darkText in light mode
  'outline': '#86A5A9', // sheikahCyan in both modes
  
  // Shadow colors with opacities
  'shadowSm': 'rgba(83, 111, 80, 0.10)', // Light theme
  'shadowMd': 'rgba(83, 111, 80, 0.15)',
  'shadowLg': 'rgba(83, 111, 80, 0.20)',
  'shadowDarkSm': 'rgba(0, 0, 0, 0.20)', // Dark theme
  'shadowDarkMd': 'rgba(0, 0, 0, 0.30)',
  'shadowDarkLg': 'rgba(0, 0, 0, 0.40)',
};

export const radii = {
  'sm': 4,
  'md': 8,
  'lg': 16,
  'xl': 24,
  'full': 9999,
};

export const space = {
  '0': 0,
  '0.5': 2,
  '1': 4,
  '2': 8,
  '3': 12,
  '4': 16,
  '5': 20,
  '6': 24,
  '8': 32,
  '10': 40,
  '12': 48,
  '16': 64,
};

export const sizes = {
  ...space,
};

export const fonts = {
  'heading': 'HyliaSerif',
  'body': 'CalamitySans',
  'mono': 'SpaceMono',
};

// Default export with all tokens
export default {
  colors,
  radii,
  space,
  sizes,
  fonts,
};
```


# (root files)

### eas.json
**Path:** eas.json
**Size:** 343 bytes

```json
{
  "cli": {
    "version": ">= 16.3.2",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "distribution": "internal"
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}
```

### file_hierarchy.txt
**Path:** file_hierarchy.txt
**Size:** 5451 bytes

```
.
./.expo
./.expo/types
./.expo/types/router.d.ts
./.expo/settings.json
./.expo/README.md
./.expo/devices.json
./types
./types/trpc-types.ts
./types/index.ts
./tailwind.config.js
./ts_errors.log
./app
./app/compose.tsx
./app/index.tsx
./app/toast-test.tsx
./app/auth
./app/auth/login.tsx
./app/auth/update-password.tsx
./app/auth/register.tsx
./app/auth/_layout.tsx
./app/auth/forgot-password.tsx
./app/auth/verify-email.tsx
./app/(tabs)
./app/(tabs)/settings
./app/(tabs)/settings/index.tsx
./app/(tabs)/home
./app/(tabs)/home/index.tsx
./app/(tabs)/home/details.tsx
./app/(tabs)/home/_layout.tsx
./app/(tabs)/planner
./app/(tabs)/planner/index.tsx
./app/(tabs)/rewards
./app/(tabs)/rewards/index.tsx
./app/(tabs)/_layout.tsx
./app/(tabs)/compass
./app/(tabs)/compass/index.tsx
./app/(tabs)/explore.tsx
./app/utils
./app/utils/api-types.ts
./app/+not-found.tsx
./app/_layout.tsx
./app.d.ts
./app.json
./.expo 2
./constants
./constants/Colors.ts
./constants/motion.ts
./providers
./providers/ToastProvider.tsx
./providers/AppProvider.tsx
./providers/ConfettiProvider.tsx
./providers/Providers.tsx
./AETHER_TODO.md
./expo-env.d.ts
./output
./output/app_code_overview.txt
./stores
./stores/uiStore.ts
./modals
./server
./server/package-lock.json
./server/package.json
./server/.env
./server/tsconfig.json
./server/src
./server/src/routers
./server/src/routers/dashboardRouter.ts
./server/src/routers/habitRouter.ts
./server/src/routers/rewardsRouter.ts
./server/src/routers/taskRouter.ts
./server/src/routers/valueRouter.ts
./server/src/routers/goalRouter.ts
./server/src/routers/trackedStateRouter.ts
./server/src/routers/userRouter.ts
./server/src/router.ts
./server/src/context.ts
./server/src/index.ts
./utils
./utils/colors.ts
./utils/query-client.ts
./utils/offline-sync.ts
./utils/trpc.ts
./utils/settings.ts
./utils/nats-client.ts
./utils/haptics.ts
./utils/generated-hooks.ts
./utils/supabase.ts
./utils/auth.ts
./utils/offline-mutations.ts
./utils/mock-api.ts
./eas.json
./.tamagui
./.tamagui/tamagui.config.json
./supabase
./supabase/migrations
./supabase/migrations/20250424035717_add_missing_tables.sql
./supabase/migrations/20250424035232_add_missing_tables.sql
./supabase/migrations/20250424033333_initial_schema.sql
./supabase/migrations/20250425000000_create_user_settings_table.sql
./supabase/migrations/20250426000000_create_rewards_tables.sql
./supabase/.branches
./supabase/.branches/_current_branch
./supabase/.temp
./supabase/.temp/postgres-version
./supabase/.temp/project-ref
./supabase/.temp/rest-version
./supabase/.temp/storage-version
./supabase/.temp/gotrue-version
./supabase/.temp/pooler-url
./supabase/.temp/cli-latest
./supabase/.gitignore
./supabase/config.toml
./README.md
./assets 2
./components
./components/ui
./components/ui/ConfettiButton.tsx
./components/ui/FrostedCard.tsx
./components/ui/TabBarBackground.tsx
./components/ui/IconSymbol.ios.tsx
./components/ui/AnimatedCountingText.tsx
./components/ui/iOS
./components/ui/iOS/NativeWindButton.tsx
./components/ui/iOS/Button.tsx
./components/ui/TabBarBackground.ios.tsx
./components/ui/FloatingActionButton.tsx
./components/ui/Button.tsx
./components/ui/ErrorBanner.tsx
./components/ui/HabitToggleRow.tsx
./components/ui/IconSymbol.tsx
./components/ui/Skeleton.tsx
./components/ui/nativewind-setup.tsx
./components/settings
./components/settings/ThemePreview.tsx
./components/settings/NotificationRow.tsx
./components/ExternalLink.tsx
./components/ThemedText.tsx
./components/auth
./components/auth/FloatingInput.tsx
./components/planner
./components/planner/HabitsList.tsx
./components/planner/HabitTracker.tsx
./components/planner/StreakCalendar.tsx
./components/planner/GoalsList.tsx
./components/ThemedView.tsx
./components/EmptyOrSkeleton.tsx
./components/rewards
./components/rewards/ConfettiBurst.tsx
./components/HelloWave.tsx
./components/aether
./components/aether/GoalCard.tsx
./components/aether/ProgressRing.tsx
./components/aether/ValueBadge.tsx
./components/aether/AetherCard.tsx
./components/aether/HabitCard.tsx
./components/dashboard
./components/dashboard/DashboardSection.tsx
./components/dashboard/GoalSummaryCard.tsx
./components/dashboard/StateIndicator.tsx
./components/dashboard/HabitCheckItem.tsx
./components/dashboard/TaskItem.tsx
./components/__tests__
./components/__tests__/ThemedText-test.tsx
./components/__tests__/__snapshots__
./components/__tests__/__snapshots__/ThemedText-test.tsx.snap
./components/ParallaxScrollView.tsx
./components/HapticTab.tsx
./components/OfflineIndicator.tsx
./components/Collapsible.tsx
./yarn.lock
./file_hierarchy.txt
./babel.config.js
./.gitignore
./package.json
./.env
./hooks
./hooks/useSkeleton.ts
./hooks/useColorScheme.web.ts
./hooks/useThemeColor.ts
./hooks/useColorScheme.ts
./hooks/useOfflineSync.ts
./scripts
./scripts/generate-all.js
./scripts/generate-trpc-types.js
./scripts/reset-project.js
./scripts/generate-trpc-client.js
./scripts/generate_app_code_overview.sh
./.github
./.github/workflows
./.github/workflows/ci.yml
./.eslintrc.js
./global.d.ts
./tsconfig.json
./.env.example
./postcss.config.js
./assets
./assets/images
./assets/images/icon.png
./assets/images/partial-react-logo.png
./assets/images/react-logo@2x.png
./assets/images/react-logo@3x.png
./assets/images/favicon.png
./assets/images/adaptive-icon.png
./assets/images/react-logo.png
./assets/images/splash-icon.png
./assets/fonts
./assets/fonts/SpaceMono-Regular.ttf
./tamagui.config.ts
./SUPABASE_INTEGRATION.md
```

### gather_debug_info.js
**Path:** gather_debug_info.js
**Size:** 1659 bytes

```javascript
// gather_debug_info.js
// Reads and exports the content of key configuration and source files for debugging purposes.

const fs = require('fs');
const path = require('path');

const projectRoot = path.resolve(__dirname); // Assumes this script is run from the project root
const outputFileName = 'debug_context.txt';

const filesToRead = [
  'tamagui.config.ts',
  'babel.config.js',
  'providers/Providers.tsx',
  'app/_layout.tsx',
  'package.json',
  'tsconfig.json'
];

let combinedContent = `========================================\n`;
combinedContent += ` AETHERIPHONE DEBUG CONTEXT DUMP     \n`;
combinedContent += `========================================\n\n`;
combinedContent += `Date: ${new Date().toISOString()}\n\n`;


filesToRead.forEach(filePath => {
  const fullPath = path.join(projectRoot, filePath);
  combinedContent += `========================================\n`;
  combinedContent += `FILE: ${filePath}\n`;
  combinedContent += `----------------------------------------\n\n`;
  try {
    const content = fs.readFileSync(fullPath, 'utf-8');
    combinedContent += content;
    console.log(`Successfully read: ${filePath}`);
  } catch (error) {
    const errorMessage = `Error reading file ${filePath}: ${error.message}`;
    combinedContent += errorMessage;
    console.error(`Error reading file ${filePath}:`, error);
  }
  combinedContent += `\n\n[EOF: ${filePath}]\n\n`;
});

try {
  fs.writeFileSync(path.join(projectRoot, outputFileName), combinedContent);
  console.log(`\nSuccessfully wrote combined content to ${outputFileName}`);
} catch (error) {
  console.error(`\nError writing to output file ${outputFileName}:`, error);
}```

### gather_implementation_details.sh
**Path:** gather_implementation_details.sh
**Size:** 5042 bytes

```bash
#!/bin/bash

# Create or truncate the implementation_details.txt file
echo "# Aether iPhone: Implementation Details for Migration Questions" > implementation_details.txt
echo "Generated on $(date)" >> implementation_details.txt
echo "" >> implementation_details.txt

# Function to add a file to the output with header
add_file_with_header() {
  local filename=$1
  local header=$2
  
  echo "\n\n## $header" >> implementation_details.txt
  
  if [ -f "$filename" ]; then
    echo "**File:** $filename" >> implementation_details.txt
    echo "\n\`\`\`" >> implementation_details.txt
    cat "$filename" >> implementation_details.txt
    echo "\`\`\`" >> implementation_details.txt
    echo "Added $filename to implementation_details.txt"
  else
    echo "**File not found:** $filename" >> implementation_details.txt
  fi
}

# Function to add just a section header
add_section_header() {
  local header=$1
  echo "\n\n# $header" >> implementation_details.txt
}

# 1. tRPC Routers and Procedures
add_section_header "1️⃣ tRPC Router Names & Procedure Signatures"

# First, find all router files
echo "\n## Router Definitions" >> implementation_details.txt
find server/src/routers -name "*.ts" -type f 2>/dev/null | while read file; do
  router_name=$(basename "$file" .ts)
  add_file_with_header "$file" "Router: $router_name"
done

# Look for router imports/exports to find the main app router
echo "\n## Router Import/Export Structure" >> implementation_details.txt
add_file_with_header "server/src/routers/index.ts" "Main App Router"

# Check if there's a dashboard-specific router
add_file_with_header "server/src/routers/dashboardRouter.ts" "Dashboard Router"

# Core entity routers (based on user's mention)
ROUTERS=(
  "server/src/routers/goalRouter.ts"
  "server/src/routers/taskRouter.ts"
  "server/src/routers/habitRouter.ts"
  "server/src/routers/profileRouter.ts"
  "server/src/routers/principleRouter.ts"
  "server/src/routers/rewardRouter.ts"
)

for file in "${ROUTERS[@]}"; do
  router_name=$(basename "$file" .ts | sed 's/Router//')
  add_file_with_header "$file" "$router_name Router"
done

# 2. Points Economy Endpoint
add_section_header "2️⃣ Points Economy Endpoint"

# Look for reward or points related files
echo "\n## Reward System Implementation" >> implementation_details.txt

# Check for reward/points routers
add_file_with_header "server/src/routers/rewardRouter.ts" "Reward Router"

# Check for points mutation handlers
find server/src -name "*.ts" -type f -exec grep -l "points\|rupees\|reward" {} \; 2>/dev/null | while read file; do
  if [[ $file != *test* ]]; then
    add_file_with_header "$file" "Points/Rewards Handler: $(basename "$file")"
  fi
done

# Frontend reward/points components
find components -name "*.tsx" -type f -exec grep -l "points\|rupees\|reward" {} \; 2>/dev/null | while read file; do
  if [[ $file != *test* ]]; then
    component_name=$(basename "$file" .tsx)
    add_file_with_header "$file" "Points/Rewards Component: $component_name"
  fi
done

# 3. Realtime Strategy
add_section_header "3️⃣ Realtime Strategy"

# Check for Supabase realtime implementation
echo "\n## Supabase Realtime Implementation" >> implementation_details.txt

# Look for channel subscriptions
find . -name "*.ts" -o -name "*.tsx" | grep -v "node_modules\|.git" | xargs grep -l "supabase.*channel\|on(\|channel" 2>/dev/null | while read file; do
  add_file_with_header "$file" "Realtime Channel: $(basename "$file")"
done

# Check for polling mechanisms
echo "\n## Polling Implementation" >> implementation_details.txt
find . -name "*.ts" -o -name "*.tsx" | grep -v "node_modules\|.git" | xargs grep -l "refetchInterval\|polling\|setInterval" 2>/dev/null | while read file; do
  add_file_with_header "$file" "Polling: $(basename "$file")"
done

# 4. Core Query Hooks
add_section_header "4️⃣ Core Query Hooks"

# Extract query hooks from the codebase
find hooks -name "*.ts" -type f 2>/dev/null | while read file; do
  hook_name=$(basename "$file" .ts)
  add_file_with_header "$file" "Hook: $hook_name"
done

# Look for any usage of tRPC queries
echo "\n## tRPC Query Usage Examples" >> implementation_details.txt
find app -name "*.tsx" -type f | xargs grep -l "useQuery\|useMutation\|trpc" 2>/dev/null | head -5 | while read file; do
  add_file_with_header "$file" "tRPC Query Example: $(basename "$file")"
done

# 5. Swipe-to-Complete Implementation
add_section_header "5️⃣ Dashboard "Task Swipe → Done" Flow"

# Look for swipe implementations
add_file_with_header "components/ui/SwipeableRow.tsx" "SwipeableRow Component"
add_file_with_header "components/dashboard/TaskItem.tsx" "TaskItem Component"

# Check task completion handlers
find . -name "*.ts" -o -name "*.tsx" | grep -v "node_modules\|.git" | xargs grep -l "completeTask\|onComplete\|markTaskComplete" 2>/dev/null | while read file; do
  add_file_with_header "$file" "Task Completion Handler: $(basename "$file")"
done

echo "\nAll implementation details for your open questions have been collected in implementation_details.txt"
```

### gather_integrated_context.sh
**Path:** gather_integrated_context.sh
**Size:** 5734 bytes

```bash
#!/bin/bash

# Create or truncate the project.txt file
echo "# Aether iPhone: Tamagui to Gluestack/NativeWind Migration" > project.txt
echo "Generated on $(date)" >> project.txt
echo "" >> project.txt

# Function to add a file to the project.txt with header
add_file_with_header() {
  local filename=$1
  local header=$2
  
  echo "\n\n## $header" >> project.txt
  
  if [ -f "$filename" ]; then
    echo "**Current implementation:** $filename" >> project.txt
    echo "\n\`\`\`" >> project.txt
    cat "$filename" >> project.txt
    echo "\`\`\`" >> project.txt
    echo "Added $filename to project.txt"
  else
    echo "**File planned but not yet created:** $filename" >> project.txt
  fi
}

# Function to add just the section header
add_section_header() {
  local header=$1
  echo "\n\n# $header" >> project.txt
}


# --- 1. Core Design System ---
add_section_header "1️⃣ Core Design System"
echo "\nMigration path: Tamagui tokens → Gluestack UI + NativeWind" >> project.txt

# Add current tamagui.config.ts
add_file_with_header "tamagui.config.ts" "Current tokens (tamagui.config.ts)"

# Add current tailwind.config.js
add_file_with_header "tailwind.config.js" "tailwind.config.js (to be rewritten)"

# Add constants/motion.ts for animation reference
add_file_with_header "constants/motion.ts" "Motion constants"

# Note planned files that don't exist yet
echo "\n\n## Planned new files" >> project.txt
echo "* tokens.ts - Export Tailwind-ready object instead of Tamagui createTokens" >> project.txt
echo "* theme.glue.ts - Wire Zelda palette & fonts into Gluestack provider" >> project.txt 
echo "* Primitives.tsx - Create wrappers for Gluestack equivalents" >> project.txt
echo "* Animations.ts - Create reusable Moti presets" >> project.txt


# --- 2. Global Providers ---
add_section_header "2️⃣ Global Providers"

# Current app/_layout.tsx implementation
add_file_with_header "app/_layout.tsx" "Current app/_layout.tsx (to be rewritten)"

# Show existing provider implementations
find providers -name "*.tsx" -type f 2>/dev/null | while read file; do
  filename=$(basename "$file")
  add_file_with_header "$file" "Current $filename (to be refactored)"
done

# Note planned providers
echo "\n\n## Planned new providers" >> project.txt
echo "* providers/TRPCProvider.tsx - Instantiate trpc.createClient() + React Query" >> project.txt
echo "* providers/SupabaseProvider.tsx - Context for supabase-js instance + session" >> project.txt


# --- 3. Navigation Shells ---
add_section_header "3️⃣ Navigation Shells (Expo Router)"

# Current tab layout implementation
add_file_with_header "app/(tabs)/_layout.tsx" "Current tab layout (to be rewritten)"

# Current auth layout implementation
add_file_with_header "app/(auth)/_layout.tsx" "Current auth layout"


# --- 4. Reusable Components ---
add_section_header "4️⃣ Reusable Components"

# Show current primitive components
echo "\n\n## Current UI primitives" >> project.txt
find components/ui/primitives -name "*.tsx" -type f 2>/dev/null | while read file; do
  component_name=$(basename "$file" .tsx)
  add_file_with_header "$file" "$component_name"
done

# Show some key components that will need conversion
echo "\n\n## Key components to migrate" >> project.txt
KEY_COMPONENTS=(
  "components/ui/Container.tsx"
  "components/ui/EmptyOrSkeleton.tsx"
  "components/dashboard/DashboardSection.tsx"
  "components/dashboard/GoalSummaryCard.tsx"
)

for file in "${KEY_COMPONENTS[@]}"; do
  if [ -f "$file" ]; then
    component_name=$(basename "$file" .tsx)
    add_file_with_header "$file" "$component_name"
  fi
done

# Note planned components
echo "\n\n## Planned new components" >> project.txt
echo "* SectionCard.tsx - Glazed parchment card with header, children slot" >> project.txt
echo "* StatBadge.tsx - Heart/rupee style KPI badge" >> project.txt
echo "* SkeletonCard.tsx - NativeWind animated placeholder" >> project.txt
echo "* EmptyState.tsx - Triforce-in-cloud illustration + call-to-action" >> project.txt


# --- 5. Feature Screens ---
add_section_header "5️⃣ Feature Screens"

# Show current implementations of main feature screens
echo "\n\n## Current implementations" >> project.txt
FEATURE_SCREENS=(
  "app/(tabs)/home/index.tsx"
  "app/(tabs)/planner/index.tsx"
  "app/(tabs)/compass/index.tsx"
  "app/(tabs)/rewards/index.tsx"
  "app/(tabs)/settings/index.tsx"
)

for file in "${FEATURE_SCREENS[@]}"; do
  if [ -f "$file" ]; then
    screen_name=$(echo "$file" | sed 's/.*\/(.*)\/\(.*\)\/index.tsx/\1-\2/')
    add_file_with_header "$file" "Current $screen_name screen"
  fi
done


# --- 6. Utilities & Hooks ---
add_section_header "6️⃣ Utils & Hooks"

# Show current client implementations
UTIL_FILES=(
  "utils/supabase.ts"
  "utils/trpc.ts"
)

for file in "${UTIL_FILES[@]}"; do
  if [ -f "$file" ]; then
    util_name=$(basename "$file" .ts)
    add_file_with_header "$file" "$util_name"
  fi
done

# --- 7. Type Definitions (for reference) ---
add_section_header "Type Definitions (for reference)"

TYPE_FILES=(
  "utils/api-types.ts"
  "server/src/types/trpc-types.ts"
)

for file in "${TYPE_FILES[@]}"; do
  if [ -f "$file" ]; then
    type_file=$(basename "$file" .ts)
    add_file_with_header "$file" "$type_file"
  fi
done


# --- 8. Assets ---
add_section_header "7️⃣ Assets"

# Just list asset directories
echo "\n\n## Font Files in assets/fonts:" >> project.txt
ls -la assets/fonts 2>/dev/null >> project.txt || echo "No font directory found" >> project.txt

echo "\n\n## Lottie Files in assets:" >> project.txt
find assets -name "*.json" 2>/dev/null | sort >> project.txt || echo "No Lottie files found" >> project.txt

echo "\n\nAll migration context has been collected in project.txt with integrated file contexts"
```

### gather_project_context.sh
**Path:** gather_project_context.sh
**Size:** 11828 bytes

```bash
#!/bin/bash

# Create or truncate the project.txt file
echo "# Aether iPhone Project Context for Tamagui to Gluestack/NativeWind Migration" > project.txt
echo "Generated on $(date)" >> project.txt

# Add refactoring plan to the beginning
cat << 'EOF' >> project.txt

## Refactoring Plan

File-by-file work-order for the frontend refactor.
* Top-level paths follow an Expo Router layout (app/…)
* 🔮 marks assumptions to be confirmed

### 1️⃣ Core Design System (/design-system)

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| tokens.ts | keep → export Tailwind-ready object instead of Tamagui createTokens | n/a | single source for color / spacing across Gluestack and NativeWind |
| theme.glue.ts | new – export const gluestackTheme = {tokens, components} | tokens.ts, Gluestack | wires Zelda palette + fonts into Gluestack provider |
| tailwind.config.js | rewrite with content: ["app/**/*.{tsx,ts}"] + colors from tokens | tokens.ts, NativeWind | unlocks className="bg-parchment" etc. in JSX |
| Primitives.tsx | new – <Stack> <Text> <Button> wrappers ⮕ Gluestack equivalents | gluestackTheme | lets old code migrate screen-by-screen w/out mass edits |
| Animations.ts | new – reusable Moti presets (fadeInUp, runePulse) | moti, react-native-reanimated | consistent motion language |

### 2️⃣ Global Providers

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| app/_layout.tsx | rewrite – wrap with <GluestackProvider theme={gluestackTheme}>, <TRPCProvider>, <SupabaseProvider> | theme.glue.ts, 🔮 TRPCProvider, 🔮 SupabaseProvider | guarantees every screen sees styled components + auth + queries |
| providers/TRPCProvider.tsx | new – instantiates trpc.createClient() + React Query | @trpc/client, @tanstack/react-query | centralises tRPC; screens just useTRPCQuery() |
| providers/SupabaseProvider.tsx | new – context for supabase-js instance + session | @supabase/auth-helpers-react | avoids prop-drilling, keeps auth refresh logic isolated |

### 3️⃣ Navigation Shells (Expo Router)

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| app/(tabs)/_layout.tsx | rewrite – BottomTabs with icons (Shield, Scroll, Compass, Ruby, Cog) | gluestack/svg icons | Zelda-flavoured nav & group-wide background parchment |
| app/(tabs)/index.tsx | rewrite – Home list (see SectionCard) | 📄 SectionCard.tsx, 🔮 trpc.dashboard.getDashboardData | one entry to test new DS without touching others |
| app/(auth)/ | unchanged aside from Tailwind classes | existing screens | auth flow continues to work |

### 4️⃣ Reusable Components (app/components)

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| SectionCard.tsx | new – glazed parchment card with header, children slot | Primitives, Animations | reusable for Dashboard sections, Planner lists, etc. |
| StatBadge.tsx | new – heart/rupee style KPI badge | Primitives | quick "level / points" readouts |
| SkeletonCard.tsx | port from Tamagui variant → NativeWind animated placeholder | react-native-linear-gradient | keeps perceived performance |
| EmptyState.tsx | new – Triforce-in-cloud illustration + call-to-action | svg-asset | encourages first-time engagement |

### 5️⃣ Feature Folders

#### 🛡 Home app/dashboard

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| index.tsx | new (move logic from old screen) – <FlatList> of section data | SectionCard, StatBadge, 🔮 useDashboardQuery | declarative; pull-to-refresh Lottie spinner |
| hooks/useDashboardQuery.ts | new – typed wrapper around trpc.dashboard.getDashboardData | RouterOutputs | co-locates data logic with UI |

#### 📜 Planner app/planner

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| _layout.tsx | new – SegmentedControl (Goals / Tasks / Habits) | Gluestack SegmentedControl | local navigation |
| Goals.tsx / Tasks.tsx / Habits.tsx | rewrite each list-view with RecyclerListView + swipe actions | 🔮 useGoalsQuery, etc. | performant infinite scrolling |
| hooks/useGoalsQuery.ts etc. | new wrappers | RouterOutputs | enforce Zod types end-to-end |
| components/GoalRow.tsx | new card with progress bar | Primitives, Animations | consistent visual language |

#### 🧭 Compass app/compass

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| index.tsx | rewrite – master/detail responsive layout | react-native-responsive-layout | quick principle lookup & edit |
| components/PrinciplePreview.tsx | new | Primitives | mini-card list |
| hooks/usePrinciplesQuery.ts | new | RouterOutputs | typed |

#### 🎁 Rewards app/rewards

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| index.tsx | rewrite – Grid/List toggle with derived animation | Moti | engaging loot boutique |
| components/RewardTile.tsx | new | Primitives | highlights image + cost |
| hooks/useRewardsQuery.ts | new | RouterOutputs | realtime claim updates |

#### ⚙️ Settings app/settings

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| index.tsx | rewrite – grouped list with divide-y classes | NativeWind | cleaner iOS look |
| hooks/useProfileMutation.ts | new | RouterInputs | patch profile + toast |

### 6️⃣ Utils & Hooks (app/lib)

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| supabaseClient.ts | keep | @supabase/supabase-js | single import site |
| trpcClient.ts | keep (point to new URL if needed) | @trpc/client | no API change |
| useOfflineCache.ts | new – queryClient.persist() to SQLite | expo-sqlite | offline UX on flights |
| useAuthGuard.tsx | new – redirect unauth users to (auth) stack | Supabase session | consistent gating |

### 7️⃣ Assets

| Item | Action | Why |
| --- | --- | --- |
| assets/fonts/HyliaSerif.ttf CalamitySans.ttf | keep | brand typefaces |
| assets/lottie/sheikah_spinner.json | keep | loading flair |
| assets/svg/triforce_cloud.svg | new | EmptyState illustration |

### 8️⃣ Testing & CI

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| e2e/Home.spec.ts | new – Playwright test clicks through sections | expo-playwright | prevents regressions |
| jest/setup.ts | update mocks for Gluestack primitives | jest | green unit tests |
| .eas.json | update channel preview-green | Expo EAS | staged rollout |

### 🔮 Assumptions / Unknowns
* TRPC routers exist for dashboard, goal, task, habit, principle, reward, profile. If any are missing we'll stub until backend delivers.
* Auth context – I assumed you expose useSession() from Supabase; if not we'll craft it.
* SVG icon set – I'm planning to import Heroicons + custom Zelda glyphs; confirm license.
EOF

echo "\n## Migration Overview" >> project.txt
echo "Current: Tamagui-based design system" >> project.txt
echo "Target: Gluestack UI + NativeWind" >> project.txt
echo "" >> project.txt

# Function to add a file to the project.txt
add_file() {
  local filename=$1
  
  if [ -f "$filename" ]; then
    echo "\n\n===========================================================" >> project.txt
    echo "# FILE: $filename" >> project.txt
    echo "===========================================================\n" >> project.txt
    cat "$filename" >> project.txt
    echo "Added $filename to project.txt"
  else
    echo "Warning: File $filename not found"
  fi
}

# 1) Core Configuration Files
echo "\n\n===========================================================" >> project.txt
echo "# 1️⃣ CORE DESIGN SYSTEM" >> project.txt
echo "===========================================================\n" >> project.txt

# Main config files
CORE_CONFIG_FILES=(
  "tamagui.config.ts"
  "tailwind.config.js"
  "constants/motion.ts"
  "constants/theme.ts"
  "package.json"
)

for file in "${CORE_CONFIG_FILES[@]}"; do
  add_file "$file"
done

# 2) Type Definitions (important for migrating to new system)
echo "\n\n===========================================================" >> project.txt
echo "# TYPE DEFINITIONS" >> project.txt
echo "===========================================================\n" >> project.txt

TYPE_FILES=(
  "types/database.types.ts"
  "utils/api-types.ts"
  "server/src/types/trpc-types.ts"
  "utils/generated-hooks.ts"
)

for file in "${TYPE_FILES[@]}"; do
  add_file "$file"
done

# 3) Global Providers
echo "\n\n===========================================================" >> project.txt
echo "# 2️⃣ GLOBAL PROVIDERS" >> project.txt
echo "===========================================================\n" >> project.txt

add_file "app/_layout.tsx"

# Find all provider files
find providers -name "*.tsx" -type f 2>/dev/null | while read file; do
  add_file "$file"
done

# Find utils with client setup (for trpc and supabase)
echo "\n\n===========================================================" >> project.txt
echo "# 6️⃣ CLIENT UTILITIES" >> project.txt
echo "===========================================================\n" >> project.txt

UTIL_FILES=(
  "utils/supabase.ts"
  "utils/trpc.ts"
  "utils/api.ts"
)

for file in "${UTIL_FILES[@]}"; do
  add_file "$file"
done

# 4) Navigation Layout Files
echo "\n\n===========================================================" >> project.txt
echo "# 3️⃣ NAVIGATION SHELLS" >> project.txt
echo "===========================================================\n" >> project.txt

NAV_FILES=(
  "app/(tabs)/_layout.tsx"
  "app/(tabs)/index.tsx"
  "app/(auth)/_layout.tsx"
)

for file in "${NAV_FILES[@]}"; do
  add_file "$file"
done

# 5) Key UI Components for Migration
echo "\n\n===========================================================" >> project.txt
echo "# 4️⃣ REUSABLE COMPONENTS" >> project.txt
echo "===========================================================\n" >> project.txt

# UI primitives first
find components/ui/primitives -name "*.tsx" -type f 2>/dev/null | while read file; do
  add_file "$file"
done

# Core shared components that will need migration
KEY_COMPONENTS=(
  "components/ui/Container.tsx"
  "components/ui/EmptyOrSkeleton.tsx"
  "components/ui/SwipeableRow.tsx"
  "components/dashboard/DashboardSection.tsx"
  "components/dashboard/GoalSummaryCard.tsx"
  "components/dashboard/DailyProgressBanner.tsx"
  "components/dashboard/TaskItem.tsx"
  "components/dashboard/HabitCheckItem.tsx"
  "components/lists/GoalList.tsx"
  "components/lists/TaskList.tsx"
  "components/lists/HabitList.tsx"
  "components/settings/ThemePreview.tsx"
  "components/compass/PrincipleCard.tsx"
  "components/rewards/ConfettiBurst.tsx"
)

for file in "${KEY_COMPONENTS[@]}"; do
  add_file "$file"
done

# 6) Feature Screens
echo "\n\n===========================================================" >> project.txt
echo "# 5️⃣ FEATURE SCREENS" >> project.txt
echo "===========================================================\n" >> project.txt

# Core feature screens
FEATURE_SCREENS=(
  "app/(tabs)/home/index.tsx"
  "app/(tabs)/planner/index.tsx"
  "app/(tabs)/compass/index.tsx"
  "app/(tabs)/rewards/index.tsx"
  "app/(tabs)/settings/index.tsx"
)

for file in "${FEATURE_SCREENS[@]}"; do
  add_file "$file"
done

# 7) Assets
echo "\n\n===========================================================" >> project.txt
echo "# 7️⃣ ASSETS" >> project.txt
echo "===========================================================\n" >> project.txt

# Just list asset directories
echo "Font Files in assets/fonts:" >> project.txt
ls -la assets/fonts 2>/dev/null >> project.txt || echo "No font directory found" >> project.txt

echo "\nLottie Files in assets:" >> project.txt
find assets -name "*.json" 2>/dev/null | sort >> project.txt || echo "No Lottie files found" >> project.txt

echo "\nSVG Files in assets:" >> project.txt
find assets -name "*.svg" 2>/dev/null | sort >> project.txt || echo "No SVG files found" >> project.txt

echo "\nAll project context has been collected in project.txt"
```

### gather_tamagui_styles.sh
**Path:** gather_tamagui_styles.sh
**Size:** 2223 bytes

```bash
#!/bin/bash

# Create or truncate the project.txt file
echo "# Aether iPhone Project Context for Tamagui to Gluestack/NativeWind Migration" > project.txt
echo "Generated on $(date)" >> project.txt
echo "\n## Migration Overview" >> project.txt
echo "Current: Tamagui-based design system" >> project.txt
echo "Target: Gluestack UI + NativeWind" >> project.txt
echo "" >> project.txt

# Function to add a file to the project.txt
add_file() {
  local filename=$1
  
  if [ -f "$filename" ]; then
    echo "\n\n===========================================================" >> project.txt
    echo "# FILE: $filename" >> project.txt
    echo "===========================================================\n" >> project.txt
    cat "$filename" >> project.txt
    echo "Added $filename to project.txt"
  else
    echo "Warning: File $filename not found"
  fi
}

# Add main Tamagui configuration files
add_file "tamagui.config.ts"
add_file ".tamagui/tamagui.config.json"
add_file "app/_layout.tsx"

# Process all component directories
echo "\n\n===========================================================" >> project.txt
echo "# ALL COMPONENTS" >> project.txt
echo "===========================================================\n" >> project.txt

# Find all component files
find components -name "*.tsx" -type f | while read file; do
  add_file "$file"
done

# Process all app screens
echo "\n\n===========================================================" >> project.txt
echo "# APP SCREENS" >> project.txt
echo "===========================================================\n" >> project.txt

# Find all app screen files
find app -name "*.tsx" -type f | grep -v "_layout.tsx" | while read file; do
  add_file "$file"
done

# Add constants and utils
echo "\n\n===========================================================" >> project.txt
echo "# CONSTANTS AND UTILS" >> project.txt
echo "===========================================================\n" >> project.txt

# List of styling utility files
STYLING_FILES=(
  "constants/motion.ts"
  "constants/theme.ts"
  "utils/themes.ts"
  "utils/styleUtils.ts"
)

for file in "${STYLING_FILES[@]}"; do
  add_file "$file"
done

echo "\nAll styling-related files have been collected in project.txt"```

### global.d.ts
**Path:** global.d.ts
**Size:** 43 bytes

```typescript
/// <reference types="nativewind/types" /> ```


# hooks

### useColorScheme.ts
**Path:** hooks/useColorScheme.ts
**Size:** 47 bytes

```typescript
export { useColorScheme } from 'react-native';
```

### useColorScheme.web.ts
**Path:** hooks/useColorScheme.web.ts
**Size:** 480 bytes

```typescript
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}
```

### useOfflineSync.ts
**Path:** hooks/useOfflineSync.ts
**Size:** 6199 bytes

```typescript
import { useEffect, useCallback } from 'react';
import NetInfo from '@react-native-community/netinfo';
import { onlineManager } from '@tanstack/react-query';
import { saveOfflineMutation, syncOfflineMutations, getPendingItems, PendingItem, setupBackgroundSync } from '@/utils/offline-sync';
import { useState } from 'react';

/**
 * Hook to provide offline sync functionality
 */
export function useOfflineSync<T extends { id: string }>(entityType: string) {
  const [isOnline, setIsOnline] = useState(true);
  const [pendingItems, setPendingItems] = useState<PendingItem[]>([]);
  const [isSyncing, setIsSyncing] = useState(false);

  // Load pending items on mount
  useEffect(() => {
    loadPendingItems();
    
    // Set up network status listener
    const unsubscribe = NetInfo.addEventListener(state => {
      const online = state.isConnected !== false && state.isInternetReachable !== false;
      setIsOnline(online);
      
      // If going from offline to online, try to sync
      if (online) {
        syncItems();
      }
    });
    
    // Also set up background sync (network status changes outside this component)
    const unsubscribeBackground = setupBackgroundSync();
    
    return () => {
      unsubscribe();
      unsubscribeBackground();
    };
  }, [entityType]);

  // Load pending items from storage
  const loadPendingItems = useCallback(async () => {
    const items = await getPendingItems(entityType);
    setPendingItems(items);
  }, [entityType]);

  // Create an item (works offline)
  const createItem = useCallback(async (data: Omit<T, 'id'>): Promise<{ id: string, isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, create directly
        // In a real app, you'd use your API client (like supabase) here
        // const { data: newItem, error } = await supabase.from(entityType).insert(data).select();
        // if (error) throw error;
        // return { id: newItem.id, isOffline: false };
        
        // For demo purposes, simulate success
        return { id: `server-${Date.now()}`, isOffline: false };
      } else {
        // If offline, save to be synced later
        const tempId = await saveOfflineMutation('create', entityType, data);
        await loadPendingItems(); // Reload pending items
        return { id: tempId, isOffline: true };
      }
    } catch (error) {
      console.error('Error creating item:', error);
      // If API call fails, save offline
      const tempId = await saveOfflineMutation('create', entityType, data);
      await loadPendingItems(); // Reload pending items
      return { id: tempId, isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Update an item (works offline)
  const updateItem = useCallback(async (item: T): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, update directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).update(item).eq('id', item.id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('update', entityType, item);
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error updating item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('update', entityType, item);
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Delete an item (works offline)
  const deleteItem = useCallback(async (id: string): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, delete directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).delete().eq('id', id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('delete', entityType, { id });
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error deleting item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('delete', entityType, { id });
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Manually trigger sync
  const syncItems = useCallback(async (): Promise<boolean> => {
    if (isSyncing) return false;
    
    setIsSyncing(true);
    try {
      const success = await syncOfflineMutations();
      if (success) {
        await loadPendingItems(); // Reload pending items after successful sync
      }
      return success;
    } catch (error) {
      console.error('Error syncing items:', error);
      return false;
    } finally {
      setIsSyncing(false);
    }
  }, [isSyncing, loadPendingItems]);

  // Check if an item is pending sync
  const isItemPending = useCallback((id: string): boolean => {
    return pendingItems.some(item => item.id === id);
  }, [pendingItems]);

  return {
    isOnline,
    isSyncing,
    pendingItems,
    createItem,
    updateItem,
    deleteItem,
    syncItems,
    isItemPending,
  };
} ```

### useSkeleton.ts
**Path:** hooks/useSkeleton.ts
**Size:** 3702 bytes

```typescript
import { useEffect } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withTiming,
  withSequence,
  withDelay,
  Easing,
} from 'react-native-reanimated';
import { durations, easings } from '@/constants/motion';

export interface SkeletonOptions {
  /**
   * Width of the gradient shimmer (as % of the component width)
   * @default 0.7
   */
  shimmerWidth?: number;
  /**
   * Base color of the skeleton component
   * @default '#E1E9EE'
   */
  baseColor?: string;
  /**
   * Highlight color for the shimmer effect
   * @default '#F2F8FC'
   */
  highlightColor?: string;
  /**
   * Duration for a complete shimmer cycle in ms
   * @default 2000
   */
  duration?: number;
  /**
   * Delay before starting animation in ms
   * @default 0
   */
  delay?: number;
  /**
   * Whether animation should start automatically
   * @default true
   */
  autoStart?: boolean;
  /**
   * Loading state to determine if skeletons should be shown
   * @default false
   */
  isLoading?: boolean;
  /**
   * Number of skeleton items to generate
   * @default 1
   */
  count?: number;
  /**
   * Type of skeleton to generate
   * @default 'card'
   */
  type?: 'card' | 'row' | 'circle';
}

/**
 * Hook to create skeleton loading animations with shimmer effect
 */
export function useSkeleton(options: SkeletonOptions = {}) {
  const {
    shimmerWidth = 0.7,
    baseColor = '#E1E9EE',
    highlightColor = '#F2F8FC',
    duration = durations.long * 2,
    delay = 0,
    autoStart = true,
  } = options;
  
  // Animation value to track shimmer position
  const translateX = useSharedValue(-1);
  
  // Start the animation
  useEffect(() => {
    if (autoStart) {
      translateX.value = withDelay(
        delay,
        withRepeat(
          withSequence(
            withTiming(-1, { duration: 0 }),
            withTiming(1, { 
              duration, 
              easing: easings.linear 
            }),
          ),
          -1, // Infinite repeat
        ),
      );
    }
  }, [translateX, duration, delay, autoStart]);
  
  // Generate the animated styles for the shimmer effect
  const shimmerStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateX: translateX.value * (1 + shimmerWidth) }],
    };
  });
  
  // Create styles for both container and shimmer
  const styles = StyleSheet.create({
    container: {
      backgroundColor: baseColor,
      overflow: 'hidden',
    },
    shimmer: {
      width: `${shimmerWidth * 100}%`,
      height: '100%',
      backgroundColor: highlightColor,
      position: 'absolute',
      top: 0,
      bottom: 0,
      opacity: 0.7,
    },
  });
  
  // Utility function to manually start the animation
  const startAnimation = () => {
    translateX.value = withDelay(
      delay,
      withRepeat(
        withSequence(
          withTiming(-1, { duration: 0 }),
          withTiming(1, { 
            duration, 
            easing: easings.linear 
          }),
        ),
        -1, // Infinite repeat
      ),
    );
  };
  
  // Utility function to stop the animation
  const stopAnimation = () => {
    translateX.value = withTiming(-1, { duration: 200 });
  };
  
  // Generate array of skeletons based on count and type
  const generateSkeletons = () => {
    if (!options.isLoading) return [];
    
    const count = options.count || 1;
    const type = options.type || 'card';
    
    return Array.from({ length: count }).map((_, index) => ({
      key: `skeleton-${index}`,
      type,
    }));
  };
  
  return {
    baseColor,
    shimmerStyle,
    styles,
    startAnimation,
    stopAnimation,
    skeletons: generateSkeletons(),
  };
} ```

### useThemeColor.ts
**Path:** hooks/useThemeColor.ts
**Size:** 536 bytes

```typescript
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}
```


# (root files)

### implementation_details.txt
**Path:** implementation_details.txt
**Size:** 649907 bytes
*(omitted – binary or >204800 bytes)*

### index.js
**Path:** index.js
**Size:** 128 bytes

```javascript
// index.js - Custom entry point to guarantee Tamagui config loads first
import './tamagui.config';
import 'expo-router/entry';
```

### jest.config.server.js
**Path:** jest.config.server.js
**Size:** 547 bytes

```javascript
/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  displayName: 'Server',
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['<rootDir>/__tests__/server/**/*.test.ts'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
  },
  // Do NOT include setupFilesAfterEnv that point to UI-specific setup (like jest.setup.js)
  // Add any server-specific setup files here if needed in the future
  // setupFilesAfterEnv: ['./jest.server.setup.js'],
  clearMocks: true, // Good practice to clear mocks between tests
};
```

### jest.config.ui.js
**Path:** jest.config.ui.js
**Size:** 822 bytes

```javascript
module.exports = {
  preset: 'jest-expo',
  transformIgnorePatterns: [
    'node_modules/(?!((jest-)?react-native|@react-native(-community)?)|expo(nent)?|@expo(nent)?/.*|@expo-google-fonts/.*|react-navigation|@react-navigation/.*|@unimodules/.*|unimodules|sentry-expo|native-base|react-native-svg|tamagui|@tamagui/.*|solito|moti|@motify/.*)'
  ],
  setupFilesAfterEnv: ['@testing-library/jest-native/extend-expect', './jest.setup.js'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
  },
  moduleDirectories: ['node_modules', '<rootDir>'], 
  collectCoverageFrom: [
    '**/*.{js,jsx,ts,tsx}',
    '!**/node_modules/**',
    '!**/babel.config.js',
    '!**/jest.setup.js',
  ],
  testPathIgnorePatterns: [
    '/node_modules/',
    '/__tests__/test-utils\\.tsx$',
    '/__tests__/server/test-helpers\\.ts$'
  ],
};
```

### jest.server.config.js
**Path:** jest.server.config.js
**Size:** 660 bytes

```javascript
module.exports = {
  // Use Node.js environment for server tests
  testEnvironment: 'node',
  // Only transform TypeScript files
  transform: {
    '^.+\\.tsx?$': ['ts-jest']
  },
  // Don't need transformIgnorePatterns for server tests as we're not testing React Native components
  // Use our server-specific setup file
  setupFilesAfterEnv: ['./jest.server.setup.js'],
  // Match our server test files
  testMatch: ['**/__tests__/server/**/*.test.ts'],
  // Root directory
  rootDir: './',
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
  },
  // Clear mocks between tests
  clearMocks: true,
  // Don't watch files for changes
  watchman: false,
};
```

### jest.server.setup.js
**Path:** jest.server.setup.js
**Size:** 1026 bytes

```javascript
// Minimal Jest setup file for server-side tests
// No UI-related mocks needed for router tests

// Global mocks for server tests
global.mockSupabaseAdmin = {
  from: jest.fn().mockReturnThis(),
  select: jest.fn().mockReturnThis(),
  insert: jest.fn().mockReturnThis(),
  update: jest.fn().mockReturnThis(),
  delete: jest.fn().mockReturnThis(),
  eq: jest.fn().mockReturnThis(),
  neq: jest.fn().mockReturnThis(),
  order: jest.fn().mockReturnThis(),
  limit: jest.fn().mockReturnThis(),
  single: jest.fn().mockReturnThis(),
  in: jest.fn().mockReturnThis(),
  gte: jest.fn().mockReturnThis(),
  lte: jest.fn().mockReturnThis(),
  is: jest.fn().mockReturnThis(),
  or: jest.fn().mockReturnThis(),
  match: jest.fn().mockReturnThis(),
  rpc: jest.fn().mockReturnValue({ data: [], error: null }),
};

// Mock UUID for deterministic testing
jest.mock('uuid', () => ({
  v4: jest.fn().mockReturnValue('test-uuid-1234'),
}));

// Set test environment timezone
process.env.TZ = 'UTC';

console.log('Server test setup complete');
```

### jest.setup.js
**Path:** jest.setup.js
**Size:** 2064 bytes

```javascript
import '@testing-library/jest-native/extend-expect';
import { StyleSheet } from 'react-native';

// Mock tRPC procedures *before* routers are imported by tests
jest.mock('./server/src/router', () => {
  // console.log('MOCKING ./server/src/router'); // Debugging line
  const actualTrpc = jest.requireActual('./server/src/router');

  // Simple mock procedure chain structure
  const mockProcedure = {
    input: jest.fn().mockReturnThis(),
    output: jest.fn().mockReturnThis(),
    query: jest.fn((resolver) => resolver), // Pass resolver through
    mutation: jest.fn((resolver) => resolver), // Pass resolver through
    use: jest.fn().mockReturnThis(), // Mock middleware usage
  };

  return {
    ...actualTrpc, // Keep other exports (like appRouter if needed elsewhere, though unlikely in unit tests)
    router: jest.fn((definition) => definition), // Mock the router factory function
    publicProcedure: mockProcedure,
    protectedProcedure: mockProcedure,
  };
});

// No longer using global mockTamagui

// Mock the router from expo-router
jest.mock('expo-router', () => ({
  router: {
    push: jest.fn(),
    replace: jest.fn(),
    back: jest.fn(),
  },
  useRouter: () => ({
    push: jest.fn(),
    replace: jest.fn(),
    back: jest.fn(),
  }),
  useNavigation: () => ({
    navigate: jest.fn(),
  }),
  useLocalSearchParams: jest.fn().mockReturnValue({}),
}));

// Mock the Ionicons component
jest.mock('@expo/vector-icons', () => {
  const { View } = require('react-native');
  return {
    Ionicons: (props) => {
      return <View testID={`icon-${props.name}`} {...props} />;
    },
  };
});

// Mock the trpc hook
jest.mock('@/utils/trpc', () => ({
  trpc: {
    useQuery: jest.fn().mockReturnValue({
      data: null,
      isLoading: false,
      error: null,
    }),
    useMutation: jest.fn().mockReturnValue({
      mutate: jest.fn(),
      isLoading: false,
    }),
    useContext: jest.fn(),
  },
}));

// Silence React Native warnings during tests
global.console = {
  ...global.console,
  warn: jest.fn(),
  error: jest.fn(),
};
```

### metro.config.js
**Path:** metro.config.js
**Size:** 228 bytes

```javascript
const { getDefaultConfig } = require("expo/metro-config");
const { withNativeWind } = require("nativewind/metro");

const config = getDefaultConfig(__dirname);
module.exports = withNativeWind(config, { input: "./global.css" });
```


# modals

### compose.tsx
**Path:** modals/compose.tsx
**Size:** 3199 bytes

```typescript
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { Stack, useRouter } from 'expo-router';
import { Button } from '@/components/ui/iOS/Button';
import Animated, { 
  SlideInDown, 
  // SlideOutDown, // Not using exit animation with gesture
  useSharedValue, 
  useAnimatedStyle, 
  withTiming, 
  runOnJS 
} from 'react-native-reanimated';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';

const { height: SCREEN_HEIGHT } = Dimensions.get('window');
const DISMISS_THRESHOLD = SCREEN_HEIGHT * 0.25; // Swipe 25% down to dismiss

export default function ComposeModal() {
  const router = useRouter();

  // Reanimated shared value for tracking vertical translation
  const translateY = useSharedValue(0);
  const context = useSharedValue({ y: 0 });

  // Gesture handler for swipe down
  const gesture = Gesture.Pan()
    .onStart(() => {
      context.value = { y: translateY.value };
    })
    .onUpdate((event) => {
      translateY.value = Math.max(0, context.value.y + event.translationY); // Only allow downward swipe
    })
    .onEnd(() => {
      if (translateY.value > DISMISS_THRESHOLD) {
        // Animate out and navigate back
        translateY.value = withTiming(SCREEN_HEIGHT, { duration: 200 }, () => {
          runOnJS(router.back)();
        });
      } else {
        // Snap back to original position
        translateY.value = withTiming(0, { duration: 150 });
      }
    });

  // Animated style for the view
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateY: translateY.value }],
    };
  });

  return (
    // Wrap with GestureDetector
    <GestureDetector gesture={gesture}>
      {/* Apply animated style and entrance animation */}
      <Animated.View 
        style={[styles.container, animatedStyle]}
        entering={SlideInDown.duration(300)} 
      >
        {/* Optional: Add a small drag handle indicator */}
        <View style={styles.handleIndicator} />

        {/* Use Stack.Screen to configure the modal title */}
        <Stack.Screen 
          options={{
            title: 'Compose New',
            // Ensure header interaction doesn't conflict with gesture
            // headerLeft: () => <Button title="Close" onPress={() => router.back()} />
          }} 
        />
        <Text style={{ fontSize: 20, marginBottom: 20 }}>Swipe Down to Dismiss</Text>
        <Button onPress={() => router.back()}>Close Modal</Button>
      </Animated.View>
    </GestureDetector>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1, 
    alignItems: 'center', 
    justifyContent: 'center',
    backgroundColor: 'white', // Modals usually have solid background
    borderTopLeftRadius: 10, // Apply radius only to top corners for modal sheet look
    borderTopRightRadius: 10,
    // Add shadow for depth if desired
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -3 },
    shadowOpacity: 0.1,
    shadowRadius: 5,
    elevation: 5, // For Android shadow
  },
  handleIndicator: {
    width: 40,
    height: 5,
    backgroundColor: '#ccc',
    borderRadius: 2.5,
    position: 'absolute',
    top: 10,
    alignSelf: 'center',
  }
}); ```


# (root files)

### o3.txt
**Path:** o3.txt
**Size:** 50017 bytes

```
Debug Report - 2025-04-30T02:39:05.474Z
Generated by gather_debug_info.js
Focusing on files related to the runtime errors.

========================================
FILE: app/(tabs)/compass/index.tsx
ISSUE CONTEXT: Main compass screen that renders PrinciplesTab
----------------------------------------

// Compass screen with Principles and States tabs
import React, { useState } from 'react';
import { YStack, XStack, Text, Tabs, Button, ScrollView } from 'tamagui'; 
import { SafeAreaView } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc, type RouterOutputs } from '@/utils/trpc'; 
import { useColorScheme } from '@/hooks/useColorScheme'; 
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { router, type Href } from 'expo-router'; 
import { PrincipleCard } from '@/components/compass/PrincipleCard'; 
import { StateDefinitionCard } from '@/components/compass/StateDefinitionCard'; 

interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'principles',
    title: 'Principles',
    icon: <Ionicons name="compass-outline" size={18} color="currentColor" />
  },
  {
    key: 'states',
    title: 'States',
    icon: <Ionicons name="pulse-outline" size={18} color="currentColor" />
  }
];

export default function CompassScreen() {
  const [activeTab, setActiveTab] = useState<string>('principles');
  const colorScheme = useColorScheme();

  const handleAddPress = () => {
    const route = `/compose?type=${activeTab === 'principles' ? 'value' : 'state'}` as Href;
    router.push(route);
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Compass</Text>
          <Button
            size="$3"
            circular
            onPress={handleAddPress} 
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>

        {/* Tabs */}
        <Tabs
          defaultValue="principles"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {React.cloneElement(tab.icon as React.ReactElement, { color: activeTab === tab.key ? '$colorFocus' : '$color' })}
                  <Text color={activeTab === tab.key ? '$colorFocus' : '$color'}>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>

          {/* Tab Content */}
          <Tabs.Content value="principles" flex={1} key="principles-content">
            <ScrollView>
              <PrinciplesTab />
            </ScrollView>
          </Tabs.Content>

          <Tabs.Content value="states" flex={1} key="states-content">
            <ScrollView>
              <StatesTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Define the specific types from RouterOutputs
type Principle = RouterOutputs['value']['getValues'][number];
type StateDefinition = RouterOutputs['state']['getDefinitions'][number]; 

// Principles Tab Component (manages data fetching and list rendering)
function PrinciplesTab() {
  const { data: principles, isLoading, error, refetch } = trpc.value.getValues.useQuery();

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }

  if (error) {
    return (
      <EmptyOrSkeleton
        isEmpty={false}
        isError={true}
        onRetry={refetch}
        text="Failed to load principles"
      />
    );
  }

  if (!principles || principles.length === 0) {
    return (
      <EmptyOrSkeleton
        isEmpty={true}
        text="No principles defined yet"
        actionText="Add Your First Principle"
        onAction={() => router.push('/compose?type=value' as Href)}
      />
    );
  }

  return (
    <YStack space="$3"> 
      {principles.map((principle: Principle) => (
        <PrincipleCard
          key={principle.id}
          principle={principle}
          onPress={() => router.push(`/values/${principle.id}` as Href)}
        />
      ))}
    </YStack>
  );
}

// States Tab Component (manages data fetching and list rendering)
function StatesTab() {
  const { data: states, isLoading, error, refetch } = trpc.state.getDefinitions.useQuery(); 

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }

  if (error) {
    return (
      <EmptyOrSkeleton
        isEmpty={false}
        isError={true}
        onRetry={refetch}
        text="Failed to load tracked state definitions"
      />
    );
  }

  if (!states || states.length === 0) {
    return (
      <EmptyOrSkeleton
        isEmpty={true}
        text="No state definitions found"
        actionText="Define Your First State"
        onAction={() => router.push('/compose?type=state' as Href)}
      />
    );
  }

  return (
    <YStack space="$3"> 
      {states.map((state: StateDefinition) => (
        <StateDefinitionCard
          key={state.id}
          state={state}
          onPress={() => router.push(`/states/${state.id}` as Href)}
        />
      ))}
    </YStack>
  );
}

// 
// Removed inline PrincipleCard definition (extracted to components/compass/PrincipleCard.tsx)
// 

// 
// Removed inline StateDefinitionCard definition (extracted to components/compass/StateDefinitionCard.tsx)
// 


[EOF: app/(tabs)/compass/index.tsx]

========================================
FILE: components/compass/PrinciplesTab.tsx
ISSUE CONTEXT: TypeError: principles.map is not a function (it is undefined)
----------------------------------------

Error: File not found at /Users/tylerbedford/Documents/Coding Projects/AetherIphone/components/compass/PrinciplesTab.tsx
This missing file could be related to the routing or component errors.


[EOF: components/compass/PrinciplesTab.tsx]

========================================
FILE: app/(tabs)/rewards/index.tsx
ISSUE CONTEXT: Duplicate Key Warning: "Encountered two children with the same key, `.$undefined-grid=2undefined-grid`"
----------------------------------------

// Rewards screen with grid/list toggle and claim functionality
import React, { useState, useCallback } from 'react';
import { YStack, XStack, Text, Button, ScrollView, Card, Checkbox, useTheme, H1 } from 'tamagui';
import { SafeAreaView, View, FlatList, ImageBackground, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { RouterOutputs } from '@/utils/trpc'; // Import RouterOutputs
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton'; // Import helper component

// Define inferred type for rewards
type RewardItem = RouterOutputs['rewards']['getAvailableRewards'][number];

enum ViewMode {
  Grid = 'grid',
  List = 'list'
}

export default function RewardsScreen() {
  const [viewMode, setViewMode] = useState<ViewMode>(ViewMode.Grid);
  const colorScheme = useColorScheme();
  const theme = useTheme();

  // Define fallback colors
  const blue2 = theme?.blue2?.val ?? '#eff6ff';
  const blue5 = theme?.blue5?.val ?? '#60a5fa';
  const blue10 = theme?.blue10?.val ?? '#1e40af';
  const blue11 = theme?.blue11?.val ?? '#1e3a8a';
  const green9 = theme?.green9?.val ?? '#16a34a';

  // Fetch available rewards from tRPC
  const { 
    data: rewards, 
    isLoading, 
    error, 
    refetch 
  } = trpc.rewards.getAvailableRewards.useQuery();

  // Mutation for claiming rewards
  const claimMutation = trpc.rewards.earnReward.useMutation({
    onSuccess: (data) => {
      console.log('Reward claimed successfully:', data);
      // Maybe show confetti?
      Alert.alert('Reward Claimed!', `You spent ${data.reward.points_spent} points. Remaining: ${data.remainingPoints}`);
      refetch(); // Refetch the list of available rewards
    },
    onError: (err) => {
      console.error('Failed to claim reward:', err);
      Alert.alert('Claim Failed', err.message || 'Could not claim reward.');
    }
  });
  
  const handleClaimReward = useCallback((rewardId: string) => {
    if (claimMutation.isPending) return; // Prevent double-clicks
    
    Alert.alert(
      'Confirm Claim',
      'Are you sure you want to spend points on this reward?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Claim', 
          onPress: () => {
            claimMutation.mutate({ rewardId });
          },
          style: 'default'
        }
      ]
    );
  }, [claimMutation]);
  
  const renderItem = ({ item }: { item: RewardItem }) => { // Use inferred type
    // Assuming backend field is image_url, map to imagePath
    const imagePath = item.image_url; 
    // All items from getAvailableRewards are considered claimable (not yet claimed)
    const claimed = false; 
    // Map required_points to pointCost
    const pointCost = item.required_points;

    if (viewMode === ViewMode.Grid) {
      return (
        <Card
          size="$4"
          bordered
          width={160}
          height={200}
          margin="$2"
          overflow="hidden"
          elevation="$2"
          opacity={claimed ? 0.7 : 1}
        >
          <ImageBackground
            source={{ uri: imagePath }}
            style={{ width: '100%', height: 100 }}
          >
            <View style={{ 
              position: 'absolute', 
              top: 5, 
              right: 5, 
              backgroundColor: blue5,
              borderRadius: 10,
              padding: 4
            }}>
              <Text color="white" fontSize="$2" fontWeight="bold">
                {pointCost} pts
              </Text>
            </View>
          </ImageBackground>
          
          <YStack padding="$2" flex={1} justifyContent="space-between">
            <Text fontSize="$4" fontWeight="bold" numberOfLines={1}>
              {item.name}
            </Text>
            
            <Button
              size="$2"
              themeInverse={claimed}
              backgroundColor={claimed ? undefined : blue10}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </YStack>
        </Card>
      );
    } else {
      return (
        <Card
          bordered
          margin="$2"
          padding="$3"
          opacity={claimed ? 0.7 : 1}
        >
          <XStack space="$3" alignItems="center">
            {imagePath && (
              <View style={{ 
                width: 60, 
                height: 60, 
                borderRadius: 8, 
                overflow: 'hidden',
                backgroundColor: theme.gray3.val
              }}>
                <ImageBackground
                  source={{ uri: imagePath }}
                  style={{ width: '100%', height: '100%' }}
                />
              </View>
            )}
            
            <YStack flex={1} space="$1">
              <Text fontSize="$5" fontWeight="bold">{item.name}</Text>
              <Text fontSize="$3" color="$gray11" numberOfLines={2}>{item.description}</Text>
              <Text fontSize="$3" color={blue10} fontWeight="500">{pointCost} points</Text>
            </YStack>
            
            <Button
              size="$3"
              backgroundColor={claimed ? undefined : blue10}
              themeInverse={claimed}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </XStack>
        </Card>
      );
    }
  };
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        <YStack space="$4">
          {/* Header */}
          <XStack justifyContent="space-between" alignItems="center">
            <H1>Rewards</H1>
            
            <XStack space="$2">
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.Grid ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.Grid)}
              >
                <Ionicons 
                  name="grid-outline" 
                  size={22} 
                  color={viewMode === ViewMode.Grid ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
              
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.List ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.List)}
              >
                <Ionicons 
                  name="list-outline" 
                  size={22} 
                  color={viewMode === ViewMode.List ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
            </XStack>
          </XStack>
          
          {/* Stats */}
          <Card padding="$3" backgroundColor={blue2}>
            <XStack justifyContent="space-between" alignItems="center">
              <Text fontSize="$5" fontWeight="bold" color={blue11}>Your Points</Text>
              <Text fontSize="$6" fontWeight="bold" color={blue10}>275</Text>
            </XStack>
          </Card>
        </YStack>
        
        {/* Content Area */} 
        <EmptyOrSkeleton 
          isLoading={isLoading}
          isEmpty={!isLoading && (!rewards || rewards.length === 0)}
          isError={!!error}
          text={error ? error.message : 'No rewards available yet.'} // Use text for error OR empty msg
          onRetry={refetch}
          type={viewMode === ViewMode.Grid ? 'card' : 'row'}
          count={viewMode === ViewMode.Grid ? 6 : 3}
        >
          <FlatList
            key={viewMode} // Change key based on viewMode to force re-render
            data={rewards}
            renderItem={renderItem}
            keyExtractor={(item) => `${item.id}-${viewMode}`} // Apply patch #1
            numColumns={viewMode === ViewMode.Grid ? 2 : 1}
            contentContainerStyle={{ paddingBottom: 50 }} // Add padding at the bottom
            // Optional Optimizations (Patch #6)
            initialNumToRender={8}
            removeClippedSubviews={true} // Note: Can have visual glitches on iOS sometimes
          />
        </EmptyOrSkeleton>

      </YStack>
    </SafeAreaView>
  );
}


[EOF: app/(tabs)/rewards/index.tsx]

========================================
FILE: app/(tabs)/_layout.tsx
ISSUE CONTEXT: Warnings: "No route named planner/index & settings/index exists in nested children"
----------------------------------------

// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/_layout.tsx
import React from 'react';
import { Tabs } from 'expo-router';
import { Ionicons } from '@expo/vector-icons'; // Example icon library
import { useThemeColor } from '@/hooks/useThemeColor'; // Assuming path alias is set

export default function TabLayout() {
  const tabBarActiveTintColor = useThemeColor({}, 'tabIconSelected');
  const tabBarInactiveTintColor = useThemeColor({}, 'tabIconDefault');
  const backgroundColor = useThemeColor({}, 'background'); // Use standard background color

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: tabBarActiveTintColor,
        tabBarInactiveTintColor: tabBarInactiveTintColor,
        tabBarStyle: {
          backgroundColor: backgroundColor,
          // Add other styles like borderTopColor if needed
        },
        headerShown: false, // We might handle headers inside each screen or using Stack
      }}
    >
      <Tabs.Screen
        name="home/index"
        options={{
          title: 'Home',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="home-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="planner/index"
        options={{
          title: 'Planner',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="calendar-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="compass/index"
        options={{
          title: 'Compass',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="compass-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="rewards/index"
        options={{
          title: 'Rewards',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="gift-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="settings/index"
        options={{
          title: 'Settings',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="settings-outline" size={size} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}


[EOF: app/(tabs)/_layout.tsx]

========================================
FILE: app/(tabs)/planner/index.tsx
ISSUE CONTEXT: Possibly missing or index file needs to be created
----------------------------------------

// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/planner/index.tsx
import React, { useState, Suspense } from 'react';
import { YStack, XStack, Text, Tabs, Button, Spinner, Card } from 'tamagui';
import { SafeAreaView, FlatList, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { RouterOutputs } from '@/utils/api-types';
import { SectionError } from '@/components/ui/ErrorBanner';


interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'goals',
    title: 'Goals',
    icon: <Ionicons name="trophy-outline" size={18} color="currentColor" />
  },
  {
    key: 'habits',
    title: 'Habits',
    icon: <Ionicons name="repeat-outline" size={18} color="currentColor" />
  },
  {
    key: 'calendar',
    title: 'Calendar',
    icon: <Ionicons name="calendar-outline" size={18} color="currentColor" />
  }
];

export default function PlannerScreen() {
  const [activeTab, setActiveTab] = useState<string>('goals');
  const colorScheme = useColorScheme();
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Planner</Text>
          <Button
            size="$3"
            circular
            onPress={() => {/* Handle new item */}}
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>
        
        {/* Tabs */}
        <Tabs
          defaultValue="goals"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List 
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {tab.icon}
                  <Text>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>
          
          {/* Tab Content */}
          <Tabs.Content value="goals" flex={1}>
            <ScrollView>
              <GoalsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="habits" flex={1}>
            <ScrollView>
              <HabitsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="calendar" flex={1}>
            <ScrollView>
              <CalendarTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Goals Tab
function GoalsTab() {
  // Fetch goals using tRPC
  const { data: goals, isLoading, error, refetch } = trpc.goal.getGoals.useQuery();
  
  // Define the inferred type for a single goal
  type PlannerGoal = RouterOutputs['goal']['getGoals'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load goals" 
      />
    );
  }
  
  if (!goals || goals.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No goals yet" 
        actionText="Create a goal" 
        onAction={() => router.push('/planner/add-goal')} 
      />
    );
  }
  
  return (
    <YStack space="$4">
      {goals.map((goal: PlannerGoal) => (
        <Button 
          key={goal.id} 
          height="$12" 
          justifyContent="flex-start" 
          paddingHorizontal="$3"
          onPress={() => router.push({ pathname: '/planner/goal/[id]', params: { id: goal.id } })}
        >
          <YStack>
            <Text fontWeight="bold">{goal.title}</Text>
            <Text fontSize="$2" color="$gray10">
              {goal.dueDate ? new Date(goal.dueDate).toLocaleDateString() : 'No due date'}
            </Text>
          </YStack>
        </Button>
      ))}
    </YStack>
  );
}

// Habits Tab
function HabitsTab() {
  // Fetch habits using tRPC
  const { data: habits, isLoading, error, refetch } = trpc.habit.getHabits.useQuery();
  
  // Define the inferred type for a single habit
  type PlannerHabit = RouterOutputs['habit']['getHabits'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={isLoading} count={3} type="row" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load habits" 
      />
    );
  }
  
  if (!habits || habits.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No habits yet" 
        actionText="Create a habit" 
        onAction={() => router.push('/planner/add-habit')} 
      />
    );
  }
  
  return (
    <YStack space="$3">
      {habits.map((habit: PlannerHabit) => (
        <XStack 
          key={habit.id} 
          justifyContent="space-between" 
          alignItems="center" 
          paddingVertical="$3" 
          paddingHorizontal="$3" 
          borderBottomWidth={1} 
          borderColor="$gray5"
          pressStyle={{ opacity: 0.7 }}
          tag="pressable"
          onPress={() => router.push({ pathname: '/planner/habit/[id]', params: { id: habit.id } })}
        >
          <Text>{habit.title}</Text>
          <Button
            size="$2"
            circular
            backgroundColor={habit.completed ? '$green9' : '$gray9'}
            onPress={() => {
              // Use today's date for the habit entry
              const today = new Date().toISOString().split('T')[0];
              
              // Create a mutation to toggle habit completion
              const toggleHabit = trpc.habit.createHabitEntry.useMutation({
                onSuccess: () => {
                  refetch(); // Refresh data after toggling
                },
                onError: (error) => {
                  // Show error message
                  console.error('Failed to toggle habit:', error.message);
                }
              });
              
              // Toggle the habit completion status
              toggleHabit.mutate({
                habitId: habit.id,
                completed: !habit.completed,
                date: today
              });
            }}
            icon={<Ionicons name="checkmark" size={18} color="white" />}
          />
        </XStack>
      ))}
    </YStack>
  );
}

// Calendar Tab
function CalendarTab() {
  return (
    <YStack alignItems="center" justifyContent="center" padding="$8">
      <Text fontSize="$5" textAlign="center">
        Calendar integration coming soon
      </Text>
      <Text marginTop="$2" color="$gray10" textAlign="center">
        This tab will display task and habit schedules in a calendar view
      </Text>
    </YStack>
  );
}


[EOF: app/(tabs)/planner/index.tsx]

========================================
FILE: app/(tabs)/settings/index.tsx
ISSUE CONTEXT: Possibly missing or index file needs to be created
----------------------------------------

// Settings screen with account, preferences, and app settings
import React, { useState } from 'react';
import { YStack, XStack, Text, Button, Switch, Separator, ScrollView, Card, H1 } from 'tamagui';
import { SafeAreaView, View, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { supabase } from '@/utils/supabase';
import { useColorScheme } from '@/hooks/useColorScheme';
import { useUiStore } from '@/stores/uiStore';

interface SettingsSectionProps {
  title: string;
  icon: React.ReactNode;
  children: React.ReactNode;
}

const SettingsSection = ({ title, icon, children }: SettingsSectionProps) => {
  return (
    <YStack marginVertical="$2">
      <XStack alignItems="center" space="$2" marginBottom="$2">
        {icon}
        <Text fontSize="$5" fontWeight="bold">{title}</Text>
      </XStack>
      <Card padding="$3" bordered>
        {children}
      </Card>
    </YStack>
  );
};

interface SettingsRowProps {
  label: string;
  icon?: React.ReactNode;
  rightElement?: React.ReactNode;
  onPress?: () => void;
  showChevron?: boolean;
}

const SettingsRow = ({ label, icon, rightElement, onPress, showChevron = false }: SettingsRowProps) => {
  return (
    <XStack
      paddingVertical="$3"
      justifyContent="space-between"
      alignItems="center"
      onPress={onPress}
      pressStyle={onPress ? { opacity: 0.7 } : undefined}
    >
      <XStack space="$3" alignItems="center" flex={1}>
        {icon}
        <Text fontSize="$4">{label}</Text>
      </XStack>
      <XStack space="$2" alignItems="center">
        {rightElement}
        {showChevron && <Ionicons name="chevron-forward" size={18} color="#A0A0A0" />}
      </XStack>
    </XStack>
  );
};

export default function SettingsScreen() {
  const colorScheme = useColorScheme();
  const { isDarkMode, toggleTheme } = useUiStore();
  const [notificationsEnabled, setNotificationsEnabled] = useState(true);
  const [trackingEnabled, setTrackingEnabled] = useState(true);
  
  const handleLogout = async () => {
    Alert.alert(
      'Log Out',
      'Are you sure you want to log out?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Log Out', 
          style: 'destructive',
          onPress: async () => {
            await supabase.auth.signOut();
            router.replace('/(auth)/login');
          }
        }
      ]
    );
  };
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <ScrollView>
        <YStack flex={1} padding="$4">
          <H1 marginBottom="$4">Settings</H1>
          
          {/* Account Section */}
          <SettingsSection
            title="Account"
            icon={<Ionicons name="person-circle-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Edit Profile"
                icon={<Ionicons name="person-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/profile' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Security"
                icon={<Ionicons name="lock-closed-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/security' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Data & Privacy"
                icon={<Ionicons name="shield-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/privacy' as any)}
              />
            </YStack>
          </SettingsSection>
          
          {/* Appearance Section */}
          <SettingsSection
            title="Appearance"
            icon={<Ionicons name="color-palette-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Dark Mode"
                icon={<Ionicons name="moon-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={isDarkMode}
                    onCheckedChange={toggleTheme}
                  />
                }
              />
            </YStack>
          </SettingsSection>
          
          {/* Notifications Section */}
          <SettingsSection
            title="Notifications"
            icon={<Ionicons name="notifications-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Push Notifications"
                icon={<Ionicons name="push-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={notificationsEnabled}
                    onCheckedChange={setNotificationsEnabled}
                  />
                }
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Notification Settings"
                icon={<Ionicons name="options-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/notifications' as any)}
              />
            </YStack>
          </SettingsSection>
          
          {/* Privacy Section */}
          <SettingsSection
            title="Privacy & Data"
            icon={<Ionicons name="analytics-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Analytics Tracking"
                icon={<Ionicons name="trending-up-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={trackingEnabled}
                    onCheckedChange={setTrackingEnabled}
                  />
                }
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Export Data"
                icon={<Ionicons name="download-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => {
                  Alert.alert(
                    'Export Data',
                    'Your data will be prepared for export and sent to your email address.',
                    [
                      { text: 'Cancel', style: 'cancel' },
                      { text: 'Export', onPress: () => {
                        // Would call an API endpoint to initiate export
                        Alert.alert('Export Initiated', 'Check your email for the export file.');
                      }}
                    ]
                  );
                }}
              />
            </YStack>
          </SettingsSection>
          
          {/* Support Section */}
          <SettingsSection
            title="Support & About"
            icon={<Ionicons name="help-circle-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Help Center"
                icon={<Ionicons name="help-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/help' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="About Aether"
                icon={<Ionicons name="information-circle-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/about' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="App Version"
                icon={<Ionicons name="code-outline" size={20} color="#A0A0A0" />}
                rightElement={<Text color="$gray10">1.0.0</Text>}
              />
            </YStack>
          </SettingsSection>
          
          {/* Logout Button */}
          <Button
            marginTop="$6"
            marginBottom="$8"
            size="$4"
            themeInverse
            onPress={handleLogout}
          >
            Log Out
          </Button>
        </YStack>
      </ScrollView>
    </SafeAreaView>
  );
}


[EOF: app/(tabs)/settings/index.tsx]

========================================
FILE: app/(tabs)/planner/index.tsx
ISSUE CONTEXT: ReferenceError: Property "ScrollView" doesn't exist
----------------------------------------

// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/planner/index.tsx
import React, { useState, Suspense } from 'react';
import { YStack, XStack, Text, Tabs, Button, Spinner, Card } from 'tamagui';
import { SafeAreaView, FlatList, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { RouterOutputs } from '@/utils/api-types';
import { SectionError } from '@/components/ui/ErrorBanner';


interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'goals',
    title: 'Goals',
    icon: <Ionicons name="trophy-outline" size={18} color="currentColor" />
  },
  {
    key: 'habits',
    title: 'Habits',
    icon: <Ionicons name="repeat-outline" size={18} color="currentColor" />
  },
  {
    key: 'calendar',
    title: 'Calendar',
    icon: <Ionicons name="calendar-outline" size={18} color="currentColor" />
  }
];

export default function PlannerScreen() {
  const [activeTab, setActiveTab] = useState<string>('goals');
  const colorScheme = useColorScheme();
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Planner</Text>
          <Button
            size="$3"
            circular
            onPress={() => {/* Handle new item */}}
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>
        
        {/* Tabs */}
        <Tabs
          defaultValue="goals"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List 
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {tab.icon}
                  <Text>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>
          
          {/* Tab Content */}
          <Tabs.Content value="goals" flex={1}>
            <ScrollView>
              <GoalsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="habits" flex={1}>
            <ScrollView>
              <HabitsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="calendar" flex={1}>
            <ScrollView>
              <CalendarTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Goals Tab
function GoalsTab() {
  // Fetch goals using tRPC
  const { data: goals, isLoading, error, refetch } = trpc.goal.getGoals.useQuery();
  
  // Define the inferred type for a single goal
  type PlannerGoal = RouterOutputs['goal']['getGoals'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load goals" 
      />
    );
  }
  
  if (!goals || goals.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No goals yet" 
        actionText="Create a goal" 
        onAction={() => router.push('/planner/add-goal')} 
      />
    );
  }
  
  return (
    <YStack space="$4">
      {goals.map((goal: PlannerGoal) => (
        <Button 
          key={goal.id} 
          height="$12" 
          justifyContent="flex-start" 
          paddingHorizontal="$3"
          onPress={() => router.push({ pathname: '/planner/goal/[id]', params: { id: goal.id } })}
        >
          <YStack>
            <Text fontWeight="bold">{goal.title}</Text>
            <Text fontSize="$2" color="$gray10">
              {goal.dueDate ? new Date(goal.dueDate).toLocaleDateString() : 'No due date'}
            </Text>
          </YStack>
        </Button>
      ))}
    </YStack>
  );
}

// Habits Tab
function HabitsTab() {
  // Fetch habits using tRPC
  const { data: habits, isLoading, error, refetch } = trpc.habit.getHabits.useQuery();
  
  // Define the inferred type for a single habit
  type PlannerHabit = RouterOutputs['habit']['getHabits'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={isLoading} count={3} type="row" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load habits" 
      />
    );
  }
  
  if (!habits || habits.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No habits yet" 
        actionText="Create a habit" 
        onAction={() => router.push('/planner/add-habit')} 
      />
    );
  }
  
  return (
    <YStack space="$3">
      {habits.map((habit: PlannerHabit) => (
        <XStack 
          key={habit.id} 
          justifyContent="space-between" 
          alignItems="center" 
          paddingVertical="$3" 
          paddingHorizontal="$3" 
          borderBottomWidth={1} 
          borderColor="$gray5"
          pressStyle={{ opacity: 0.7 }}
          tag="pressable"
          onPress={() => router.push({ pathname: '/planner/habit/[id]', params: { id: habit.id } })}
        >
          <Text>{habit.title}</Text>
          <Button
            size="$2"
            circular
            backgroundColor={habit.completed ? '$green9' : '$gray9'}
            onPress={() => {
              // Use today's date for the habit entry
              const today = new Date().toISOString().split('T')[0];
              
              // Create a mutation to toggle habit completion
              const toggleHabit = trpc.habit.createHabitEntry.useMutation({
                onSuccess: () => {
                  refetch(); // Refresh data after toggling
                },
                onError: (error) => {
                  // Show error message
                  console.error('Failed to toggle habit:', error.message);
                }
              });
              
              // Toggle the habit completion status
              toggleHabit.mutate({
                habitId: habit.id,
                completed: !habit.completed,
                date: today
              });
            }}
            icon={<Ionicons name="checkmark" size={18} color="white" />}
          />
        </XStack>
      ))}
    </YStack>
  );
}

// Calendar Tab
function CalendarTab() {
  return (
    <YStack alignItems="center" justifyContent="center" padding="$8">
      <Text fontSize="$5" textAlign="center">
        Calendar integration coming soon
      </Text>
      <Text marginTop="$2" color="$gray10" textAlign="center">
        This tab will display task and habit schedules in a calendar view
      </Text>
    </YStack>
  );
}


[EOF: app/(tabs)/planner/index.tsx]

========================================
FILE: app/(tabs)/planner/_layout.tsx
ISSUE CONTEXT: Navigation structure for planner tab
----------------------------------------

// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/planner/_layout.tsx
import { Stack } from 'expo-router';
import React from 'react';

export default function PlannerLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      {/* The index screen is the default for the planner tab */}
      <Stack.Screen name="index" />
      {/* Add screens for the sub-pages */}
      <Stack.Screen name="add-task" options={{ presentation: 'modal', title: 'Add Task' }} />
      <Stack.Screen name="add-habit" options={{ presentation: 'modal', title: 'Add Habit' }} />
      <Stack.Screen name="add-goal" options={{ presentation: 'modal', title: 'Add Goal' }} />
      <Stack.Screen name="goal/[id]" options={{ title: 'Goal Details' }} />
      <Stack.Screen name="habit/[id]" options={{ title: 'Habit Details' }} />
    </Stack>
  );
}


[EOF: app/(tabs)/planner/_layout.tsx]

========================================
FILE: app/(tabs)/settings/_layout.tsx
ISSUE CONTEXT: Navigation structure for settings tab
----------------------------------------

// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/settings/_layout.tsx
import { Stack } from 'expo-router';
import React from 'react';

export default function SettingsLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      {/* The index screen is the default for the settings tab */}
      <Stack.Screen name="index" />
      {/* Add screens for the sub-pages */}
      <Stack.Screen name="profile" options={{ title: 'Edit Profile' }} />
      <Stack.Screen name="security" options={{ title: 'Security' }} />
      <Stack.Screen name="privacy" options={{ title: 'Data & Privacy' }} />
      <Stack.Screen name="notifications" options={{ title: 'Notifications' }} />
      <Stack.Screen name="help" options={{ title: 'Help & Support' }} />
      <Stack.Screen name="about" options={{ title: 'About Aether' }} />
    </Stack>
  );
}


[EOF: app/(tabs)/settings/_layout.tsx]


========================================
ERROR ANALYSIS AND RECOMMENDATIONS
----------------------------------------


Okay, let's break down the issues from the debug report and identify which other files would be helpful.

**1. Issue: `TypeError: principles.map is not a function` (in `PrinciplesTab.tsx`)**

* **Explanation:** As the report context suggests, this error happens because the `principles` variable (coming from the `trpc.value.getValues` query) is `undefined` when the `.map()` function tries to run. This occurs during the initial loading state or if the query returns an error.
* **Code Provided:** `app/(tabs)/compass/index.tsx` shows how `PrinciplesTab` is rendered, but not the internal code of `PrinciplesTab` itself.
* **IMPORTANT NOTE: The `components/compass/PrinciplesTab.tsx` file was NOT FOUND by the script.** This suggests either:
  1. The file is in a different location
  2. The component might be defined inline in another file
  3. The file might have a different name
* **Files Needed for Fix:**
  * **`components/compass/PrinciplesTab.tsx`**: This file is essential but missing. We need its content to see exactly how `principles` is being accessed and add the necessary checks (`if (isLoading)...`, `if (error)...`, `if (!principles || !Array.isArray(principles))...`) before the `.map()` call.

**2. Issue: Duplicate Key Warning (`.$undefined-grid=2undefined-grid`) in `RewardsScreen`**

* **Explanation:** The `FlatList` in `app/(tabs)/rewards/index.tsx` uses a `keyExtractor` function that combines `item.id` with `viewMode`. The generated key `.$undefined-grid=2undefined-grid` indicates that for at least one item in the `rewards` array (when `viewMode` is 'grid'), `item.id` is coming through as `undefined`. React requires unique string keys for list items.
* **Code Provided:** `app/(tabs)/rewards/index.tsx` shows the `FlatList` setup.
* **Analysis of Server Code:** If `server/src/routers/rewardsRouter.ts` was found, it should be checked to see if the `getAvailableRewards` procedure correctly selects the `id` field. If the router code looks okay, the issue might be in the database data itself.
* **Next Step:** Log the `rewards` data inside the `RewardsScreen` component right before the `FlatList` is rendered to find which item(s) are missing the `id`:
  ```javascript
  // Inside RewardsScreen component
  console.log("Rewards Data:", JSON.stringify(rewards, null, 2)); // Log before FlatList
  ```
* **Files Needed for Fix:**
  * **`server/src/routers/rewardsRouter.ts`**: To check the `getAvailableRewards` procedure.

**3. Issue: Routing Warnings (`No route named planner/index & settings/index exists...`)**

* **Explanation:** The provided code for `app/(tabs)/_layout.tsx` *does* use the correct naming (`name="planner/index"`, `name="settings/index"`). This should resolve the specific warnings mentioned in the logs.
* **Possible Reasons for Persisting Warnings:**
  * The running app might not have fully reflected the code change yet (clear cache, restart Metro with `npx expo start -c`).
  * There might be *other* places in the code (like `Link` components or `router.push` calls) that are still using old, incorrect short names.
  * The issue might be deeper within Expo Router's handling of nested layouts.
* **Action:** Confirm if the warnings specifically for `planner/index` and `settings/index` are still showing up *after* applying the fix and restarting/clearing cache. If so, search for `Link` or `router.push` calls that might still use short names.

**4. Issue: `ReferenceError: Property "ScrollView" doesn't exist` (in `PlannerScreen`)**

* **Explanation:** The code in `app/(tabs)/planner/index.tsx` uses the `<ScrollView>` component, but it's missing the corresponding import statement.
* **Code Provided:** `app/(tabs)/planner/index.tsx` shows the usage without the import.
* **✅ Fix:** Add the import to `app/(tabs)/planner/index.tsx`:
  ```javascript
  import { YStack, XStack, Text, Tabs, Button, Spinner, Card, ScrollView } from 'tamagui'; // Add ScrollView here
  // or if you intended the React Native one:
  // import { ScrollView } from 'react-native'; 
  ```

**Hypothesis Summary:**

* The `PrinciplesTab` error is likely the same "accessing undefined data before load/error check" issue seen previously, but **we couldn't find the actual file to confirm**.
* The `RewardsScreen` duplicate key error suggests inconsistent data (missing `id`s) coming from the `rewards.getAvailableRewards` tRPC call. Data inspection is needed.
* The `PlannerScreen` `ScrollView` error is a simple missing import - easy to fix.

For a more complete analysis, we would need to locate the missing `PrinciplesTab.tsx` file, possibly by checking other component directories, and also examine the data flowing through the `RewardsScreen` component.
```


# output

### app_code_overview.txt
**Path:** output/app_code_overview.txt
**Size:** 365087 bytes
*(omitted – binary or >204800 bytes)*

### routing.md
**Path:** output/routing.md
**Size:** 4418 bytes

```markdown
# Aether iPhone App – Routing Audit

> Generated: 2025-04-27 13:06 (local)

This audit inspects **all Expo Router routes, layouts, and navigation calls** in the repository and highlights every mismatch currently causing the “resource not available” / “no route named …” warnings seen at runtime.

---

## 1. Current Route File Structure (`app/`)

```plaintext
app/
├─ _layout.tsx                 ← Root stack (global providers)
├─ (auth)/                     ← Hidden segment – NOT shown in URL
│  ├─ _layout.tsx              ← <Stack> – login flow
│  ├─ login.tsx
│  ├─ register.tsx
│  └─ forgot-password.tsx
└─ (tabs)/                     ← Hidden segment – bottom-tab navigator
   ├─ _layout.tsx              ← <Tabs> (5 tabs)
   ├─ home/
   │  └─ index.tsx
   ├─ planner/
   │  └─ index.tsx
   ├─ compass/
   │  └─ index.tsx
   ├─ rewards/
   │  └─ index.tsx
   └─ settings/
      └─ index.tsx
```

>There is **no** `app/index.tsx`, so navigating to `/` currently resolves to a blank screen unless Expo Router falls back to the first child automatically. Creating a lightweight redirect (or turning `(tabs)` into `index.tsx`) is recommended.

---

## 2. Tab Layout vs. Discovered Children

`app/(tabs)/_layout.tsx` registers five `Tabs.Screen`s:

| Declared `name` prop | Actual generated route | Diagnosis |
| --- | --- | --- |
| `home` | `home/index` | ❌ **Mismatch** – Expo emits *exact* file paths (folder + `index`).* |
| `planner` | `planner/index` | ❌ |
| `compass` | `compass/index` | ❌ |
| `rewards` | `rewards/index` | ❌ |
| `settings` | `settings/index` | ❌ |

*Expo Router warning: “No route named `home` exists in nested children: ["home/index", …]”.*

**✅ Fix** – change the `name` props to include `/index`, e.g.

```tsx
<Tabs.Screen name="home/index" … />
```

OR create `home.tsx` files next to the folders to alias the index pages.

---

## 3. Navigation Calls (`router.push`) vs. Real Files

### 3.1  Planner-related pushes

| Push Target | File exists? | Notes |
| --- | --- | --- |
| `/planner` | ✔️ `(tabs)/planner/index.tsx` | OK |
| `/planner/add-task` | ❌ | Missing screen. |
| `/planner/add-habit` | ❌ | Missing. |
| `/planner/add-goal` | ❌ | Missing. |
| `/planner/goal/[id]` | ❌ | Needs `planner/goal/[id].tsx` folder/file pair. |
| `/planner/habit/[id]` | ❌ | Needs `planner/habit/[id].tsx`. |

### 3.2 Home quick-actions

Same missing targets as above because Home forwards to Planner.

### 3.3 Settings pushes

| Push Target | File exists? |
| --- | --- |
| `/settings/profile` | ❌ |
| `/settings/security` | ❌ |
| `/settings/privacy` | ❌ |
| `/settings/notifications` | ❌ |
| `/settings/help` | ❌ |
| `/settings/about` | ❌ |

All of these should live under `(tabs)/settings/` as separate files or a nested stack.

### 3.4 Auth flow

`/(auth)` screens match their pushes (`router.replace('/(auth)/login')`). ✅

---

## 4. Initial Route / Deep Linking

Because there is no `app/index.tsx`, cold-launching the app without a deep link may show the root &lt;Slot&gt; with nothing rendered. On some devices Expo Router silently chooses the first route (`home/index`), but this isn’t guaranteed. A robust pattern is:

```tsx
// app/index.tsx
import { Redirect } from 'expo-router';
export default function () {
  return <Redirect href="/home" />;
}
```

---

## 5. Recommended Fixes (Action List)

1. **Tab names** – update `Tabs.Screen name` props to include `/index` (or supply alias files).
2. **Create missing screens:**
   * `app/(tabs)/planner/add-task.tsx`
   * `app/(tabs)/planner/add-habit.tsx`
   * `app/(tabs)/planner/add-goal.tsx`
   * `app/(tabs)/planner/goal/[id].tsx`
   * `app/(tabs)/planner/habit/[id].tsx`
   * `app/(tabs)/settings/{profile,security,privacy,notifications,help,about}.tsx`
3. **Root redirect** – add `app/index.tsx` that redirects to `/home`.
4. **Use type-safe `router.push`** – once screens are in place, remove the `as any` casts.
5. **Optional** – wrap settings & planner sub-pages in their own `<Stack>` navigator for headers and back gestures.

---

## 6. After Patching

Running `npx expo start` should no longer print the “No route named …” warnings, and every button should open a valid screen. Add placeholder components first; design can be fleshed out later.
```

### tamagui.md
**Path:** output/tamagui.md
**Size:** 9980 bytes

```markdown
# Aether iPhone App – Tamagui Integration Blueprint

> Generated: 2025-04-27 14:32 (local)

This document distils **best-practice research** and a **step-by-step migration plan** for adopting Tamagui across the entire Expo / React-Native code-base, while preserving **end-to-end type-safety** from Postgres ➜ Supabase ➜ tRPC ➜ React Query ➜ Tamagui UI.

---

## 1. Why Tamagui?

| Benefit | Impact on Aether iPhone App |
| --- | --- |
| **One code-base / multi-platform** | Expo (native) + web builds share  ⬆ performance & design. |
| **Typed tokens (theme, sizes, fonts)** | Eliminates magic numbers; easier dark / light modes. |
| **Compile-time extraction** | Smaller JS bundle, lower startup cost. |
| **Headless components** | Toasts, dialogs, sheets, etc. ready-made. |

---

## 2. Current Pain Points

1. `tamagui.config.ts` is valid but some runtime imports (e.g. `@tamagui/toast`) **cannot locate the config** → _"Can’t find Tamagui configuration"_.
2. Screens use **inline styled-components & View/Text** instead of Tamagui primitives (duplicated styles).
3. UI props are loosely typed; rarely use `RouterOutputs` from tRPC.
4. Toast logic duplicated in custom `providers/ToastProvider.tsx` _and_ `@tamagui/toast`.
5. Expo Router route mismatch warnings (see `routing.md`) clutter logs.

---

## 3. Foundations – One Source of Truth

### 3.1 Tamagui config

```ts
// tamagui.config.ts (simplified)
export const config = createTamagui({
  tokens: {
    color: { brand: '#4C6EF5', background: '#fff', text: '#111' },
    space: { 0: 0, 1: 4, 2: 8, 3: 12, 4: 16, 5: 24 },
    radius: { 0: 0, 1: 3, 2: 6, 3: 12 },
  },
  themes: {
    light: { background: '$background', color: '$text' },
    dark: { background: '#000', color: '#eee' },
  },
  fonts: {
    heading: createFont({ family: 'Inter_700Bold', size: { 4: 18, 5: 22, 6: 28 } }),
    body: createFont({ family: 'Inter_400Regular', size: { 4: 14, 5: 16 } }),
  },
  shorthands: { p: 'padding', m: 'margin' },
});
```

*Everything* imports `config` from that single module; **never** duplicate calls to `createTamagui`.

### 3.2 Providers Layer

```tsx
// providers/UIProviders.tsx
export function UIProviders({ children }: { children: ReactNode }) {
  return (
    <TamaguiProvider config={config} defaultTheme="light">
      <ToastProvider>
        {children}
        <ToastViewport name="global_top" top={50} right={0} left={0} />
      </ToastProvider>
    </TamaguiProvider>
  );
}
```

* UIProviders is imported by `app/_layout.tsx` **before** any screen mounts.
* `ToastProvider` re-exports `@tamagui/toast` primitives; delete custom hand-rolled provider unless extra animations required.

---

## 4. Screen Composition Pattern

```tsx
import { YStack, XStack, H2, Paragraph, Button } from 'tamagui';
import { trpc } from '@/utils/trpc';
import type { RouterOutputs } from '@/utils/trpc';

type DashboardData = RouterOutputs['dashboard']['getDashboardData'];

export default function HomeScreen() {
  const { data } = trpc.dashboard.getDashboardData.useQuery();
  if (!data) return null;

  return (
    <YStack flex={1} bg="$background" p="$4">
      <H2>Welcome back</H2>
      <GoalsSection goals={data.goals} />
      <HabitsSection habits={data.habits} />
    </YStack>
  );
}
```

### Rules

1. **Tamagui primitives first** (`YStack`, `XStack`, `Text`, `Button`). Only fall back to `react-native` primitives for edge-cases.
2. **Typed props** – derive from `RouterOutputs`.
3. All spacing / sizes use token syntax (`$4`, `$space.4`) so the compiler can optimise.

---

## 5. Toast Strategy

| Requirement | Implementation |
| --- | --- |
| Trigger toast in any hook or component | `import { useToastController } from '@tamagui/toast';` |
| Standard variants (success, error, info) | Create helper:

```ts
export function showSuccess(msg: string) {
  const toast = useToastController();
  toast.show(msg, { type: 'success' });
}
``` 

| Auto-dismiss | Default 4s; override per call. |
| Accessibility | `announce="polite"` prop optional; Tamagui sets role automatically. |

Remove old `providers/ToastProvider.tsx` – the library already handles animation and state.

---

## 6. tRPC + Tamagui + React Query Glue

1. **Server ⇒ Client inference** already set up (`createTRPCReact`).
2. Define hooks under `hooks/useXYZ.ts` that wrap queries & transform to UI-friendly shape.
3. UI imports typed hooks and passes data to Tamagui components.
4. Keep transformations server-side when possible to minimise client code.

---

## 7. Routing Alignment

Follow fixes in `routing.md` _before_ styling so screens load predictably.

1. Name all tab screens `foo/index` or alias with files.
2. Add missing pages so `router.push` is type-safe.
3. Provide root redirect `app/index.tsx`.

---

## 8. Migration Checklist

| Step | Status | Notes |
| --- | --- | --- |
| Add `jsx: 'react-native'` to `tsconfig.json` | ✅ | Done. |
| Delete `providers/ToastProvider.tsx` | ☐ | Replace with Tamagui provider usage. |
| Create `providers/UIProviders.tsx` (as above) | ☐ | Import in `app/_layout.tsx`. |
| Replace all `View/Text/Pressable` with Tamagui primitives | ☐ | Work screen-by-screen. |
| Use typed RouterOutputs in every component props | ☐ | Reference `type-diagnosis.md`. |
| Implement missing screens (routing.md) | ☐ | Even if placeholder. |
| Re-run `@tamagui/cli treeshake` & ensure build passes | ☐ | |

---

## 9. Resources & References

* Tamagui Docs – https://tamagui.dev/docs/intro
* Expo Tamagui guide – https://tamagui.dev/docs/intro/expo
* Blog: **“End-to-end Type-Safety with tRPC & Tamagui”** – https://benmvp.com/blog/trpc-tamagui-types/
* Example full-stack repo – https://github.com/tamagui/starters/tree/master/next-native-tamagui

---

## 10. Conclusion

Adopting the above blueprint will give Aether iPhone App a **consistent design language, smaller bundle size, and rock-solid type-safety** from database to UI. Work through the checklist iteratively; once `providers/UIProviders.tsx` replaces the custom toast logic and screens start using tokens, the lingering _“Can’t find Tamagui configuration”_ error should disappear for good.

---

## 11. Screen-by-Screen Tamagui Implementation Plan

Below is an actionable map for migrating every UI surface to Tamagui primitives, ensuring **tokens, themes, and full type-safety** across the stack.

| Screen / Area | Main Components | Tamagui Strategy |
| --- | --- | --- |
| **Root Providers** (`app/_layout.tsx`) | `UIProviders` wrapper | Import `UIProviders` (see §3) that embeds `TamaguiProvider`, `ToastProvider`, and a global `ToastViewport`. |
| **Auth Flow** (`/(auth)` folder) | `Login`, `Register`, `ForgotPassword` | Replace all `View/Text/Pressable` with `YStack`, `Input`, `Button`, `Paragraph`. Use `$space` tokens for gaps, `Variant` props (`Button theme="active"`). |
| **Tabs Layout** (`(tabs)/_layout.tsx`) | The `<Tabs>` navigator | Minimal edits. Use Tamagui icons (`@tamagui/lucide-icons`) and theme-aware colors for tab bar. |
| **Home Screen** | `GoalSummaryCard`, `HabitCheckItem`, `DashboardSection`, `EmptyOrSkeleton`, `ProgressRing` | Convert each card to `Card`, `XStack`, `YStack`. Pull type definitions from `RouterOutputs['dashboard']['getDashboardData']`. Use tokenized radius + space. Animate ring with `tamagui/animate` helpers. |
| **Planner Screen** | `GoalsTab`, `HabitsTab`, `TasksTab` | Use `Tabs` from `@tamagui/tabs` for internal segmentation. Each row becomes a `ListItem` with `Checkbox` or `Switch`. |
| **Planner Detail Pages** (`goal/[id]`, `habit/[id]`) | `GoalDetail`, `HabitDetail` | Use `Sheet` for edit modal, `ProgressCircle` for metrics, `Button` variants for actions. |
| **Compass** | `ValuesList`, `TrackedStateList` | Map DB rows to `ListItem` + icon. Use `InfiniteScroll` from `@tamagui/lists`. |
| **Rewards** | `RewardCard`, `RedeemDialog` | `Card` with `Image` + `Text`. `Dialog` primitive for confirmation. |
| **Settings** | `Profile`, `Security`, `Privacy`, `Notifications`, `Help`, `About` screens | Build uniform `Form` using `Fieldset`, `Label`, `Switch`, `Input`. Tokens ensure consistent padding. |
| **Shared Components** | `ErrorBanner`, `Skeleton`, `ProgressRing`, `StateIndicator` | Rewrite as standalone Tamagui components, exporting typed props. Use `styled()` to accept variant props (e.g., `severity="error|info"`). |

### Implementation Order

1. **Providers & Root Layout (Day 1)** – guarantees config is loaded everywhere.
2. **Auth Flow (Day 1-2)** – small, self-contained screens → quick wins.
3. **Dashboard/Home (Day 2-3)** – high-visibility screen; exercise cards & lists.
4. **Planner Tabs (Day 3-4)** – data-heavy; validates List & Checkbox patterns.
5. **Misc Screens (Compass/Re​wards/Settings) (Day 4-5)**.
6. **Polish & Remove Legacy Styles (Day 6)** – delete remaining `StyleSheet.create` blocks.

### Type-Safety Hooks

For every data-driven screen:
```ts
import { RouterOutputs } from '@/utils/trpc';

type Goal = RouterOutputs['goal']['getGoals'][number];
```
…then wire to UI props.

### Global ESLint Rule

Add:
```json
"no-restricted-imports": ["error", {
  "paths": [{ "name": "react-native", "importNames": ["View","Text","Pressable","TouchableOpacity"] }]
}] 
```
This enforces Tamagui primitives in new code.

---

## 12. Confirmation of Comprehensive Tamagui Usage

* **Config** – Single `tamagui.config.ts` imported by *every* UI module.
* **Primitives** – All new UI code uses Tamagui components; legacy components scheduled for rewrite per roadmap.
* **Headless Features** – Toast, Sheet, Dialog, Tabs primitives integrated.
* **Compile-time Extraction** – `@tamagui/babel-plugin` already in `babel.config.js`; run `npx tamagui` before production builds.
* **Type-Safe Data Flow** – Components typed via `RouterOutputs`, ensuring DB→UI consistency.

Completion of the roadmap will guarantee **full-stack cohesion** and eliminate runtime configuration errors.
```

### type-diagnosis.md
**Path:** output/type-diagnosis.md
**Size:** 5943 bytes

```markdown
# Aether iPhone App – End-to-End Type-System Diagnosis

> Date generated: 2025-04-27 12:45 (local)

---

## 1. Summary

This document audits the **client (Expo/React Native)** and **server (tRPC)** layers to ensure that:

1. Every screen/component receives the props it expects.
2. Every tRPC procedure returns the shape the client actually consumes.
3. The shared `zod` schemas in `server/src/types/trpc-types.ts` are used consistently.

Mismatches are called out with **❌ Problems** and recommended fixes with **✅ Fix**.

---

## 2. Screens & Components

| Screen / Component | Expected Props (runtime) | Source of Data | Diagnosis |
| --- | --- | --- | --- |
| `HomeScreen` (`app/(tabs)/home/index.tsx`) | `dashboardData.goals: { id, title, progress, tasks }[]`<br>`dashboardData.habits: { id, title, completed, streak }[]` | `trpc.dashboard.getDashboardData` | ✅ **Fixed:** Server returns correct shape. Client component updated to use inferred types. |
| `PlannerScreen.GoalsTab` | `trpc.goal.getGoals → Goal[]` where `Goal` has `title`, `dueDate` | `goalRouter.getGoals` | ✅ **Fixed:** Server returns `title`, `dueDate` (mapped from `target_date`). Client needs check. |
| `PlannerScreen.HabitsTab` | `trpc.habit.getHabits → { id, title, completed }[]` | `habitRouter.getHabits` | ✅ **Fixed:** Server returns `title` (mapped from `name`) and `completed`. Client needs check. |
| `HabitCheckItem` | `{ id, title, streak, completed }` | Comes from `HomeScreen` sliced habits | ✅ **Fixed:** Server returns correct shape (`completed`, `title`). Component updated to use inferred type and correct prop name. |
| `GoalSummaryCard` | `{ id, title, progress, tasks:{total,completed} }` | Comes from `HomeScreen` goals slice | ✅ **Fixed:** Server returns correct shape. Component updated to use inferred type. |
| `CompassScreen` (`principles` / `states` tabs) | commented-out placeholders for `value` / `trackedState` lists | Server routers (`valueRouter`, `trackedStateRouter`) implemented; client not wired. | ⚠️ Implementation pending on client side. |
| `RewardsScreen` | Place-holder comments; expects `rewards.list` etc. | `rewardsRouter` exists. | ⚠️ Not wired. |

> **General pattern:** Most table columns are named `name`, but UI components uniformly expect `title`. Unify naming to avoid cast-as-any in UI.

---

## 3. tRPC Procedures

Below is the canonical list (from `server/src/router.ts`) with notes on client usage.

| Router | Procedure | Input Schema | Output | Consumed By | Diagnosis |
| --- | --- | --- | --- | --- | --- |
| `dashboard` | `getDashboardData` | none | `{ habits, goals, tasks, values, habitEntries }` (processed) | HomeScreen | ✅ **Fixed:** Returns computed fields/correct names. |
| `dashboard` | `getWeeklyProgress` | none | metrics & arrays | Not yet used | – |
| `habit` | `getHabits` | none | `habits.*` with `title` and `completed` | Planner.HabitsTab, HomeScreen | ✅ **Fixed:** Returns `title` and `completed`. |
| `habit` | `createHabitEntry` | `{ habitId, date, completed, notes? }` | HabitEntry row | HomeScreen & Planner.HabitsTab toggle | ✅ Matches. |
| `goal` | `getGoals` | none | Goal rows with `title` and `dueDate` | Planner.GoalsTab | ✅ **Fixed:** Returns `title` and `dueDate`. |
| `goal` | `getGoalById` | `{ id }` | Goal row | Planner goal detail screen (not yet implemented) | – |
| `task` | CRUD | – | – | Not yet consumed in UI; future work.
| `value`, `state`, `rewards`, `user` | various | – | – | Only stubbed on client. |

---

## 4. Shared Type Definitions (`server/src/types/trpc-types.ts`)

* Pros
  * 👍 Centralised Zod schemas for DB rows & common inputs.
  * 👍 `RouterInputs` / `RouterOutputs` exported for client inference.

* Issues
  * Client components are **not** importing these helpers; instead rely on implicit any-typed objects.
  * `utils/trpc.ts` re-exports `RouterInputs/Outputs`, but no UI code uses them.

**✅ Fix**: import as
```ts
import { RouterOutputs } from '@/utils/trpc';
type DashboardGoal = RouterOutputs['dashboard']['getDashboardData']['goals'][number];
```

---

## 5. Gaps & Recommendations

1. **Field Name Alignment**
   * Rename DB column `name` → `title` **or** map in router (`select('id, name as title, streak')`).
   * Add aggregates (progress %, task counts) inside `dashboard.getDashboardData` so UI stops faking them.
2. **Explicit Types in UI**
   * Stop inline object creation (`goal: { id, title, … }`). Use output inference helpers.
3. **Pass Query Params Correctly**
   * Currently using `router.push('/planner' as any)`; replace with strongly typed routes once Expo Router v2 type support lands.
4. **Unused Routers**
   * `valueRouter`, `trackedStateRouter`, `rewardsRouter` are implemented server-side but unused. Create UI fetch hooks or remove dead code.
5. **Shared Hooks Generator**
   * Consider running `trpc-codegen` to generate typed React Query hooks instead of `createTRPCReact` raw call.
6. **Testing**
   * Add unit tests ensuring router output matches Zod schema expected by UI.

---

## 6. Next Steps Checklist

* [x] Refactor server routers (`dashboard`, `habit`, `goal`) to join/aggregate and return correctly named/shaped data (`progress`, `tasks`, `completed`, `title`, `dueDate`).
* [x] Update `HomeScreen`, `GoalSummaryCard`, `HabitCheckItem` components to consume new typed outputs using `RouterOutputs`.
* [x] Update `PlannerScreen` tabs (`GoalsTab`, `HabitsTab`) to use inferred types from `goalRouter.getGoals` and `habitRouter.getHabits`.
* [x] Replace magic strings (`'day'|'week'`) with enums imported from shared types (Checked: No hardcoded strings found; Zod enum `Habit.frequency_period` used).
* [ ] Wire Compass & Rewards screens to their routers.
* [ ] Enforce `strictNullChecks` and `--noImplicitAny` in `tsconfig`.

---

### 🚀 Once these fixes land, the client and server will share a robust, fully inferred end-to-end type-system.
```


# (root files)

### package.json
**Path:** package.json
**Size:** 2510 bytes

```json
{
  "name": "aetheriphone",
  "version": "1.0.0",
  "main": "expo-router/entry",
  "private": true,
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "lint": "expo lint",
    "generate": "node ./scripts/generate-all.js",
    "dev": "npm run generate && expo start"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.2",
    "@gluestack-ui/config": "^1.1.20",
    "@gluestack-ui/themed": "^1.1.73",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "@shopify/flash-list": "^1.8.0",
    "@supabase/supabase-js": "^2.49.4",
    "@tamagui/core": "1.126.1",
    "@tamagui/lucide-icons": "1.126.1",
    "@tamagui/stacks": "1.126.1",
    "@tamagui/themes": "1.126.1",
    "@tamagui/toast": "1.126.1",
    "@tanstack/query-async-storage-persister": "^5.74.4",
    "@tanstack/react-query": "^5.74.11",
    "@tanstack/react-query-persist-client": "^5.74.4",
    "@trpc/client": "^11.1.2",
    "@trpc/react-query": "^11.1.2",
    "burnt": "^0.13.0",
    "date-fns": "^4.1.0",
    "expo": "~52.0.46",
    "expo-blur": "~14.0.3",
    "expo-constants": "~17.0.8",
    "expo-dev-client": "~5.0.20",
    "expo-font": "~13.0.4",
    "expo-haptics": "~14.0.1",
    "expo-linking": "~7.0.5",
    "expo-router": "~4.0.20",
    "expo-secure-store": "^14.0.1",
    "expo-splash-screen": "~0.29.24",
    "expo-status-bar": "~2.0.1",
    "expo-web-browser": "~14.0.2",
    "lottie-react-native": "7.1.0",
    "moti": "^0.30.0",
    "nativewind": "^4.1.23",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-native": "0.76.9",
    "react-native-gesture-handler": "^2.25.0",
    "react-native-reanimated": "^3.17.5",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-svg": "15.8.0",
    "react-native-swipe-list-view": "^3.2.9",
    "react-native-url-polyfill": "^2.0.0",
    "superjson": "^2.2.2",
    "tamagui": "1.126.1",
    "text-encoding": "^0.7.0",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@testing-library/react-native": "^13.2.0",
    "@types/react": "~18.3.12",
    "@types/react-test-renderer": "^18.3.0",
    "eslint": "^8.57.0",
    "eslint-config-expo": "~8.0.1",
    "jest-expo": "~52.0.6",
    "nativewind": "^4.1.23",
    "tailwindcss": "^3.4.17",
    "typescript": "^5.3.3"
  },
  "resolutions": {
    "@gluestack-ui/config": "^1.1.20",
    "react-native-gesture-handler": "^2.25.0"
  }
}
```

### postcss.config.js
**Path:** postcss.config.js
**Size:** 83 bytes

```javascript
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}; ```

### project.txt
**Path:** project.txt
**Size:** 130581 bytes

```
# Aether iPhone: Tamagui to Gluestack/NativeWind Migration
Generated on Wed Apr 30 00:52:25 CDT 2025

\n\n# 1️⃣ Core Design System
\nMigration path: Tamagui tokens → Gluestack UI + NativeWind
\n\n## Current tokens (tamagui.config.ts)
**Current implementation:** tamagui.config.ts
\n```
// tamagui.config.ts
import { createAnimations } from '@tamagui/animations-react-native';
import { createFont, createTamagui, createTokens } from 'tamagui';
import { Platform } from 'react-native';
import * as MotionConstants from '@/constants/motion'; // Import motion constants

// Font definitions - Zelda Theme
// Assumes 'CalamitySans' and 'HyliaSerif' are loaded via useFonts or similar
const headingFont = createFont({
  family: 'HyliaSerif', // Zelda Display Font
  size: {
    // Mapped closer to iOS Dynamic Type: https://developer.apple.com/design/human-interface-guidelines/typography
    1: 13,  // Caption 2
    2: 15,  // Subheadline
    3: 17,  // Body (true default)
    4: 20,  // Title 3
    5: 22,  // Title 2
    6: 28,  // Title 1
    7: 34,  // Large Title
    8: 40,  // Extra Large Title (custom)
    true: 17, // Default size (Body)
  },
  lineHeight: {
    // Approximate line heights based on new sizes
    1: 18, 2: 20, 3: 22, 4: 25, 5: 28, 6: 34, 7: 41, 8: 50, 
    true: 22,
  },
  weight: {
    // Prompt 2 asks for 400-700
    4: '400', // Normal
    6: '600', // Semi-bold/Bold
    7: '700', // Extra-bold/Black
    true: '400',
  },
  letterSpacing: {
    1: 0, 2: 0, 3: -0.5, 4: -0.5, 5: -1, 6: -1, 7: -1.5, 8: -1.5,
    true: 0,
  },
  // Required: Map weights to specific font faces if needed (e.g., 'HyliaSerif-Bold')
  // face: {
  //   400: { normal: 'HyliaSerif-Regular' },
  //   700: { normal: 'HyliaSerif-Bold' },
  // },
});

const bodyFont = createFont({
  family: 'CalamitySans', // Zelda Body Font
  size: {
    // Mapped closer to iOS Dynamic Type
    1: 11,  // Footnote
    2: 12,  // Caption 1
    3: 13,  // Caption 2
    4: 15,  // Subheadline
    5: 17,  // Body (true default)
    6: 20,  // Title 3 (matching headingFont.$4)
    true: 17, // Default body size
  },
  lineHeight: {
    // Approximate line heights
    1: 13, 2: 16, 3: 18, 4: 20, 5: 22, 6: 25,
    true: 22, // Default body line height
  },
  weight: {
    4: '400', // Regular
    5: '500', // Medium (if available)
    7: '700', // Bold (if needed/available)
    true: '400',
  },
  letterSpacing: {
    1: 0.1, 2: 0.1, 3: 0, 4: 0, 5: -0.1, 6: -0.1,
    true: 0,
  },
  // Required: Map weights to specific font faces if needed (e.g., 'CalamitySans-Medium')
  // face: {
  //   400: { normal: 'CalamitySans-Regular' },
  //   500: { normal: 'CalamitySans-Medium' },
  // },
});

const monoFont = createFont({
  family: Platform.select({ web: 'monospace', default: 'SpaceMono' }), // Keep SpaceMono for code
  size: {
    1: 12, 2: 14, 3: 15, 4: 16, 5: 18, 6: 20, true: 15,
  },
  lineHeight: {
    1: 18, 2: 22, 3: 24, 4: 26, 5: 28, 6: 32, true: 24,
  },
  weight: {
    4: '400', // Normal weight
    true: '400',
  },
  letterSpacing: {
    4: 0,
    true: 0,
  },
  face: {
    400: { normal: 'SpaceMono' }, // Map weight 400 to the loaded SpaceMono font
  },
});

// Animation driver using reanimated
const animations = createAnimations({
  fast: {
    type: 'timing',
    duration: MotionConstants.durations.standard,
    // easing: MotionConstants.easings.standard, // Removed as createAnimations defaults work well
  },
  medium: {
    type: 'timing',
    duration: MotionConstants.durations.modal,
  },
  slow: {
    type: 'timing',
    duration: MotionConstants.durations.long,
  },
  bouncy: {
    type: 'spring',
    damping: 9,
    mass: 0.9,
    stiffness: 150,
  },
  lazy: {
    type: 'spring',
    damping: 18,
    stiffness: 50,
  },
  quick: {
    type: 'spring',
    damping: 20,
    mass: 1.2,
    stiffness: 250,
  },
});

// Standard Radix Gray scale (light theme)
const gray = {
  gray1: '#fcfcfc', gray2: '#f8f8f8', gray3: '#f3f3f3', gray4: '#ededed', gray5: '#e8e8e8', gray6: '#e2e2e2', gray7: '#dbdbdb', gray8: '#c7c7c7', gray9: '#8f8f8f', gray10: '#858585', gray11: '#6f6f6f', gray12: '#171717',
};

// Standard Radix Gray scale (dark theme)
const grayDark = {
  gray1: '#191919', gray2: '#212121', gray3: '#282828', gray4: '#303030', gray5: '#393939', gray6: '#424242', gray7: '#4f4f4f', gray8: '#626262', gray9: '#737373', gray10: '#838383', gray11: '#ababab', gray12: '#ededed',
};

// Tokens (refined based on your existing config)
const tokens = createTokens({
  size: {
    0: 0, 1: 4, 2: 8, 3: 12, 4: 16, 5: 20, 6: 24, 7: 28, 8: 32, 9: 36, 10: 40, 11: 44, 12: 48, 13: 52, 14: 56, 15: 60, 16: 64, true: 16,
  },
  space: {
    0: 0, 1: 4, 2: 8, 3: 12, 4: 16, 5: 20, 6: 24, 7: 28, 8: 32, 9: 36, 10: 40, 11: 44, 12: 48, 13: 52, 14: 56, 15: 60, 16: 64, true: 16, '-1': -4, '-2': -8, '-3': -12, '-4': -16,
  },
  radius: {
    0: 0, 1: 3, 2: 5, 3: 8, 4: 10, 5: 14, 6: 16, 7: 20, 8: 24, 9: 28, 10: 32, true: 10, // Updated radius.5 to 14
  },
  zIndex: { 0: 0, 1: 100, 2: 200, 3: 300, 4: 400, 5: 500 },
  color: {
    // Zelda Palette (Prompt 1)
    ...gray, // Add light greys
    ...grayDark, // Add dark greys (will be overridden in dark theme definition)
    parchment: '#FDFFE0',
    sheikahCyan: '#86A5A9',
    korokGreen: '#92C582',
    darkText: '#536F50',
    guardianOrange: '#FF9F0A',
    darkTealBg: '#1A2E3A',
    darkCyanGlow: '#64FFDA',

    // Shadow Colors (Prompt 5)
    shadowColorLight: 'rgba(83, 111, 80, 1)', // dark desaturated text color
    shadowColorDark: 'rgba(0, 0, 0, 1)', // Black base
    white: '#FFFFFF',
    black: '#000000',
  },
});

// Define themes using Zelda Palette
const lightTheme = {
  // Base Colors
  background: tokens.color.parchment,      // Light bg
  backgroundStrong: tokens.color.white,     // Keep white for strong contrast areas if needed
  backgroundTransparent: 'rgba(253, 255, 224, 0)', // Fully transparent parchment
  color: tokens.color.darkText,             // Dark desaturated text
  colorSecondary: tokens.color.darkText,      // Use main text color, maybe slightly lighter if needed later
  colorTertiary: tokens.color.sheikahCyan,    // Use accent for tertiary info?
  borderColor: tokens.color.sheikahCyan,      // Use accent for borders
  borderColorHover: tokens.color.korokGreen,  // Korok green on hover?

  // Theme-specific states (can refine later)
  backgroundHover: tokens.color.parchment,    // Keep parchment, maybe slightly darker/lighter
  backgroundPress: tokens.color.parchment,    // Keep parchment
  backgroundFocus: tokens.color.parchment,    // Keep parchment
  colorHover: tokens.color.korokGreen,        // Korok green text on hover?
  colorPress: tokens.color.korokGreen,
  colorFocus: tokens.color.sheikahCyan,
  borderColorPress: tokens.color.korokGreen,
  borderColorFocus: tokens.color.sheikahCyan,

  // Semantic Tokens (Prompt 4)
  accent: tokens.color.sheikahCyan,
  surfaceSubtle: tokens.color.parchment,    // Base color, apply opacity in component (e.g., rgba(253,255,224,0.8))
  destructive: tokens.color.guardianOrange,

  // Standard Semantic Mapping (can use Zelda colors)
  primary: tokens.color.sheikahCyan,        // Map primary to accent
  secondary: tokens.color.korokGreen,       // Map secondary to korok green?
  success: tokens.color.korokGreen,
  warning: tokens.color.guardianOrange,     // Use guardian orange for warning
  error: tokens.color.guardianOrange,       // Use guardian orange for error
  info: tokens.color.sheikahCyan,

  // Semantic Aliases (Playbook 1.1)
  surface: tokens.color.parchment, // Maps to background
  onSurface: tokens.color.darkText,  // Maps to color
  outline: tokens.color.sheikahCyan, // Maps to borderColor

  // Shadows (Playbook 1.1 & Prompt 5)
  shadowColor: tokens.color.shadowColorLight, // Use darkText color base for shadow
  shadowColorHover: 'rgba(83, 111, 80, 0.15)',
  shadowSm: 'rgba(83, 111, 80, 0.10)', // 10% opacity
  shadowMd: 'rgba(83, 111, 80, 0.15)', // 15% opacity
  shadowLg: 'rgba(83, 111, 80, 0.20)', // 20% opacity

  // Toast Themes (Report Item 6)
  toast_success_background: tokens.color.korokGreen,
  toast_success_color: tokens.color.parchment,
  toast_error_background: tokens.color.guardianOrange,
  toast_error_color: tokens.color.parchment,
  toast_warning_background: tokens.color.guardianOrange, // Often same as error
  toast_warning_color: tokens.color.parchment,
  toast_info_background: tokens.color.sheikahCyan,
  toast_info_color: tokens.color.parchment,
};

const darkTheme: typeof lightTheme = {
  // Base Colors
  ...grayDark, // Override light greys with dark greys
  background: tokens.color.darkTealBg,      // Dark-mode bg
  backgroundStrong: tokens.color.black,       // Black for contrast?
  backgroundTransparent: 'rgba(26, 46, 58, 0)', // Fully transparent dark teal
  color: tokens.color.parchment,          // Use light parchment for text
  colorSecondary: tokens.color.sheikahCyan,   // Sheikah cyan for secondary text
  colorTertiary: tokens.color.korokGreen,     // Korok green for tertiary
  borderColor: tokens.color.sheikahCyan,      // Sheikah cyan borders
  borderColorHover: tokens.color.darkCyanGlow, // Glow cyan on hover?

  // Theme-specific states
  backgroundHover: tokens.color.darkTealBg,   // Keep bg, maybe slightly lighter
  backgroundPress: tokens.color.darkTealBg,
  backgroundFocus: tokens.color.darkTealBg,
  colorHover: tokens.color.darkCyanGlow,
  colorPress: tokens.color.darkCyanGlow,
  colorFocus: tokens.color.darkCyanGlow,
  borderColorPress: tokens.color.darkCyanGlow,
  borderColorFocus: tokens.color.darkCyanGlow,

  // Semantic Tokens (Prompt 4)
  accent: tokens.color.sheikahCyan,
  surfaceSubtle: tokens.color.darkTealBg, // Use dark bg, apply opacity in component
  destructive: tokens.color.guardianOrange,

  // Standard Semantic Mapping
  primary: tokens.color.darkCyanGlow,       // Use glow cyan for primary actions
  secondary: tokens.color.korokGreen,
  success: tokens.color.korokGreen,
  warning: tokens.color.guardianOrange,
  error: tokens.color.guardianOrange,
  info: tokens.color.sheikahCyan,

  // Semantic Aliases (Playbook 1.1)
  surface: tokens.color.darkTealBg,   // Maps to background
  onSurface: tokens.color.parchment,  // Maps to color
  outline: tokens.color.sheikahCyan, // Maps to borderColor

  // Shadows (Playbook 1.1 & Prompt 5)
  shadowColor: tokens.color.shadowColorDark, // Darker shadow for dark mode
  shadowColorHover: 'rgba(0, 0, 0, 0.30)',
  shadowSm: 'rgba(0, 0, 0, 0.20)', // 20% opacity
  shadowMd: 'rgba(0, 0, 0, 0.30)', // 30% opacity
  shadowLg: 'rgba(0, 0, 0, 0.40)', // 40% opacity

  // Toast Themes (Report Item 6)
  toast_success_background: tokens.color.korokGreen,
  toast_success_color: tokens.color.darkTealBg,
  toast_error_background: tokens.color.guardianOrange,
  toast_error_color: tokens.color.darkTealBg,
  toast_warning_background: tokens.color.guardianOrange, // Often same as error
  toast_warning_color: tokens.color.darkTealBg,
  toast_info_background: tokens.color.sheikahCyan,
  toast_info_color: tokens.color.darkTealBg,
};

// Create the Tamagui config
const config = createTamagui({
  animations,
  shouldAddPrefersColorThemes: true,
  themeClassNameOnRoot: true,
  shorthands: {
    // Keep your existing shorthands
    m: 'margin', mt: 'marginTop', mr: 'marginRight', mb: 'marginBottom', ml: 'marginLeft', mx: 'marginHorizontal', my: 'marginVertical',
    p: 'padding', pt: 'paddingTop', pr: 'paddingRight', pb: 'paddingBottom', pl: 'paddingLeft', px: 'paddingHorizontal', py: 'paddingVertical',
    bg: 'backgroundColor', br: 'borderRadius', bw: 'borderWidth', bc: 'borderColor',
    f: 'flex', fd: 'flexDirection', ai: 'alignItems', jc: 'justifyContent', w: 'width', h: 'height',
    ac: 'alignContent',
    als: 'alignSelf',
    btc: 'borderTopColor',
    bbc: 'borderBottomColor',
    blc: 'borderLeftColor',
    brc: 'borderRightColor',
    boc: 'borderColor',
    bs: 'borderStyle',
    dsp: 'display',
    fb: 'flexBasis',
    fg: 'flexGrow',
    fs: 'flexShrink',
    fw: 'flexWrap',
    mah: 'maxHeight',
    maw: 'maxWidth',
    mih: 'minHeight',
    miw: 'minWidth',
    op: 'opacity',
    ov: 'overflow',
    r: 'right',
    shac: 'shadowColor',
    shar: 'shadowRadius',
    shof: 'shadowOffset',
    shop: 'shadowOpacity',
    t: 'top',
    ta: 'textAlign',
    tt: 'textTransform',
    va: 'verticalAlign',
    zi: 'zIndex',
  },
  fonts: {
    // Use Zelda fonts
    heading: headingFont,
    body: bodyFont,
    mono: monoFont, // Keep mono
  },
  themes: {
    light: lightTheme,
    dark: darkTheme,
  },
  tokens,
  media: { // Keep standard media queries
    xs: { maxWidth: 660 }, sm: { maxWidth: 800 }, md: { maxWidth: 1020 }, lg: { maxWidth: 1280 }, xl: { maxWidth: 1420 }, xxl: { maxWidth: 1600 },
    gtXs: { minWidth: 661 }, gtSm: { minWidth: 801 }, gtMd: { minWidth: 1021 }, gtLg: { minWidth: 1281 },
    short: { maxHeight: 820 }, tall: { minHeight: 820 },
    hoverNone: { hover: 'none' }, pointerCoarse: { pointer: 'coarse' },
  },
  settings: {
      allowedStyleValues: 'somewhat-strict',
      autocompleteSpecificTokens: 'except-special',
  },
});

type AppConfig = typeof config;

// Augment Tamagui interface - this is crucial!
declare module '@tamagui/core' {
  // If AppConfig is defined and exported:
  interface TamaguiCustomConfig extends AppConfig {}
}

export default config;```
\n\n## tailwind.config.js (to be rewritten)
**Current implementation:** tailwind.config.js
\n```
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./app/**/*.{js,jsx,ts,tsx}",
    "./components/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {
      // iOS standard colors
      colors: {
        // iOS system colors
        'ios-blue': '#007AFF',
        'ios-dark-blue': '#0A84FF', // dark mode variant
        'ios-red': '#FF3B30',
        'ios-dark-red': '#FF453A', // dark mode variant
        'ios-green': '#34C759',
        'ios-dark-green': '#30D158', // dark mode variant
        'ios-orange': '#FF9500',
        'ios-dark-orange': '#FF9F0A', // dark mode variant
        'ios-purple': '#AF52DE',
        'ios-dark-purple': '#BF5AF2', // dark mode variant
        'ios-yellow': '#FFCC00',
        'ios-dark-yellow': '#FFD60A', // dark mode variant
        'ios-pink': '#FF2D55',
        'ios-dark-pink': '#FF375F', // dark mode variant
        'ios-indigo': '#5856D6',
        'ios-dark-indigo': '#5E5CE6', // dark mode variant
        
        // iOS gray palette
        'ios-gray': {
          1: '#8E8E93',
          2: '#AEAEB2',
          3: '#C7C7CC',
          4: '#D1D1D6',
          5: '#E5E5EA',
          6: '#F2F2F7',
        },
        'ios-dark-gray': {
          1: '#8E8E93',
          2: '#636366',
          3: '#48484A',
          4: '#3A3A3C',
          5: '#2C2C2E',
          6: '#1C1C1E',
        },
        
        // System background colors
        'ios-system': {
          DEFAULT: '#FFFFFF',
          secondary: '#F2F2F7',
          tertiary: '#FFFFFF',
        },
        'ios-dark-system': {
          DEFAULT: '#000000',
          secondary: '#1C1C1E',
          tertiary: '#2C2C2E',
        },
      },
      
      // iOS standard spacing
      spacing: {
        // Added standard iOS spacing if needed beyond Tailwind defaults
      },
      
      // iOS standard border radius
      borderRadius: {
        'ios-small': '4px',
        'ios-regular': '8px',
        'ios-large': '12px',
        'ios-xl': '16px',
      },
      
      // iOS system font weights
      fontWeight: {
        'ios-regular': '400',
        'ios-medium': '500', 
        'ios-semibold': '600',
        'ios-bold': '700',
      },
      
      // iOS shadows
      boxShadow: {
        'ios-small': '0 1px 2px rgba(0, 0, 0, 0.05)',
        'ios-medium': '0 2px 4px rgba(0, 0, 0, 0.1)',
        'ios-large': '0 4px 6px rgba(0, 0, 0, 0.1)',
      },
    },
  },
  plugins: [],
}; ```
\n\n## Motion constants
**Current implementation:** constants/motion.ts
\n```
import { Easing } from 'react-native-reanimated';

/**
 * Standard animation durations (in milliseconds)
 */
export const durations = {
  /** Ultra-fast for micro-interactions */
  micro: 80,
  /** Tap/press feedback */
  tap: 120,
  /** Default animation speed for most UI transitions */
  standard: 200,
  /** For more noticeable animations */
  medium: 250,
  /** Modal entrances/exits, complex transitions */
  modal: 300,
  /** Full screen transitions */
  screen: 350,
  /** Extended animations for emphasis */
  long: 450,
};

/**
 * Standard easing curves
 */
export const easings = {
  /** Quick acceleration, gradual deceleration - for elements entering the screen */
  enter: Easing.bezier(0.25, 0.1, 0.25, 1.0),
  /** Gradual acceleration, quick deceleration - for elements exiting the screen */
  exit: Easing.bezier(0.25, 0.0, 0.2, 1.0),
  /** For transitions between UI states */
  standard: Easing.bezier(0.4, 0.0, 0.2, 1.0),
  /** Quick in, quick out - for emphasis */
  energetic: Easing.bezier(0.55, 0.0, 0.1, 1.0),
  /** Linear - consistent motion with no acceleration/deceleration */
  linear: Easing.linear,
  /** Slow start, fast finish */
  accelerate: Easing.in(Easing.quad),
  /** Fast start, slow finish */
  decelerate: Easing.out(Easing.quad),
  /** Fast start and end, slower in the middle */
  emphasize: Easing.inOut(Easing.quad),
};

/**
 * Animation presets for common UI patterns
 */
export const presets = {
  fadeIn: {
    duration: durations.standard,
    easing: easings.enter,
  },
  fadeOut: {
    duration: durations.standard,
    easing: easings.exit,
  },
  slideIn: {
    duration: durations.modal,
    easing: easings.enter,
  },
  slideOut: {
    duration: durations.modal,
    easing: easings.exit,
  },
  scaleIn: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  scaleOut: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  tapFeedback: {
    duration: durations.tap,
    easing: easings.emphasize,
  },
  skeleton: {
    duration: durations.long * 2,
    easing: easings.linear,
  },
};

/**
 * Animation values for specific components
 */
export const componentAnimations = {
  toast: {
    show: {
      duration: durations.modal,
      easing: easings.enter,
    },
    hide: {
      duration: durations.standard,
      easing: easings.exit,
    },
  },
  modal: {
    overlay: {
      show: {
        duration: durations.modal,
        easing: easings.standard,
      },
      hide: {
        duration: durations.modal,
        easing: easings.standard,
      },
    },
    content: {
      show: {
        duration: durations.modal,
        easing: easings.enter,
      },
      hide: {
        duration: durations.standard,
        easing: easings.exit,
      },
    },
  },
  button: {
    press: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
    release: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
  },
  navigation: {
    screen: {
      duration: durations.screen,
      easing: easings.standard,
    },
    tab: {
      duration: durations.standard,
      easing: easings.standard,
    },
  },
}; ```
\n\n## Planned new files
* tokens.ts - Export Tailwind-ready object instead of Tamagui createTokens
* theme.glue.ts - Wire Zelda palette & fonts into Gluestack provider
* Primitives.tsx - Create wrappers for Gluestack equivalents
* Animations.ts - Create reusable Moti presets
\n\n# 2️⃣ Global Providers
\n\n## Current app/_layout.tsx (to be rewritten)
**Current implementation:** app/_layout.tsx
\n```
// app/_layout.tsx
import '../tamagui.config'; // Import config first!

import React, { useCallback, useEffect, useState, ReactNode, createContext, useContext } from 'react';
import { Slot, SplashScreen, useRouter, useSegments } from 'expo-router';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { StatusBar } from 'expo-status-bar';
import { View, ActivityIndicator, Platform } from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { useFonts } from 'expo-font';
import { useColorScheme } from 'react-native';
import { TamaguiProvider, Theme } from 'tamagui'; // Consolidate Tamagui imports
// tamagui config is already imported at the top of the file
import type { ThemeName } from '@tamagui/core'; // Ensure ThemeName is imported from @tamagui/core
import * as SecureStore from 'expo-secure-store'; // Import SecureStore

import { supabase } from '@/utils/supabase';

import type { Session } from '@supabase/supabase-js';

// Prevent the splash screen from auto-hiding
SplashScreen.preventAutoHideAsync();

/* ------------------------------------------------------------------ */
/*  1. Simple Auth-aware context                                       */
/* ------------------------------------------------------------------ */
interface AuthCtx {
  session: Session | null;
  isLoading: boolean;
}
export const AuthContext = React.createContext<AuthCtx>({
  session: null,
  isLoading: true,
});
export const useAuth = () => React.useContext(AuthContext);

/* ------------------------------------------------------------------ */
/*  2. The actual Provider                                             */
/* ------------------------------------------------------------------ */
function AuthProvider({ children }: { children: ReactNode }) {
  const [session, setSession] = useState<Session | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Initial session check
  useEffect(() => {
    supabase.auth.getSession().then(({ data }) => {
      setSession(data.session ?? null);
      setIsLoading(false);
      console.log('Initial session check:', data.session ? 'Session found' : 'No session');
    }).catch(error => {
        console.error("Error getting initial session:", error);
        setIsLoading(false);
    });

    // Subscribe to auth changes (login / logout / token refresh)
    const { data: authListener } = supabase.auth.onAuthStateChange(
      (_event, newSession) => {
        console.log('Auth state changed:', _event, newSession ? 'New session' : 'No session');
        setSession(newSession ?? null);
        // If the event is SIGNED_IN or TOKEN_REFRESHED, loading might briefly be true again
        // depending on how you handle redirects, but usually setting session is enough.
        // If SIGNED_OUT, ensure loading is false.
        if (_event === 'SIGNED_OUT') {
          setIsLoading(false);
        }
      },
    );

    return () => {
      authListener?.subscription.unsubscribe();
    };
  }, []);

  return (
    <AuthContext.Provider value={{ session, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
}

/* ------------------------------------------------------------------ */
/*  3. Enforce splash-screen logic & route guarding                    */
/* ------------------------------------------------------------------ */
function Root() {
  const { session, isLoading } = useAuth();
  const router = useRouter();
  const segments = useSegments(); // e.g., ["(tabs)", "home"] or ["(auth)", "login"]

  /* Load Fonts ----------------------------------------------------- */
  const [fontsLoaded, fontError] = useFonts({
    // Ensure font names match those used in tamagui.config.ts
    Inter: require('@tamagui/font-inter/otf/Inter-Medium.otf'),
    InterBold: require('@tamagui/font-inter/otf/Inter-Bold.otf'),
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
  });

  /* Handle Font Loading & Errors ----------------------------------- */
  useEffect(() => {
    if (fontError) {
      console.error("Font loading error:", fontError);
      // Decide how to handle font errors - maybe show an error message?
      // For now, we still need to hide splash eventually.
      SplashScreen.hideAsync();
    }
  }, [fontError]);

  /* Redirect Logic ------------------------------------------------- */
  useEffect(() => {
    // Wait until auth state is confirmed AND fonts are potentially loaded
    if (isLoading || !fontsLoaded && !fontError) return;

    const inAuthGroup = segments[0] === '(auth)';

    console.log(`Auth State: isLoading=${isLoading}, session=${!!session}, inAuthGroup=${inAuthGroup}, segments=${segments.join('/')}`);

    if (!session && !inAuthGroup) {
      console.log('Redirecting to login...');
      router.replace('/(auth)/login');
    } else if (session && inAuthGroup) {
      console.log('Redirecting to home...');
      router.replace('/(tabs)/home');
    } else {
        console.log('No redirect needed.');
    }
  }, [isLoading, session, segments, router, fontsLoaded, fontError]);

  /* Hide splash only when fonts loaded/error AND auth check done ---- */
  useEffect(() => {
    if ((fontsLoaded || fontError) && !isLoading) {
        console.log('Hiding SplashScreen...');
      SplashScreen.hideAsync();
    }
  }, [fontsLoaded, fontError, isLoading]);

  /* Show loading indicator until ready ----------------------------- */
  if (!fontsLoaded && !fontError || isLoading) {
    // Optionally, return the Splash Screen component itself or a custom loading view
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#1C1C1E' /* Approx dark bg */ }}>
        <ActivityIndicator size="large" color="#FFFFFF" />
      </View>
    );
  }

  // Once loaded and auth checked, render the content based on route
  return (
    <>
      <StatusBar style={Platform.OS === 'ios' ? 'light' : 'auto'} />
      <Slot />
    </>
  );
}

/* ------------------------------------------------------------------ */
/*  4. Wrap everything with SafeArea, Providers, etc.                  */
/* ------------------------------------------------------------------ */
import { ToastProvider, Toast, useToastState, ToastViewport } from '@tamagui/toast';
import { CheckCircle, AlertCircle, AlertTriangle, Info } from '@tamagui/lucide-icons';
import { YStack, XStack } from 'tamagui';
import { ThemeProvider, DarkTheme, DefaultTheme } from '@react-navigation/native';

const ACCENT_COLOR_KEY = 'userAccentColor';
const DEFAULT_ACCENT = 'blue'; // Set your default accent color theme name here

// Context to provide accent update function down the tree
const AccentContext = createContext({
  setAccent: (color: string) => {},
});
export const useAccent = () => useContext(AccentContext);

function RootLayoutNav() {
  const colorScheme = useColorScheme();
  const themeMode = colorScheme === 'dark' ? 'dark' : 'light';

  return (
    <ToastProvider swipeDirection="horizontal" duration={6000}>
      <Slot />
      <CurrentToast />
      <ToastViewport name="DefaultViewport" top={40} left={0} right={0} /> 
    </ToastProvider>
  );
}

function CurrentToast() {
  const currentToast = useToastState();

  if (!currentToast || currentToast.isHandledNatively) {
    return null;
  }

  const toastType = currentToast.customData?.type || 'info'; // Default to 'info'
  let themeName = 'toast_info'; // Default theme
  let IconComponent = Info;

  switch (toastType) {
    case 'success':
      themeName = 'toast_success';
      IconComponent = CheckCircle;
      break;
    case 'error':
      themeName = 'toast_error';
      IconComponent = AlertCircle;
      break;
    case 'warning':
      themeName = 'toast_warning';
      IconComponent = AlertTriangle;
      break;
  }

  return (
    <Theme name={themeName as ThemeName}> {/* Cast themeName to ThemeName */}
      <Toast
        key={currentToast.id}
        duration={currentToast.duration}
        enterStyle={{ opacity: 0, scale: 0.5, y: -25 }}
        exitStyle={{ opacity: 0, scale: 0.95, y: -10 }} // Adjusted exit style slightly
        y={0}
        opacity={1}
        scale={1}
        animation="bouncy" // Apply bouncy animation
        viewportName={currentToast.viewportName ?? 'DefaultViewport'}
        backgroundColor="$background" // Use background from the wrapped theme
        padding="$3"
        borderRadius="$4"
        marginHorizontal="$4"
        elevate
        shadowColor="$shadowColor"
      >
        <YStack space="$1">
          <XStack space="$2" alignItems="center">
            <IconComponent size={18} color="$color" /> {/* Use color from the wrapped theme */}
            <Toast.Title color="$color">{currentToast.title}</Toast.Title> {/* Use color from the wrapped theme */}
          </XStack>
          {!!currentToast.message && (
            <Toast.Description color="$color"> {/* Use color from the wrapped theme */}
              {currentToast.message}
            </Toast.Description>
          )}
        </YStack>
      </Toast>
    </Theme>
  );
}

function Providers({ children }: { children: React.ReactNode }) {
  const colorScheme = useColorScheme();
  const [accentColor, setAccentColor] = useState(DEFAULT_ACCENT);

  // Load accent color on mount
  useEffect(() => {
    const loadAccent = async () => {
      try {
        const savedAccent = await SecureStore.getItemAsync(ACCENT_COLOR_KEY);
        if (savedAccent) {
          setAccentColor(savedAccent);
        }
      } catch (error) {
        console.error('Failed to load accent color:', error);
      }
    };
    loadAccent();
  }, []);

  // Function to update and save accent color
  const handleSetAccent = useCallback(async (newColor: string) => {
    try {
      await SecureStore.setItemAsync(ACCENT_COLOR_KEY, newColor);
      setAccentColor(newColor);
    } catch (error) {
      console.error('Failed to save accent color:', error);
    }
  }, []);

  return (
    <AccentContext.Provider value={{ setAccent: handleSetAccent }}>
      <Theme name={accentColor as ThemeName}> {/* Cast accentColor to ThemeName */}
        {children}
      </Theme>
    </AccentContext.Provider>
  );
}

export default function RootLayout() {
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        {/* Core Providers (Tamagui, QueryClient, tRPC) */}
        <Providers>
          {/* Auth Provider manages session state */}
          <AuthProvider>
            {/* Root handles splash, font loading, and redirects */}
            <RootLayoutNav />
          </AuthProvider>
        </Providers>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}
```
\n\n## Current AppProvider.tsx (to be refactored)
**Current implementation:** providers/AppProvider.tsx
\n```
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { httpBatchLink } from '@trpc/client';
import { useEffect, useState, type ReactNode } from 'react';
import { Platform } from 'react-native';
import { TamaguiProvider } from 'tamagui';

import { NativeWindProvider } from '@/components/ui/nativewind-setup';
import config from '../tamagui.config';
import { trpc } from '@/utils/trpc';
import { useUiStore } from '@/stores/uiStore'; // Import store to get theme

/**
 * Complete app provider that integrates:
 * - tRPC
 * - React Query
 * - Tamagui
 * - NativeWind
 * - Additional providers can be added here
 */
export function AppProvider({ children }: { children: ReactNode }) {
  // Create Query Client
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 1000, // 5 seconds
        retry: Platform.OS === 'web' ? 3 : 1, // Less retries on mobile to save battery
      },
    },
  }));
  
  // Create tRPC client
  const [trpcClient] = useState(() => 
    trpc.createClient({
      links: [
        httpBatchLink({
          url: 'http://localhost:3000/api/trpc',
          fetch: (input, init) => {
            return fetch(input, {
              ...init,
              credentials: 'include',
            });
          },
        }),
      ],
    })
  );
  
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';
  
  // You could add NATS initialization here
  useEffect(() => {
    // Example: Initialize NATS for real-time updates
    // Note: This is commented out since we don't have a real NATS server to connect to
    /*
    try {
      const url = 'ws://localhost:4222';
      initNatsClient(url, queryClient)
        .then(conn => {
          console.log('NATS client initialized successfully');
          // Set up subscriptions to relevant topics
          subscribeWithCache('users.updates', ['users']);
          subscribeWithCache('messages.updates', ['messages']);
        })
        .catch(err => {
          console.error('Failed to initialize NATS client:', err);
        });
    } catch (error) {
      console.error('Error in NATS setup:', error);
    }
    
    // Cleanup on unmount
    return () => {
      closeNatsConnection().catch(err => {
        console.error('Error closing NATS connection:', err);
      });
    };
    */
  }, [queryClient]);
  
  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <NativeWindProvider theme={currentTheme}>
          <TamaguiProvider config={config}>
            {children}
          </TamaguiProvider>
        </NativeWindProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
} ```
\n\n## Current ConfettiProvider.tsx (to be refactored)
**Current implementation:** providers/ConfettiProvider.tsx
\n```
import { ReactNode, createContext, useCallback, useContext, useRef, useState } from 'react';
import { StyleSheet, Dimensions } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSequence,
  withDelay,
  runOnJS,
} from 'react-native-reanimated';
import { View } from 'tamagui';
import * as Haptics from 'expo-haptics';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');
const CONFETTI_COUNT = 50; // Number of confetti pieces
const COLORS = ['#ff4747', '#ffae47', '#fff347', '#47ff70', '#47d0ff', '#9147ff', '#ff47f3'];

interface ConfettiContextValue {
  showConfetti: () => void;
}

const ConfettiContext = createContext<ConfettiContextValue>({
  showConfetti: () => {},
});

export const useConfetti = () => useContext(ConfettiContext);

// Create a single confetti piece component
function ConfettiPiece({ 
  size, 
  color, 
  initialX, 
  initialY, 
  duration, 
  delay 
}: { 
  size: number, 
  color: string, 
  initialX: number, 
  initialY: number, 
  duration: number, 
  delay: number 
}) {
  const translateX = useSharedValue(initialX);
  const translateY = useSharedValue(initialY);
  const rotate = useSharedValue(0);
  const opacity = useSharedValue(1);

  // Create animation when component mounts
  useState(() => {
    // Random horizontal movement
    const targetX = initialX + (Math.random() * 2 - 1) * SCREEN_WIDTH * 0.5;
    
    // Fall down animation
    translateY.value = withDelay(
      delay,
      withTiming(SCREEN_HEIGHT + 100, { duration })
    );
    
    // Horizontal movement with some randomness
    translateX.value = withDelay(
      delay,
      withSequence(
        withTiming(targetX, { duration: duration * 0.4 }),
        withTiming(targetX + (Math.random() * 2 - 1) * 100, { duration: duration * 0.6 })
      )
    );
    
    // Rotation animation
    rotate.value = withDelay(
      delay,
      withTiming(Math.random() * 1080, { duration })
    );
    
    // Fade out toward the end
    opacity.value = withDelay(
      delay + duration * 0.7,
      withTiming(0, { duration: duration * 0.3 })
    );
  });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { rotate: `${rotate.value}deg` },
    ],
    opacity: opacity.value,
  }));

  return (
    <Animated.View
      style={[
        {
          position: 'absolute',
          width: size,
          height: size * (Math.random() * 0.8 + 0.2), // Varying heights
          backgroundColor: color,
          borderRadius: Math.random() > 0.5 ? size / 2 : 0, // Some round, some square
        },
        animatedStyle,
      ]}
    />
  );
}

export function ConfettiProvider({ children }: { children: ReactNode }) {
  const [isVisible, setIsVisible] = useState(false);
  const animationTimeout = useRef<NodeJS.Timeout | null>(null);
  
  // Generate confetti pieces data
  const generateConfettiData = useCallback(() => {
    const pieces = [];
    for (let i = 0; i < CONFETTI_COUNT; i++) {
      pieces.push({
        id: i,
        size: Math.random() * 8 + 4, // Size between 4-12
        color: COLORS[Math.floor(Math.random() * COLORS.length)],
        initialX: Math.random() * SCREEN_WIDTH,
        initialY: -20, // Start just above the screen
        duration: Math.random() * 1000 + 2000, // Duration between 2-3 seconds
        delay: Math.random() * 500, // Random delay up to 500ms
      });
    }
    return pieces;
  }, []);

  const [confettiPieces, setConfettiPieces] = useState(generateConfettiData());

  const showConfetti = useCallback(() => {
    // Trigger haptic feedback
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    
    // Clear any existing timeout
    if (animationTimeout.current) {
      clearTimeout(animationTimeout.current);
    }
    
    // Generate new confetti data and show
    setConfettiPieces(generateConfettiData());
    setIsVisible(true);
    
    // Hide confetti after animation completes
    animationTimeout.current = setTimeout(() => {
      setIsVisible(false);
    }, 3500); // Slightly longer than the max animation time to ensure all pieces are gone
  }, [generateConfettiData]);

  return (
    <ConfettiContext.Provider value={{ showConfetti }}>
      {children}
      {isVisible && (
        <View style={styles.confettiContainer} pointerEvents="none">
          {confettiPieces.map((piece) => (
            <ConfettiPiece
              key={piece.id}
              size={piece.size}
              color={piece.color}
              initialX={piece.initialX}
              initialY={piece.initialY}
              duration={piece.duration}
              delay={piece.delay}
            />
          ))}
        </View>
      )}
    </ConfettiContext.Provider>
  );
}

const styles = StyleSheet.create({
  confettiContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 9999,
    pointerEvents: 'none',
  },
}); ```
\n\n## Current Providers.tsx (to be refactored)
**Current implementation:** providers/Providers.tsx
\n```
// providers/Providers.tsx
import '../tamagui.config'; // Ensure Tamagui config is loaded first!
import { getConfig } from '@tamagui/core';
console.log('Effective Tamagui config keys:', Object.keys(getConfig() ?? {}));
import { QueryClientProvider } from '@tanstack/react-query';
import { persistQueryClient } from '@tanstack/react-query-persist-client';
import { TamaguiProvider, type TamaguiProviderProps } from 'tamagui';
import { ToastProvider, ToastViewport } from '@tamagui/toast'; // Import from Tamagui Toast
import React, { useEffect, useState, type ReactNode } from 'react';
import { Platform } from 'react-native'; // Import Platform

import config from '../tamagui.config'; // Import your config
import { trpc } from '../utils/trpc'; // Your tRPC hook setup
import { queryClient, persister, initializeNetworkMonitoring, resumeMutationsAndInvalidate } from '@/utils/query-client';
import { useUiStore } from '@/stores/uiStore';
import { supabase } from '@/utils/supabase'; // Needed for auth link
import { createTRPCClient, httpBatchLink, TRPCLink, TRPCClientError } from '@trpc/client'; // Import TRPC Client utils
import { observable } from '@trpc/server/observable';
import type { AppRouter } from '../server/src/router'; // Adjust path if needed
import type { Session } from '@supabase/supabase-js';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

// Setup query client persistence
persistQueryClient({
  queryClient,
  persister,
  maxAge: 1000 * 60 * 60 * 24, // 24 hours
  dehydrateOptions: {
    shouldDehydrateMutation: () => false, // Usually don't dehydrate mutations
  },
});

// New component for the viewport using safe area
const CurrentToastViewport = () => {
  const { top, bottom, left, right } = useSafeAreaInsets();
  return (
    <>
      {/* Adjust positioning based on your desired toast location */}
      <ToastViewport
        name="global_top"
        flexDirection="column" // Stack new toasts below older ones
        top={top + 10} // Add padding below status bar
        left={left + 10} // Add padding from sides
        right={right + 10}
      />
      <ToastViewport
        name="global_bottom"
        flexDirection="column-reverse"
        bottom={bottom + 10}
        left={left + 10}
        right={right + 10}
      />
    </>
  );
};

// Extract tRPC links setup
function getTRPCLinks(getSession: () => Promise<Session | null>): TRPCLink<AppRouter>[] {
  const apiBaseUrl = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api/trpc'; // Default to localhost
  console.log('Using tRPC API URL:', apiBaseUrl);

  return [
    // Link to handle auth token injection and refresh
    (runtime) => {
      return ({ op, next }) => {
        return observable((observer) => {
          getSession().then(session => {
            const headers = (op.context?.headers || {}) as Record<string, string>;
            if (session?.access_token) {
              headers['Authorization'] = `Bearer ${session.access_token}`;
            }

            // Proceed with the request, ensuring context is passed correctly
            next({ ...op, context: { ...op.context, headers } })
              .subscribe({
                next: (value) => observer.next(value),
                error: async (err) => {
                  if (err instanceof TRPCClientError && err.data?.httpStatus === 401) {
                    console.log('tRPC: Token expired or invalid, attempting refresh...');
                    try {
                      // Supabase handles refresh internally if needed when getSession is called
                      const { data, error: refreshError } = await supabase.auth.refreshSession();
                      if (refreshError) throw refreshError;

                      if (data.session) {
                        console.log('tRPC: Session refreshed successfully, retrying request.');
                        const refreshedHeaders = { ...headers, Authorization: `Bearer ${data.session.access_token}` };
                        // Retry with new headers in context
                        next({ ...op, context: { ...op.context, headers: refreshedHeaders } }).subscribe(observer);
                      } else {
                        console.error('tRPC: Session refresh failed, no session returned.');
                        observer.error(err); // Propagate original error if no new session
                        // Optionally trigger logout here
                        supabase.auth.signOut();
                      }
                    } catch (refreshCatchError) {
                      console.error('tRPC: Session refresh catch error:', refreshCatchError);
                      observer.error(err); // Propagate original error
                      supabase.auth.signOut();
                    }
                  } else {
                    observer.error(err); // Propagate non-auth errors
                  }
                },
                complete: () => observer.complete(),
              });
          }).catch(err => {
             console.error('tRPC: Error getting session for headers:', err);
             observer.error(new TRPCClientError('Failed to get session')); // Use TRPCClientError
          });

          // Return cleanup function if needed
          return () => {};
        });
      };
    },
    // The terminating HTTP link
    httpBatchLink({
      url: apiBaseUrl,
       headers() {
         // Headers are injected by the middleware link above
         return {};
       },
      // Add superjson transformer here if you use one
      // transformer: superjson,
    }),
  ];
}

export function Providers({ children }: { children: ReactNode }) {
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';

  // Initialize network monitoring and query client persistence
  useEffect(() => {
    const unsubscribeNetworkMonitoring = initializeNetworkMonitoring();
    resumeMutationsAndInvalidate(); // Try resuming mutations on app load
    return () => {
      unsubscribeNetworkMonitoring();
    };
  }, []);

  // Memoize tRPC client creation
  const [trpcClient] = useState(() =>
    trpc.createClient({
      links: getTRPCLinks(async () => { // Pass session getter to links setup
        const { data } = await supabase.auth.getSession();
        return data.session;
      }),
    })
  );

  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <TamaguiProvider
            config={config}
            defaultTheme={currentTheme}
            // disableInjectCSS // May not be needed depending on setup
        >
          {/* Use Tamagui's ToastProvider */}
          <ToastProvider
            // burntOptions={{ from: 'top' }} // Disabled until native module 'Burnt' is installed
            swipeDirection="horizontal"
            duration={4000}
            native={[]}
          >
            {children}
            {/* Add the safe-area aware ToastViewport */}
            <CurrentToastViewport />
          </ToastProvider>
        </TamaguiProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
}```
\n\n## Planned new providers
* providers/TRPCProvider.tsx - Instantiate trpc.createClient() + React Query
* providers/SupabaseProvider.tsx - Context for supabase-js instance + session
\n\n# 3️⃣ Navigation Shells (Expo Router)
\n\n## Current tab layout (to be rewritten)
**Current implementation:** app/(tabs)/_layout.tsx
\n```
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/_layout.tsx
import React from 'react';
import { Tabs } from 'expo-router';
import { Ionicons } from '@expo/vector-icons'; // Example icon library
import { useThemeColor } from '@/hooks/useThemeColor'; // Assuming path alias is set

export default function TabLayout() {
  const tabBarActiveTintColor = useThemeColor({}, 'tabIconSelected');
  const tabBarInactiveTintColor = useThemeColor({}, 'tabIconDefault');
  const backgroundColor = useThemeColor({}, 'background'); // Use standard background color

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: tabBarActiveTintColor,
        tabBarInactiveTintColor: tabBarInactiveTintColor,
        tabBarStyle: {
          backgroundColor: backgroundColor,
          // Add other styles like borderTopColor if needed
        },
        headerShown: false, // We might handle headers inside each screen or using Stack
      }}
    >
      <Tabs.Screen
        name="home/index"
        options={{
          title: 'Home',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="home-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="planner/index"
        options={{
          title: 'Planner',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="calendar-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="compass/index"
        options={{
          title: 'Compass',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="compass-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="rewards/index"
        options={{
          title: 'Rewards',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="gift-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="settings/index"
        options={{
          title: 'Settings',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="settings-outline" size={size} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}
```
\n\n## Current auth layout
**Current implementation:** app/(auth)/_layout.tsx
\n```
// Auth Stack Layout
import React from 'react';
import { Stack } from 'expo-router';

export default function AuthLayout() {
  return (
    <Stack>
      <Stack.Screen 
        name="login" 
        options={{ 
          title: 'Sign In',
          headerShown: false
        }} 
      />
      <Stack.Screen 
        name="register" 
        options={{ 
          title: 'Create Account',
          headerShown: false
        }} 
      />
      <Stack.Screen 
        name="forgot-password" 
        options={{ 
          title: 'Reset Password',
          headerShown: false
        }} 
      />
    </Stack>
  );
}
```
\n\n# 4️⃣ Reusable Components
\n\n## Current UI primitives
\n\n## AetherListItem
**Current implementation:** components/ui/primitives/AetherListItem.tsx
\n```
import React from 'react';
import { XStack, YStack, Text, styled, GetProps, Stack } from 'tamagui';
import { Ionicons } from '@expo/vector-icons';

// Base ListItem container
const ListItemContainer = styled(XStack, {
  name: 'ListItemContainer',
  backgroundColor: '$cardBackground',
  paddingVertical: '$3',
  paddingHorizontal: '$4',
  borderRadius: '$3',
  alignItems: 'center',
  justifyContent: 'space-between',
  borderBottomWidth: 1,
  borderBottomColor: '$borderColor',
  minHeight: 60,
  
  variants: {
    isLast: {
      true: {
        borderBottomWidth: 0,
      },
    },
    interactive: {
      true: {
        pressStyle: {
          backgroundColor: '$backgroundPress',
          opacity: 0.9,
        },
        hoverStyle: {
          backgroundColor: '$backgroundHover',
        },
      },
    },
    variant: {
      default: {},
      header: {
        backgroundColor: '$backgroundStrong',
        borderBottomColor: '$borderColor',
        paddingVertical: '$2',
      },
    },
  } as const,
  
  defaultVariants: {
    isLast: false,
    interactive: true,
    variant: 'default',
  },
});

type ListItemContainerProps = GetProps<typeof ListItemContainer>;

export interface AetherListItemProps extends ListItemContainerProps {
  title: string;
  subtitle?: string;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  showChevron?: boolean;
  badge?: string | number;
}

/**
 * AetherListItem - A consistent list item component for use in lists, menus, and settings
 *
 * @param title - The primary text
 * @param subtitle - Optional secondary text shown below the title
 * @param leftIcon - Optional icon component to show on the left side
 * @param rightIcon - Optional icon component to show on the right side
 * @param showChevron - Whether to show a right chevron (useful for navigation items)
 * @param badge - Optional badge text/number to display
 * @param isLast - Whether this is the last item in a list (removes bottom border)
 * @param interactive - Whether the item should visually respond to touch
 */
export function AetherListItem({
  title,
  subtitle,
  leftIcon,
  rightIcon,
  showChevron = false,
  badge,
  isLast,
  interactive,
  ...props
}: AetherListItemProps) {
  return (
    <ListItemContainer isLast={isLast} interactive={interactive} {...props}>
      {/* Left section with icon and text */}
      <XStack space="$3" flex={1} alignItems="center">
        {leftIcon && (
          <Stack marginRight="$2">{leftIcon}</Stack>
        )}
        
        <YStack>
          <Text fontWeight="500" fontSize="$4">{title}</Text>
          {subtitle && (
            <Text fontSize="$2" color="$gray10">{subtitle}</Text>
          )}
        </YStack>
      </XStack>
      
      {/* Right section with badge, custom icon or chevron */}
      <XStack space="$2" alignItems="center">
        {badge && (
          <XStack 
            backgroundColor="$primary"
            paddingHorizontal="$2"
            paddingVertical="$1"
            borderRadius="$2"
          >
            <Text color="white" fontSize="$1" fontWeight="bold">{badge}</Text>
          </XStack>
        )}
        
        {rightIcon && rightIcon}
        
        {showChevron && (
          <Ionicons name="chevron-forward" size={16} color="$gray10" />
        )}
      </XStack>
    </ListItemContainer>
  );
}
```
\n\n## SectionHeader
**Current implementation:** components/ui/primitives/SectionHeader.tsx
\n```
import React from 'react';
import { XStack, Text, styled, GetProps, Button } from 'tamagui';

const SectionContainer = styled(XStack, {
  name: 'SectionContainer',
  paddingVertical: '$2',
  paddingHorizontal: '$4',
  marginTop: '$4',
  marginBottom: '$2',
  justifyContent: 'space-between',
  alignItems: 'center',
});

type SectionContainerProps = GetProps<typeof SectionContainer>;

export interface SectionHeaderProps extends SectionContainerProps {
  title: string;
  actionLabel?: string;
  onAction?: () => void;
}

/**
 * SectionHeader - A consistent section header with optional action button
 * 
 * Used to separate content sections in screens like Home, Settings, etc.
 *
 * @param title - The section title
 * @param actionLabel - Optional label for the action button
 * @param onAction - Optional callback when action button is pressed
 */
export function SectionHeader({ 
  title, 
  actionLabel, 
  onAction, 
  ...props 
}: SectionHeaderProps) {
  return (
    <SectionContainer {...props}>
      <Text 
        fontSize="$5" 
        fontWeight="600" 
        color="$color"
      >
        {title}
      </Text>
      
      {actionLabel && onAction && (
        <Button
          onPress={onAction}
          fontSize="$2"
          backgroundColor="transparent"
          color="$primary"
          paddingHorizontal="$2"
          height="$5"
        >
          {actionLabel}
        </Button>
      )}
    </SectionContainer>
  );
}
```
\n\n## AetherCard
**Current implementation:** components/ui/primitives/AetherCard.tsx
\n```
import React from 'react';
import { Card, CardProps, YStack, styled } from 'tamagui';

type AetherCardVariant = 'default' | 'elevated' | 'outlined';

interface AetherCardProps extends CardProps {
  variant?: AetherCardVariant;
  // Additional props specific to AetherCard
  isInteractive?: boolean;
}

// Create a styled Card component that uses our custom Tamagui theme variables
const StyledCard = styled(Card, {
  name: 'AetherCard',
  backgroundColor: '$cardBackground',
  borderRadius: '$4',
  padding: '$4',
  elevate: true,

  variants: {
    variant: {
      default: {
        // Using our theme tokens
        shadowColor: '$shadowColor',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 3,
        elevation: 2,
      },
      elevated: {
        shadowColor: '$shadowColor',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 6,
        elevation: 4,
      },
      outlined: {
        backgroundColor: 'transparent',
        borderWidth: 1,
        borderColor: '$borderColor',
        shadowOpacity: 0,
        elevation: 0,
      },
    },
    isInteractive: {
      true: {
        pressStyle: {
          backgroundColor: '$cardBackgroundPress',
          opacity: 0.9,
        },
        hoverStyle: {
          backgroundColor: '$cardBackgroundHover',
        },
      },
    },
  } as const,

  defaultVariants: {
    variant: 'default',
    isInteractive: false,
  },
});

/**
 * AetherCard - A stylized card component following Aether design system
 *
 * @param variant - The visual style variant: 'default', 'elevated', or 'outlined'
 * @param isInteractive - Whether the card responds to press/hover states
 */
export function AetherCard({ children, variant, isInteractive, ...props }: AetherCardProps) {
  return (
    <StyledCard variant={variant} isInteractive={isInteractive} {...props}>
      {children}
    </StyledCard>
  );
}
```
\n\n## Key components to migrate
\n\n## Container
**Current implementation:** components/ui/Container.tsx
\n```
import React, { ReactNode } from 'react';
import { SafeAreaView, SafeAreaViewProps } from 'react-native';
import { styled, useTheme, YStack } from 'tamagui';

interface ContainerProps extends SafeAreaViewProps {
  children: ReactNode;
}

const StyledSafeArea = styled(SafeAreaView, {
  name: 'StyledSafeArea',
  flex: 1,
});

export const Container: React.FC<ContainerProps> = ({ style, children, ...props }) => {
  const theme = useTheme();
  return (
    <StyledSafeArea
      style={[
        { backgroundColor: theme.background.val },
        style as any
      ]}
      {...props}
    >
      <YStack flex={1}>{children}</YStack>
    </StyledSafeArea>
  );
};

export default Container;
```
\n\n## EmptyOrSkeleton
**Current implementation:** components/ui/EmptyOrSkeleton.tsx
\n```
import React from 'react';
import { YStack, Text, Button } from 'tamagui';
import { SkeletonCard, SkeletonRow, SkeletonCircle } from './Skeleton';
import { SectionError } from './ErrorBanner';

export interface EmptyOrSkeletonProps {
  // Loading state
  isLoading?: boolean;
  count?: number;
  type?: 'card' | 'row' | 'circle';
  
  // Empty state
  isEmpty?: boolean;
  text?: string;
  actionText?: string;
  onAction?: () => void;
  
  // Error state
  isError?: boolean;
  onRetry?: () => void;
  
  // Children to render when not in any special state
  children?: React.ReactNode;
}

export const EmptyOrSkeleton = ({
  isLoading = false,
  count = 3,
  type = 'row',
  isEmpty = false,
  text = 'No items found',
  actionText = 'Add New',
  onAction,
  isError = false,
  onRetry,
  children
}: EmptyOrSkeletonProps) => {
  // Generate skeleton based on type
  const renderSkeletons = () => {
    const skeletons = [];
    for (let i = 0; i < count; i++) {
      if (type === 'card') {
        skeletons.push(<SkeletonCard key={i} />);
      } else if (type === 'circle') {
        skeletons.push(<SkeletonCircle key={i} />);
      } else {
        skeletons.push(<SkeletonRow key={i} />);
      }
    }
    return skeletons;
  };

  // Show skeleton if loading
  if (isLoading) {
    return (
      <YStack space="$3">
        {renderSkeletons()}
      </YStack>
    );
  }
  
  // Show error state if there's an error
  if (isError) {
    return (
      <SectionError 
        message={text} 
        onRetry={onRetry} 
      />
    );
  }
  
  // Show empty state if empty
  if (isEmpty) {
    return (
      <YStack
        padding="$4"
        alignItems="center"
        justifyContent="center"
        space="$3"
      >
        <Text textAlign="center" color="$gray11">
          {text}
        </Text>
        {onAction && (
          <Button size="$3" onPress={onAction}>
            {actionText}
          </Button>
        )}
      </YStack>
    );
  }
  
  // Default: return children
  return <>{children}</>;
};
```
\n\n## DashboardSection
**Current implementation:** components/dashboard/DashboardSection.tsx
\n```
import React, { ReactNode } from 'react';
import { Text, YStack, XStack, Button, Anchor, H4 } from 'tamagui';
import { router } from 'expo-router';
import { SkeletonRow } from '@/components/ui/Skeleton';
import { SectionError } from '@/components/ui/ErrorBanner';
import { BlurView } from 'expo-blur'; // Import BlurView

interface DashboardSectionProps<T> {
  title: string;
  data?: T[];
  isLoading?: boolean;
  emptyMessage?: string;
  seeAllRoute?: string;
  renderItem?: (item: T) => ReactNode;
  skeletonCount?: number;
  error?: string;
  onRetry?(): void;
  children?: ReactNode;
  onSeeAll?(): void;
}

export default function DashboardSection<T>({ 
  title, 
  data, 
  isLoading, 
  emptyMessage,
  seeAllRoute,
  renderItem,
  skeletonCount = 2,
  error,
  onRetry,
  children,
  onSeeAll
}: DashboardSectionProps<T>) {
  return (
    <YStack space="$2">
      <XStack justifyContent="space-between" alignItems="center" marginBottom="$2" paddingHorizontal="$2">
        <H4>{title}</H4>
        {((data && data.length > 0 && seeAllRoute) || onSeeAll) && (
          <Button 
            chromeless 
            size="$2" 
            onPress={() => {
              if (onSeeAll) {
                onSeeAll();
              } else if (seeAllRoute) {
                // Navigate to route using type assertions
                // Safe because the route will be a tab/screen name within the app
                router.push(seeAllRoute as any);
              }
            }}
          >
            See All
          </Button>
        )}
      </XStack>
      
      {/* Wrap content in BlurView */}
      <BlurView 
        intensity={50} 
        tint="default" 
        style={{ borderRadius: 12, overflow: 'hidden' }} 
      >
        <YStack padding="$3">
          {/* If children are provided, render them */}
          {children ? (
            children
          ) : isLoading ? (
            <SkeletonRow lines={skeletonCount} />
          ) : error ? (
            <SectionError message={error ? String(error) : 'An error occurred'} onRetry={onRetry} />
          ) : data && data.length === 0 ? (
            <YStack alignItems="center" padding="$4">
              <Text color="$gray10">{emptyMessage ?? 'No items found'}</Text>
            </YStack>
          ) : (
            data && renderItem && data.map(renderItem)
          )}
        </YStack>
      </BlurView>
    </YStack>
  );
} ```
\n\n## GoalSummaryCard
**Current implementation:** components/dashboard/GoalSummaryCard.tsx
\n```
import React from 'react';
import { Text, XStack, Button } from 'tamagui';
import ProgressRing from '@/components/aether/ProgressRing';
import { RouterOutputs } from '@/utils/trpc';
import { BlurView } from 'expo-blur'; // Import BlurView

// Define a custom type that includes everything we need
type DashboardGoal = {
  id: string;
  title: string;
  status?: string;
  priority?: number;
  progress: number;
  tasks?: {
    total: number;
    completed: number;
  };
};

interface GoalSummaryCardProps {
  goal: DashboardGoal;
  onPress: () => void;
}

export default function GoalSummaryCard({ goal, onPress }: GoalSummaryCardProps) {
  return (
    <BlurView 
      intensity={50} 
      tint="default" 
      style={{ borderRadius: 12, overflow: 'hidden' }}
    >
      <Button 
        chromeless // Remove default button styling
        padding="$3" 
        onPress={onPress}
        width="100%" // Ensure it fills the BlurView
      >
        <XStack alignItems="center" space="$3" flex={1}> 
          <ProgressRing
            progress={goal.progress}
            size={40}
            primaryColor="$primary"
          />
          <XStack flex={1} flexDirection="column">
            <Text fontSize="$4" fontWeight="500" color="$color">
              {goal.title}
            </Text>
            {goal.tasks && (
              <Text color="$gray9" fontSize="$2">
                {goal.tasks.completed}/{goal.tasks.total} tasks completed
              </Text>
            )}
          </XStack>
        </XStack>
      </Button>
    </BlurView>
  );
}```
\n\n## Planned new components
* SectionCard.tsx - Glazed parchment card with header, children slot
* StatBadge.tsx - Heart/rupee style KPI badge
* SkeletonCard.tsx - NativeWind animated placeholder
* EmptyState.tsx - Triforce-in-cloud illustration + call-to-action
\n\n# 5️⃣ Feature Screens
\n\n## Current implementations
\n\n## Current  screen
**Current implementation:** app/(tabs)/home/index.tsx
\n```
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/home/index.tsx
import React, { useCallback, useMemo } from 'react';
import { YStack, H1, Text, XStack, Button, ScrollView, Spinner } from 'tamagui';
import { SafeAreaView, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc, RouterOutputs } from '@/utils/trpc';
import DashboardSection from '@/components/dashboard/DashboardSection';
import GoalSummaryCard from '@/components/dashboard/GoalSummaryCard';
import HabitCheckItem from '@/components/dashboard/HabitCheckItem';
import TaskItem from '@/components/dashboard/TaskItem';
import StateIndicator from '@/components/dashboard/StateIndicator';
import DailyProgressBanner from '@/components/dashboard/DailyProgressBanner'; // Import Banner
import EmptyOrSkeleton from '@/components/ui/EmptyOrSkeleton';
import { SkeletonCard, SkeletonRow } from '@/components/ui/Skeleton';
import { useSkeleton } from '@/hooks/useSkeleton';
import { useColorScheme } from '@/hooks/useColorScheme';
import { useToastController } from '@tamagui/toast';
import { BlurView } from 'expo-blur';
import { Plus } from '@tamagui/lucide-icons';
import LottieView from 'lottie-react-native';
import SwipeableRow from '@/components/ui/SwipeableRow'; // Import SwipeableRow

// Types inferred from tRPC Router
type RouterOutput = RouterOutputs['dashboard']['getDashboardData'];
// --- Define types for the STRUCTURE AFTER mapping in useMemo ---
export type DashboardGoal = {
  id: string;
  title: string;
  progress: number;
  tasks: { completed: number; total: number };
  // Include other relevant fields if needed by GoalSummaryCard
  status?: string | null; 
  priority?: number | null;
};
export type DashboardHabit = {
  id: string;
  name: string;
  description?: string | null;
  completed: boolean; // Mapped from completedToday
  streak: number;
  last_entry_id?: string; // Mapped from habit.last_entry_id (null -> undefined)
  habit_type?: string | null;
};
export type DashboardTask = {
  id: string;
  name: string;
  status: string | null; // Allow null
  due_date?: Date | string | null;
  // Include other relevant fields if needed by TaskItem
};
export type DashboardState = {
  id: string;
  name: string | null;
  unit: string | null;
  currentValue: number | string | null;
  lastUpdated: string | null;
  lastEntry: { value: number | null; created_at: Date | string } | null; // Explicitly include lastEntry
};
// --- End mapped type definitions ---

export default function HomeScreen() {
  const colorScheme = useColorScheme();
  const toast = useToastController();
  const utils = trpc.useUtils(); // Get tRPC utils for mutations
  
  // Define types using RouterOutputs for clarity and safety
  // type DashboardGoal = RouterOutputs['dashboard']['getDashboardData']['goals'][number];
  // type DashboardHabit = RouterOutputs['dashboard']['getDashboardData']['habits'][number];
  // type DashboardTask = RouterOutputs['dashboard']['getDashboardData']['tasks'][number];

  // Use tRPC hooks to fetch data - Types are inferred but can be explicitly used
  const { 
    data: dashboardData, 
    isLoading, 
    error, 
    refetch,
    isRefetching 
  } = trpc.dashboard.getDashboardData.useQuery();

  // Define the habit entry mutation hook
  const createHabitEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: () => {
      refetch(); // Refresh data after successful mutation
      // Optional: Add success toast
      // toast.show('Habit updated!', { type: 'success' });
    },
    onError: (error) => {
      // Handle tRPC client error
      toast.show(error.message || 'Failed to update habit', { type: 'error' });
    }
  });

  // Handle errors
  React.useEffect(() => {
    if (error) {
      toast.show(error.message || 'Failed to load dashboard data', { type: 'error' });
    }
  }, [error, toast]);

  // Set up pull-to-refresh
  const onRefresh = useCallback(() => {
    refetch();
  }, [refetch]);

  // Custom skeleton states from your hooks
  const { isLoading: skeletonsLoading, count: skeletonCount = 3 } = {
    isLoading,
    count: 3 // Number of skeleton items to show
  };
  
  // Generate skeleton UI based on loading state
  const renderSkeletons = () => {
    return Array.from({ length: skeletonCount }).map((_, index) => (
      <SkeletonCard key={`skeleton-${index}`} />
    ));
  };

  // Get current date and greeting
  const greeting = getGreeting();
  const currentDate = new Date().toLocaleDateString('en-US', { 
    weekday: 'long', 
    month: 'long', 
    day: 'numeric' 
  });

  const dashboardDataMemo = useMemo(() => {
    // Fix: Add check to ensure dashboardData exists before accessing properties
    if (!dashboardData) {
      return null; // Or return default structure: { goals: [], habits: [], tasks: [], trackedStates: [] }
    }

    // Map and filter data, ensuring structure matches exported types
    return {
      // Filter goals to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      goals: (dashboardData.goals ?? [])
        .filter((goal): goal is typeof goal & { id: string } => !!goal?.id)
        .map((goal) => ({
        // Map to DashboardGoal structure
        id: goal.id, 
        title: goal.title ?? 'Untitled Goal', // Provide default for title
        progress: goal.progress ?? 0, 
        tasks: goal.tasks ?? { completed: 0, total: 0 }, 
        status: goal.status,
        priority: goal.priority,
      })),
      // Filter habits to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      habits: (dashboardData.habits ?? [])
        .filter((habit): habit is typeof habit & { id: string } => !!habit?.id)
        .map((habit) => ({
        // Map to DashboardHabit structure
        id: habit.id, 
        name: habit.name ?? 'Unnamed Habit', // Provide default for name
        description: habit.description,
        completed: habit.completedToday ?? false, // Map completedToday to completed
        streak: habit.streak ?? 0, 
        last_entry_id: habit.last_entry_id ?? undefined, // Map null to undefined
        habit_type: habit.habit_type,
      })),
      // Filter tasks to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      tasks: (dashboardData.tasks ?? [])
        .filter((task): task is typeof task & { id: string } => !!task?.id)
        .map((task) => ({
        // Map to DashboardTask structure
        id: task.id,
        name: task.name ?? 'Untitled Task', // Provide default name
        status: task.status,
        due_date: task.due_date,
      })),
      // Map trackedStates, ensuring lastEntry is preserved
      // Fix: Use nullish coalescing and optional chaining
      trackedStates: (dashboardData.trackedStates ?? [])
        .filter((state): state is typeof state & { id: string } => !!state?.id)
        .map((trackedState) => ({
        // Map to DashboardState structure
        id: trackedState.id,
        name: trackedState.name,
        unit: trackedState.unit,
        currentValue: trackedState.currentValue,
        lastUpdated: trackedState.lastUpdated,
        // Ensure lastEntry structure matches definition or is null
        lastEntry: trackedState.lastEntry ?? null, 
      })),
    };
  }, [dashboardData]);

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <ScrollView 
        showsVerticalScrollIndicator={false}
        contentContainerStyle={{ paddingBottom: 100 }}
        refreshControl={
          <RefreshControl
            refreshing={isRefetching}
            onRefresh={onRefresh}
            tintColor="transparent" // Hide default spinner
            colors={['transparent']} // Hide default spinner (Android)
            progressBackgroundColor="transparent" // Hide default bg (Android)
            refreshingComponent={
              <LottieView
                source={require('@/assets/refresh-sheikah.json')} // ASSUMES this file exists
                autoPlay
                loop
                style={{ width: 48, height: 48, alignSelf: 'center' }} // Center the animation
              />
            }
          />
        }
      >
        <YStack space="$4" paddingHorizontal="$4">
          {/* Header */}
          <YStack space="$1">
            <H1>{greeting}</H1>
            <Text color="$gray10">{currentDate}</Text>
          </YStack>

          {/* Daily Progress Banner */}
          <DailyProgressBanner 
            // tasksCompleted={...} 
            // totalTasks={...} 
            // habitsChecked={...} 
            // totalHabits={...} 
          />

          {/* Goals Section */}
          <DashboardSection 
            title="Goals"
            onSeeAll={() => router.push('/planner')}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load goals"
              />
            ) : !dashboardDataMemo?.goals || dashboardDataMemo.goals.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No goals yet"
                actionText="Create a goal"
                onAction={() => router.push('/planner/add-goal')}
              />
            ) : (
              <YStack space="$3">
                {dashboardDataMemo.goals.slice(0, 3).map((goal) => (
                  <SwipeableRow
                    key={goal.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.goal.delete.mutate({ id: goal.id })
                      console.log('Attempting to delete goal:', goal.id); // Placeholder
                      // utils.goal.delete.mutate({ id: goal.id });
                    }}
                  >
                    <GoalSummaryCard
                      goal={goal}
                      onPress={() => router.push(`/planner/goal/${goal.id}`)}
                    />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>

          {/* Today's Habits */}
          <DashboardSection 
            title="Today's Habits"
            onSeeAll={() => router.push('/planner?tab=habits')}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load habits"
              />
            ) : !dashboardDataMemo?.habits || dashboardDataMemo.habits.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No habits for today"
                actionText="Create a habit"
                onAction={() => router.push('/planner/add-habit')}
              />
            ) : (
              <YStack space="$2">
                {dashboardDataMemo.habits.slice(0, 4).map((habit) => (
                  <SwipeableRow
                    key={habit.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.habit.delete.mutate({ id: habit.id })
                      console.log('Attempting to delete habit:', habit.id); // Placeholder
                      // utils.habit.delete.mutate({ id: habit.id });
                    }}
                  >
                    <HabitCheckItem habit={habit} />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>

          {/* Today's State */}
          <DashboardSection
            title="Today's State"
            // TODO: Add navigation to a dedicated state tracking screen
            onSeeAll={() => console.log('Navigate to State Tracking screen')}
          >
            {isLoading ? (
              renderSkeletons() // Use generic skeletons or specific state skeletons
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load state"
              />
            ) : !dashboardDataMemo?.trackedStates || dashboardDataMemo.trackedStates.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No states being tracked"
                actionText="Track a state"
                // TODO: Navigate to state definition creation screen
                onAction={() => console.log('Navigate to Add State screen')}
              />
            ) : (
              <XStack space="$3" flexWrap="wrap"> 
                {dashboardDataMemo.trackedStates.map((stateData) => (
                  <StateIndicator
                    key={stateData.id}
                    state={stateData} // Pass the whole state object which includes lastEntry
                    lastEntry={stateData.lastEntry} // Pass lastEntry explicitly
                    // TODO: Handle interaction - e.g., navigate to state detail/entry screen
                    onPress={() => console.log('State pressed:', stateData.id)}
                  />
                ))}
              </XStack>
            )}
          </DashboardSection>

          {/* Upcoming Tasks */}
          <DashboardSection 
            title="Upcoming Tasks"
            onSeeAll={() => {/* Navigate to tasks list */}}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load tasks"
              />
            ) : !dashboardDataMemo?.tasks || dashboardDataMemo.tasks.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No upcoming tasks"
                actionText="Create a task"
                onAction={() => {/* Navigate to create task */}}
              />
            ) : (
              <YStack space="$2">
                {dashboardDataMemo.tasks.slice(0, 5).map((task) => (
                  <SwipeableRow
                    key={task.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.task.delete.mutate({ id: task.id })
                      console.log('Attempting to delete task:', task.id); // Placeholder
                      // utils.task.delete.mutate({ id: task.id });
                    }}
                  >
                    <TaskItem
                      task={{
                        // Explicitly pass props matching DashboardTask type
                        id: task.id, // Ensure id is passed
                        name: task.name, // Already defaulted in map
                        status: task.status, // Pass status
                        due_date: task.due_date, // Pass due_date
                      }}
                      isLast={false} // Adjust if needed for styling
                      onPress={() => console.log('Task Item Pressed:', task.id)}
                    />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>
        </YStack>
      </ScrollView>
      <QuickAddFAB />
    </SafeAreaView>
  );
}

// Helper function for greeting
function getGreeting() {
  const hour = new Date().getHours();
  if (hour < 12) return 'Good Morning';
  if (hour < 18) return 'Good Afternoon';
  return 'Good evening';
}

// Quick Add FAB Component
function QuickAddFAB() {
  return (
    <BlurView intensity={40} tint="default" style={{ position:'absolute', bottom:24, right:24, borderRadius:32, overflow: 'hidden' }}>
      <Button
        circular
        size="$5"
        backgroundColor="$accent"
        icon={Plus}
        elevate
        shadowColor="$shadowColor"
        shadowRadius={5}
        shadowOffset={{ width: 0, height: 2 }}
        pressStyle={{ scale: 0.95, opacity: 0.9 }}
        onPress={() => {
          router.push('/planner/add-task');
        }}
      />
    </BlurView>
  );
}
```
\n\n## Current  screen
**Current implementation:** app/(tabs)/planner/index.tsx
\n```
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/planner/index.tsx
import React, { useState, Suspense } from 'react';
import { YStack, XStack, Text, Tabs, Button, Spinner, Card, ScrollView } from 'tamagui';
import { SafeAreaView, FlatList, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { RouterOutputs } from '@/utils/api-types';
import { SectionError } from '@/components/ui/ErrorBanner';


interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'goals',
    title: 'Goals',
    icon: <Ionicons name="trophy-outline" size={18} color="currentColor" />
  },
  {
    key: 'habits',
    title: 'Habits',
    icon: <Ionicons name="repeat-outline" size={18} color="currentColor" />
  },
  {
    key: 'calendar',
    title: 'Calendar',
    icon: <Ionicons name="calendar-outline" size={18} color="currentColor" />
  }
];

export default function PlannerScreen() {
  const [activeTab, setActiveTab] = useState<string>('goals');
  const colorScheme = useColorScheme();
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Planner</Text>
          <Button
            size="$3"
            circular
            onPress={() => {/* Handle new item */}}
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>
        
        {/* Tabs */}
        <Tabs
          defaultValue="goals"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List 
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {tab.icon}
                  <Text>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>
          
          {/* Tab Content */}
          <Tabs.Content value="goals" flex={1}>
            <ScrollView>
              <GoalsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="habits" flex={1}>
            <ScrollView>
              <HabitsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="calendar" flex={1}>
            <ScrollView>
              <CalendarTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Goals Tab
function GoalsTab() {
  // Fetch goals using tRPC
  const { data: goals, isLoading, error, refetch } = trpc.goal.getGoals.useQuery();
  
  // Define the inferred type for a single goal
  type PlannerGoal = RouterOutputs['goal']['getGoals'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load goals" 
      />
    );
  }
  
  if (!goals || goals.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No goals yet" 
        actionText="Create a goal" 
        onAction={() => router.push('/planner/add-goal')} 
      />
    );
  }
  
  return (
    <YStack space="$4">
      {goals.map((goal: PlannerGoal) => (
        <Button 
          key={goal.id} 
          height="$12" 
          justifyContent="flex-start" 
          paddingHorizontal="$3"
          onPress={() => router.push({ pathname: '/planner/goal/[id]', params: { id: goal.id } })}
        >
          <YStack>
            <Text fontWeight="bold">{goal.title}</Text>
            <Text fontSize="$2" color="$gray10">
              {goal.dueDate ? new Date(goal.dueDate).toLocaleDateString() : 'No due date'}
            </Text>
          </YStack>
        </Button>
      ))}
    </YStack>
  );
}

// Habits Tab
function HabitsTab() {
  // Fetch habits using tRPC
  const { data: habits, isLoading, error, refetch } = trpc.habit.getHabits.useQuery();
  
  // Define the inferred type for a single habit
  type PlannerHabit = RouterOutputs['habit']['getHabits'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={isLoading} count={3} type="row" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load habits" 
      />
    );
  }
  
  if (!habits || habits.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No habits yet" 
        actionText="Create a habit" 
        onAction={() => router.push('/planner/add-habit')} 
      />
    );
  }
  
  return (
    <YStack space="$3">
      {habits.map((habit: PlannerHabit) => (
        <XStack 
          key={habit.id} 
          justifyContent="space-between" 
          alignItems="center" 
          paddingVertical="$3" 
          paddingHorizontal="$3" 
          borderBottomWidth={1} 
          borderColor="$gray5"
          pressStyle={{ opacity: 0.7 }}
          tag="pressable"
          onPress={() => router.push({ pathname: '/planner/habit/[id]', params: { id: habit.id } })}
        >
          <Text>{habit.title}</Text>
          <Button
            size="$2"
            circular
            backgroundColor={habit.completed ? '$green9' : '$gray9'}
            onPress={() => {
              // Use today's date for the habit entry
              const today = new Date().toISOString().split('T')[0];
              
              // Create a mutation to toggle habit completion
              const toggleHabit = trpc.habit.createHabitEntry.useMutation({
                onSuccess: () => {
                  refetch(); // Refresh data after toggling
                },
                onError: (error) => {
                  // Show error message
                  console.error('Failed to toggle habit:', error.message);
                }
              });
              
              // Toggle the habit completion status
              toggleHabit.mutate({
                habitId: habit.id,
                completed: !habit.completed,
                date: today
              });
            }}
            icon={<Ionicons name="checkmark" size={18} color="white" />}
          />
        </XStack>
      ))}
    </YStack>
  );
}

// Calendar Tab
function CalendarTab() {
  return (
    <YStack alignItems="center" justifyContent="center" padding="$8">
      <Text fontSize="$5" textAlign="center">
        Calendar integration coming soon
      </Text>
      <Text marginTop="$2" color="$gray10" textAlign="center">
        This tab will display task and habit schedules in a calendar view
      </Text>
    </YStack>
  );
}
```
\n\n## Current  screen
**Current implementation:** app/(tabs)/compass/index.tsx
\n```
// Compass screen with Principles and States tabs
import React, { useState } from 'react';
import { YStack, XStack, Text, Tabs, Button, ScrollView } from 'tamagui'; 
import { SafeAreaView } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc, type RouterOutputs } from '@/utils/trpc'; 
import { useColorScheme } from '@/hooks/useColorScheme'; 
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { router, type Href } from 'expo-router'; 
import { PrincipleCard } from '@/components/compass/PrincipleCard';
import PrinciplesTab from '@/components/compass/PrinciplesTab';
import { StateDefinitionCard } from '@/components/compass/StateDefinitionCard'; 

interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'principles',
    title: 'Principles',
    icon: <Ionicons name="compass-outline" size={18} color="currentColor" />
  },
  {
    key: 'states',
    title: 'States',
    icon: <Ionicons name="pulse-outline" size={18} color="currentColor" />
  }
];

export default function CompassScreen() {
  const [activeTab, setActiveTab] = useState<string>('principles');
  const colorScheme = useColorScheme();

  const handleAddPress = () => {
    const route = `/compose?type=${activeTab === 'principles' ? 'value' : 'state'}` as Href;
    router.push(route);
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Compass</Text>
          <Button
            size="$3"
            circular
            onPress={handleAddPress} 
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>

        {/* Tabs */}
        <Tabs
          defaultValue="principles"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {React.cloneElement(tab.icon as React.ReactElement, { color: activeTab === tab.key ? '$colorFocus' : '$color' })}
                  <Text color={activeTab === tab.key ? '$colorFocus' : '$color'}>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>

          {/* Tab Content */}
          <Tabs.Content value="principles" flex={1} key="principles-content">
            <ScrollView>
              <PrinciplesTab />
            </ScrollView>
          </Tabs.Content>

          <Tabs.Content value="states" flex={1} key="states-content">
            <ScrollView>
              <StatesTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Define the specific types from RouterOutputs
// Types are now defined in the PrinciplesTab component
type StateDefinition = RouterOutputs['state']['getDefinitions'][number]; 

// Principles Tab Component is now imported from '@/components/compass/PrinciplesTab'

// States Tab Component (manages data fetching and list rendering)
function StatesTab() {
  const { data: states, isLoading, error, refetch } = trpc.state.getDefinitions.useQuery(); 

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }

  if (error) {
    return (
      <EmptyOrSkeleton
        isEmpty={false}
        isError={true}
        onRetry={refetch}
        text="Failed to load tracked state definitions"
      />
    );
  }

  if (!states || states.length === 0) {
    return (
      <EmptyOrSkeleton
        isEmpty={true}
        text="No state definitions found"
        actionText="Define Your First State"
        onAction={() => router.push('/compose?type=state' as Href)}
      />
    );
  }

  return (
    <YStack space="$3"> 
      {states.map((state: StateDefinition) => (
        <StateDefinitionCard
          key={state.id}
          state={state}
          onPress={() => router.push(`/states/${state.id}` as Href)}
        />
      ))}
    </YStack>
  );
}

// 
// Removed inline PrincipleCard definition (extracted to components/compass/PrincipleCard.tsx)
// 

// 
// Removed inline StateDefinitionCard definition (extracted to components/compass/StateDefinitionCard.tsx)
// 
```
\n\n## Current  screen
**Current implementation:** app/(tabs)/rewards/index.tsx
\n```
// Rewards screen with grid/list toggle and claim functionality
import React, { useState, useCallback } from 'react';
import { YStack, XStack, Text, Button, ScrollView, Card, Checkbox, useTheme, H1 } from 'tamagui';
import { SafeAreaView, View, FlatList, ImageBackground, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { RouterOutputs } from '@/utils/trpc'; // Import RouterOutputs
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton'; // Import helper component

// Define inferred type for rewards
type RewardItem = RouterOutputs['rewards']['getAvailableRewards'][number];

enum ViewMode {
  Grid = 'grid',
  List = 'list'
}

export default function RewardsScreen() {
  const [viewMode, setViewMode] = useState<ViewMode>(ViewMode.Grid);
  const colorScheme = useColorScheme();
  const theme = useTheme();

  // Define fallback colors
  const blue2 = theme?.blue2?.val ?? '#eff6ff';
  const blue5 = theme?.blue5?.val ?? '#60a5fa';
  const blue10 = theme?.blue10?.val ?? '#1e40af';
  const blue11 = theme?.blue11?.val ?? '#1e3a8a';
  const green9 = theme?.green9?.val ?? '#16a34a';

  // Fetch available rewards from tRPC
  const { 
    data: rewards, 
    isLoading, 
    error, 
    refetch 
  } = trpc.rewards.getAvailableRewards.useQuery();

  // Mutation for claiming rewards
  const claimMutation = trpc.rewards.earnReward.useMutation({
    onSuccess: (data) => {
      console.log('Reward claimed successfully:', data);
      // Maybe show confetti?
      Alert.alert('Reward Claimed!', `You spent ${data.reward.points_spent} points. Remaining: ${data.remainingPoints}`);
      refetch(); // Refetch the list of available rewards
    },
    onError: (err) => {
      console.error('Failed to claim reward:', err);
      Alert.alert('Claim Failed', err.message || 'Could not claim reward.');
    }
  });
  
  const handleClaimReward = useCallback((rewardId: string) => {
    if (claimMutation.isPending) return; // Prevent double-clicks
    
    Alert.alert(
      'Confirm Claim',
      'Are you sure you want to spend points on this reward?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Claim', 
          onPress: () => {
            claimMutation.mutate({ rewardId });
          },
          style: 'default'
        }
      ]
    );
  }, [claimMutation]);
  
  const renderItem = ({ item }: { item: RewardItem }) => { // Use inferred type
    // Assuming backend field is image_url, map to imagePath
    const imagePath = item.image_url; 
    // All items from getAvailableRewards are considered claimable (not yet claimed)
    const claimed = false; 
    // Map required_points to pointCost
    const pointCost = item.required_points;

    if (viewMode === ViewMode.Grid) {
      return (
        <Card
          size="$4"
          bordered
          width={160}
          height={200}
          margin="$2"
          overflow="hidden"
          elevation="$2"
          opacity={claimed ? 0.7 : 1}
        >
          <ImageBackground
            source={{ uri: imagePath }}
            style={{ width: '100%', height: 100 }}
          >
            <View style={{ 
              position: 'absolute', 
              top: 5, 
              right: 5, 
              backgroundColor: blue5,
              borderRadius: 10,
              padding: 4
            }}>
              <Text color="white" fontSize="$2" fontWeight="bold">
                {pointCost} pts
              </Text>
            </View>
          </ImageBackground>
          
          <YStack padding="$2" flex={1} justifyContent="space-between">
            <Text fontSize="$4" fontWeight="bold" numberOfLines={1}>
              {item.name}
            </Text>
            
            <Button
              size="$2"
              themeInverse={claimed}
              backgroundColor={claimed ? undefined : blue10}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </YStack>
        </Card>
      );
    } else {
      return (
        <Card
          bordered
          margin="$2"
          padding="$3"
          opacity={claimed ? 0.7 : 1}
        >
          <XStack space="$3" alignItems="center">
            {imagePath && (
              <View style={{ 
                width: 60, 
                height: 60, 
                borderRadius: 8, 
                overflow: 'hidden',
                backgroundColor: theme.gray3.val
              }}>
                <ImageBackground
                  source={{ uri: imagePath }}
                  style={{ width: '100%', height: '100%' }}
                />
              </View>
            )}
            
            <YStack flex={1} space="$1">
              <Text fontSize="$5" fontWeight="bold">{item.name}</Text>
              <Text fontSize="$3" color="$gray11" numberOfLines={2}>{item.description}</Text>
              <Text fontSize="$3" color={blue10} fontWeight="500">{pointCost} points</Text>
            </YStack>
            
            <Button
              size="$3"
              backgroundColor={claimed ? undefined : blue10}
              themeInverse={claimed}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </XStack>
        </Card>
      );
    }
  };
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        <YStack space="$4">
          {/* Header */}
          <XStack justifyContent="space-between" alignItems="center">
            <H1>Rewards</H1>
            
            <XStack space="$2">
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.Grid ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.Grid)}
              >
                <Ionicons 
                  name="grid-outline" 
                  size={22} 
                  color={viewMode === ViewMode.Grid ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
              
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.List ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.List)}
              >
                <Ionicons 
                  name="list-outline" 
                  size={22} 
                  color={viewMode === ViewMode.List ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
            </XStack>
          </XStack>
          
          {/* Stats */}
          <Card padding="$3" backgroundColor={blue2}>
            <XStack justifyContent="space-between" alignItems="center">
              <Text fontSize="$5" fontWeight="bold" color={blue11}>Your Points</Text>
              <Text fontSize="$6" fontWeight="bold" color={blue10}>275</Text>
            </XStack>
          </Card>
        </YStack>
        
        {/* Content Area */} 
        <EmptyOrSkeleton 
          isLoading={isLoading}
          isEmpty={!isLoading && !error && (!rewards || rewards.length === 0)}
          isError={!!error}
          text={error ? error.message : 'No rewards available yet.'} // Use text for error OR empty msg
          onRetry={refetch}
          type={viewMode === ViewMode.Grid ? 'card' : 'row'}
          count={viewMode === ViewMode.Grid ? 6 : 3}
        >
          <FlatList
            key={viewMode} // Change key based on viewMode to force re-render
            data={rewards}
            renderItem={renderItem}
            keyExtractor={(item, index) =>
              `${item?.id ?? `tmp-${index}`}-${viewMode}`   // fall back to index if ID is missing
            }
            
            // Optional: Log corrupt data in development
            onLayout={() => {
              if (__DEV__) {
                const missing = (rewards ?? []).filter(r => !r?.id);
                if (missing.length) console.warn('Rewards missing id:', missing);
              }
            }}
            numColumns={viewMode === ViewMode.Grid ? 2 : 1}
            contentContainerStyle={{ paddingBottom: 50 }} // Add padding at the bottom
            // Optional Optimizations (Patch #6)
            initialNumToRender={8}
            removeClippedSubviews={true} // Note: Can have visual glitches on iOS sometimes
          />
        </EmptyOrSkeleton>

      </YStack>
    </SafeAreaView>
  );
}
```
\n\n## Current  screen
**Current implementation:** app/(tabs)/settings/index.tsx
\n```
// Settings screen with account, preferences, and app settings
import React, { useState } from 'react';
import { YStack, XStack, Text, Button, Switch, Separator, ScrollView, Card, H1 } from 'tamagui';
import { SafeAreaView, View, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { supabase } from '@/utils/supabase';
import { useColorScheme } from 'react-native';
import { useAccent } from '@/app/_layout'; // Import the useAccent hook

interface SettingsSectionProps {
  title: string;
  icon: React.ReactNode;
  children: React.ReactNode;
}

const SettingsSection = ({ title, icon, children }: SettingsSectionProps) => {
  return (
    <YStack marginVertical="$2">
      <XStack alignItems="center" space="$2" marginBottom="$2">
        {icon}
        <Text fontSize="$5" fontWeight="bold">{title}</Text>
      </XStack>
      <Card padding="$3" bordered>
        {children}
      </Card>
    </YStack>
  );
};

interface SettingsRowProps {
  label: string;
  icon?: React.ReactNode;
  rightElement?: React.ReactNode;
  onPress?: () => void;
  showChevron?: boolean;
}

const SettingsRow = ({ label, icon, rightElement, onPress, showChevron = false }: SettingsRowProps) => {
  return (
    <XStack
      paddingVertical="$3"
      justifyContent="space-between"
      alignItems="center"
      onPress={onPress}
      pressStyle={onPress ? { opacity: 0.7 } : undefined}
    >
      <XStack space="$3" alignItems="center" flex={1}>
        {icon}
        <Text fontSize="$4">{label}</Text>
      </XStack>
      <XStack space="$2" alignItems="center">
        {rightElement}
        {showChevron && <Ionicons name="chevron-forward" size={18} color="#A0A0A0" />}
      </XStack>
    </XStack>
  );
};

export default function SettingsScreen() {
  const colorScheme = useColorScheme();
  const [notificationsEnabled, setNotificationsEnabled] = useState(true);
  const [trackingEnabled, setTrackingEnabled] = useState(true);
  const { setAccent } = useAccent(); // Get the function to update accent color
  const [selectedAccent, setSelectedAccent] = useState('blue'); // Placeholder state for selected accent

  const handleLogout = async () => {
    Alert.alert(
      'Log Out',
      'Are you sure you want to log out?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Log Out', 
          style: 'destructive',
          onPress: async () => {
            await supabase.auth.signOut();
            router.replace('/(auth)/login');
          }
        }
      ]
    );
  };

  const AccentSelector = ({ currentAccent, onSelect }: { currentAccent: string, onSelect: (accent: string) => void }) => {
    const accents = ['blue', 'green', 'orange', 'red']; // Example accents corresponding to theme names
    return (
      <XStack space="$2">
        {accents.map((accent) => (
          <Button 
            key={accent} 
            onPress={() => {
              onSelect(accent);
              setAccent(accent); // Call setAccent with the selected accent
            }} 
            theme={accent as any} // Preview the theme (cast needed for demo)
            backgroundColor={accent === currentAccent ? '$backgroundStrong' : '$background'}
          >
            {accent.charAt(0).toUpperCase() + accent.slice(1)}
          </Button>
        ))}
      </XStack>
    );
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <ScrollView>
        <YStack flex={1} padding="$4">
          <H1 marginBottom="$4">Settings</H1>
          
          {/* Account Section */}
          <SettingsSection
            title="Account"
            icon={<Ionicons name="person-circle-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Edit Profile"
                icon={<Ionicons name="person-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/profile' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Security"
                icon={<Ionicons name="lock-closed-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/security' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Data & Privacy"
                icon={<Ionicons name="shield-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/privacy' as any)}
              />
            </YStack>
          </SettingsSection>
          
          {/* Appearance Section */}
          <SettingsSection
            title="Appearance"
            icon={<Ionicons name="color-palette-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Theme"
                icon={<Ionicons name="moon-outline" size={20} color="#A0A0A0" />}
                rightElement={<Text color="$gray10">{colorScheme === 'dark' ? 'Dark (System)' : 'Light (System)'}</Text>}
              />
              <SettingsRow
                label="Accent Color"
                icon={<Ionicons name="color-palette-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <AccentSelector 
                    currentAccent={selectedAccent} 
                    onSelect={(accent) => setSelectedAccent(accent)} 
                  />
                }
              />
            </YStack>
          </SettingsSection>
          
          {/* Notifications Section */}
          <SettingsSection
            title="Notifications"
            icon={<Ionicons name="notifications-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Push Notifications"
                icon={<Ionicons name="push-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={notificationsEnabled}
                    onCheckedChange={setNotificationsEnabled}
                  />
                }
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Notification Settings"
                icon={<Ionicons name="options-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/notifications' as any)}
              />
            </YStack>
          </SettingsSection>
          
          {/* Privacy Section */}
          <SettingsSection
            title="Privacy & Data"
            icon={<Ionicons name="analytics-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Analytics Tracking"
                icon={<Ionicons name="trending-up-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={trackingEnabled}
                    onCheckedChange={setTrackingEnabled}
                  />
                }
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Export Data"
                icon={<Ionicons name="download-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => {
                  Alert.alert(
                    'Export Data',
                    'Your data will be prepared for export and sent to your email address.',
                    [
                      { text: 'Cancel', style: 'cancel' },
                      { text: 'Export', onPress: () => {
                        // Would call an API endpoint to initiate export
                        Alert.alert('Export Initiated', 'Check your email for the export file.');
                      }}
                    ]
                  );
                }}
              />
            </YStack>
          </SettingsSection>
          
          {/* Support Section */}
          <SettingsSection
            title="Support & About"
            icon={<Ionicons name="help-circle-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Help Center"
                icon={<Ionicons name="help-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/help' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="About Aether"
                icon={<Ionicons name="information-circle-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/about' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="App Version"
                icon={<Ionicons name="code-outline" size={20} color="#A0A0A0" />}
                rightElement={<Text color="$gray10">1.0.0</Text>}
              />
            </YStack>
          </SettingsSection>
          
          {/* Logout Button */}
          <Button
            marginTop="$6"
            marginBottom="$8"
            size="$4"
            themeInverse
            onPress={handleLogout}
          >
            Log Out
          </Button>
        </YStack>
      </ScrollView>
    </SafeAreaView>
  );
}
```
\n\n# 6️⃣ Utils & Hooks
\n\n## supabase
**Current implementation:** utils/supabase.ts
\n```
import 'react-native-url-polyfill/auto';
import { createClient } from '@supabase/supabase-js';
import * as SecureStore from 'expo-secure-store';

// SecureStore adapter for Supabase auth persistence
const ExpoSecureStoreAdapter = {
  getItem: (key: string) => {
    return SecureStore.getItemAsync(key);
  },
  setItem: (key: string, value: string) => {
    return SecureStore.setItemAsync(key, value);
  },
  removeItem: (key: string) => {
    return SecureStore.deleteItemAsync(key);
  },
};

// Get Supabase URL and anon key from environment variables
// In production, these should be set in app.config.js or via EAS secrets
const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL || '';
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY || '';

if (!supabaseUrl || !supabaseAnonKey) {
  console.warn(
    'Supabase URL or anon key not found. Make sure to set EXPO_PUBLIC_SUPABASE_URL and EXPO_PUBLIC_SUPABASE_ANON_KEY environment variables.'
  );
}

// Create Supabase client
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: ExpoSecureStoreAdapter,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
});

// Helper function to check if user is authenticated
export const isAuthenticated = async () => {
  const { data, error } = await supabase.auth.getSession();
  return !!data.session;
};

// Helper function to get current user
export const getCurrentUser = async () => {
  const { data, error } = await supabase.auth.getUser();
  if (error) {
    console.error('Error getting user:', error.message);
    return null;
  }
  return data.user;
}; ```
\n\n## trpc
**Current implementation:** utils/trpc.ts
\n```
import { createTRPCReact } from '@trpc/react-query';
import { type inferRouterInputs, type inferRouterOutputs } from '@trpc/server';

// Import the real AppRouter type from our server
import { type AppRouter } from '../server/src/router';

// Import types using the updated path
import { RouterInputs as TypedRouterInputs, RouterOutputs as TypedRouterOutputs } from '../server/src/types/trpc-types';

/**
 * tRPC React client
 * The client for consuming your tRPC API from React components
 */
export const trpc = createTRPCReact<AppRouter>();

/**
 * Inference helpers for input/output types
 * Use the pre-defined types from trpc-types.ts
 */
export type RouterInputs = TypedRouterInputs;
export type RouterOutputs = TypedRouterOutputs; ```
\n\n# Type Definitions (for reference)
\n\n## api-types
**Current implementation:** utils/api-types.ts
\n```
/**
 * This file was auto-generated by the generate-trpc-types script.
 * Do not edit manually! Instead, run the script again.
 */

import type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from '../server/src/router';

/**
 * Inference helper for inputs.
 *
 * @example type HelloInput = RouterInputs['example']['hello']
 */
export type RouterInputs = inferRouterInputs<AppRouter>;

/**
 * Inference helper for outputs.
 *
 * @example type HelloOutput = RouterOutputs['example']['hello']
 */
export type RouterOutputs = inferRouterOutputs<AppRouter>;
```
\n\n## trpc-types
**Current implementation:** server/src/types/trpc-types.ts
\n```
// server/src/types/trpc-types.ts
/*
  Aether – Shared tRPC Types
  ------------------------------------------------------------------
  Every Zod schema that powers a router lives here so both the server
  (routers) and the client (React Query hooks) reference a **single**
  source‑of‑truth.  Import these types everywhere else – **never** hand‑roll
  shapes again.
*/

import { z } from 'zod';
import { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from '../router';

/* ------------------------------------------------------------------
 * Enums (keep in sync with DB enums)
 * ----------------------------------------------------------------*/
export const TaskStatusEnum = z.enum(['todo', 'doing', 'done', 'blocked', 'pending']);
export const TaskPriorityEnum = z.enum(['low', 'medium', 'high']);
export const RewardTypeEnum = z.enum(['badge', 'achievement', 'item', 'discount']);
export const HabitTypeEnum = z.enum(['boolean', 'quantity']);
export const HabitFrequencyPeriodEnum = z.enum(['day', 'week', 'month']);

/* ------------------------------------------------------------------
 * Domain Models (DB row shapes) – keep in sync with Supabase tables
 * ----------------------------------------------------------------*/
export const UserProfile = z.object({
  id: z.string().uuid(),
  username: z.string().nullish(),
  avatar_url: z.string().url().nullish(),
  full_name: z.string().nullish(),
  bio: z.string().nullish(),
  points: z.number().int().nonnegative().default(0),
  time_zone: z.string().nullish(),
  onboarding_completed: z.boolean().default(false),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type UserProfile = z.infer<typeof UserProfile>;

export const NotificationPrefs = z.object({
  email: z.boolean().default(true),
  push: z.boolean().default(true),
  task_reminders: z.boolean().default(true),
  goal_updates: z.boolean().default(true),
  habit_reminders: z.boolean().default(true),
});

export const UiPrefs = z.object({
  theme: z.enum(['system', 'light', 'dark']).default('system'),
  compact_view: z.boolean().default(false),
  show_completed_tasks: z.boolean().default(true),
  first_day_of_week: z.number().int().min(0).max(6).default(0),
});

export const UserSettings = z.object({
  id: z.string().uuid().optional(),
  user_id: z.string().uuid(),
  notification_preferences: NotificationPrefs,
  ui_preferences: UiPrefs,
});
export type UserSettings = z.infer<typeof UserSettings>;

export const Value = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), 
  description: z.string().nullish(),
  color: z.string().nullish(),
  icon: z.string().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type Value = z.infer<typeof Value>;

export const Principle = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), // <<< Changed from 'name' to 'title'
  body: z.string(), // <<< Renamed from description for clarity, matching migration
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type Principle = z.infer<typeof Principle>;

export const Goal = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  description: z.string().nullish(),
  progress: z.number().nullish(),
  target_date: z.string().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime().nullish(),
  updated_at: z.string().datetime().nullish(),
});
export type Goal = z.infer<typeof Goal>;

export const Task = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  notes: z.string().nullish(),
  status: TaskStatusEnum.default('todo'),
  priority_enum: TaskPriorityEnum.nullish(), // <<< Renamed from priority
  due_date: z.string().datetime().nullish(),
  goal_id: z.string().uuid().nullish(),
  parent_task_id: z.string().uuid().nullish(),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Task = z.infer<typeof Task>;

export const Habit = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  cue: z.string().nullish(),
  routine: z.string().nullish(),
  reward: z.string().nullish(),
  streak: z.number().nonnegative().default(0),
  best_streak: z.number().nonnegative().default(0),
  habit_type: HabitTypeEnum.default('boolean'),
  goal_quantity: z.number().int().nullish(),
  goal_unit: z.string().nullish(),
  frequency_period: HabitFrequencyPeriodEnum.default('day'),
  goal_frequency: z.number().int().positive().default(1),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(), // <<< Added sort_order
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Habit = z.infer<typeof Habit>;

export const HabitEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  habit_id: z.string().uuid(),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be in YYYY-MM-DD format"),
  completed: z.boolean().default(false),
  quantity_value: z.number().int().nullish(),
  notes: z.string().nullish(),
  created_at: z.string().datetime(),
});
export type HabitEntry = z.infer<typeof HabitEntry>;

export const TrackedStateDef = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  name: z.string(),
  // category: z.string(), // Category seems removed/replaced in DB schema by scale/custom_labels
  scale: z.enum(['1-5', 'low-high', 'custom']), // <<< Added scale
  custom_labels: z.array(z.string()).nullish(), // <<< Added custom_labels
  unit: z.string().nullish(), // Keep unit if still used alongside scale
  icon: z.string().nullish(), // Keep icon if still used
  target_min_value: z.number().nullish(), // <<< Added
  target_max_value: z.number().nullish(), // <<< Added
  active: z.boolean().default(true), // <<< Added active
  priority: z.number().int().default(1), // <<< Added priority
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type TrackedStateDef = z.infer<typeof TrackedStateDef>;

export const StateEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  definition_id: z.string().uuid(), // <<< Renamed from tracked_state_def_id for consistency? check DB
  value_numeric: z.number().optional().nullable(),
  value_text: z.string().optional().nullable(),
  entry_timestamp: z.string().datetime({ message: "Invalid datetime string. Must be UTC ISO 8601" }).optional(),
  notes: z.string().optional().nullable(), // <<< Added notes
});
export type StateEntry = z.infer<typeof StateEntry>;

export const Reward = z.object({
  id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullish(),
  type: RewardTypeEnum,
  required_points: z.number().int().nonnegative().default(0),
  can_earn_multiple: z.boolean().default(false),
  image_url: z.string().url().nullish(),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Reward = z.infer<typeof Reward>;

export const UserReward = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  reward_id: z.string().uuid(),
  reward_type: z.string().nullish(), // From DB schema
  earned_at: z.string().datetime(),
  points_spent: z.number().int().nonnegative().default(0),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type UserReward = z.infer<typeof UserReward>;

export const PointTransaction = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  points: z.number().int(),
  reason: z.string(),
  source_type: z.string(),
  source_id: z.string().uuid().nullish(),
  created_at: z.string().datetime(),
});
export type PointTransaction = z.infer<typeof PointTransaction>;

export const BadgeDefinition = z.object({
  id: z.string(), // From DB: text primary key
  title: z.string(),
  description: z.string().nullish(),
  icon: z.string(),
});
export type BadgeDefinition = z.infer<typeof BadgeDefinition>;

export const UserBadge = z.object({
  // Note: user_badges might be merged into user_rewards with type='badge'
  user_id: z.string().uuid(),
  badge_id: z.string(), // Matches badge_definitions.id (text)
  earned_at: z.string().datetime(),
  progress: z.number().nullish(), // From DB schema
});
export type UserBadge = z.infer<typeof UserBadge>;

export const Reminder = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
  reminder_time: z.string().datetime(),
  is_active: z.boolean().default(true),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Reminder = z.infer<typeof Reminder>;

export const GoalProgressNote = z.object({
  id: z.string().uuid(),
  goal_id: z.string().uuid(),
  user_id: z.string().uuid(),
  note: z.string(),
  created_at: z.string().datetime(),
});
export type GoalProgressNote = z.infer<typeof GoalProgressNote>;

/* ------------------------------------------------------------------
 * Router‑level Schemas – inputs & outputs for every procedure
 * ----------------------------------------------------------------*/
export const greetingInput = z.object({ name: z.string().optional() });
export const greetingOutput = z.object({ greeting: z.string() });

// User
export const updateProfileInput = UserProfile.partial().omit({ id: true, created_at: true, updated_at: true });
export const updateSettingsInput = z.object({
  notification_preferences: NotificationPrefs.partial().optional(),
  ui_preferences: UiPrefs.partial().optional(),
});

// Values
export const createValueInput = Value.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateValueInput = createValueInput.partial().extend({ id: z.string().uuid() });

// Principles
// Uses 'title' and 'body' from the updated Principle schema
export const createPrincipleInput = Principle.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updatePrincipleInput = createPrincipleInput.partial().extend({ id: z.string().uuid() });

// Goals
export const createGoalInput = Goal.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateGoalInput = createGoalInput.partial().extend({ id: z.string().uuid() });

// Tasks
export const createTaskInput = Task.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateTaskInput = createTaskInput.partial().extend({ id: z.string().uuid() });
export const updateTaskStatusInput = z.object({ id: z.string().uuid(), status: TaskStatusEnum });

// Habits
export const createHabitInput = Habit.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateHabitInput = createHabitInput.partial().extend({ id: z.string().uuid() });

// Habit Entries
export const createHabitEntryInput = HabitEntry.omit({ id: true, user_id: true, created_at: true });
export const updateHabitEntryInput = createHabitEntryInput.partial().extend({ id: z.string().uuid() });

// Tracked State Definitions
export const createTrackedStateDefInput = TrackedStateDef.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateTrackedStateDefInput = createTrackedStateDefInput.partial().extend({ id: z.string().uuid() });
export const GetTrackedStateDefByIdInput = z.object({ id: z.string().uuid() });
export const DeleteTrackedStateDefInput = z.object({ id: z.string().uuid() });

// State Entries
export const CreateStateEntryInput = StateEntry.omit({ id: true, user_id: true })
.extend({
  tracked_state_def_id: z.string().uuid(), // Ensure this is required
  // Values are optional in base schema
});
export const updateStateEntryInput = CreateStateEntryInput.partial().extend({ id: z.string().uuid() });
export const GetStateEntriesInput = z.object({
  tracked_state_def_id: z.string().uuid(), // Renamed from definition_id to match DB? Check usage.
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  limit: z.number().int().positive().optional(),
});
export const DeleteStateEntryInput = z.object({ id: z.string().uuid() });

// Rewards (Assuming rewards definitions are managed elsewhere)
// No create/update for Reward definitions needed via API?
export const claimLootInput = z.object({
  rewardId: z.string().uuid(), // Use rewardId to match router
});

// Badges
export const awardBadgeInput = z.object({
  badgeId: z.string(), // Matches text ID in badge_definitions
  description: z.string().optional(), // Example custom field if needed
});

// Reminders
export const createReminderInput = Reminder.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateReminderInput = createReminderInput.partial().extend({ id: z.string().uuid() });
export const GetRemindersForEntityInput = z.object({
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
});
export const DeleteReminderInput = z.object({ id: z.string().uuid() });

// Goal Progress Notes
export const createGoalProgressNoteInput = GoalProgressNote.omit({ id: true, user_id: true, created_at: true });
export const updateGoalProgressNoteInput = createGoalProgressNoteInput.partial().extend({ id: z.string().uuid() });
export const GetGoalProgressNotesInput = z.object({ goal_id: z.string().uuid() });
export const DeleteGoalProgressNoteInput = z.object({ id: z.string().uuid() });

/* ------------------------------------------------------------------
 * Aggregate Router Types – automatically inferred
 * ----------------------------------------------------------------*/
export type RouterInputs = inferRouterInputs<AppRouter>;
export type RouterOutputs = inferRouterOutputs<AppRouter>;

/*
  Usage (client‑side):

  const utils = trpc.useUtils();
  type TasksOutput = RouterOutputs['task']['getTasks'];
  type CreateTaskInput = RouterInputs['task']['createTask'];
*/```
\n\n# 7️⃣ Assets
\n\n## Font Files in assets/fonts:
total 184
drwxr-xr-x  3 tylerbedford  staff     96 Apr 23 09:37 .
drwxr-xr-x  5 tylerbedford  staff    160 Apr 29 22:50 ..
-rwxr-xr-x  1 tylerbedford  staff  93252 Apr 21 23:33 SpaceMono-Regular.ttf
\n\n## Lottie Files in assets:
assets/refresh-sheikah.json
```

### project_structure.txt
**Path:** project_structure.txt
**Size:** 6102 bytes

```
/Users/tylerbedford/Documents/Coding Projects/AetherIphone
├── AETHER_TODO.md
├── Projects/
│   └── AetherIphone/
│       ├── __tests__/
│       │   ├── components/
│       │   │   ├── lists/
│       │   │   └── ui/
│       │   │       └── primitives/
│       │   └── server/
│       │       └── routers/
│       ├── components/
│       │   ├── lists/
│       │   └── ui/
│       │       └── primitives/
│       └── supabase/
│           └── migrations/
├── README.md
├── REFACTORING_PLAN_V2.yaml
├── SUPABASE_INTEGRATION.md
├── __tests__/
│   ├── components/
│   │   ├── dashboard/
│   │   │   └── HabitCheckItem.test.tsx
│   │   ├── lists/
│   │   │   ├── GoalList.test.tsx
│   │   │   ├── HabitList.test.tsx
│   │   │   └── TaskList.test.tsx
│   │   ├── ui/
│   │   │   └── primitives/
│   │   │       ├── AetherCard.test.tsx
│   │   │       └── AetherListItem.test.tsx
│   └── server/
│       ├── routers/
│       │   ├── dashboardRouter.getWeeklyProgress.test.ts
│       │   ├── dashboardRouter.test.ts
│       │   ├── habitRouter.test.ts
│       │   └── taskRouter.toggleTask.test.ts
│       └── test-helpers.ts
│   └── test-utils.tsx
├── aether_styling_context.txt
├── app/
│   ├── (auth)/
│   │   ├── _layout.tsx
│   │   ├── forgot-password.tsx
│   │   ├── login.tsx
│   │   └── register.tsx
│   ├── (tabs)/
│   │   ├── _layout.tsx
│   │   ├── compass/
│   │   │   └── index.tsx
│   │   ├── home/
│   │   │   └── index.tsx
│   │   ├── journal/
│   │   │   ├── _layout.tsx
│   │   │   ├── entries/
│   │   │   │   ├── index.tsx
│   │   │   │   └── [id].tsx
│   │   │   └── index.tsx
│   │   ├── profile/
│   │   │   └── index.tsx
│   │   └── settings/
│   │       ├── _layout.tsx
│   │       ├── account.tsx
│   │       ├── appearance.tsx
│   │       ├── data-sync.tsx
│   │       ├── feedback.tsx
│   │       └── index.tsx
│   ├── _layout.tsx
│   ├── index.tsx
│   └── modal.tsx
├── app.config.ts
├── app.json
├── assets/
│   ├── animations/
│   │   └── sheikah-loader.json
│   ├── fonts/
│   │   └── SpaceMono-Regular.ttf
│   ├── images/
│   │   ├── adaptive-icon.png
│   │   ├── favicon.png
│   │   ├── icon.png
│   │   └── splash.png
│   └── refresh-sheikah.json
├── babel.config.js
├── components/
│   ├── AuthForm.tsx
│   ├── ControlledInput.tsx
│   ├── ControlledSwitch.tsx
│   ├── DashboardHeader.tsx
│   ├── EditScreenInfo.tsx
│   ├── ExternalLink.tsx
│   ├── Themed.tsx
│   ├── calendar/
│   │   └── DateStrip.tsx
│   ├── dashboard/
│   │   ├── DashboardSection.tsx
│   │   ├── GoalSummaryCard.tsx
│   │   ├── HabitCheckItem.tsx
│   │   ├── StateIndicator.tsx
│   │   ├── TaskItem.tsx
│   │   └── WeeklyProgressChart.tsx
│   ├── hooks/
│   │   └── useRefreshControl.tsx
│   ├── lists/
│   │   ├── GoalList.tsx
│   │   ├── HabitList.tsx
│   │   └── TaskList.tsx
│   ├── modal/
│   │   └── AddItemModal.tsx
│   └── ui/
│       ├── EmptyOrSkeleton.tsx
│       └── primitives/
│           ├── AetherCard.tsx
│           ├── AetherIconButton.tsx
│           ├── AetherListItem.tsx
│           ├── AetherSegmentedControl.tsx
│           ├── AetherSheet.tsx
│           └── AetherSwitch.tsx
├── constants/
│   ├── Colors.ts
│   ├── Motion.ts
│   └── Styles.ts
├── debug_context.txt
├── eas.json
├── expo-env.d.ts
├── gather_debug_info.js
├── index.js
├── jest.config.server.js
├── jest.config.ui.js
├── jest.setup.js
├── metro.config.js
├── package.json
├── postcss.config.js
├── providers/
│   └── Providers.tsx
├── scripts/
│   ├── generate-all.js
│   ├── generate-trpc-client.js
│   └── generate-trpc-types.js
├── server/
│   ├── index.ts
│   ├── src/
│   │   ├── context.ts
│   │   ├── db/
│   │   │   └── schema.ts
│   │   ├── lib/
│   │   │   └── dateUtils.ts
│   │   ├── router.ts
│   │   ├── routers/
│   │   │   ├── _app.ts
│   │   │   ├── auth.ts
│   │   │   ├── dashboard.ts
│   │   │   ├── goal.ts
│   │   │   ├── habit.ts
│   │   │   ├── journal.ts
│   │   │   └── task.ts
│   │   ├── trpc.ts
│   │   └── types/
│   │       └── trpc.ts
│   └── tsconfig.json
├── stores/
│   ├── authStore.ts
│   └── uiStore.ts
├── supabase/
│   ├── config.toml
│   ├── functions/
│   │   └── _shared/
│   │       ├── cors.ts
│   │       └── supabaseAdmin.ts
│   ├── migrations/
│   │   └── ... (omitted content)
│   └── seed.sql
├── tailwind.config.js
├── tamagui.config.ts
├── tsconfig.json
├── types/
│   ├── api.ts
│   ├── components.ts
│   └── domain.ts
├── utils/
│   ├── api.ts
│   ├── query-client.ts
│   ├── supabase.ts
│   └── trpc.ts
└── yarn.lock
```


# providers

### AppProvider.tsx
**Path:** providers/AppProvider.tsx
**Size:** 2809 bytes

```typescript
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { httpBatchLink } from '@trpc/client';
import { useEffect, useState, type ReactNode } from 'react';
import { Platform } from 'react-native';
import { TamaguiProvider } from 'tamagui';

import { NativeWindProvider } from '@/components/ui/nativewind-setup';
import config from '../tamagui.config';
import { trpc } from '@/utils/trpc';
import { useUiStore } from '@/stores/uiStore'; // Import store to get theme

/**
 * Complete app provider that integrates:
 * - tRPC
 * - React Query
 * - Tamagui
 * - NativeWind
 * - Additional providers can be added here
 */
export function AppProvider({ children }: { children: ReactNode }) {
  // Create Query Client
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 1000, // 5 seconds
        retry: Platform.OS === 'web' ? 3 : 1, // Less retries on mobile to save battery
      },
    },
  }));
  
  // Create tRPC client
  const [trpcClient] = useState(() => 
    trpc.createClient({
      links: [
        httpBatchLink({
          url: 'http://localhost:3000/api/trpc',
          fetch: (input, init) => {
            return fetch(input, {
              ...init,
              credentials: 'include',
            });
          },
        }),
      ],
    })
  );
  
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';
  
  // You could add NATS initialization here
  useEffect(() => {
    // Example: Initialize NATS for real-time updates
    // Note: This is commented out since we don't have a real NATS server to connect to
    /*
    try {
      const url = 'ws://localhost:4222';
      initNatsClient(url, queryClient)
        .then(conn => {
          console.log('NATS client initialized successfully');
          // Set up subscriptions to relevant topics
          subscribeWithCache('users.updates', ['users']);
          subscribeWithCache('messages.updates', ['messages']);
        })
        .catch(err => {
          console.error('Failed to initialize NATS client:', err);
        });
    } catch (error) {
      console.error('Error in NATS setup:', error);
    }
    
    // Cleanup on unmount
    return () => {
      closeNatsConnection().catch(err => {
        console.error('Error closing NATS connection:', err);
      });
    };
    */
  }, [queryClient]);
  
  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <NativeWindProvider theme={currentTheme}>
          <TamaguiProvider config={config}>
            {children}
          </TamaguiProvider>
        </NativeWindProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
} ```

### ConfettiProvider.tsx
**Path:** providers/ConfettiProvider.tsx
**Size:** 5038 bytes

```typescript
import { ReactNode, createContext, useCallback, useContext, useRef, useState } from 'react';
import { StyleSheet, Dimensions } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSequence,
  withDelay,
  runOnJS,
} from 'react-native-reanimated';
import { View } from 'tamagui';
import * as Haptics from 'expo-haptics';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');
const CONFETTI_COUNT = 50; // Number of confetti pieces
const COLORS = ['#ff4747', '#ffae47', '#fff347', '#47ff70', '#47d0ff', '#9147ff', '#ff47f3'];

interface ConfettiContextValue {
  showConfetti: () => void;
}

const ConfettiContext = createContext<ConfettiContextValue>({
  showConfetti: () => {},
});

export const useConfetti = () => useContext(ConfettiContext);

// Create a single confetti piece component
function ConfettiPiece({ 
  size, 
  color, 
  initialX, 
  initialY, 
  duration, 
  delay 
}: { 
  size: number, 
  color: string, 
  initialX: number, 
  initialY: number, 
  duration: number, 
  delay: number 
}) {
  const translateX = useSharedValue(initialX);
  const translateY = useSharedValue(initialY);
  const rotate = useSharedValue(0);
  const opacity = useSharedValue(1);

  // Create animation when component mounts
  useState(() => {
    // Random horizontal movement
    const targetX = initialX + (Math.random() * 2 - 1) * SCREEN_WIDTH * 0.5;
    
    // Fall down animation
    translateY.value = withDelay(
      delay,
      withTiming(SCREEN_HEIGHT + 100, { duration })
    );
    
    // Horizontal movement with some randomness
    translateX.value = withDelay(
      delay,
      withSequence(
        withTiming(targetX, { duration: duration * 0.4 }),
        withTiming(targetX + (Math.random() * 2 - 1) * 100, { duration: duration * 0.6 })
      )
    );
    
    // Rotation animation
    rotate.value = withDelay(
      delay,
      withTiming(Math.random() * 1080, { duration })
    );
    
    // Fade out toward the end
    opacity.value = withDelay(
      delay + duration * 0.7,
      withTiming(0, { duration: duration * 0.3 })
    );
  });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { rotate: `${rotate.value}deg` },
    ],
    opacity: opacity.value,
  }));

  return (
    <Animated.View
      style={[
        {
          position: 'absolute',
          width: size,
          height: size * (Math.random() * 0.8 + 0.2), // Varying heights
          backgroundColor: color,
          borderRadius: Math.random() > 0.5 ? size / 2 : 0, // Some round, some square
        },
        animatedStyle,
      ]}
    />
  );
}

export function ConfettiProvider({ children }: { children: ReactNode }) {
  const [isVisible, setIsVisible] = useState(false);
  const animationTimeout = useRef<NodeJS.Timeout | null>(null);
  
  // Generate confetti pieces data
  const generateConfettiData = useCallback(() => {
    const pieces = [];
    for (let i = 0; i < CONFETTI_COUNT; i++) {
      pieces.push({
        id: i,
        size: Math.random() * 8 + 4, // Size between 4-12
        color: COLORS[Math.floor(Math.random() * COLORS.length)],
        initialX: Math.random() * SCREEN_WIDTH,
        initialY: -20, // Start just above the screen
        duration: Math.random() * 1000 + 2000, // Duration between 2-3 seconds
        delay: Math.random() * 500, // Random delay up to 500ms
      });
    }
    return pieces;
  }, []);

  const [confettiPieces, setConfettiPieces] = useState(generateConfettiData());

  const showConfetti = useCallback(() => {
    // Trigger haptic feedback
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    
    // Clear any existing timeout
    if (animationTimeout.current) {
      clearTimeout(animationTimeout.current);
    }
    
    // Generate new confetti data and show
    setConfettiPieces(generateConfettiData());
    setIsVisible(true);
    
    // Hide confetti after animation completes
    animationTimeout.current = setTimeout(() => {
      setIsVisible(false);
    }, 3500); // Slightly longer than the max animation time to ensure all pieces are gone
  }, [generateConfettiData]);

  return (
    <ConfettiContext.Provider value={{ showConfetti }}>
      {children}
      {isVisible && (
        <View style={styles.confettiContainer} pointerEvents="none">
          {confettiPieces.map((piece) => (
            <ConfettiPiece
              key={piece.id}
              size={piece.size}
              color={piece.color}
              initialX={piece.initialX}
              initialY={piece.initialY}
              duration={piece.duration}
              delay={piece.delay}
            />
          ))}
        </View>
      )}
    </ConfettiContext.Provider>
  );
}

const styles = StyleSheet.create({
  confettiContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 9999,
    pointerEvents: 'none',
  },
}); ```

### GluestackProvider.tsx
**Path:** providers/GluestackProvider.tsx
**Size:** 0 bytes
*(file listed in source control but not found locally)*

### Providers.tsx
**Path:** providers/Providers.tsx
**Size:** 0 bytes
*(file listed in source control but not found locally)*


# (root files)

### refactor_checklist.md
**Path:** refactor_checklist.md
**Size:** 5769 bytes

```markdown
# Aether App – Holistic Refactor Checklist

> Generated: 2025-04-27

This document is derived from a **second-pass audit** of the current codebase (`app/`, `components/`, `utils/`, `types/`) and the **Supabase schema** in `types/database.types.ts`.  It enumerates every outstanding task, design consideration, and cross-dependency needed to land the new Home / Planner / Compass / Rewards architecture.

---

## 0  Legend
- [ ] = Not started   ☐
- [~] = In-progress    ~
- [x] = Done           ✔

---

## 1  Design-System / Tamagui
| ID | Task | Blocking / Notes |
|:-|---|---|
| DS-1 | [x] Finalize **brand tokens** (`$brandBlue`, `$brandGreen`, …) in `tamagui.config.ts`. | ✓ Added brand colors with light/dark variants |
| DS-2 | [x] Generate **light / dark** theme objects with Tamagui CLI, merge overrides. | ✓ Updated theme objects with brand colors |
| DS-3 | [x] Create shared **Card**, **ListItem**, **SectionHeader** primitives with spacing & shadows. | ✓ Created in components/ui/primitives |
| DS-4 | [ ] Audit code for **literal hex / spacing** → replace with tokens. | Will be done incrementally as we refactor screens |
| DS-5 | [x] Enable **system colour-scheme** in `Providers.tsx` (currently forced light). | ✓ Using currentTheme from useUiStore |

---

## 2  Data Layer (tRPC ⇄ Supabase)
| ID | Task | Tables / Types | Blocks |
|:-|---|---|---|
| DL-1 | [~] Ensure **goalRouter**, **habitRouter**, **taskRouter** have full CRUD + list procedures. | `goals`, `habits`, `tasks` | |
| DL-1a | [x] Implement **habitRouter.toggleHabit** for dashboard habit check-in. | `habits`, `habit_entries` | |
| DL-2 | [ ] Create **dashboardRouter.getDashboardData** aggregate query. | multiple | |
| DL-3 | [ ] Add **analyticsRouter** (`streaks`, `goalProgress`, `points`). | materialised views | Compass |
| DL-4 | [ ] Implement **rewardsRouter** (`list`, `earnReward`). | `rewards`, `points_ledger`, `badge_definitions` | Rewards |
| DL-5 | [ ] Wire **Supabase JWT refresh** in tRPC link (Providers). | | |
| DL-6 | [ ] Integrate **offline-mutation queue** helper in every mutation. | utils/offline-mutations.ts | |

---

## 3  Screens – Functional Requirements

### 3.1  Home (Dashboard)
- [ ] Fetch `dashboard.getDashboardData`.
- [ ] Render sections:
  - GoalProgressCard list (progress ring).
  - HabitCheckItem list (today entries).  **Mutation:** `habit.toggleEntry` (optimistic + haptics).
  - TaskRow list (upcoming ≤ tomorrow).
- [ ] Quick-action buttons → create modals.
- [ ] Empty & error states via `EmptyOrSkeleton` / `SectionError`.

### 3.2  Planner
- [ ] Segmented Tabs (`Goals | Habits | Tasks`).
- [ ] Each tab = `FlatList` powered by `goal.list`, `habit.list`, `task.list`.
- [ ] Pull-to-refresh, skeleton, empty.
- [ ] Swipe actions: delete / mark done.
- [ ] “+” FAB routes to context-aware add-* modal.

### 3.3  Compass
- [ ] Queries: `analytics.streaks`, `analytics.goalProgress`, `analytics.points`.
- [ ] Charts: `StreakChart`, `ProgressChart` (victory-native).
- [ ] Time-range filter (7 d / 30 d / All).
- [ ] Empty placeholder until views ready.

### 3.4  Rewards
- [ ] List `rewards.list` & `badges.list`.
- [ ] Grid / list toggle (existing code partial).
- [ ] `earnReward` mutation with confirmation alert & toast.
- [ ] Points balance top-bar (from `analytics.points`).

### 3.5  Settings
- [ ] Profile form (bind to `profiles` table).
- [ ] Toggle rows persisted via `utils/settings.ts`.
- [ ] Static pages (About, Help) markdown render.

---

## 4  Creation & Detail Screens
| Entity | Create Fields | Detail Functions |
|-|-|-|
| Goal | title, description, target_date | edit, delete, progress slider |
| Habit | title, cue, routine, reward | streak graph, edit, delete |
| Task | title, notes, due, priority, goal_id (optional) | mark done, edit, delete |

All use **react-hook-form + zod** and share `FormField` component.

---

## 5  Reusable Components to Implement
- [x] `GoalCard`, `HabitCard`, `TaskCard` (Tap-able Card rows) - implemented in components/lists/*.
- [x] `GoalList`, `HabitList`, `TaskList` (FlatList wrappers) - implemented in components/lists/*.
- [ ] `StreakChart`, `ProgressChart` (SVG charts).
- [ ] `BadgeCard`, `PointsBalanceBar`.
- [ ] `SectionError` banner.

---

## 6  UX Enhancements
- [ ] Global haptics: success/error cues (`utils/haptics.ts`).
- [ ] Toast feedback via `@tamagui/toast`.
- [ ] Safe-area aware `ToastViewport` (already done).

---

## 7  Testing & CI
- [x] Jest configuration with proper transformers for React Native and Tamagui.
- [x] Unit tests for primitive components (AetherCard, AetherListItem).
- [x] Unit tests for list components with mock data matching Supabase schema.
- [x] Type-safe tests ensuring database → server → UI type consistency.
- [ ] Test coverage for UI component edge cases (loading, error, empty states).
- [ ] Detox e2e: auth flow, add habit, toggle habit, dashboard refresh.
- [ ] GitHub Actions: lint, test, `expo prebuild`, `eas build --profile preview`.

---

## 8  Technical Debt / Notes
- Planner & Compass screens currently monolithic; will be split per list/tab.
- TypeScript strict mode is **on** – types must be correct.
- Some `ScrollView` imports still present after FlatList migration (clean up).
- `Providers.tsx` temporarily forces `light` theme; remove once DS-2 done.

---

## 9  Priority Roadmap (macro)
1. **DS-1 → DS-3** (Design system foundation)
2. **DL-1 + DL-2** (Core routers) & **DL-6** (offline queue)
3. **Home** rewrite (shows immediate value)
4. **Planner** refactor (lists & CRUD)
5. **Creation / Detail** screens
6. **Analytics views + Compass** MVP
7. **Rewards** MVP
8. **Testing & CI** hardening

> **Next Action:** Start DS-1: finalise brand tokens in `tamagui.config.ts`.
```

### refactoring_plan.md
**Path:** refactoring_plan.md
**Size:** 8991 bytes

```markdown
# Aether iOS App – Comprehensive Refactor Plan

> **Last updated:** 2025-04-27
>
> This document lays out, in exhaustive detail, how every screen, component, and data interaction in the app should be structured.  It weaves together best-practice guidance from **Expo**, **Tamagui**, **tRPC**, and **Supabase**.

---

## 1  Objectives

1.  Fully embrace iOS design conventions while staying cross-platform-ready.
2.  Establish a robust data layer (tRPC ⇄ Supabase) with offline resilience.
3.  Standardise UI via Tamagui tokens, themes, and reusable components.
4.  Tighten navigation, error handling, accessibility, and performance.
5.  Automate quality via tests and CI/EAS pipelines.

---

## 2  Guiding Principles & Key Packages

| Domain  | Principle | Practical Rules |
|---------|-----------|-----------------|
| **Expo** | Lean on file-based routing (Expo Router) and EAS Build/Submit. | • Keep `_layout.tsx` files focused on navigator config.<br>• Use `expo-constants` + `expo-secure-store` for env secrets in client.<br>• Always wrap root in `SafeAreaProvider`.<br>• Use `expo-updates` channels for staging & prod. |
| **Tamagui** | Treat `tamagui.config.ts` as single source of design truth. | • Reference tokens (`$blue9`, `$space.3`) – never hard-code.<br>• Theme switching: system‐color-scheme by default (re-enable once light theme stabilised).<br>• Respect iOS HIG: generous whitespace & 16 pt default body.<br>• Use `YStack/XStack` instead of `View`/`Row`. |
| **tRPC** | End-to-end types, react-query integration. | • Each model gets `list`, `getById`, `create`, `update`, `delete` procedures.<br>• Split routers by domain (goalRouter, habitRouter, taskRouter, authRouter).<br>• Authed links inject Supabase JWT, refresh on 401. |
| **Supabase** | Postgres + RLS for multitenancy. | • Tables: `goals`, `habits`, `tasks`, `habit_entries`, `rewards`.<br>• Use row-level security: policy `user_id = auth.uid()`.<br>• Database schema lives in `/supabase/migrations`. |

---

## 3  Navigation Hierarchy

```
app/
  _layout.tsx          ← root Stack (auth-gate)
  index.tsx            ← redirects based on auth
  (auth)/              ← login / register / forgot-password
  (tabs)/              ← MainBottomTabs
    _layout.tsx        ← Tab navigator
    home/
      index.tsx        ← Dashboard
    compass/
      index.tsx        ← Analytics / insights
    planner/
      _layout.tsx      ← Planner stack
      index.tsx        ← Master lists (Goals / Habits / Tasks)
      add-goal.tsx
      add-habit.tsx
      add-task.tsx
      goal/[id].tsx
      habit/[id].tsx
    rewards/
      index.tsx        ← Points & redemptions
    settings/
      _layout.tsx      ← Settings stack
      index.tsx        ← List of subsections
      profile.tsx • security.tsx • notifications.tsx • privacy.tsx • about.tsx • help.tsx
```

**Modal vs Push**  
Creation screens (`add-*`) open as **modal** (`presentation:"modal"` in route options). Detail screens push onto Planner stack.

---

## 4  Screen-by-Screen Specs

### 4.1  Home (`(tabs)/home/index.tsx`)
| Concern | Specification |
|---------|---------------|
| **Purpose** | Daily snapshot: goals progress, today’s habits, upcoming tasks. |
| **Data** | `trpc.dashboard.getDashboardData.useQuery()` returns:<br>• `todayHabits: HabitWithEntryStatus[]`<br>• `upcomingTasks: Task[]`<br>• `goalProgress: GoalProgressSummary[]` |
| **UI Layout** | `ScrollView` inside `SafeAreaView`<br>1.  Header (date, greeting).<br>2.  Quick actions (`Add Habit`, `Add Task`).<br>3.  Sections (each uses `DashboardSection`). |
| **Components** | `GoalProgressCard`, `HabitCheckItem`, `TaskRow`, `EmptyOrSkeleton`, `SectionError`. |
| **State Flow** | • Loading → skeleton placeholders.<br>• Error → `SectionError` with retry.<br>• Success → render data. |
| **Interactions** | • Habit toggle → `trpc.habit.toggleEntry.useMutation()` (optimistic).<br>• Quick actions navigate to modal create screens. |

### 4.2  Planner Index (`(tabs)/planner/index.tsx`)
| | |
|---|---|
| **Purpose** | Full management: list, filter, search all goals/habits/tasks. |
| **Data** | Three queries in parallel with `useSuspenseQueries`:<br>• `trpc.goal.list`<br>• `trpc.habit.list`<br>• `trpc.task.list` |
| **UI** | Segmented control (`Tabs` from Tamagui) switching between lists.<br>Each list is a `FlatList` with pull-to-refresh.<br>FAB (`+`) opens context-aware create modal. |
| **Empty State** | Illustrated placeholder with “Create first x” button. |

### 4.3  Creation Modals (`add-goal.tsx`, `add-habit.tsx`, `add-task.tsx`)
* Use `react-hook-form` + `zodResolver` for validation.
* Fields follow tamagui `<Fieldset><Label><Input/></Fieldset>` pattern.
* Submit triggers appropriate `create` mutation; on success:
  1. Invalidate relevant list/dash queries via `queryClient.invalidateQueries()`.
  2. Show success toast (`Toast.show({message})`).
  3. Dismiss modal (`router.back()`).

### 4.4  Detail Screens
* Fetch by ID query.
* Show read-only view first, edit via top-right `Edit`.
* Edit toggles form mode; on save uses `update` mutation.
* Danger zone section for `Delete` (with confirmation alert).  

### 4.5  Compass & Rewards (MVP)
* Placeholder charts via `react-native-svg` + `victory-native`.
* Data endpoints to be defined later (analytics / point ledger).

### 4.6  Settings Stack
* Grouped list UI (`ListItem` with chevron).
* Each subsection is a simple form or markdown doc.

---

## 5  Reusable Components Library
| Component | Description | Notes |
|-----------|-------------|-------|
| `DashboardSection` | Card-like container with title & optional action. | Accepts `isLoading`, `isError`, etc. |
| `EmptyOrSkeleton` | Wrapper deciding Skeleton / Empty state / children. | Centralises UX logic. |
| `SectionError` | Banner with retry button. | Use $gray3 background, $red9 accents. |
| `ProgressRing` | Circular SVG progress. | Now typed with `ColorTokens`. |
| `FormField` | Label + Input + error msg. | Driven by RHF context. |
| `ToastViewport` | Safe-area aware toasts (already implemented). | |

---

## 6  State & Logic
* **Zustand stores**: `uiStore` (theme, network), `authStore` (session, user).
* **Offline**: react-query mutation queue; network detector triggers flush.
* **Auth**: Supabase listener → refresh JWT → inject into tRPC link header.

---

## 7  Environment & Secrets
```ini
# app.config.js reads these via process.env
EXPO_PUBLIC_SUPABASE_URL     = https://xyz.supabase.co
EXPO_PUBLIC_SUPABASE_ANON_KEY= ********
EXPO_PUBLIC_API_URL          = https://api.myapp.com/trpc
```
* In EAS, configure **development**, **preview**, **production** channels each with distinct env groups.

---

## 8  Testing & CI
* **Unit**: Jest + @testing-library/react-native (components, hooks).
* **E2E**: Detox flows – login, create habit, toggle habit, logout.
* **CI**: GitHub Actions → run `yarn test`, `expo prebuild --platform ios`, `eas build --profile preview`.

---

## 9  TODO Checklist (Living)

- [ ] **Fix remaining TypeScript & Markdown lints**  
  _Context:_ CI must be green before EAS builds.

- [ ] **Home screen polish**  
  - [ ] Final spacing & theming tweaks  
  - [ ] Hook `utils/offline-mutations.ts` into habit toggle  
  - [ ] Add success haptic via `utils/haptics.ts`

- [ ] **Offline mutation wiring (global prerequisite)**  
  _Integrate `queueOfflineMutation()` into every create/update/toggle/delete mutation across the app._

- [ ] **Add haptics feedback (cross-cutting)**  
  _Call `triggerSuccess()` / `triggerError()` after key user actions._

- [ ] **Planner refactor**  
  - [ ] Implement segmented lists in `(tabs)/planner/index.tsx` using `useSuspenseQueries`  
  - [ ] Swipe-to-delete with optimistic update (depends on offline wiring)

- [ ] **Creation modals**  
  - [ ] Build `add-goal.tsx` (react-hook-form + zod)  
  - [ ] Build `add-habit.tsx`  
  - [ ] Build `add-task.tsx`  
  _Prerequisite:_ offline mutation wiring.

- [ ] **Detail screens**  
  - [ ] Fetch by ID queries  
  - [ ] Edit mode with update mutation  
  - [ ] Delete action with confirmation (depends on offline wiring)

- [ ] **Compass & Rewards MVP**  
  - [ ] Define Supabase views (`goal_progress_view`, `streaks_view`)  
  - [ ] Create `rewards` / `points_ledger` tables & tRPC routers  
  - [ ] Implement charts with `victory-native`

- [ ] **Settings stack implementation**  
  - [ ] Profile form bound to `profiles` table  
  - [ ] Toggle switches saved via `utils/settings.ts`

- [ ] **Token audit** – replace any literal colour/spacing values with Tamagui tokens.

- [ ] **Remove duplicate** `app/planner/add-habit.tsx` once confirmed unused.

- [ ] **Testing & CI**  
  - [ ] Jest unit coverage for utils & components  
  - [ ] Detox e2e flows (auth, create habit, toggle habit)  
  - [ ] GitHub Actions + EAS Build pipelines

> **Next Immediate Step:** Start Planner index refactor (checkbox above).
```


# scripts

### generate-all.js
**Path:** scripts/generate-all.js
**Size:** 1086 bytes

```javascript
const { execSync } = require('child_process');
const path = require('path');

/**
 * This script runs all code generation scripts in the correct order.
 * It ensures that:
 * 1. TRPC types are generated first (shared zod schemas)
 * 2. React Query hooks are generated from the TRPC router
 */
console.log('🚀 Running all code generators...');

try {
  console.log('\n📝 Generating TRPC shared types...');
  execSync('node ./scripts/generate-trpc-types.js', { stdio: 'inherit' });
  
  console.log('\n📝 Generating TRPC client hooks...');
  execSync('node ./scripts/generate-trpc-client.js', { stdio: 'inherit' });

  console.log('\n✅ All code generation complete!');
  console.log('\n🔍 Checking for TypeScript errors...');
  
  try {
    execSync('npx tsc --noEmit', { stdio: 'inherit' });
    console.log('✅ TypeScript validation successful!');
  } catch (error) {
    console.log('⚠️ TypeScript validation found some errors. Please fix them before continuing.');
  }

} catch (error) {
  console.error('\n❌ Generation failed:', error.message);
  process.exit(1);
} ```

### generate-trpc-client.js
**Path:** scripts/generate-trpc-client.js
**Size:** 2188 bytes

```javascript
const fs = require('fs');
const path = require('path');

/**
 * This script generates a TRPC client file with typed hooks for each procedure
 * in the AppRouter. This provides full type safety for the client code.
 */

// Configuration
const outputPath = path.join(__dirname, '../utils/generated-hooks.ts');
const routerPath = path.resolve(__dirname, '../server/src/router.ts');

const generateTRPCClient = () => {
  // First, let's read the router file to understand its structure
  const routerContent = fs.readFileSync(routerPath, 'utf-8');
  
  // Extract all the router imports
  const routerImportRegex = /import\s+{\s*(.*?)Router\s*}\s*from\s*['"](.+?)['"];/g;
  const routerImports = [];
  let match;
  
  while ((match = routerImportRegex.exec(routerContent)) !== null) {
    routerImports.push({
      name: match[1],
      path: match[2]
    });
  }
  
  // Extract the router registrations from appRouter
  const routerRegistrationRegex = /(\w+)\s*:\s*(\w+)Router,/g;
  const routerRegistrations = [];
  
  while ((match = routerRegistrationRegex.exec(routerContent)) !== null) {
    routerRegistrations.push({
      key: match[1],
      name: match[2]
    });
  }
  
  // Generate the type-safe hooks file
  const hookFileContent = `/**
 * GENERATED FILE - DO NOT EDIT
 * This file is automatically generated by the generate-trpc-client script.
 * To update this file, run: npm run generate-hooks
 */

import { trpc } from './trpc';
import { RouterInputs, RouterOutputs } from '../server/src/types/trpc-types';

/**
 * Type-safe hooks for TRPC procedures
 */

${routerRegistrations.map(router => {
  return `// ${router.key} hooks
export const use${capitalizeFirstLetter(router.key)} = {
  // Add strongly typed hooks here
};
`;
}).join('\n')}

// Example type usage
type GreetingOutput = RouterOutputs['greeting']['hello'];
`;

  // Write the generated file
  fs.writeFileSync(outputPath, hookFileContent);
  console.log(`✅ Generated TRPC client hooks at ${outputPath}`);
};

// Helper function to capitalize the first letter
function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

// Run the generator
generateTRPCClient(); ```

### generate-trpc-types.js
**Path:** scripts/generate-trpc-types.js
**Size:** 1158 bytes

```javascript
const fs = require('fs');
const path = require('path');

// Path to the generated types output file
const outputPath = path.join(__dirname, '../app/utils/api-types.ts');

const generateTypes = () => {
  // Define the content of the types file
  const typesContent = `/**
 * This file was auto-generated by the generate-trpc-types script.
 * Do not edit manually! Instead, run the script again.
 */

import type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from '../../server/src/router';

/**
 * Inference helper for inputs.
 *
 * @example type HelloInput = RouterInputs['example']['hello']
 */
export type RouterInputs = inferRouterInputs<AppRouter>;

/**
 * Inference helper for outputs.
 *
 * @example type HelloOutput = RouterOutputs['example']['hello']
 */
export type RouterOutputs = inferRouterOutputs<AppRouter>;
`;

  // Ensure directory exists
  const dir = path.dirname(outputPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  // Write the file
  fs.writeFileSync(outputPath, typesContent);
  console.log(`✅ Types generated at ${outputPath}`);
};

generateTypes(); ```

### generate_app_code_overview.sh
**Path:** scripts/generate_app_code_overview.sh
**Size:** 2402 bytes

```bash
#!/bin/bash

# Create output directory if it doesn't exist
mkdir -p output

OUTPUT_FILE="output/app_code_overview.txt"

# Clear output file if it exists
echo "# Aether App Code Overview" > $OUTPUT_FILE
echo "Generated on $(date)" >> $OUTPUT_FILE
echo "" >> $OUTPUT_FILE

# Function to add file content to the output file
add_file() {
  local file=$1
  echo "## File: $file" >> $OUTPUT_FILE
  echo '```' >> $OUTPUT_FILE
  cat "$file" >> $OUTPUT_FILE
  echo '```' >> $OUTPUT_FILE
  echo "" >> $OUTPUT_FILE
}

# Find all relevant files
# Exclude:
# - node_modules
# - .git
# - .expo
# - .tamagui (generated code)
# - Large files like package-lock.json
# - Binary files
# Include important code files with extensions:
# - .tsx, .ts, .js, .jsx
# - .json (except package-lock.json)
# - .md for documentation

echo "Finding and processing relevant files..."

find . -type f \
  -not -path "*/node_modules/*" \
  -not -path "*/.git/*" \
  -not -path "*/.expo/*" \
  -not -path "*/.tamagui/*" \
  -not -name "package-lock.json" \
  -not -path "*/output/*" \
  \( -name "*.tsx" -o -name "*.ts" -o -name "*.js" -o -name "*.jsx" -o -name "*.md" \) | sort | while read -r file; do
  
  # Check if file size is less than 500KB (to avoid very large files)
  file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
  if [ "$file_size" -lt 500000 ]; then
    echo "Processing: $file"
    add_file "$file"
  else
    echo "Skipping large file: $file"
    echo "## File: $file (skipped - too large, size: $file_size bytes)" >> $OUTPUT_FILE
    echo "" >> $OUTPUT_FILE
  fi
done

# Add select JSON files (excluding package-lock.json which is already excluded above)
find . -type f -name "*.json" \
  -not -path "*/node_modules/*" \
  -not -path "*/.git/*" \
  -not -path "*/.expo/*" \
  -not -path "*/.tamagui/*" \
  -not -name "package-lock.json" \
  -not -path "*/output/*" | sort | while read -r file; do
  
  file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
  if [ "$file_size" -lt 100000 ]; then
    echo "Processing: $file"
    add_file "$file"
  else
    echo "Skipping large file: $file"
    echo "## File: $file (skipped - too large, size: $file_size bytes)" >> $OUTPUT_FILE
    echo "" >> $OUTPUT_FILE
  fi
done

echo "Code overview generated at $OUTPUT_FILE"
echo "Total size: $(stat -f%z "$OUTPUT_FILE" 2>/dev/null || stat -c%s "$OUTPUT_FILE" 2>/dev/null) bytes" ```

### reset-project.js
**Path:** scripts/reset-project.js
**Size:** 3608 bytes

```javascript
#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It deletes or moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example based on user input and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require("fs");
const path = require("path");
const readline = require("readline");

const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const exampleDir = "app-example";
const newAppDir = "app";
const exampleDirPath = path.join(root, exampleDir);

const indexContent = `import { Text, View } from "react-native";

export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}
`;

const layoutContent = `import { Stack } from "expo-router";

export default function RootLayout() {
  return <Stack />;
}
`;

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const moveDirectories = async (userInput) => {
  try {
    if (userInput === "y") {
      // Create the app-example directory
      await fs.promises.mkdir(exampleDirPath, { recursive: true });
      console.log(`📁 /${exampleDir} directory created.`);
    }

    // Move old directories to new app-example directory or delete them
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      if (fs.existsSync(oldDirPath)) {
        if (userInput === "y") {
          const newDirPath = path.join(root, exampleDir, dir);
          await fs.promises.rename(oldDirPath, newDirPath);
          console.log(`➡️ /${dir} moved to /${exampleDir}/${dir}.`);
        } else {
          await fs.promises.rm(oldDirPath, { recursive: true, force: true });
          console.log(`❌ /${dir} deleted.`);
        }
      } else {
        console.log(`➡️ /${dir} does not exist, skipping.`);
      }
    }

    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log("\n📁 New /app directory created.");

    // Create index.tsx
    const indexPath = path.join(newAppDirPath, "index.tsx");
    await fs.promises.writeFile(indexPath, indexContent);
    console.log("📄 app/index.tsx created.");

    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, "_layout.tsx");
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log("📄 app/_layout.tsx created.");

    console.log("\n✅ Project reset complete. Next steps:");
    console.log(
      `1. Run \`npx expo start\` to start a development server.\n2. Edit app/index.tsx to edit the main screen.${
        userInput === "y"
          ? `\n3. Delete the /${exampleDir} directory when you're done referencing it.`
          : ""
      }`
    );
  } catch (error) {
    console.error(`❌ Error during script execution: ${error.message}`);
  }
};

rl.question(
  "Do you want to move existing files to /app-example instead of deleting them? (Y/n): ",
  (answer) => {
    const userInput = answer.trim().toLowerCase() || "y";
    if (userInput === "y" || userInput === "n") {
      moveDirectories(userInput).finally(() => rl.close());
    } else {
      console.log("❌ Invalid input. Please enter 'Y' or 'N'.");
      rl.close();
    }
  }
);
```


# server

### .env
**Path:** server/.env
**Size:** 431 bytes

```
EXPO_PUBLIC_SUPABASE_URL=https://fjzzeprbdjwpxnhnltqm.supabase.co
EXPO_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZqenplcHJiZGp3cHhuaG5sdHFtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5NjU1ODEsImV4cCI6MjA2MDU0MTU4MX0.iXWsMcw72PV6dtzDnna9LuPFF1MPYvlmFcasx0Qlo34
SUPABASE_URL=https://fjzzeprbdjwpxnhnltqm.supabase.co
SUPABASE_SERVICE_ROLE_KEY=<your-service-role-key-from-supabase-settings>```

### package.json
**Path:** server/package.json
**Size:** 694 bytes

```json
{
  "name": "aether-server",
  "version": "1.0.0",
  "description": "Backend server for Aether app",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "dependencies": {
    "@supabase/supabase-js": "^2.49.4",
    "cors": "^2.8.5",
    "date-fns": "^4.1.0",
    "express": "^4.18.2",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/node": "^20.11.20",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.3.3"
  }
}
```

### context.ts
**Path:** server/src/context.ts
**Size:** 1794 bytes

```typescript
import { createClient } from '@supabase/supabase-js';
import { TRPCError } from '@trpc/server';
import dotenv from 'dotenv';

// Load environment variables from ./server/.env
dotenv.config();

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

// Add checks to ensure variables are loaded
if (!supabaseUrl) {
    console.log('Attempting Supabase init. URL found: No'); // Keep log here
    throw new Error('Missing environment variable: SUPABASE_URL in server/.env');
}
if (!supabaseServiceKey) {
    throw new Error('Missing environment variable: SUPABASE_SERVICE_ROLE_KEY in server/.env');
}

console.log('Attempting Supabase init. URL found: Yes'); // Log success

// Initialize Supabase Admin client
export const supabaseAdmin = createClient(
  supabaseUrl,
  supabaseServiceKey,
  {
    auth: {
        autoRefreshToken: false,
        persistSession: false
    }
  }
);

// Context passed to all tRPC resolvers
export interface Context {
  supabaseAdmin: typeof supabaseAdmin;
  userId: string;
}

// Build context from incoming request
export async function createContext({ req }: { req: any }): Promise<Context> {
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: 'Missing Authorization header' });
  }
  const token = authHeader.split(' ')[1];
  if (!token) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: 'Invalid Authorization header' });
  }

  // Validate JWT and get user
  const { data, error } = await supabaseAdmin.auth.getUser(token);
  if (error || !data.user) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: error?.message || 'Invalid token' });
  }

  return {
    supabaseAdmin,
    userId: data.user.id,
  };
} ```

### index.ts
**Path:** server/src/index.ts
**Size:** 941 bytes

```typescript
import express, { Request, Response } from 'express';
import cors from 'cors';
import { createExpressMiddleware } from '@trpc/server/adapters/express';
import { appRouter } from './router';
import { createContext } from './context';

const app = express();
const port = process.env.PORT || 3000;

// Enable CORS for client app
app.use(cors({
  origin: ['http://localhost:8081', 'http://localhost:19000', 'http://localhost:19006', 'exp://localhost:19000'],
  credentials: true,
}));

// Health check endpoint
app.get('/health', (_: Request, res: Response) => {
  res.status(200).json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Create tRPC middleware
app.use('/api/trpc', createExpressMiddleware({
  router: appRouter,
  createContext,
}));

// Start server
app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
  console.log(`tRPC API available at http://localhost:${port}/api/trpc`);
}); ```

### router.ts
**Path:** server/src/router.ts
**Size:** 2087 bytes

```typescript
import { initTRPC } from '@trpc/server';
import { z } from 'zod';
import { TRPCError } from '@trpc/server';
import { supabaseAdmin, Context } from './context';

// Initialize tRPC with Supabase context
const t = initTRPC.context<Context>().create();

// Public procedure (no auth required)
export const router = t.router;
export const publicProcedure = t.procedure;

// Protected procedures ensure user is authenticated
export const protectedProcedure = t.procedure.use(({ ctx, next }) => {
  if (!ctx.userId) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }
  return next({ ctx: { supabaseAdmin: ctx.supabaseAdmin, userId: ctx.userId } });
});

// Import individual routers
import { dashboardRouter } from './routers/dashboardRouter';
import { valueRouter } from './routers/valueRouter';
import { principleRouter } from './routers/principleRouter';
import { goalRouter } from './routers/goalRouter';
import { taskRouter } from './routers/taskRouter';
import { habitRouter } from './routers/habitRouter';
import { trackedStateRouter } from './routers/trackedStateRouter';
import { userRouter } from './routers/userRouter';
import { rewardsRouter } from './routers/rewardsRouter';
import { reminderRouter } from './routers/reminderRouter';
import { goalProgressNoteRouter } from './routers/goalProgressNoteRouter';

// Create the router with Supabase-backed procedures
export const appRouter = router({
  greeting: {
    hello: publicProcedure
      .input(z.object({ name: z.string().optional() }))
      .query(async ({ input }) => {
        return { greeting: `Hello ${input.name ?? 'world'}` };
      }),
    goodbye: publicProcedure
      .query(() => {
        return { greeting: 'Goodbye!' };
      }),
  },
  user: userRouter,
  dashboard: dashboardRouter,
  value: valueRouter,
  principle: principleRouter,
  goal: goalRouter,
  task: taskRouter,
  habit: habitRouter,
  state: trackedStateRouter,
  rewards: rewardsRouter,
  reminder: reminderRouter,
  goalProgressNote: goalProgressNoteRouter,
});

// Export type router type
export type AppRouter = typeof appRouter; ```

### dashboardRouter.ts
**Path:** server/src/routers/dashboardRouter.ts
**Size:** 21397 bytes

```typescript
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';

// Define fields for consistent selection - align with Zod schemas & table structure
const HABIT_FIELDS = 'id, user_id, name, description, habit_type, goal_quantity, goal_units, frequency_type, frequency_details, reminder_id, streak, best_streak, sort_order, created_at, updated_at'; // Added reminder_id
const GOAL_FIELDS = 'id, user_id, name, description, priority, status, target_date, sort_order, created_at, updated_at'; // Use target_date
const TASK_FIELDS = 'id, user_id, name, notes, status, priority, due_date, reminder_id, goal_id, sort_order, created_at, updated_at'; // Use due_date, reminder_id
const HABIT_ENTRY_FIELDS = 'id, habit_id, user_id, date, quantity_value, notes, created_at';
const TRACKED_STATE_DEF_FIELDS = 'id, user_id, name, description, data_type, unit, sort_order, active, notes, created_at, updated_at'; // Adjusted based on potential schema changes

export const dashboardRouter = router({
  getDashboardData: protectedProcedure
    .input(
      z.object({
        habitLimit: z.number().min(1).default(5),
        goalLimit: z.number().min(1).default(5),
        taskLimit: z.number().min(1).default(10)
      }).optional()
    )
    .query(async ({ ctx, input }) => {
      try {
        // Get limits from input or use defaults
        const habitLimit = input?.habitLimit || 5;
        const goalLimit = input?.goalLimit || 5;
        const taskLimit = input?.taskLimit || 10;

        // --- Fetch Habits ---
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
          .limit(habitLimit);
        if (habitsError) throw habitsError;

        // --- Fetch Goals ---
        const { data: goals, error: goalsError } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
          .limit(goalLimit);
        if (goalsError) throw goalsError;

        // --- Fetch Upcoming Tasks (focus on upcoming tasks and prioritize those due soon) ---
        const today = new Date();
        const twoWeeksFromNow = new Date();
        twoWeeksFromNow.setDate(today.getDate() + 14);
        
        // We want to fetch tasks that are:
        // 1. Not completed
        // 2. Due within the next two weeks, or overdue
        // 3. Either unassigned or associated with the dashboard goals
        const { data: tasks, error: tasksError } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .neq('status', 'completed') // Use correct enum value
          .or(`due_date.lte.${twoWeeksFromNow.toISOString()},due_date.is.null`)
          .order('due_date', { ascending: true, nullsFirst: false }) // Use 'due_date'
          .limit(taskLimit);
        if (tasksError) throw tasksError;

        // --- Fetch Active Tracked State Definitions ---
        const { data: trackedStateDefinitions, error: statesError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .eq('active', true)
          .order('sort_order', { ascending: true, nullsFirst: false }); // Correct: nullsFirst: false for nulls last
        if (statesError) throw statesError;
        
        // --- Fetch Latest State Entries for Active Definitions ---
        let latestEntriesMap: Record<string, { value: any; created_at: string }> = {};
        const stateDefIds = (trackedStateDefinitions || []).map(s => s.id);

        if (stateDefIds.length > 0) {
          // Use a CTE and ROW_NUMBER() to get the latest entry per state_id
          const { data: latestEntries, error: entriesError } = await ctx.supabaseAdmin.rpc(
            'get_latest_state_entries_for_user', 
            { p_user_id: ctx.userId, p_state_ids: stateDefIds }
          );

          if (entriesError) {
            console.error('Error fetching latest state entries:', entriesError);
            // Decide how to handle this - throw, or continue with empty/default values?
            // For now, log and continue, states will show default value
          } else {
            // Define expected type for entries from RPC
            type LatestEntry = { state_id: string; value: any; created_at: string };
            
            latestEntriesMap = (latestEntries as LatestEntry[] || []).reduce(
              (acc: Record<string, { value: any; created_at: string }>, entry: LatestEntry) => {
              acc[entry.state_id] = { value: entry.value, created_at: entry.created_at };
              return acc;
            }, {} as typeof latestEntriesMap);
          }
        }

        // --- Process Habits for 'completed' flag ---
        const todayStr = new Date().toISOString().split('T')[0];
        const habitIds = (habits || []).map(h => h.id);
        const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id') // Only need habit_id to check existence
          .eq('user_id', ctx.userId)
          .eq('date', todayStr) // Filter by date
          .in('habit_id', habitIds);
        if (todayEntriesError) throw todayEntriesError;

        const completedHabitIds = new Set((habitEntriesToday || []).map(e => e.habit_id));

        const formattedHabits = (habits || []).map(h => ({
          id: h.id,
          name: h.name, // Use name
          description: h.description, // Pass other potentially useful fields
          habit_type: h.habit_type,
          streak: h.streak,
          // Consider a habit completed if *any* entry exists for today
          completed: completedHabitIds.has(h.id)
        }));

        // --- Process Goals for 'progress' ---
        const goalIds = (goals || []).map(g => g.id);
        let tasksMap: Record<string, { total: number; completed: number }> = {};
        if (goalIds.length > 0) {
          const { data: allTasksForGoals, error: tasksError2 } = await ctx.supabaseAdmin
            .from('tasks')
            .select('goal_id, status')
            .eq('user_id', ctx.userId)
            .in('goal_id', goalIds);
          if (tasksError2) throw tasksError2;

          tasksMap = (allTasksForGoals || []).reduce<Record<string, { total: number; completed: number }>>((acc, task) => {
            if (task.goal_id) { // Ensure goal_id is not null
              const gid = task.goal_id;
              if (!acc[gid]) acc[gid] = { total: 0, completed: 0 };
              acc[gid].total++;
              if (task.status === 'completed') acc[gid].completed++;
            }
            return acc;
          }, {});
        }

        const formattedGoals = (goals || []).map((g) => {
          const { total = 0, completed: comp = 0 } = tasksMap[g.id] || {};
          // Calculate progress based on tasks, ignore goal.progress field for now
          const progress = total > 0 ? comp / total : 0;
          return {
            id: g.id,
            title: g.name, // Changed name to title to match frontend expectations
            status: g.status, // Pass status directly
            priority: g.priority, // Pass priority
            progress: Math.round(progress * 100) / 100, // Keep calculated progress
            tasks: { // Add tasks information expected by GoalSummaryCard
              total: total,
              completed: comp
            }
          };
        });

        // --- Format Tasks (Minimal formatting needed if TASK_FIELDS is correct) ---
        const formattedTasks = (tasks || []).map((t) => ({
          id: t.id,
          name: t.name,
          status: t.status,
          priority: t.priority,
          due_date: t.due_date, // Use due_date
          // Add other fields as needed by the dashboard UI
        }));

        // --- Format Tracked States with Latest Values ---
        const formattedTrackedStates = (trackedStateDefinitions || []).map((def) => {
          const latestEntry = latestEntriesMap[def.id];
          return {
            id: def.id,
            name: def.name,
            unit: def.unit, // Use 'unit' field
            currentValue: latestEntry ? latestEntry.value : null, // Default to null
            lastUpdated: latestEntry ? latestEntry.created_at : null,
          };
        });

        // Return formatted data including trackedStates
        return {
          habits: formattedHabits,
          goals: formattedGoals,
          tasks: tasks || [], // Ensure tasks is always an array
          trackedStates: formattedTrackedStates, // Use the newly formatted array
        };
      } catch (error: any) {
        console.error('Dashboard data fetch error:', error);
        
        // Handle specific error types with appropriate error codes
        if (error.code === '42P01') { // Table doesn't exist
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Database schema error',
          });
        }
        
        if (error.code === '23505') { // Unique violation
          throw new TRPCError({
            code: 'CONFLICT',
            message: 'Resource already exists',
          });
        }
        
        // Default error handling
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch dashboard data',
        });
      }
    }),
  
  getWeeklyProgress: protectedProcedure
    .input(z.object({
      daysToInclude: z.number().min(1).optional().default(7),
      includeRawData: z.boolean().optional().default(false),
    }).optional())
    .query(async ({ ctx, input }) => {
      try {
        // Calculate date range based on input or default to past week
        const daysToInclude = input?.daysToInclude || 7;
        const includeRawData = input?.includeRawData || false;
        
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(endDate.getDate() - (daysToInclude - 1));
        
        const todayStr = endDate.toISOString().split('T')[0];
        const startDateStr = startDate.toISOString().split('T')[0];
        
        // Generate array of all dates in the range for daily aggregation
        const dateRange: string[] = [];
        const tempDate = new Date(startDate);
        while (tempDate <= endDate) {
          dateRange.push(tempDate.toISOString().split('T')[0]);
          tempDate.setDate(tempDate.getDate() + 1);
        }
        
        // Fetch habits relevant to the date range (active during any part of the range)
        // Need to consider habits created *before* the end date and not archived *before* the start date
        const HABIT_FIELDS_FOR_PROGRESS = 'id, name, habit_type, frequency_type, frequency_details, created_at, streak, best_streak'; // Add streak fields
        const { data: relevantHabits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS_FOR_PROGRESS)
          .eq('user_id', ctx.userId)
          // Add logic here if needed to filter habits active within the date range
          // e.g., .lt('created_at', endDate.toISOString())
          //       .or(`archived_at.gte.${startDate.toISOString()},archived_at.is.null`)
          ;
        if (habitsError) throw habitsError;

        const relevantHabitIds = (relevantHabits || []).map(h => h.id);

        // Fetch habit entries within the date range for relevant habits
        const { data: habitEntries, error: entriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('id, habit_id, date, completed, quantity_value, notes')
          .eq('user_id', ctx.userId)
          .in('habit_id', relevantHabitIds.length > 0 ? relevantHabitIds : ['dummy-uuid']) // Filter by relevant habits
          .gte('date', startDate.toISOString().split('T')[0])
          .lte('date', endDate.toISOString().split('T')[0])
          .order('date', { ascending: true });
 
        if (entriesError) throw entriesError;

        // Get all tasks completed or due within the date range
        const { data: relevantTasks, error: tasksError } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .or(`due_date.gte.${startDateStr}.and.due_date.lte.${todayStr},status.eq.completed.and.updated_at.gte.${startDateStr}.and.updated_at.lte.${todayStr}`);

        if (tasksError) throw tasksError;
        
        // Get total tasks count for completion rate
        const { count: totalTasks, error: countError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', ctx.userId);
          
        if (countError) throw countError;
        
        // Get goal progress snapshots for the period
        const { data: goalSnapshots, error: goalSnapshotsError } = await ctx.supabaseAdmin
          .from('goal_progress_snapshots') // Assuming we have this table
          .select('goal_id, progress, created_at')
          .eq('user_id', ctx.userId)
          .gte('created_at', startDate.toISOString())
          .lte('created_at', endDate.toISOString())
          .order('created_at', { ascending: true });
          
        if (goalSnapshotsError) throw goalSnapshotsError;

        // -- AGGREGATE DATA BY DAY --
        
        // Create daily habit completion structure
        const habitsByDay: Record<string, { completed: number; total: number; entries: any[]; expected: number }> = {};
        dateRange.forEach(date => {
          habitsByDay[date] = { completed: 0, total: 0, entries: [], expected: 0 };
        });
        
        // Populate completed habits from entries (count existence, not completed flag)
        habitEntries?.forEach((entry: any) => {
          const dateStr = (entry.date as string).split('T')[0];
          if (habitsByDay[dateStr]) {
            // Only count one completion per habit per day
            if (!habitsByDay[dateStr].entries.some((e: any) => e.habit_id === entry.habit_id)) {
              habitsByDay[dateStr].completed++;
            }
            habitsByDay[dateStr].entries.push(entry);
          }
        });
        
        // Create daily task completion structure
        const tasksByDay: Record<string, { completed: number; entries: any[] }> = {};
        dateRange.forEach(date => {
          tasksByDay[date] = { completed: 0, entries: [] };
        });
        
        // Process completed tasks into daily stats
        relevantTasks?.forEach(task => {
          const completedDate = (task.updated_at as string).split('T')[0];
          if (tasksByDay[completedDate]) {
            tasksByDay[completedDate].completed++;
            tasksByDay[completedDate].entries.push(task);
          }
        });
        
        // Calculate expected habits per day based on frequency
        const isHabitExpected = (habit: any, date: string): boolean => {
          const dateObj = new Date(date + 'T00:00:00Z'); // Ensure UTC
          const dayOfWeek = dateObj.getUTCDay(); // 0 = Sunday, 6 = Saturday
          const dayOfMonth = dateObj.getUTCDate();
          const month = dateObj.getUTCMonth(); // 0 = January, 11 = December

          const habitCreatedDate = new Date(habit.created_at);
          if (dateObj < habitCreatedDate) {
            return false; // Cannot be expected before it was created
          }

          switch (habit.frequency_type) {
            case 'daily':
              return true;
            case 'specific_days':
              return Array.isArray(habit.frequency_details?.days) && habit.frequency_details.days.includes(dayOfWeek);
            // TODO: Add logic for 'weekly', 'monthly' etc. as needed
            default:
              return false;
          }
        };
        relevantHabits?.forEach(habit => {
          dateRange.forEach(date => {
            if (isHabitExpected(habit, date)) {
              habitsByDay[date].expected++;
            }
          });
        });
        
        // Format into daily progress reports
        const dailyProgress = dateRange.map(date => {
          const habitStats = habitsByDay[date];
          const taskStats = tasksByDay[date];
          
          const habitCompletionRate = habitStats.expected > 0 
            ? habitStats.completed / habitStats.expected 
            : 0;
            
          return {
            date,
            habits: {
              total: habitStats.total,
              completed: habitStats.completed,
              completionRate: habitCompletionRate,
              expected: habitStats.expected
            },
            tasks: {
              completed: taskStats.completed
            },
            // Optionally include raw entries if requested
            ...(includeRawData ? {
              habitEntries: habitStats.entries,
              completedTasks: taskStats.entries
            } : {})
          };
        });
        
        // Calculate overall metrics
        const totalHabitEntries = Object.values(habitsByDay).reduce(
          (sum, day) => sum + day.total, 0);
        const completedHabitEntries = Object.values(habitsByDay).reduce(
          (sum, day) => sum + day.completed, 0);
        const totalCompletedTasks = Object.values(tasksByDay).reduce(
          (sum, day) => sum + day.completed, 0);
          
        const taskCompletionRate = totalTasks ? totalCompletedTasks / totalTasks : 0;
        const habitConsistency = totalHabitEntries > 0 
          ? completedHabitEntries / totalHabitEntries 
          : 0;
          
        // Calculate habit streaks (could be moved to a separate helper function)
        const habitStreaks = (relevantHabits || []).map(habit => ({
          id: habit.id,
          name: habit.name,
          currentStreak: habit.streak || 0,
          bestStreak: habit.best_streak || 0
        }));
        
        // Prepare goal progress data
        const goalProgress: Record<string, { snapshots: any[]; startProgress?: number; endProgress?: number }> = {};
        
        (goalSnapshots || []).forEach(snapshot => {
          if (!goalProgress[snapshot.goal_id]) {
            goalProgress[snapshot.goal_id] = { snapshots: [] };
          }
          goalProgress[snapshot.goal_id].snapshots.push({
            progress: snapshot.progress,
            date: (snapshot.created_at as string).split('T')[0]
          });
        });
        
        // Calculate start and end progress for each goal
        Object.keys(goalProgress).forEach(goalId => {
          const snapshots = goalProgress[goalId].snapshots;
          if (snapshots.length > 0) {
            // Sort by date
            snapshots.sort((a, b) => a.date.localeCompare(b.date));
            goalProgress[goalId].startProgress = snapshots[0].progress;
            goalProgress[goalId].endProgress = snapshots[snapshots.length - 1].progress;
          }
        });
        
        return {
          dailyProgress,
          overallMetrics: {
            totalHabitEntries,
            completedHabitEntries,
            habitCompletionRate: habitConsistency,
            completedTasksCount: totalCompletedTasks,
            taskCompletionRate,
            // Trend indicators (compared to previous period)
            trends: {
              habitsImproving: true, // Placeholder - would compare to previous period
              tasksImproving: false // Placeholder - would compare to previous period
            }
          },
          habitStreaks,
          goalProgress: Object.entries(goalProgress).map(([goalId, data]) => ({
            goalId,
            progressChange: (data.endProgress || 0) - (data.startProgress || 0),
            currentProgress: data.endProgress || 0
          })),
          dateRange: {
            start: startDateStr,
            end: todayStr,
            days: dateRange
          }
        };
      } catch (error: any) {
        console.error('Weekly progress fetch error:', error);
        
        // Handle specific error types with appropriate error codes
        if (error.code === '42P01') { // Table doesn't exist
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Database schema error',
          });
        }
        
        if (error.code === '22P02') { // Invalid text representation
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Invalid input format',
          });
        }
        
        // Default error handling
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch weekly progress',
        });
      }
    }),
}); ```

### goalProgressNoteRouter.ts
**Path:** server/src/routers/goalProgressNoteRouter.ts
**Size:** 5325 bytes

```typescript
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createGoalProgressNoteInput,
  updateGoalProgressNoteInput,
  GetGoalProgressNotesInput,
  DeleteGoalProgressNoteInput,
} from '../types/trpc-types';

// Define fields for consistent selection
const GOAL_PROGRESS_NOTE_FIELDS = 'id, goal_id, user_id, note, created_at';

export const goalProgressNoteRouter = router({
  // Get all notes for a specific goal
  getNotesForGoal: protectedProcedure
    .input(GetGoalProgressNotesInput)
    .query(async ({ ctx, input }) => {
      try {
        // First, ensure the goal exists and belongs to the user
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        // Fetch the notes for that goal
        const { data, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .eq('user_id', ctx.userId) // Redundant check, but good practice
          .eq('goal_id', input.goal_id)
          .order('created_at', { ascending: false }); // Newest first

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal progress notes',
        });
      }
    }),

  createNote: protectedProcedure
    .input(createGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Ensure the goal exists and belongs to the user before adding a note
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        const { data: note, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return note;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal progress note',
        });
      }
    }),

  updateNote: protectedProcedure
    .input(updateGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership of the note
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { data: updatedNote, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return updatedNote;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal progress note',
        });
      }
    }),

  deleteNote: protectedProcedure
    .input(DeleteGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal progress note',
        });
      }
    }),
});
```

### goalRouter.ts
**Path:** server/src/routers/goalRouter.ts
**Size:** 7823 bytes

```typescript
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createGoalInput, updateGoalInput } from '../types/trpc-types';

const GOAL_FIELDS = 'id, user_id, title, description, progress, target_date, archived_at, sort_order, created_at, updated_at';

export const goalRouter = router({
  getGoals: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;

        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals',
        });
      }
    }),

  getGoalById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!goal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found',
          });
        }

        return goal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal',
        });
      }
    }),

  createGoal: protectedProcedure
    .input(createGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return goal;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal',
        });
      }
    }),

  updateGoal: protectedProcedure
    .input(updateGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to update it',
          });
        }

        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal',
        });
      }
    }),

  deleteGoal: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to delete it',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goals')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal',
        });
      }
    }),

  listActive: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals (in listActive stub)',
        });
      }
    }),

  listArchived: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived goals',
        });
      }
    }),

  archiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') { 
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive goal',
        });
      }
    }),

  unarchiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive goal',
        });
      }
    }),
});```

### habitRouter.ts
**Path:** server/src/routers/habitRouter.ts
**Size:** 22269 bytes

```typescript
import { z } from "zod";
import { router, protectedProcedure } from "../router";
import { TRPCError } from "@trpc/server";
import {
  createHabitInput,
  updateHabitInput,
  createHabitEntryInput,
  updateHabitEntryInput,
} from '../types/trpc-types';
import {
  differenceInCalendarDays,
  parseISO,
  format
} from 'date-fns'; // Need date-fns

const HABIT_FIELDS =
  'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, sort_order, streak, best_streak, created_at, updated_at';

const HABIT_ENTRY_FIELDS =
  'id, user_id, habit_id, date, completed, quantity_value, notes, created_at';

async function calculateAndUpdateStreak(habitId: string, userId: string, supabase: any): Promise<{ currentStreak: number, bestStreak: number }> {
  try {
    // Fetch all entries for the habit, ordered by date descending
    const { data: entries, error: entriesError } = await supabase
      .from('habit_entries')
      .select('date, completed') // Only need date and completed status
      .eq('habit_id', habitId)
      .eq('user_id', userId)
      .order('date', { ascending: false });

    if (entriesError) {
      console.error(`Streak Calc Error: Failed to fetch entries for habit ${habitId}:`, entriesError);
      return { currentStreak: 0, bestStreak: 0 }; // Return 0 if entries can't be fetched
    }

    if (!entries || entries.length === 0) {
      // No entries, reset streak
      const { error: updateErr } = await supabase
        .from('habits')
        .update({ streak: 0 })
        .eq('id', habitId);
      if (updateErr) console.error(`Streak Calc Error: Failed to reset streak for habit ${habitId}`, updateErr);
      // Fetch best streak to return it accurately even if current is 0
      const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
      return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 };
    }

    let currentStreak = 0;
    const today = new Date();
    let expectedDate = today; // Start checking from today
    const todayStr = format(today, 'yyyy-MM-dd');
    const todayEntry = entries.find((e: any) => e.date === todayStr);

    // Determine starting point for streak check
    if (todayEntry?.completed) {
      currentStreak = 1;
      expectedDate = new Date(today.setDate(today.getDate() - 1)); // Start checking from yesterday
    } else {
      const yesterday = new Date(); // Need a fresh date object
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayStr = format(yesterday, 'yyyy-MM-dd');
      const yesterdayEntry = entries.find((e: any) => e.date === yesterdayStr);
      if (yesterdayEntry?.completed) {
        currentStreak = 1;
        expectedDate = new Date(yesterday.setDate(yesterday.getDate() - 1)); // Start checking from day before yesterday
      } else {
        currentStreak = 0;
        // No need to loop if streak is already 0 based on today/yesterday
      }
    }

    // Only loop if there's a potential streak > 0
    if (currentStreak > 0) {
      // Find index of the entry *before* the expectedDate (since we check backwards)
      let startIndex = entries.findIndex((e: any) => e.date === format(expectedDate, 'yyyy-MM-dd'));
      // If expected date wasn't found (e.g., yesterday was the start), adjust index
      if (startIndex === -1) {
        // Start from the entry after the one that established the initial streak (today or yesterday)
        const initialStreakDateStr = todayEntry?.completed ? todayStr : (format(new Date(new Date().setDate(new Date().getDate() - 1)), 'yyyy-MM-dd'));
        const initialEntryIndex = entries.findIndex((e: any) => e.date === initialStreakDateStr);
        startIndex = initialEntryIndex !== -1 ? initialEntryIndex + 1 : 0;
      }

      for (let i = startIndex; i < entries.length; i++) {
        const entry = entries[i];
        const entryDate = parseISO(entry.date);
        const expectedDateStr = format(expectedDate, 'yyyy-MM-dd');

        if (entry.date === expectedDateStr) {
          if (entry.completed) {
            currentStreak++;
            expectedDate.setDate(expectedDate.getDate() - 1); // Move to check previous day
          } else {
            break; // Streak broken by uncompleted entry
          }
        } else {
          // Check if the date difference breaks the streak (allowing for gaps)
          const previousDate = i > 0 ? parseISO(entries[i - 1].date) : parseISO(entries[0].date);
          const dateDiff = differenceInCalendarDays(previousDate, entryDate);

          if (dateDiff > 1) {
            break; // Gap too large, streak broken
          }

          // If gap is 1 day, but this entry wasn't completed, streak is broken
          if (!entry.completed) {
            break;
          }

          // If gap is 1 day and completed, it doesn't continue the *current* consecutive sequence
          // but doesn't necessarily break it either (e.g., completed Mon, Wed - streak is 1 from Wed).
          // For simplicity, we break the loop here, assuming the *consecutive* streak from today/yesterday is what matters.
          // A more complex implementation could find the *longest* streak ending recently.
          break;
        }
      }
    }

    // Fetch current best_streak
    const { data: habitData, error: habitFetchError } = await supabase
      .from('habits')
      .select('best_streak')
      .eq('id', habitId)
      .single();

    if (habitFetchError) {
      console.error(`Streak Calc Error: Failed to fetch habit ${habitId} for best_streak:`, habitFetchError);
      // Fallback best streak if fetch fails
      const bestStreakFallback = Math.max(currentStreak, 0); 
      const { error: updateError } = await supabase
        .from('habits')
        .update({ streak: currentStreak, best_streak: bestStreakFallback })
        .eq('id', habitId);
      if (updateError) console.error(`Streak Calc Error: Failed to update streak (fallback) for habit ${habitId}:`, updateError);
      console.log(`Streak Updated (Fallback Best) for habit ${habitId}: Current=${currentStreak}, Best=${bestStreakFallback}`);
      return { currentStreak, bestStreak: bestStreakFallback };
    }

    const bestStreak = Math.max(currentStreak, habitData?.best_streak || 0);

    // Update the habit record
    const { error: updateError } = await supabase
      .from('habits')
      .update({ streak: currentStreak, best_streak: bestStreak })
      .eq('id', habitId);

    if (updateError) {
      console.error(`Streak Calc Error: Failed to update streak for habit ${habitId}:`, updateError);
    }

    console.log(`Streak Updated for habit ${habitId}: Current=${currentStreak}, Best=${bestStreak}`);
    return { currentStreak, bestStreak };

  } catch (error) {
    console.error(`Unexpected error calculating streak for habit ${habitId}:`, error);
    // Attempt to fetch best streak even on error
    const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
    return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 }; // Return 0 current streak on error
  }
}

export const habitRouter = router({
  getHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (habitsError) throw habitsError;
        if (!habits) return [];

        const todayStr = new Date().toISOString().split('T')[0];

        const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id')
          .eq('user_id', ctx.userId)
          .eq('date', todayStr)
          .in('habit_id', habits.map(h => h.id));

        if (todayEntriesError) throw todayEntriesError;

        const completedMap = (habitEntriesToday || []).reduce<Record<string, boolean>>((acc, entry) => {
          acc[entry.habit_id] = true;
          return acc;
        }, {});

        const formattedHabits = habits.map(h => ({
          ...h,
          completedToday: !!completedMap[h.id]
        }));

        return formattedHabits;
      } catch (error: any) {
        throw new TRPCError({ 
          code: 'INTERNAL_SERVER_ERROR', 
          message: error.message || 'Failed to fetch habits'
        });
      }
    }),

  getHabitById: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .select(HABIT_FIELDS)
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (error) throw new TRPCError({ 
        code: error.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: error.message 
      });
      return data;
    }),

  createHabit: protectedProcedure
    .input(createHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .insert({
          ...input,
          user_id: ctx.userId,
          streak: 0,
          best_streak: 0
        })
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  updateHabit: protectedProcedure
    .input(updateHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { id, ...updateData } = input;

      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .update(updateData)
        .eq("id", id)
        .eq('user_id', ctx.userId)
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  deleteHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { error } = await ctx.supabaseAdmin
        .from("habits")
        .delete()
        .eq("id", input.id);

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return { id: input.id };
    }),

  listArchivedHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        return habits || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived habits',
        });
      }
    }),

  archiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to archive habit' });
      }
    }),

  unarchiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to unarchive habit' });
      }
    }),

  getHabitEntries: protectedProcedure
    .input(z.object({
      habitId: z.string().uuid(),
      startDate: z.string().optional(), 
      endDate: z.string().optional(),   
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { error: habitError } = await ctx.supabaseAdmin
          .from("habits")
          .select("id")
          .eq("id", input.habitId)
          .eq("user_id", ctx.userId)
          .single();

        if (habitError) {
          if (habitError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: habitError.message });
        }

        let query = ctx.supabaseAdmin
          .from('habit_entries')
          .select(HABIT_ENTRY_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('habit_id', input.habitId);

        if (input.startDate) query = query.gte('date', input.startDate);
        if (input.endDate) query = query.lte('date', input.endDate);

        const { data, error: entriesError } = await query.order('date', { ascending: false });

        if (entriesError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: entriesError.message });
        return data || [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to fetch habit entries' });
      }
    }),

  getHabitEntriesForHabit: protectedProcedure
    .input(z.object({ habitId: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      // TODO: Implement logic to fetch habit entries for a specific habit
      console.log(`Fetching entries for habit: ${input.habitId}, user: ${ctx.userId}`);
      // Example fetch:
      // const { data, error } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select(HABIT_ENTRY_FIELDS)
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .order('date', { ascending: false });
      // if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      // return data || [];
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),

  createHabitEntry: protectedProcedure
    .input(createHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .insert({ ...input, user_id: ctx.userId })
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });

        // Update streak after successful insert
        if (data) {
          await calculateAndUpdateStreak(input.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create habit entry',
        });
      }
    }),

  updateHabitEntry: protectedProcedure
    .input(updateHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: habitEntry, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) throw new TRPCError({ 
          code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
          message: "Habit entry not found or access denied" 
        });

        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId) // Ensure ownership
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });

        // Update streak after successful update
        if (data) {
          await calculateAndUpdateStreak(data.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update habit entry',
        });
      }
    }),

  deleteHabitEntry: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Fetch habitId *before* deleting the entry
        const { data: entryToDelete, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id') // Fetch habit_id
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !entryToDelete) {
          throw new TRPCError({ 
            code: fetchError?.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Habit entry not found or access denied.' 
          });
        }

        const { habit_id: habitIdForStreak } = entryToDelete; // Store before delete

        // Perform delete
        const { error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId); // Ensure user owns the entry being deleted

        if (error) throw error; // Throw if delete fails

        // Update streak *after* successful delete
        if (habitIdForStreak) { // Check if we got the habitId
          await calculateAndUpdateStreak(habitIdForStreak, ctx.userId, ctx.supabaseAdmin);
        }

        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete habit entry',
        });
      }
    }),

  toggleHabitEntry: protectedProcedure
    .input(z.object({ habitId: z.string().uuid(), date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/) }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Implement logic to find if entry exists for habitId/date/userId.
      // If exists, delete it.
      // If not exists, create it (need default values for boolean/quantity type).
      // Call calculateAndUpdateStreak after create/delete.
      console.log(`Toggling habit entry for habit: ${input.habitId}, date: ${input.date}`);
      // Example logic:
      // const { data: existingEntry, error: findError } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select('id')
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .eq('date', input.date)
      //   .maybeSingle();
      // if (findError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: findError.message });

      // if (existingEntry) {
      //   // Delete existing
      //   const { error: deleteError } = await ctx.supabaseAdmin.from('habit_entries').delete().eq('id', existingEntry.id);
      //   if (deleteError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: deleteError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'deleted', habitId: input.habitId, date: input.date };
      // } else {
      //   // Create new
      //   // Need to know habit type to set default 'completed' or 'quantity_value'
      //   const { data: newEntry, error: createError } = await ctx.supabaseAdmin
      //     .from('habit_entries')
      //     .insert({ habit_id: input.habitId, user_id: ctx.userId, date: input.date, completed: true /* or quantity_value: default */ })
      //     .select(HABIT_ENTRY_FIELDS)
      //     .single();
      //   if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'created', entry: newEntry };
      // }
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),
});```

### principleRouter.ts
**Path:** server/src/routers/principleRouter.ts
**Size:** 5808 bytes

```typescript
// server/src/routers/principleRouter.ts
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createPrincipleInput, updatePrincipleInput } from '../types/trpc-types'; // These now expect 'title' and 'body'

// Define fields for consistent selection, using 'title' and 'body'
const PRINCIPLE_FIELDS = 'id, user_id, title, body, sort_order, created_at, updated_at';

export const principleRouter = router({
  getPrinciples: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: principles, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principles || []; // Return empty array if null
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principles',
        });
      }
    }),

  getPrincipleById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) {
           if (error.code === 'PGRST116') { // Handle not found specifically
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found' });
           }
           throw error; // Rethrow other errors
        }
        // No need for !principle check if .single() is used and error isn't PGRST116

        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principle',
        });
      }
    }),

  createPrinciple: protectedProcedure
    .input(createPrincipleInput) // This Zod schema now expects 'title' and 'body'
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .insert({
            ...input, // Spread validated input, already contains 'title' and 'body'
            user_id: ctx.userId,
          })
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create principle',
        });
      }
    }),

  updatePrinciple: protectedProcedure
    .input(updatePrincipleInput) // This Zod schema now expects 'title' and 'body' (optional)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
           if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to update it' });
           }
           throw fetchError;
        }

        // Update
        const { data: updatedPrinciple, error } = await ctx.supabaseAdmin
          .from('principles')
          .update(updateData) // updateData contains validated 'title'/'body' if provided
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return updatedPrinciple;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update principle',
        });
      }
    }),

  deletePrinciple: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
            if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to delete it' });
           }
           throw fetchError;
        }

        // Delete
        const { error } = await ctx.supabaseAdmin
          .from('principles')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete principle',
        });
      }
    }),
});```

### reminderRouter.ts
**Path:** server/src/routers/reminderRouter.ts
**Size:** 5065 bytes

```typescript
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createReminderInput,
  updateReminderInput,
  GetRemindersForEntityInput,
  DeleteReminderInput,
} from '../types/trpc-types';

// Define fields for consistent selection
const REMINDER_FIELDS = 'id, user_id, related_entity_type, related_entity_id, reminder_time, message, is_active, created_at, updated_at';

export const reminderRouter = router({
  // Get all active reminders for the user (might need refinement later)
  getActiveReminders: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('is_active', true)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch active reminders',
        });
      }
    }),

  // Get reminders linked to a specific entity
  getRemindersForEntity: protectedProcedure
    .input(GetRemindersForEntityInput)
    .query(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('related_entity_type', input.related_entity_type)
          .eq('related_entity_id', input.related_entity_id)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch reminders for entity',
        });
      }
    }),

  createReminder: protectedProcedure
    .input(createReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // TODO: Potentially validate that related_entity_id exists and belongs to user?
        // This requires knowing the related_entity_type and querying the correct table.
        // For now, assume valid input.
        const { data: reminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return reminder;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create reminder',
        });
      }
    }),

  updateReminder: protectedProcedure
    .input(updateReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { data: updatedReminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return updatedReminder;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update reminder',
        });
      }
    }),

  deleteReminder: protectedProcedure
    .input(DeleteReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('reminders')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete reminder',
        });
      }
    }),
});
```

### rewardsRouter.ts
**Path:** server/src/routers/rewardsRouter.ts
**Size:** 10610 bytes

```typescript
import { TRPCError } from '@trpc/server';
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { supabaseAdmin } from '../context';

// Corrected relative path
import { claimLootInput, awardBadgeInput } from '../types/trpc-types';

export const rewardsRouter = router({
  // Get all rewards for current user
  getUserRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Select specific fields aligned with our Zod types
        const { data: rewards, error } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('id, user_id, reward_id, earned_at, rewards(id, name, description, emoji, image_url, required_points, type)')
          .eq('user_id', ctx.userId)
          .order('earned_at', { ascending: false });

        if (error) throw error;
        return rewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user rewards',
        });
      }
    }),

  // Get available rewards that can be earned
  getAvailableRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Get all rewards with specific fields
        const { data: allRewards, error: rewardsError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('id, name, description, emoji, image_url, required_points, type, can_earn_multiple')
          .order('required_points', { ascending: true });

        if (rewardsError) throw rewardsError;

        // Get already earned rewards
        const { data: earnedRewards, error: earnedError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('reward_id')
          .eq('user_id', ctx.userId);

        if (earnedError) throw earnedError;

        // Filter out already earned one-time rewards
        const earnedIds = new Set((earnedRewards || []).map(er => er.reward_id));
        const availableRewards = allRewards?.filter(reward => 
          !earnedIds.has(reward.id) || reward.can_earn_multiple);

        return availableRewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch available rewards',
        });
      }
    }),

  // Get user points
  getUserPoints: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: userProfile, error } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (error) throw error;
        return {
          points: userProfile?.points || 0,
          lifetimePoints: userProfile?.lifetime_points || 0,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user points',
        });
      }
    }),

  // Earn a reward if eligible
  earnReward: protectedProcedure
    .input(claimLootInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get the reward details
        const { data: reward, error: rewardError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.rewardId)
          .single();

        if (rewardError || !reward) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Reward not found',
          });
        }

        // Check if user has enough points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        if (userProfile.points < reward.required_points) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Not enough points to earn this reward',
          });
        }

        // If the reward is one-time, check if already earned
        if (!reward.can_earn_multiple) {
          const { data: existingReward, error: existingError } = await ctx.supabaseAdmin
            .from('user_rewards')
            .select('id')
            .eq('user_id', ctx.userId)
            .eq('reward_id', input.rewardId)
            .single();

          if (existingReward) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'You have already earned this one-time reward',
            });
          }
        }

        // Begin transaction
        // 1. Deduct points from user
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: userProfile.points - reward.required_points,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // 2. Add reward to user's earned rewards
        const { data: userReward, error: insertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.rewardId,
            earned_at: new Date().toISOString(),
            points_spent: reward.required_points,
          })
          .select()
          .single();

        if (insertError) {
          // Rollback points if adding reward failed
          await ctx.supabaseAdmin
            .from('profiles')
            .update({
              points: userProfile.points,
            })
            .eq('id', ctx.userId);

          throw insertError;
        }

        return {
          success: true,
          reward: userReward,
          remainingPoints: userProfile.points - reward.required_points,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to earn reward',
        });
      }
    }),

  // Award points to user (e.g., for completing habits, tasks)
  awardPoints: protectedProcedure
    .input(awardBadgeInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get current user points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        // Get badge details
        const { data: badge, error: badgeError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.badgeId)
          .eq('type', 'badge')
          .single();

        if (badgeError || !badge) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Badge not found',
          });
        }

        // Default points to award
        const pointsToAward = 10;
        const currentPoints = userProfile.points || 0;
        const lifetimePoints = userProfile.lifetime_points || 0;
        const newPoints = currentPoints + pointsToAward;
        const newLifetimePoints = lifetimePoints + pointsToAward;

        // Update user points
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: newPoints,
            lifetime_points: newLifetimePoints,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // Record the point transaction
        const { data: pointTransaction, error: transactionError } = await ctx.supabaseAdmin
          .from('point_transactions')
          .insert({
            user_id: ctx.userId,
            points: pointsToAward,
            reason: `Earned badge: ${badge.name}`,
            source_type: 'badge',
            source_id: input.badgeId,
          })
          .select()
          .single();

        if (transactionError) throw transactionError;

        // Add badge to user's earned rewards
        const { data: userBadge, error: badgeInsertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.badgeId,
            reward_type: 'badge',
            earned_at: new Date().toISOString(),
            points_spent: 0, // Badges don't cost points
          })
          .select()
          .single();

        if (badgeInsertError) throw badgeInsertError;

        return {
          success: true,
          previousPoints: currentPoints,
          newPoints,
          pointsAdded: pointsToAward,
          transaction: pointTransaction,
          badge: userBadge,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to award badge',
        });
      }
    }),

  // Get point transaction history
  getPointHistory: protectedProcedure
    .input(z.object({
      limit: z.number().optional().default(20),
      cursor: z.string().optional(), // for pagination
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('point_transactions')
          .select('*')
          .eq('user_id', ctx.userId)
          .order('created_at', { ascending: false })
          .limit(input.limit);
          
        // Handle cursor-based pagination
        if (input.cursor) {
          query = query.lt('created_at', input.cursor);
        }
        
        const { data: transactions, error } = await query;

        if (error) throw error;
        
        // Determine if there are more results
        const lastItem = transactions && transactions.length > 0 
          ? transactions[transactions.length - 1] 
          : null;
          
        return {
          items: transactions || [],
          nextCursor: lastItem?.created_at,
          hasMore: (transactions?.length || 0) === input.limit,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch point history',
        });
      }
    }),
}); ```

### taskRouter.ts
**Path:** server/src/routers/taskRouter.ts
**Size:** 21532 bytes

```typescript
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createTaskInput,
  updateTaskInput,
  updateTaskStatusInput,
  TaskStatusEnum, // Import the enum
  TaskPriorityEnum,
} from '../types/trpc-types';

// Define fields for selection consistency
const TASK_FIELDS =
  'id, user_id, title, notes, status, priority, due_date, goal_id, parent_task_id, recurrence_rule, recurrence_end_date, archived_at, sort_order, created_at, updated_at'; // Corrected: 'priority' instead of 'priority_enum' if that's the actual column name after migration
const GOAL_FIELDS = 'id, user_id, title, description, progress, target_date, archived_at, sort_order, created_at, updated_at';


// --- Helper function to update goal progress ---
async function updateGoalProgress(goalId: string, userId: string, supabase: any) {
  try {
    // 1. Fetch all non-archived tasks for the goal
    const { data: tasks, error: tasksError } = await supabase
      .from('tasks')
      .select('id, status') // Only need id and status
      .eq('goal_id', goalId)
      .eq('user_id', userId)
      .is('archived_at', null); // Exclude archived tasks

    if (tasksError) {
      console.error(`Error fetching tasks for goal ${goalId} during progress update:`, tasksError);
      // Decide how to handle this - maybe just log and skip update?
      return; // Exit if tasks can't be fetched
    }

    const totalTasks = tasks?.length || 0;
    const completedTasks = tasks?.filter((t: { status: string }) => t.status === TaskStatusEnum.enum.done).length || 0;

    // 2. Calculate progress (avoid division by zero)
    const newProgress = totalTasks > 0 ? completedTasks / totalTasks : 0;
    // Ensure progress is between 0 and 1, rounded to avoid floating point issues
    const clampedProgress = Math.round(Math.min(1, Math.max(0, newProgress)) * 100) / 100;

    // 3. Update the goal record
    const { error: updateError } = await supabase
      .from('goals')
      .update({ progress: clampedProgress })
      .eq('id', goalId)
      .eq('user_id', userId); // Ensure user owns the goal

    if (updateError) {
      console.error(`Error updating progress for goal ${goalId}:`, updateError);
      // Log error but don't necessarily throw, task toggle was successful
    } else {
        console.log(`Updated progress for goal ${goalId} to ${clampedProgress}`);
    }

  } catch (err) {
    console.error(`Unexpected error during goal progress update for goal ${goalId}:`, err);
    // Log unexpected errors
  }
}

export const taskRouter = router({
  getTasks: protectedProcedure // Gets non-archived tasks
    .input(z.object({
      goalId: z.string().uuid().optional(),
      // TODO: Add filters for status, priority, dates etc.?
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null); // Filter out archived

        if (input.goalId) {
          query = query.eq('goal_id', input.goalId);
        }

        // TODO: Add complex priority enum sorting? (e.g. high > medium > low)
        const { data: tasks, error } = await query
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('due_date', { ascending: true, nullsFirst: false }) // Order by due date (nulls last)
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tasks',
        });
      }
    }),

  getTaskById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(), // Use uuid validation
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!task) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found',
          });
        }

        // TODO: Parse with Task schema?
        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch task',
        });
      }
    }),

  createTask: protectedProcedure
    .input(createTaskInput) // Use imported input type
    .mutation(async ({ ctx, input }) => {
      try {
        // Verify goal_id if provided
        if (input.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', input.goal_id)
            .eq('user_id', ctx.userId) // Ensure goal belongs to user
            .is('archived_at', null) // Ensure goal is not archived
            .single();

          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived goal ID',
            });
          }
        }

        // Verify parent_task_id if provided
        if (input.parent_task_id) {
          const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
            .from('tasks')
            .select('id')
            .eq('id', input.parent_task_id)
            .eq('user_id', ctx.userId) // Ensure parent belongs to user
            .is('archived_at', null) // Ensure parent is not archived
            .single();

          if (parentError || !parentTask) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived parent task ID',
            });
          }
        }

        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .insert({
            ...input, // Spread validated input (includes new fields like parent_task_id, recurrence etc)
            user_id: ctx.userId,
            // Ensure due_date is used if present in input
            due_date: input.due_date ?? null, // Use correct field name
          })
          .select(TASK_FIELDS)
          .single();

        if (error) {
           // Handle specific errors like FK violations?
           console.error("Create task error:", error);
           throw error;
        }
        // TODO: Parse with Task schema?
        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create task',
        });
      }
    }),

  updateTask: protectedProcedure
    .input(updateTaskInput) // Use imported input type
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input; // Separate id from update payload

        // Check ownership
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id, parent_task_id') // Select parent_task_id for cycle check
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to update it',
          });
        }

        // Verify goal_id if being updated
        if (updateData.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', updateData.goal_id)
            .eq('user_id', ctx.userId)
            .is('archived_at', null)
            .single();

          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived goal ID',
            });
          }
        }
        // Handle setting goal_id to null
        if (updateData.goal_id === null) {
          updateData.goal_id = null;
        }

        // Verify parent_task_id if being updated
        if (updateData.parent_task_id) {
           // Basic cycle check
           if (updateData.parent_task_id === id) {
             throw new TRPCError({
               code: 'BAD_REQUEST',
               message: 'Task cannot be its own parent',
             });
           }
          const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
            .from('tasks')
            .select('id')
            .eq('id', updateData.parent_task_id)
            .eq('user_id', ctx.userId)
            .is('archived_at', null)
            .single();

          if (parentError || !parentTask) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived parent task ID',
            });
          }
          // TODO: Add deeper cycle detection if needed (check if new parent is a descendant)
        }
         // Handle setting parent_task_id to null
        if (updateData.parent_task_id === null) {
          updateData.parent_task_id = null;
        }

        // Ensure correct field name for due date if provided
        const payload: Record<string, any> = { ...updateData };
        if ('due_date' in payload) {
          payload.due_date = payload.due_date ?? null;
        }

        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update(payload) // Pass validated update data
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
             // Handle specific errors like FK violations?
           console.error("Update task error:", error);
           throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update task',
        });
      }
    }),

  deleteTask: protectedProcedure
    .input(z.object({
      id: z.string().uuid(), // Use uuid validation
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to delete it',
          });
        }

        // Delete the task (consider implications for subtasks - maybe archive instead?)
        // For now, direct delete.
        const { error } = await ctx.supabaseAdmin
          .from('tasks')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete task',
        });
      }
    }),

  // ---- Archive/Unarchive ----
  listArchivedTasks: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: tasks, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null) // Filter for archived tasks
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived tasks',
        });
      }
    }),

  archiveTask: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Consider archiving subtasks recursively?
      try {
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Task not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive task',
        });
      }
    }),

  unarchiveTask: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
       // TODO: Consider check if parent is archived?
      try {
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Task not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive task',
        });
      }
    }),

  // ---- Status Update ----
  updateTaskStatus: protectedProcedure
    .input(updateTaskStatusInput) // Uses { id: string().uuid(), status: TaskStatusEnum }
    .mutation(async ({ ctx, input }) => {
       try {
         // Check ownership first
         const { data: existing, error: fetchErr } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

         if (fetchErr || !existing) {
           throw new TRPCError({ code: 'NOT_FOUND', message: 'Task not found or permission denied.' });
         }

         // Perform update
         const { data: updatedTask, error: updateErr } = await ctx.supabaseAdmin
           .from('tasks')
           .update({ status: input.status })
           .eq('id', input.id)
           .select(TASK_FIELDS)
           .single();

         if (updateErr) throw updateErr;
         // TODO: Parse with Task schema?
         return updatedTask;
       } catch (error: any) {
         if (error instanceof TRPCError) throw error;
         throw new TRPCError({
           code: 'INTERNAL_SERVER_ERROR',
           message: error.message || 'Failed to update task status',
         });
       }
    }),

  // ---- Refactored Stubs ----
  listToday: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const todayStart = new Date();
        todayStart.setHours(0, 0, 0, 0);
        const todayEnd = new Date();
        todayEnd.setHours(23, 59, 59, 999);

        const { data: tasks, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .gte('due_date', todayStart.toISOString())
          .lte('due_date', todayEnd.toISOString())
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('due_date', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list tasks for today' });
      }
    }),

  listUpcoming: protectedProcedure
    .query(async ({ ctx }) => {
       try {
         const tomorrowStart = new Date();
         tomorrowStart.setDate(tomorrowStart.getDate() + 1);
         tomorrowStart.setHours(0, 0, 0, 0);

         const { data: tasks, error } = await ctx.supabaseAdmin
           .from('tasks')
           .select(TASK_FIELDS)
           .eq('user_id', ctx.userId)
           .is('archived_at', null)
           .gte('due_date', tomorrowStart.toISOString()) // Due date is tomorrow or later
           .order('due_date', { ascending: true, nullsFirst: false })
           .order('sort_order', { ascending: true, nullsFirst: false })
           .order('created_at', { ascending: false });

         if (error) throw error;
         // TODO: Parse with Task schema?
         return tasks || [];
       } catch (error: any) {
         throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list upcoming tasks' });
       }
    }),

 listOverdue: protectedProcedure
    .query(async ({ ctx }) => {
       try {
         const todayStart = new Date();
         todayStart.setHours(0, 0, 0, 0);

         const { data: tasks, error } = await ctx.supabaseAdmin
           .from('tasks')
           .select(TASK_FIELDS)
           .eq('user_id', ctx.userId)
           .is('archived_at', null)
           .lt('due_date', todayStart.toISOString()) // Due date is before today
           .not('status', 'in', `('${TaskStatusEnum.enum.done}')`) // Exclude completed tasks
           .order('due_date', { ascending: true, nullsFirst: false })
           .order('sort_order', { ascending: true, nullsFirst: false })
           .order('created_at', { ascending: false });

         if (error) throw error;
         // TODO: Parse with Task schema?
         return tasks || [];
       } catch (error: any) {
         throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list overdue tasks' });
       }
    }),

  toggleTask: protectedProcedure // Toggles between 'todo' and 'done'
    .input(z.object({
      taskId: z.string().uuid(),
      completed: z.boolean().optional() // Optional for backward compatibility
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // 1. Fetch the current task, including goal_id
        const { data: currentTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id, status, goal_id, title') // <-- Include goal_id and title
          .eq('id', input.taskId)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !currentTask) {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Task not found or permission denied.' });
        }

        // 2. Determine the new status
        let newStatus;
        if (input.completed !== undefined) {
          // If completed was explicitly provided, use it
          newStatus = input.completed ? TaskStatusEnum.enum.done : TaskStatusEnum.enum.todo;
        } else {
          // Otherwise toggle the current status
          newStatus = currentTask.status === TaskStatusEnum.enum.done
            ? TaskStatusEnum.enum.todo
            : TaskStatusEnum.enum.done;
        }

        // 3. Update the task status
        const { data: updatedTask, error: updateError } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ status: newStatus })
          .eq('id', input.taskId)
          .select(TASK_FIELDS) // Return the full updated task
          .single();

        if (updateError) throw updateError;

        // 4. *** NEW: Update goal progress if applicable ***
        if (currentTask.goal_id) {
           // Call the helper function asynchronously - no need to await here
           // unless the UI needs the updated goal immediately (unlikely for a toggle)
          updateGoalProgress(currentTask.goal_id, ctx.userId, ctx.supabaseAdmin);
        }

        // 5. Return the updated task
        return updatedTask;

      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        console.error("Error in toggleTask:", error); // Log unexpected errors
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to toggle task status',
        });
      }
    }),

  // --- Obsolete Stubs (keep or remove based on client usage) ---
  /*
  getTasksByGoal: protectedProcedure ... // Covered by getTasks with goalId filter
  getTodaysTasks: protectedProcedure ... // Replaced by listToday
  getUpcomingTasks: protectedProcedure ... // Replaced by listUpcoming
  updateTaskStatus_OLD: protectedProcedure ... // Replaced by updateTaskStatus and toggleTask
  */

});```

### trackedStateRouter.ts
**Path:** server/src/routers/trackedStateRouter.ts
**Size:** 11442 bytes

```typescript
// File: server/src/routers/trackedStateRouter.ts

import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  // Ensure all necessary input types from trpc-types are imported
  createTrackedStateDefInput,
  updateTrackedStateDefInput,
  GetTrackedStateDefByIdInput,
  DeleteTrackedStateDefInput,
  CreateStateEntryInput,      // <--- Import for createEntry
  updateStateEntryInput,      // <--- Import for updateEntry
  GetStateEntriesInput,       // <--- Import for getEntries
  DeleteStateEntryInput       // <--- Import for deleteEntry
} from '../types/trpc-types';

// Use correct field names from database.types.ts & trpc-types.ts
const TRACKED_STATE_DEF_FIELDS = 'id, user_id, name, description, scale, custom_labels, unit, icon, target_min_value, target_max_value, created_at, updated_at, active, priority';
const STATE_ENTRY_FIELDS = 'id, user_id, definition_id, value_numeric, value_text, entry_timestamp, notes';

export const trackedStateRouter = router({
  getDefinitions: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('active', true)
          .order('priority', { ascending: true, nullsFirst: false }) // Corrected: nullsFirst
          .order('created_at', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tracked state definitions',
        });
      }
    }),

  getDefinitionById: protectedProcedure
    .input(GetTrackedStateDefByIdInput) // Use correct Zod schema
    .query(async ({ ctx, input }) => {
       try {
        const { data: definition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS)
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Tracked state definition not found.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return definition;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tracked state definition',
        });
      }
    }),

  createDefinition: protectedProcedure
    .input(createTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { data: definition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .insert({
            ...input, // input is now correctly typed
            user_id: ctx.userId,
          })
          .select(TRACKED_STATE_DEF_FIELDS)
          .single();

        if (error) throw error;
        return definition;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create tracked state definition',
        });
      }
    }),

  updateDefinition: protectedProcedure
    .input(updateTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { id, ...updateData } = input; // input is now correctly typed

        const { error: fetchError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Definition not found or access denied.',
          });
        }

        const { data: updatedDefinition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(TRACKED_STATE_DEF_FIELDS)
          .single();

        if (error) throw error;
        return updatedDefinition;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update tracked state definition',
        });
      }
    }),

  deleteDefinition: protectedProcedure
    .input(DeleteTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Definition not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .delete()
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id }; // input.id is now correctly typed
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete tracked state definition',
        });
      }
    }),

  // --- State Entry Procedures ---

  getEntries: protectedProcedure
    .input(GetStateEntriesInput) // <<<--- ADDED .input() BINDING
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('state_entries')
          .select(STATE_ENTRY_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('definition_id', input.tracked_state_def_id); // input is now typed

        if (input.startDate) { // input is now typed
          query = query.gte('entry_timestamp', input.startDate);
        }
        if (input.endDate) { // input is now typed
          query = query.lte('entry_timestamp', input.endDate);
        }

        query = query.order('entry_timestamp', { ascending: false });

        if (input.limit) { // input is now typed
          query = query.limit(input.limit);
        }

        const { data: entries, error } = await query;

        if (error) throw error;
        return entries ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch state entries',
        });
      }
    }),

  createEntry: protectedProcedure
    .input(CreateStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
      try {
        // Check definition ownership (already implemented correctly)
        const { error: defError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', input.tracked_state_def_id) // input is now typed
          .eq('user_id', ctx.userId)
          .single();

        if (defError) {
          throw new TRPCError({
            code: defError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Tracked state definition not found or invalid.',
          });
        }

        // Insert typed data
        const { data: entry, error } = await ctx.supabaseAdmin
          .from('state_entries')
          .insert({
            user_id: ctx.userId,
            definition_id: input.tracked_state_def_id, // input is now typed
            value_numeric: input.value_numeric,     // input is now typed
            value_text: input.value_text,         // input is now typed
            entry_timestamp: input.entry_timestamp || new Date().toISOString(), // input is now typed
            notes: input.notes,                 // input is now typed
          })
          .select(STATE_ENTRY_FIELDS)
          .single();

        if (error) throw error;
        return entry;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create state entry',
        });
      }
    }),

  updateEntry: protectedProcedure
    .input(updateStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input; // input is now typed

        // Check ownership (already implemented correctly)
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('state_entries')
          .select('id')
          .eq('id', id) // Use id from destructured input
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Entry not found or access denied.',
          });
        }

        // updateData is now correctly typed from the input schema
        const { data: updatedEntry, error } = await ctx.supabaseAdmin
          .from('state_entries')
          .update(updateData)
          .eq('id', id) // Use id from destructured input
          .eq('user_id', ctx.userId)
          .select(STATE_ENTRY_FIELDS)
          .single();

        if (error) throw error;
        return updatedEntry;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update state entry',
        });
      }
    }),

  deleteEntry: protectedProcedure
    .input(DeleteStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
       try {
        // Check ownership (already implemented correctly)
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('state_entries')
          .select('id')
          .eq('id', input.id) // input is now typed
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Entry not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('state_entries')
          .delete()
          .eq('id', input.id) // input is now typed
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id }; // input is now typed
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete state entry',
        });
      }
    }),
});```

### userRouter.ts
**Path:** server/src/routers/userRouter.ts
**Size:** 5710 bytes

```typescript
import { z } from 'zod';
import { router, protectedProcedure, publicProcedure } from '../router';
import { TRPCError } from '@trpc/server';

export const userRouter = router({
  getProfile: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('id, username, avatar_url, full_name, bio, time_zone, onboarding_completed, created_at, updated_at')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  updateProfile: protectedProcedure
    .input(z.object({
      full_name: z.string().optional(),
      avatar_url: z.string().optional(),
      theme: z.string().optional(),
      time_zone: z.string().optional(),
      display_name: z.string().optional(),
      bio: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update(input)
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getUserSettings: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('id, user_id, notification_preferences, ui_preferences')
        .eq('user_id', ctx.userId)
        .single();
        
      if (error) {
        // If settings don't exist, create default settings
        if (error.code === 'PGRST116') {
          const { data: newSettings, error: createError } = await ctx.supabaseAdmin
            .from('user_settings')
            .insert({
              user_id: ctx.userId,
              notification_preferences: {
                email: true,
                push: true,
                task_reminders: true,
                goal_updates: true,
                habit_reminders: true
              },
              ui_preferences: {
                theme: 'system',
                compact_view: false,
                show_completed_tasks: true
              }
            })
            .select()
            .single();
            
          if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
          return newSettings;
        }
        
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      }
      
      return data;
    }),
    
  updateUserSettings: protectedProcedure
    .input(z.object({
      notification_preferences: z.object({
        email: z.boolean().optional(),
        push: z.boolean().optional(),
        task_reminders: z.boolean().optional(),
        goal_updates: z.boolean().optional(),
        habit_reminders: z.boolean().optional()
      }).optional(),
      ui_preferences: z.object({
        theme: z.string().optional(),
        compact_view: z.boolean().optional(),
        show_completed_tasks: z.boolean().optional()
      }).optional()
    }))
    .mutation(async ({ ctx, input }) => {
      // First check if settings exist
      const { data: existingSettings, error: fetchError } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('id')
        .eq('user_id', ctx.userId)
        .single();
        
      if (fetchError && fetchError.code === 'PGRST116') {
        // Create settings if they don't exist
        const defaultSettings = {
          user_id: ctx.userId,
          notification_preferences: {
            email: true,
            push: true,
            task_reminders: true,
            goal_updates: true,
            habit_reminders: true,
            ...input.notification_preferences
          },
          ui_preferences: {
            theme: 'system',
            compact_view: false,
            show_completed_tasks: true,
            ...input.ui_preferences
          }
        };
        
        const { data, error } = await ctx.supabaseAdmin
          .from('user_settings')
          .insert(defaultSettings)
          .select()
          .single();
          
        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        return data;
      } else if (fetchError) {
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: fetchError.message });
      }
      
      // Update existing settings
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .update(input)
        .eq('user_id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getOnboardingStatus: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('id, onboarding_completed')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { onboardingCompleted: data?.onboarding_completed || false };
    }),
    
  completeOnboarding: protectedProcedure
    .mutation(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update({ onboarding_completed: true })
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { success: true };
    }),
}); ```

### valueRouter.ts
**Path:** server/src/routers/valueRouter.ts
**Size:** 5162 bytes

```typescript
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createValueInput, updateValueInput } from '../types/trpc-types';

export const valueRouter = router({
  getValues: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: values, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return values;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch values',
        });
      }
    }),

  getValueById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!value) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found',
          });
        }

        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch value',
        });
      }
    }),

  createValue: protectedProcedure
    .input(createValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create value',
        });
      }
    }),

  updateValue: protectedProcedure
    .input(updateValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // First check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to update it',
          });
        }

        // Update the value
        const { data: updatedValue, error } = await ctx.supabaseAdmin
          .from('values')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return updatedValue;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update value',
        });
      }
    }),

  deleteValue: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to delete it',
          });
        }

        // Delete the value
        const { error } = await ctx.supabaseAdmin
          .from('values')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete value',
        });
      }
    }),
});```

### index.ts
**Path:** server/src/types/index.ts
**Size:** 1538 bytes

```typescript
export type ValueId = string;
export type GoalId = string;
export type TaskId = string;
export type HabitId = string;
export type BadgeId = string;

export interface Value {
  id: ValueId;
  name: string;
  description?: string;
  color: string; // tailwind color token (e.g. 'indigo-500')
  domainId?: string; // optional grouping
}

export interface Goal {
  id: GoalId;
  title: string;
  description?: string;
  valueIds: ValueId[];
  progress: number; // 0‒1
  keyResults: KeyResult[];
  targetDate?: string; // ISO
}

export interface KeyResult {
  id: string;
  title: string;
  progress: number; // 0‒1
}

export interface Task {
  id: TaskId;
  title: string;
  notes?: string;
  status: 'todo' | 'doing' | 'done' | 'blocked';
  due?: string; // ISO date
  priority?: 1 | 2 | 3;
  goalId?: GoalId;
  valueIds?: ValueId[];
}

export interface Habit {
  id: HabitId;
  title: string;
  cue?: string;
  routine?: string;
  reward?: string;
  valueIds: ValueId[];
  streak: number; // current consecutive days
  bestStreak: number;
  history: Record<string, boolean>; // ISO day → done?
}

export interface Principle {
  id: string;
  title: string;
  body: string;
  valueIds: ValueId[];
}

export interface TrackedStateDef {
  id: string;
  name: string;
  scale: '1-5' | 'low-high' | 'custom';
  customLabels?: string[];
  valueIds: ValueId[];
}

export interface Badge {
  id: BadgeId;
  title: string;
  icon: string; // Hero‑icons name or emoji
  earnedAt?: string; // ISO
  progress?: number; // 0‒1 for not‑yet
} ```

### trpc-types.ts
**Path:** server/src/types/trpc-types.ts
**Size:** 14576 bytes

```typescript
// server/src/types/trpc-types.ts
/*
  Aether – Shared tRPC Types
  ------------------------------------------------------------------
  Every Zod schema that powers a router lives here so both the server
  (routers) and the client (React Query hooks) reference a **single**
  source‑of‑truth.  Import these types everywhere else – **never** hand‑roll
  shapes again.
*/

import { z } from 'zod';
import { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from '../router';

/* ------------------------------------------------------------------
 * Enums (keep in sync with DB enums)
 * ----------------------------------------------------------------*/
export const TaskStatusEnum = z.enum(['todo', 'doing', 'done', 'blocked', 'pending']);
export const TaskPriorityEnum = z.enum(['low', 'medium', 'high']);
export const RewardTypeEnum = z.enum(['badge', 'achievement', 'item', 'discount']);
export const HabitTypeEnum = z.enum(['boolean', 'quantity']);
export const HabitFrequencyPeriodEnum = z.enum(['day', 'week', 'month']);

/* ------------------------------------------------------------------
 * Domain Models (DB row shapes) – keep in sync with Supabase tables
 * ----------------------------------------------------------------*/
export const UserProfile = z.object({
  id: z.string().uuid(),
  username: z.string().nullish(),
  avatar_url: z.string().url().nullish(),
  full_name: z.string().nullish(),
  bio: z.string().nullish(),
  points: z.number().int().nonnegative().default(0),
  time_zone: z.string().nullish(),
  onboarding_completed: z.boolean().default(false),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type UserProfile = z.infer<typeof UserProfile>;

export const NotificationPrefs = z.object({
  email: z.boolean().default(true),
  push: z.boolean().default(true),
  task_reminders: z.boolean().default(true),
  goal_updates: z.boolean().default(true),
  habit_reminders: z.boolean().default(true),
});

export const UiPrefs = z.object({
  theme: z.enum(['system', 'light', 'dark']).default('system'),
  compact_view: z.boolean().default(false),
  show_completed_tasks: z.boolean().default(true),
  first_day_of_week: z.number().int().min(0).max(6).default(0),
});

export const UserSettings = z.object({
  id: z.string().uuid().optional(),
  user_id: z.string().uuid(),
  notification_preferences: NotificationPrefs,
  ui_preferences: UiPrefs,
});
export type UserSettings = z.infer<typeof UserSettings>;

export const Value = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), 
  description: z.string().nullish(),
  color: z.string().nullish(),
  icon: z.string().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type Value = z.infer<typeof Value>;

export const Principle = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), // <<< Changed from 'name' to 'title'
  body: z.string(), // <<< Renamed from description for clarity, matching migration
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type Principle = z.infer<typeof Principle>;

export const Goal = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  description: z.string().nullish(),
  progress: z.number().nullish(),
  target_date: z.string().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime().nullish(),
  updated_at: z.string().datetime().nullish(),
});
export type Goal = z.infer<typeof Goal>;

export const Task = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  notes: z.string().nullish(),
  status: TaskStatusEnum.default('todo'),
  priority_enum: TaskPriorityEnum.nullish(), // <<< Renamed from priority
  due_date: z.string().datetime().nullish(),
  goal_id: z.string().uuid().nullish(),
  parent_task_id: z.string().uuid().nullish(),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Task = z.infer<typeof Task>;

export const Habit = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  cue: z.string().nullish(),
  routine: z.string().nullish(),
  reward: z.string().nullish(),
  streak: z.number().nonnegative().default(0),
  best_streak: z.number().nonnegative().default(0),
  habit_type: HabitTypeEnum.default('boolean'),
  goal_quantity: z.number().int().nullish(),
  goal_unit: z.string().nullish(),
  frequency_period: HabitFrequencyPeriodEnum.default('day'),
  goal_frequency: z.number().int().positive().default(1),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(), // <<< Added sort_order
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Habit = z.infer<typeof Habit>;

export const HabitEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  habit_id: z.string().uuid(),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be in YYYY-MM-DD format"),
  completed: z.boolean().default(false),
  quantity_value: z.number().int().nullish(),
  notes: z.string().nullish(),
  created_at: z.string().datetime(),
});
export type HabitEntry = z.infer<typeof HabitEntry>;

export const TrackedStateDef = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  name: z.string(),
  // category: z.string(), // Category seems removed/replaced in DB schema by scale/custom_labels
  scale: z.enum(['1-5', 'low-high', 'custom']), // <<< Added scale
  custom_labels: z.array(z.string()).nullish(), // <<< Added custom_labels
  unit: z.string().nullish(), // Keep unit if still used alongside scale
  icon: z.string().nullish(), // Keep icon if still used
  target_min_value: z.number().nullish(), // <<< Added
  target_max_value: z.number().nullish(), // <<< Added
  active: z.boolean().default(true), // <<< Added active
  priority: z.number().int().default(1), // <<< Added priority
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type TrackedStateDef = z.infer<typeof TrackedStateDef>;

export const StateEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  definition_id: z.string().uuid(), // <<< Renamed from tracked_state_def_id for consistency? check DB
  value_numeric: z.number().optional().nullable(),
  value_text: z.string().optional().nullable(),
  entry_timestamp: z.string().datetime({ message: "Invalid datetime string. Must be UTC ISO 8601" }).optional(),
  notes: z.string().optional().nullable(), // <<< Added notes
});
export type StateEntry = z.infer<typeof StateEntry>;

export const Reward = z.object({
  id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullish(),
  type: RewardTypeEnum,
  required_points: z.number().int().nonnegative().default(0),
  can_earn_multiple: z.boolean().default(false),
  image_url: z.string().url().nullish(),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Reward = z.infer<typeof Reward>;

export const UserReward = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  reward_id: z.string().uuid(),
  reward_type: z.string().nullish(), // From DB schema
  earned_at: z.string().datetime(),
  points_spent: z.number().int().nonnegative().default(0),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type UserReward = z.infer<typeof UserReward>;

export const PointTransaction = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  points: z.number().int(),
  reason: z.string(),
  source_type: z.string(),
  source_id: z.string().uuid().nullish(),
  created_at: z.string().datetime(),
});
export type PointTransaction = z.infer<typeof PointTransaction>;

export const BadgeDefinition = z.object({
  id: z.string(), // From DB: text primary key
  title: z.string(),
  description: z.string().nullish(),
  icon: z.string(),
});
export type BadgeDefinition = z.infer<typeof BadgeDefinition>;

export const UserBadge = z.object({
  // Note: user_badges might be merged into user_rewards with type='badge'
  user_id: z.string().uuid(),
  badge_id: z.string(), // Matches badge_definitions.id (text)
  earned_at: z.string().datetime(),
  progress: z.number().nullish(), // From DB schema
});
export type UserBadge = z.infer<typeof UserBadge>;

export const Reminder = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
  reminder_time: z.string().datetime(),
  is_active: z.boolean().default(true),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Reminder = z.infer<typeof Reminder>;

export const GoalProgressNote = z.object({
  id: z.string().uuid(),
  goal_id: z.string().uuid(),
  user_id: z.string().uuid(),
  note: z.string(),
  created_at: z.string().datetime(),
});
export type GoalProgressNote = z.infer<typeof GoalProgressNote>;

/* ------------------------------------------------------------------
 * Router‑level Schemas – inputs & outputs for every procedure
 * ----------------------------------------------------------------*/
export const greetingInput = z.object({ name: z.string().optional() });
export const greetingOutput = z.object({ greeting: z.string() });

// User
export const updateProfileInput = UserProfile.partial().omit({ id: true, created_at: true, updated_at: true });
export const updateSettingsInput = z.object({
  notification_preferences: NotificationPrefs.partial().optional(),
  ui_preferences: UiPrefs.partial().optional(),
});

// Values
export const createValueInput = Value.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateValueInput = createValueInput.partial().extend({ id: z.string().uuid() });

// Principles
// Uses 'title' and 'body' from the updated Principle schema
export const createPrincipleInput = Principle.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updatePrincipleInput = createPrincipleInput.partial().extend({ id: z.string().uuid() });

// Goals
export const createGoalInput = Goal.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateGoalInput = createGoalInput.partial().extend({ id: z.string().uuid() });

// Tasks
export const createTaskInput = Task.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateTaskInput = createTaskInput.partial().extend({ id: z.string().uuid() });
export const updateTaskStatusInput = z.object({ id: z.string().uuid(), status: TaskStatusEnum });

// Habits
export const createHabitInput = Habit.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateHabitInput = createHabitInput.partial().extend({ id: z.string().uuid() });

// Habit Entries
export const createHabitEntryInput = HabitEntry.omit({ id: true, user_id: true, created_at: true });
export const updateHabitEntryInput = createHabitEntryInput.partial().extend({ id: z.string().uuid() });

// Tracked State Definitions
export const createTrackedStateDefInput = TrackedStateDef.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateTrackedStateDefInput = createTrackedStateDefInput.partial().extend({ id: z.string().uuid() });
export const GetTrackedStateDefByIdInput = z.object({ id: z.string().uuid() });
export const DeleteTrackedStateDefInput = z.object({ id: z.string().uuid() });

// State Entries
export const CreateStateEntryInput = StateEntry.omit({ id: true, user_id: true })
.extend({
  tracked_state_def_id: z.string().uuid(), // Ensure this is required
  // Values are optional in base schema
});
export const updateStateEntryInput = CreateStateEntryInput.partial().extend({ id: z.string().uuid() });
export const GetStateEntriesInput = z.object({
  tracked_state_def_id: z.string().uuid(), // Renamed from definition_id to match DB? Check usage.
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  limit: z.number().int().positive().optional(),
});
export const DeleteStateEntryInput = z.object({ id: z.string().uuid() });

// Rewards (Assuming rewards definitions are managed elsewhere)
// No create/update for Reward definitions needed via API?
export const claimLootInput = z.object({
  rewardId: z.string().uuid(), // Use rewardId to match router
});

// Badges
export const awardBadgeInput = z.object({
  badgeId: z.string(), // Matches text ID in badge_definitions
  description: z.string().optional(), // Example custom field if needed
});

// Reminders
export const createReminderInput = Reminder.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateReminderInput = createReminderInput.partial().extend({ id: z.string().uuid() });
export const GetRemindersForEntityInput = z.object({
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
});
export const DeleteReminderInput = z.object({ id: z.string().uuid() });

// Goal Progress Notes
export const createGoalProgressNoteInput = GoalProgressNote.omit({ id: true, user_id: true, created_at: true });
export const updateGoalProgressNoteInput = createGoalProgressNoteInput.partial().extend({ id: z.string().uuid() });
export const GetGoalProgressNotesInput = z.object({ goal_id: z.string().uuid() });
export const DeleteGoalProgressNoteInput = z.object({ id: z.string().uuid() });

/* ------------------------------------------------------------------
 * Aggregate Router Types – automatically inferred
 * ----------------------------------------------------------------*/
export type RouterInputs = inferRouterInputs<AppRouter>;
export type RouterOutputs = inferRouterOutputs<AppRouter>;

/*
  Usage (client‑side):

  const utils = trpc.useUtils();
  type TasksOutput = RouterOutputs['task']['getTasks'];
  type CreateTaskInput = RouterInputs['task']['createTask'];
*/```

### tsconfig.json
**Path:** server/tsconfig.json
**Size:** 484 bytes

```json
{
  "compilerOptions": {
    "target": "es2019",
    "module": "commonjs",
    "lib": ["es2019", "esnext.asynciterable"],
    "outDir": "./dist",
    "rootDir": "../",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "sourceMap": true,
    "declaration": true
  },
  "include": ["src/**/*", "types/**/*"],
  "exclude": ["node_modules", "dist"]
}```


# stores

### uiStore.ts
**Path:** stores/uiStore.ts
**Size:** 338 bytes

```typescript
import { create } from 'zustand';

interface UiState {
  isDarkMode: boolean;
  toggleTheme: () => void;
}

// Simple Zustand store for UI state (e.g., theme)
export const useUiStore = create<UiState>((set) => ({
  isDarkMode: false, // Default to light mode
  toggleTheme: () => set((state) => ({ isDarkMode: !state.isDarkMode })),
})); ```


# (root files)

### styling_report.txt
**Path:** styling_report.txt
**Size:** 7031 bytes

```
# AetherIphone Tamagui Styling Report

This document outlines the styling approach used in the AetherIphone application, leveraging the Tamagui UI library.

## 1. Core Theme Setup (`Providers.tsx`)

The application's root is wrapped by `TamaguiProvider` within `Providers.tsx`. This provider injects the theme configuration and dynamically sets the theme based on the user's system preferences (light/dark mode).

```typescript
// Simplified snippet from providers/Providers.tsx
import { TamaguiProvider } from 'tamagui';
import config from '../tamagui.config';
import { useColorScheme } from 'react-native';

export function Providers({ children }: { children: React.ReactNode }) {
  const colorScheme = useColorScheme() ?? 'light';

  return (
    <TamaguiProvider config={config} defaultTheme={colorScheme}>
      {/* ... other providers ... */}
      {children}
    </TamaguiProvider>
  );
}
```

## 2. Theme Configuration (`tamagui.config.ts`)

This file is the central definition for the application's design system.

### 2.1. Tokens

Tokens define the fundamental building blocks (colors, spacing, fonts, etc.).

```typescript
// Snippet from tamagui.config.ts (Tokens)
const tokens = createTokens({
  size: { 0: 0, 1: 4, ..., 16: 64, true: 16 },
  space: { 0: 0, 1: 4, ..., 16: 64, true: 16, '-1': -4, ... },
  radius: { 0: 0, 1: 3, ..., 10: 32, true: 10 },
  zIndex: { 0: 0, 1: 100, ..., 5: 500 },
  color: {
    // Light Theme Brand Colors
    brandBlue: '#007AFF',
    brandGreen: '#34C759',
    // ... other brand colors ...

    // Dark Theme Brand Colors
    brandBlue_dark: '#0A84FF',
    brandGreen_dark: '#30D158',
    // ... other dark brand colors ...

    // Radix Grays (Light & Dark)
    gray1: '#fcfcfc', ..., gray12: '#171717',
    gray1_dark: '#191919', ..., gray12_dark: '#ededed',

    white: '#FFFFFF',
    black: '#000000',
  },
});
```

### 2.2. Themes

Themes map semantic roles (like background, text color, primary action color) to specific tokens for both light and dark modes.

```typescript
// Snippet from tamagui.config.ts (Themes)
const lightTheme = {
  background: tokens.color.gray2,
  backgroundHover: tokens.color.gray3,
  backgroundPress: tokens.color.gray4,
  backgroundStrong: tokens.color.white, // e.g., Card background
  color: tokens.color.gray12,
  colorSecondary: tokens.color.gray11,
  borderColor: tokens.color.gray6,
  borderColorFocus: tokens.color.brandBlue,
  primary: tokens.color.brandBlue,
  success: tokens.color.brandGreen,
  error: tokens.color.brandRed,
  inputBackground: tokens.color.white,
  cardBackground: tokens.color.white,
  shadowColor: tokens.color.gray8,
  // ... other light theme definitions
};

const darkTheme: typeof lightTheme = {
  background: tokens.color.gray1_dark,
  backgroundHover: tokens.color.gray3_dark,
  // ... maps roles to dark tokens ...
  color: tokens.color.gray12_dark,
  borderColor: tokens.color.gray5_dark,
  borderColorFocus: tokens.color.brandBlue_dark,
  primary: tokens.color.brandBlue_dark,
  cardBackground: tokens.color.gray2_dark,
  shadowColor: tokens.color.black, // Example: Darker shadow
  // ... other dark theme definitions
};

// Config creation
const config = createTamagui({
  // ... fonts, animations ...
  tokens,
  themes: {
    light: lightTheme,
    dark: darkTheme,
  },
});
```

## 3. Theme Usage Examples

Components leverage the theme configuration for consistent styling.

### 3.1. Screen Example (`app/(tabs)/planner/index.tsx`)

Screens use layout components and apply theme tokens for spacing, sizing, and colors.

```typescript
// Snippet from app/(tabs)/planner/index.tsx
import { YStack, XStack, Text, Tabs, Button, ScrollView } from 'tamagui';

// ...
<YStack flex={1} padding="$4"> // Use space token for padding
  <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
    <Text fontSize={24} fontWeight="bold">Planner</Text>
    <Button
      size="$3" // Use size token
      // ...
    />
  </XStack>

  <Tabs.List
    backgroundColor="$backgroundStrong" // Use semantic color token
    borderRadius="$4" // Use radius token
    marginBottom="$4"
  >
    {TABS.map((tab) => (
      <Tabs.Tab
        key={tab.key}
        flex={1}
        value={tab.key}
        padding="$3"
        borderRadius="$2"
        backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'} // Conditional semantic color
      >
        {/* ... */}
      </Tabs.Tab>
    ))}
  </Tabs.List>

  {/* Example Goal Item using Button */}
  <Button
    key={goal.id}
    height="$12" // Use size token
    // ...
  >
    <YStack>
      <Text fontWeight="bold">{goal.title}</Text>
      <Text fontSize="$2" color="$gray10"> {/* Use direct color token */} 
        {/* ... */}
      </Text>
    </YStack>
  </Button>

</YStack>
```

### 3.2. Primitive Component Example (`components/ui/primitives/AetherCard.tsx`)

Custom components are built using Tamagui's `styled` API and theme tokens, often with variants for different appearances.

```typescript
// Snippet from components/ui/primitives/AetherCard.tsx
import { Card, CardProps, styled } from 'tamagui';

const StyledCard = styled(Card, {
  name: 'AetherCard',
  backgroundColor: '$cardBackground', // Use semantic color
  borderRadius: '$4', // Use radius token
  padding: '$4', // Use space token
  elevate: true,

  variants: {
    variant: {
      default: {
        shadowColor: '$shadowColor',
        // ... default styles using tokens
      },
      elevated: {
        shadowColor: '$shadowColor',
        // ... elevated styles using tokens
      },
      outlined: {
        backgroundColor: 'transparent',
        borderColor: '$borderColor', // Use semantic color
        // ... outlined styles using tokens
      },
    },
    isInteractive: {
      true: {
        pressStyle: {
          backgroundColor: '$cardBackgroundPress', // Use semantic color for interaction
          opacity: 0.9,
        },
        hoverStyle: {
          backgroundColor: '$cardBackgroundHover', // Use semantic color for interaction
        },
      },
    },
  } as const,

  defaultVariants: {
    variant: 'default',
    isInteractive: false,
  },
});

export function AetherCard({ children, variant, isInteractive, ...props }: AetherCardProps) {
  return (
    <StyledCard variant={variant} isInteractive={isInteractive} {...props}>
      {children}
    </StyledCard>
  );
}
```

## 4. Summary & Best Practices

- **Consistency:** Using theme tokens (`$size`, `$color`, `$space`) ensures visual consistency.
- **Semantic Colors:** Leveraging semantic theme roles (`$background`, `$primary`, `$cardBackground`) allows components to adapt automatically to light/dark modes.
- **Custom Components:** Building reusable, themed components (like `AetherCard`) encapsulates styling logic.
- **Avoid Hardcoding:** Minimize hardcoded style values (like hex codes or pixel values) directly in components; prefer theme tokens.
- **Platform Adaptation:** The configuration handles font differences between web and native automatically.
```


# supabase

### .gitignore
**Path:** supabase/.gitignore
**Size:** 72 bytes

```
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local
```

### config.toml
**Path:** supabase/config.toml
**Size:** 11209 bytes

```toml
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "AetherIphone"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 1

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"
```

### 20250424033333_initial_schema.sql
**Path:** supabase/migrations/20250424033333_initial_schema.sql
**Size:** 17345 bytes

```sql
-- Enable UUID generation
create extension if not exists "uuid-ossp" with schema extensions;

-- === Profiles Table (From SUPABASE_INTEGRATION.md) ===
create table public.profiles (
  id uuid not null references auth.users on delete cascade primary key, -- Link directly to auth.users
  username text unique,
  avatar_url text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.profiles is 'Profile data for each user.';

-- Enable RLS
alter table public.profiles enable row level security;

-- Policies for profiles
create policy "Profiles are viewable by everyone." on public.profiles
  for select using (true);

create policy "Users can insert their own profile." on public.profiles
  for insert with check (auth.uid() = id);

create policy "Users can update their own profile." on public.profiles
  for update using (auth.uid() = id) with check (auth.uid() = id);

-- Function & Trigger to create profile on new user signup (From SUPABASE_INTEGRATION.md)
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, username)
  values (new.id, new.raw_user_meta_data ->> 'username');
  return new;
end;
$$ language plpgsql security definer set search_path = public; -- Added search_path

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- === Values Table ===
create table public.values (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  name text not null,
  description text,
  color text, -- Stores color token like 'indigo-500'
  domain_id text, -- Optional grouping identifier
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.values is 'User-defined core values.';
alter table public.values enable row level security;

create policy "Users can view their own values" on public.values for select using (auth.uid() = user_id);
create policy "Users can insert their own values" on public.values for insert with check (auth.uid() = user_id);
create policy "Users can update their own values" on public.values for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own values" on public.values for delete using (auth.uid() = user_id);


-- === Goals Table ===
create table public.goals (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  title text not null,
  description text,
  progress numeric default 0 check (progress >= 0 and progress <= 1),
  target_date date, -- Changed from timestamp to date to match UI potentially
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.goals is 'User goals and objectives.';
alter table public.goals enable row level security;

create policy "Users can view their own goals" on public.goals for select using (auth.uid() = user_id);
create policy "Users can insert their own goals" on public.goals for insert with check (auth.uid() = user_id);
create policy "Users can update their own goals" on public.goals for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own goals" on public.goals for delete using (auth.uid() = user_id);


-- === Key Results Table ===
create table public.key_results (
  id uuid primary key default uuid_generate_v4(),
  goal_id uuid not null references public.goals(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade, -- Denormalized for RLS
  title text not null,
  progress numeric default 0 check (progress >= 0 and progress <= 1),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.key_results is 'Measurable results for achieving goals.';
alter table public.key_results enable row level security;

create policy "Users can view their own key results" on public.key_results for select using (auth.uid() = user_id);
create policy "Users can insert their own key results" on public.key_results for insert with check (auth.uid() = user_id);
create policy "Users can update their own key results" on public.key_results for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own key results" on public.key_results for delete using (auth.uid() = user_id);


-- === Tasks Table ===
-- Define enum for status first
create type public.task_status as enum ('todo', 'doing', 'done', 'blocked');

create table public.tasks (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  title text not null,
  notes text,
  status public.task_status default 'todo' not null,
  due date,
  priority int check (priority in (1, 2, 3)), -- Allow NULL or 1, 2, 3
  goal_id uuid references public.goals(id) on delete set null, -- Keep task if goal deleted
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.tasks is 'Individual tasks or to-do items.';
alter table public.tasks enable row level security;

create policy "Users can view their own tasks" on public.tasks for select using (auth.uid() = user_id);
create policy "Users can insert their own tasks" on public.tasks for insert with check (auth.uid() = user_id);
create policy "Users can update their own tasks" on public.tasks for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own tasks" on public.tasks for delete using (auth.uid() = user_id);


-- === Habits Table ===
create table public.habits (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  title text not null,
  cue text,
  routine text,
  reward text,
  -- value_ids text[], -- Will use join table instead
  streak int default 0 not null,
  best_streak int default 0 not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.habits is 'User habits to track.';
alter table public.habits enable row level security;

create policy "Users can view their own habits" on public.habits for select using (auth.uid() = user_id);
create policy "Users can insert their own habits" on public.habits for insert with check (auth.uid() = user_id);
create policy "Users can update their own habits" on public.habits for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own habits" on public.habits for delete using (auth.uid() = user_id);


-- === Habit Entries Table ===
create table public.habit_entries (
  id uuid primary key default uuid_generate_v4(),
  habit_id uuid not null references public.habits(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade, -- Denormalized for RLS
  date date not null,
  completed boolean default false not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(habit_id, date) -- Ensure only one entry per habit per day
);

comment on table public.habit_entries is 'Daily check-in records for habits.';
alter table public.habit_entries enable row level security;

create policy "Users can view their own habit entries" on public.habit_entries for select using (auth.uid() = user_id);
create policy "Users can insert their own habit entries" on public.habit_entries for insert with check (auth.uid() = user_id);
create policy "Users can update their own habit entries" on public.habit_entries for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own habit entries" on public.habit_entries for delete using (auth.uid() = user_id);


-- === Principles Table ===
create table public.principles (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  title text not null,
  body text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.principles is 'User-defined guiding principles.';
alter table public.principles enable row level security;

create policy "Users can view their own principles" on public.principles for select using (auth.uid() = user_id);
create policy "Users can insert their own principles" on public.principles for insert with check (auth.uid() = user_id);
create policy "Users can update their own principles" on public.principles for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own principles" on public.principles for delete using (auth.uid() = user_id);


-- === Tracked State Definitions Table ===
create type public.tracked_state_scale as enum ('1-5', 'low-high', 'custom');

create table public.tracked_state_defs (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  name text not null,
  scale public.tracked_state_scale not null,
  custom_labels text[], -- Only relevant if scale = 'custom'
  active boolean default true not null,
  priority int default 1 not null, -- For ordering
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.tracked_state_defs is 'Definitions of states users want to track (e.g., energy, focus).';
alter table public.tracked_state_defs enable row level security;

create policy "Users can view their own state definitions" on public.tracked_state_defs for select using (auth.uid() = user_id);
create policy "Users can insert their own state definitions" on public.tracked_state_defs for insert with check (auth.uid() = user_id);
create policy "Users can update their own state definitions" on public.tracked_state_defs for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own state definitions" on public.tracked_state_defs for delete using (auth.uid() = user_id);


-- === State Entries Table ===
create table public.state_entries (
  id uuid primary key default uuid_generate_v4(),
  definition_id uuid not null references public.tracked_state_defs(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade, -- Denormalized for RLS
  value_numeric smallint, -- Use for '1-5' scale
  value_text text, -- Use for 'low-high' or 'custom' scales
  entry_timestamp timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.state_entries is 'Recorded entries for tracked states.';
alter table public.state_entries enable row level security;

create policy "Users can view their own state entries" on public.state_entries for select using (auth.uid() = user_id);
create policy "Users can insert their own state entries" on public.state_entries for insert with check (auth.uid() = user_id);
create policy "Users can update their own state entries" on public.state_entries for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own state entries" on public.state_entries for delete using (auth.uid() = user_id);


-- === Badge Definitions Table ===
create table public.badge_definitions (
  id text primary key, -- e.g., '10_day_streak', 'first_goal'
  title text not null,
  description text,
  icon text not null -- e.g., emoji or icon library name
);

comment on table public.badge_definitions is 'Definitions of all achievable badges.';
-- Enable RLS but allow all authenticated users read access. Inserts/Updates/Deletes likely managed via admin/seed script.
alter table public.badge_definitions enable row level security;

create policy "Badge definitions are viewable by authenticated users"
  on public.badge_definitions for select
  using (auth.role() = 'authenticated');


-- === User Badges Table ===
create table public.user_badges (
  user_id uuid not null references public.profiles(id) on delete cascade,
  badge_id text not null references public.badge_definitions(id) on delete cascade,
  earned_at timestamp with time zone default timezone('utc'::text, now()) not null,
  progress numeric check (progress >= 0 and progress <= 1), -- For badges with progress
  primary key (user_id, badge_id)
);

comment on table public.user_badges is 'Tracks badges earned by users.';
alter table public.user_badges enable row level security;

create policy "Users can view their own earned badges" on public.user_badges for select using (auth.uid() = user_id);
-- Typically, inserting/updating badge progress/earned status is handled by backend logic (e.g., triggers, functions)
-- For simplicity here, allowing user modification, but review this for production security.
create policy "Users can insert their own earned badges" on public.user_badges for insert with check (auth.uid() = user_id);
create policy "Users can update their own badge progress" on public.user_badges for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own earned badges" on public.user_badges for delete using (auth.uid() = user_id);


-- === Join Tables for Values ===

-- goal_values
create table public.goal_values (
  goal_id uuid not null references public.goals(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade, -- For RLS
  primary key (goal_id, value_id)
);
comment on table public.goal_values is 'Links goals to values.';
alter table public.goal_values enable row level security;
create policy "Users can manage goal_values for their own goals/values" on public.goal_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- task_values
create table public.task_values (
  task_id uuid not null references public.tasks(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade, -- For RLS
  primary key (task_id, value_id)
);
comment on table public.task_values is 'Links tasks to values.';
alter table public.task_values enable row level security;
create policy "Users can manage task_values for their own tasks/values" on public.task_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- habit_values
create table public.habit_values (
  habit_id uuid not null references public.habits(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade, -- For RLS
  primary key (habit_id, value_id)
);
comment on table public.habit_values is 'Links habits to values.';
alter table public.habit_values enable row level security;
create policy "Users can manage habit_values for their own habits/values" on public.habit_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- principle_values
create table public.principle_values (
  principle_id uuid not null references public.principles(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade, -- For RLS
  primary key (principle_id, value_id)
);
comment on table public.principle_values is 'Links principles to values.';
alter table public.principle_values enable row level security;
create policy "Users can manage principle_values for their own principles/values" on public.principle_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- tracked_state_values
create table public.tracked_state_values (
  state_id uuid not null references public.tracked_state_defs(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade, -- For RLS
  primary key (state_id, value_id)
);
comment on table public.tracked_state_values is 'Links tracked state definitions to values.';
alter table public.tracked_state_values enable row level security;
create policy "Users can manage tracked_state_values for their own states/values" on public.tracked_state_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);```

### 20250424035232_add_missing_tables.sql
**Path:** supabase/migrations/20250424035232_add_missing_tables.sql
**Size:** 0 bytes

```sql
```

### 20250424035717_add_missing_tables.sql
**Path:** supabase/migrations/20250424035717_add_missing_tables.sql
**Size:** 11942 bytes

```sql
-- Add missing tables, types, and RLS policies

-- === Values Table ===
create table public.values (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  name text not null,
  description text,
  color text,
  domain_id text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
comment on table public.values is 'User-defined core values.';
alter table public.values enable row level security;
create policy "Users can view their own values" on public.values for select using (auth.uid() = user_id);
create policy "Users can insert their own values" on public.values for insert with check (auth.uid() = user_id);
create policy "Users can update their own values" on public.values for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own values" on public.values for delete using (auth.uid() = user_id);

-- === Key Results Table ===
create table public.key_results (
  id uuid primary key default gen_random_uuid(),
  goal_id uuid not null references public.goals(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  title text not null,
  progress numeric default 0 check (progress >= 0 and progress <= 1),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
comment on table public.key_results is 'Measurable results for achieving goals.';
alter table public.key_results enable row level security;
create policy "Users can view their own key results" on public.key_results for select using (auth.uid() = user_id);
create policy "Users can insert their own key results" on public.key_results for insert with check (auth.uid() = user_id);
create policy "Users can update their own key results" on public.key_results for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own key results" on public.key_results for delete using (auth.uid() = user_id);

-- === Habits Table ===
create table public.habits (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  title text not null,
  cue text,
  routine text,
  reward text,
  streak int not null default 0,
  best_streak int not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
comment on table public.habits is 'User habits to track.';
alter table public.habits enable row level security;
create policy "Users can view their own habits" on public.habits for select using (auth.uid() = user_id);
create policy "Users can insert their own habits" on public.habits for insert with check (auth.uid() = user_id);
create policy "Users can update their own habits" on public.habits for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own habits" on public.habits for delete using (auth.uid() = user_id);

-- === Habit Entries Table ===
create table public.habit_entries (
  id uuid primary key default gen_random_uuid(),
  habit_id uuid not null references public.habits(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  date date not null,
  completed boolean not null default false,
  created_at timestamptz not null default now(),
  unique (habit_id, date)
);
comment on table public.habit_entries is 'Daily check-in records for habits.';
alter table public.habit_entries enable row level security;
create policy "Users can view their own habit entries" on public.habit_entries for select using (auth.uid() = user_id);
create policy "Users can insert their own habit entries" on public.habit_entries for insert with check (auth.uid() = user_id);
create policy "Users can update their own habit entries" on public.habit_entries for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own habit entries" on public.habit_entries for delete using (auth.uid() = user_id);

-- === Principles Table ===
create table public.principles (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  title text not null,
  body text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
comment on table public.principles is 'User-defined guiding principles.';
alter table public.principles enable row level security;
create policy "Users can view their own principles" on public.principles for select using (auth.uid() = user_id);
create policy "Users can insert their own principles" on public.principles for insert with check (auth.uid() = user_id);
create policy "Users can update their own principles" on public.principles for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own principles" on public.principles for delete using (auth.uid() = user_id);

-- === Tracked State Scale Enum ===
create type public.tracked_state_scale as enum ('1-5', 'low-high', 'custom');

-- === Tracked State Definitions Table ===
create table public.tracked_state_defs (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  name text not null,
  scale public.tracked_state_scale not null,
  custom_labels text[],
  active boolean not null default true,
  priority int not null default 1,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
comment on table public.tracked_state_defs is 'Definitions of tracked states.';
alter table public.tracked_state_defs enable row level security;
create policy "Users can view their own state definitions" on public.tracked_state_defs for select using (auth.uid() = user_id);
create policy "Users can insert their own state definitions" on public.tracked_state_defs for insert with check (auth.uid() = user_id);
create policy "Users can update their own state definitions" on public.tracked_state_defs for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own state definitions" on public.tracked_state_defs for delete using (auth.uid() = user_id);

-- === State Entries Table ===
create table public.state_entries (
  id uuid primary key default gen_random_uuid(),
  definition_id uuid not null references public.tracked_state_defs(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  value_numeric smallint,
  value_text text,
  entry_timestamp timestamptz not null default now()
);
comment on table public.state_entries is 'Recorded entries for tracked states.';
alter table public.state_entries enable row level security;
create policy "Users can view their own state entries" on public.state_entries for select using (auth.uid() = user_id);
create policy "Users can insert their own state entries" on public.state_entries for insert with check (auth.uid() = user_id);
create policy "Users can update their own state entries" on public.state_entries for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own state entries" on public.state_entries for delete using (auth.uid() = user_id);

-- === Badge Definitions Table ===
create table public.badge_definitions (
  id text primary key,
  title text not null,
  description text,
  icon text not null
);
comment on table public.badge_definitions is 'Definitions of all achievable badges.';
alter table public.badge_definitions enable row level security;
create policy "Badge definitions are viewable by authenticated users" on public.badge_definitions for select using (auth.role() = 'authenticated');

-- === User Badges Table ===
create table public.user_badges (
  user_id uuid not null references public.profiles(id) on delete cascade,
  badge_id text not null references public.badge_definitions(id) on delete cascade,
  earned_at timestamptz not null default now(),
  progress numeric check (progress >= 0 and progress <= 1),
  primary key (user_id, badge_id)
);
comment on table public.user_badges is 'Tracks badges earned by users.';
alter table public.user_badges enable row level security;
create policy "Users can view their own earned badges" on public.user_badges for select using (auth.uid() = user_id);
create policy "Users can insert their own earned badges" on public.user_badges for insert with check (auth.uid() = user_id);
create policy "Users can update their own badge progress" on public.user_badges for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own earned badges" on public.user_badges for delete using (auth.uid() = user_id);

-- === Join Tables for Values ===
-- goal_values
create table public.goal_values (
  goal_id uuid not null references public.goals(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  primary key (goal_id, value_id)
);
comment on table public.goal_values is 'Links goals to values.';
alter table public.goal_values enable row level security;
create policy "Users can manage goal_values" on public.goal_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- task_values
create table public.task_values (
  task_id uuid not null references public.tasks(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  primary key (task_id, value_id)
);
comment on table public.task_values is 'Links tasks to values.';
alter table public.task_values enable row level security;
create policy "Users can manage task_values" on public.task_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- habit_values
create table public.habit_values (
  habit_id uuid not null references public.habits(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  primary key (habit_id, value_id)
);
comment on table public.habit_values is 'Links habits to values.';
alter table public.habit_values enable row level security;
create policy "Users can manage habit_values" on public.habit_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- principle_values
create table public.principle_values (
  principle_id uuid not null references public.principles(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  primary key (principle_id, value_id)
);
comment on table public.principle_values is 'Links principles to values.';
alter table public.principle_values enable row level security;
create policy "Users can manage principle_values" on public.principle_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- tracked_state_values
create table public.tracked_state_values (
  state_id uuid not null references public.tracked_state_defs(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  primary key (state_id, value_id)
);
comment on table public.tracked_state_values is 'Links tracked states to values.';
alter table public.tracked_state_values enable row level security;
create policy "Users can manage tracked_state_values" on public.tracked_state_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
```

### 20250425000000_create_user_settings_table.sql
**Path:** supabase/migrations/20250425000000_create_user_settings_table.sql
**Size:** 1871 bytes

```sql
-- Add user_settings table and policies

-- Create user_settings table
CREATE TABLE public.user_settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  notification_preferences JSONB NOT NULL DEFAULT '{"email": true, "push": true, "task_reminders": true, "goal_updates": true, "habit_reminders": true}'::jsonb,
  ui_preferences JSONB NOT NULL DEFAULT '{"theme": "system", "compact_view": false, "show_completed_tasks": true}'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Add comment for the table
COMMENT ON TABLE public.user_settings IS 'Stores user preferences and settings';

-- Enable row level security
ALTER TABLE public.user_settings ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view their own settings" 
  ON public.user_settings 
  FOR SELECT 
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own settings" 
  ON public.user_settings 
  FOR INSERT 
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own settings" 
  ON public.user_settings 
  FOR UPDATE 
  USING (auth.uid() = user_id) 
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own settings" 
  ON public.user_settings 
  FOR DELETE 
  USING (auth.uid() = user_id);

-- Add function to create default settings on user creation
CREATE OR REPLACE FUNCTION public.create_default_user_settings()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.user_settings (user_id)
  VALUES (NEW.id);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add trigger to create default settings when a new profile is created
CREATE TRIGGER on_profile_created
  AFTER INSERT ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.create_default_user_settings(); ```

### 20250426000000_create_rewards_tables.sql
**Path:** supabase/migrations/20250426000000_create_rewards_tables.sql
**Size:** 5691 bytes

```sql
-- Create rewards tables and related schemas

-- Rewards table for different types of rewards (badges, achievements, etc.)
CREATE TABLE public.rewards (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  type TEXT NOT NULL CHECK (type IN ('badge', 'achievement', 'item', 'discount')),
  required_points INTEGER NOT NULL DEFAULT 0,
  can_earn_multiple BOOLEAN NOT NULL DEFAULT FALSE,
  image_url TEXT,
  metadata JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON TABLE public.rewards IS 'Available rewards that users can earn';

-- Junction table for user-earned rewards
CREATE TABLE public.user_rewards (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reward_id UUID NOT NULL REFERENCES public.rewards(id) ON DELETE CASCADE,
  reward_type TEXT, -- Denormalized for easier querying
  earned_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  points_spent INTEGER NOT NULL DEFAULT 0,
  metadata JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (user_id, reward_id) -- Only when can_earn_multiple is false
);

COMMENT ON TABLE public.user_rewards IS 'Rewards earned by users';

-- Point transactions table to track point history
CREATE TABLE public.point_transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  points INTEGER NOT NULL,
  reason TEXT NOT NULL,
  source_type TEXT NOT NULL,
  source_id UUID,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON TABLE public.point_transactions IS 'History of point transactions';

-- Add points columns to profiles if they don't exist
ALTER TABLE public.profiles 
ADD COLUMN IF NOT EXISTS points INTEGER NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS lifetime_points INTEGER NOT NULL DEFAULT 0;

-- Enable RLS
ALTER TABLE public.rewards ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_rewards ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.point_transactions ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Rewards policies (public read, admin write)
CREATE POLICY "Anyone can view rewards" 
  ON public.rewards 
  FOR SELECT 
  USING (true);

-- User rewards policies (user can see their own)
CREATE POLICY "Users can view their rewards" 
  ON public.user_rewards 
  FOR SELECT 
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their rewards" 
  ON public.user_rewards 
  FOR INSERT 
  WITH CHECK (auth.uid() = user_id);

-- Point transactions policies (user can see their own)
CREATE POLICY "Users can view their point transactions" 
  ON public.point_transactions 
  FOR SELECT 
  USING (auth.uid() = user_id);

-- Insert some sample rewards
INSERT INTO public.rewards (name, description, type, required_points, can_earn_multiple, image_url)
VALUES
  ('Early Bird', 'Complete 5 tasks before 9 AM', 'badge', 0, false, 'https://api.dicebear.com/7.x/icons/svg?icon=coffee'),
  ('Task Master', 'Complete 100 tasks', 'achievement', 0, false, 'https://api.dicebear.com/7.x/icons/svg?icon=checkSquare'),
  ('Habit Hero', 'Maintain a streak for 30 days', 'achievement', 0, false, 'https://api.dicebear.com/7.x/icons/svg?icon=award'),
  ('Goal Getter', 'Complete 10 goals', 'achievement', 0, false, 'https://api.dicebear.com/7.x/icons/svg?icon=target'),
  ('Theme Customization', 'Unlock custom themes', 'item', 500, false, 'https://api.dicebear.com/7.x/icons/svg?icon=palette'),
  ('Icon Pack', 'Unlock premium icons', 'item', 300, false, 'https://api.dicebear.com/7.x/icons/svg?icon=image'),
  ('Weekly Booster', 'Double points for one week', 'item', 200, true, 'https://api.dicebear.com/7.x/icons/svg?icon=zap'),
  ('Perfectionist', 'Complete all tasks for a week', 'badge', 0, true, 'https://api.dicebear.com/7.x/icons/svg?icon=clipboard');

-- Create function to award points on habit completion
CREATE OR REPLACE FUNCTION public.award_points_for_habit_completion()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.completed = true THEN
    -- Insert a point transaction
    INSERT INTO public.point_transactions (user_id, points, reason, source_type, source_id)
    VALUES (NEW.user_id, 10, 'Completed habit', 'habit', NEW.habit_id);
    
    -- Update user points
    UPDATE public.profiles
    SET 
      points = points + 10,
      lifetime_points = lifetime_points + 10
    WHERE id = NEW.user_id;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger for habit entries to award points
CREATE TRIGGER on_habit_entry_completed
  AFTER INSERT OR UPDATE ON public.habit_entries
  FOR EACH ROW
  WHEN (NEW.completed = true)
  EXECUTE FUNCTION public.award_points_for_habit_completion();

-- Create function to award points on task completion
CREATE OR REPLACE FUNCTION public.award_points_for_task_completion()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
    -- Insert a point transaction
    INSERT INTO public.point_transactions (user_id, points, reason, source_type, source_id)
    VALUES (NEW.user_id, 5, 'Completed task', 'task', NEW.id);
    
    -- Update user points
    UPDATE public.profiles
    SET 
      points = points + 5,
      lifetime_points = lifetime_points + 5
    WHERE id = NEW.user_id;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger for tasks to award points
CREATE TRIGGER on_task_completed
  AFTER INSERT OR UPDATE ON public.tasks
  FOR EACH ROW
  WHEN (NEW.status = 'completed')
  EXECUTE FUNCTION public.award_points_for_task_completion(); ```

### 20250428124230_standardize_field_naming.sql
**Path:** supabase/migrations/20250428124230_standardize_field_naming.sql
**Size:** 1071 bytes

```sql
-- Migration: Standardize field naming (name → title)
-- Description: Ensure consistency across the database by standardizing on 'title' instead of 'name'

-- This migration doesn't need to modify tables that already use 'title' consistently
-- Based on database inspection, most tables already use 'title' correctly

-- Values table: Rename 'name' to 'title'
ALTER TABLE "public"."values" RENAME COLUMN "name" TO "title";

-- Update triggers and functions if they reference these columns
-- For any downstream foreign key constraints, they should continue to work since we're just renaming columns

-- Update any indexes that might reference the old column names
DROP INDEX IF EXISTS "public"."values_name_idx";
CREATE INDEX IF NOT EXISTS "values_title_idx" ON "public"."values" ("title");

-- Update any views that might reference the old column names
-- (Add appropriate view updates if needed)

-- Note: This migration assumes 'values' is the primary table needing column renaming
-- based on code inspection. If other tables need similar treatment, add them here.
```

### 20250428130834_enhance_functional_schema.sql
**Path:** supabase/migrations/20250428130834_enhance_functional_schema.sql
**Size:** 11873 bytes

```sql
-- supabase/migrations/20250428130834_enhance_functional_schema.sql
-- Migration: Enhance DB Schema for Aether App Functionality
-- Description: Addresses functional gaps identified in user experience review.

-- === Enums and Types ===

-- Task Status Enum (Reintroduce for better type safety)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'task_status') THEN
        CREATE TYPE public.task_status AS ENUM ('todo', 'doing', 'done', 'blocked', 'pending'); -- Add 'pending' if used
    END IF;
END$$;

-- Task Priority Enum (Change from INT for clarity)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'task_priority') THEN
        CREATE TYPE public.task_priority AS ENUM ('low', 'medium', 'high');
    END IF;
END$$;

-- Reward Type Enum
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'reward_type') THEN
        CREATE TYPE public.reward_type AS ENUM ('badge', 'achievement', 'item', 'discount');
    END IF;
END$$;

-- Habit Type Enum
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'habit_type') THEN
        CREATE TYPE public.habit_type AS ENUM ('boolean', 'quantity');
    END IF;
END$$;

-- Habit Frequency Period Enum (Add if missing or confirm existence)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'habit_frequency_period') THEN
        CREATE TYPE public.habit_frequency_period AS ENUM ('day', 'week', 'month');
    END IF;
END$$;

-- === Table Enhancements ===

-- 1. Tasks Table Enhancements
ALTER TABLE public.tasks
  ADD COLUMN IF NOT EXISTS recurrence_rule TEXT NULL, -- For iCalendar RRULE strings
  ADD COLUMN IF NOT EXISTS recurrence_end_date DATE NULL,
  ADD COLUMN IF NOT EXISTS parent_task_id UUID NULL REFERENCES public.tasks(id) ON DELETE SET NULL,
  ADD COLUMN IF NOT EXISTS archived_at TIMESTAMPTZ NULL,
  ADD COLUMN IF NOT EXISTS sort_order INTEGER NULL;

-- Temporarily drop the trigger that depends on the tasks.status column
DROP TRIGGER IF EXISTS on_task_completed ON public.tasks;

-- Alter task status to use ENUM (Assuming 'pending' might be used based on router)
-- Drop default constraint if it exists
ALTER TABLE public.tasks ALTER COLUMN status DROP DEFAULT;
-- Alter column type
ALTER TABLE public.tasks
  ALTER COLUMN status TYPE public.task_status USING status::public.task_status;
-- Add default back if needed
ALTER TABLE public.tasks ALTER COLUMN status SET DEFAULT 'todo';

-- Recreate the trigger (Ensure the function award_points_for_task_completion still works correctly with the enum type)
-- The function likely still works as it compares with a string literal 'completed', which should match the enum
CREATE TRIGGER on_task_completed
  AFTER INSERT OR UPDATE ON public.tasks
  FOR EACH ROW
  WHEN (NEW.status::text = 'done') -- Explicitly cast NEW.status to text for comparison, or adjust if needed
  EXECUTE FUNCTION public.award_points_for_task_completion();

-- Alter task priority to use ENUM
ALTER TABLE public.tasks
  ADD COLUMN IF NOT EXISTS priority_enum public.task_priority NULL;

-- (Manual step recommended after migration: migrate data from priority (int) to priority_enum, then drop old priority column and rename)
-- Example (Run this manually or in a separate script after checking data):
-- UPDATE public.tasks SET priority_enum = 
--   CASE
--     WHEN priority = 1 THEN 'high'::public.task_priority
--     WHEN priority = 2 THEN 'medium'::public.task_priority
--     WHEN priority = 3 THEN 'low'::public.task_priority -- Assuming 1=High, 3=Low
--     ELSE NULL
--   END;
-- ALTER TABLE public.tasks DROP COLUMN priority;
-- ALTER TABLE public.tasks RENAME COLUMN priority_enum TO priority;

-- Add Indexes
CREATE INDEX IF NOT EXISTS idx_tasks_archived_at ON public.tasks(archived_at);
CREATE INDEX IF NOT EXISTS idx_tasks_sort_order ON public.tasks(sort_order);
CREATE INDEX IF NOT EXISTS idx_tasks_parent_task_id ON public.tasks(parent_task_id);

COMMENT ON COLUMN public.tasks.recurrence_rule IS 'iCalendar RRULE string for recurrence.';
COMMENT ON COLUMN public.tasks.parent_task_id IS 'Link to parent task for sub-tasks.';
COMMENT ON COLUMN public.tasks.archived_at IS 'Timestamp when the task was archived.';
COMMENT ON COLUMN public.tasks.sort_order IS 'Manual sort order within a list.';

-- Task Dependencies (Optional - Use if many-to-many needed)
-- CREATE TABLE public.task_dependencies (
--   task_id UUID NOT NULL REFERENCES public.tasks(id) ON DELETE CASCADE,
--   depends_on_task_id UUID NOT NULL REFERENCES public.tasks(id) ON DELETE CASCADE,
--   user_id uuid not null references public.profiles(id) on delete cascade, -- For RLS
--   PRIMARY KEY (task_id, depends_on_task_id)
-- );
-- COMMENT ON TABLE public.task_dependencies IS 'Tracks dependencies between tasks.';
-- alter table public.task_dependencies enable row level security;
-- create policy "Users can manage task_dependencies for their own tasks" on public.task_dependencies for all using (auth.uid() = user_id) with check (auth.uid() = user_id);


-- 2. Habits Table Enhancements
ALTER TABLE public.habits
  ADD COLUMN IF NOT EXISTS recurrence_rule TEXT NULL, -- For iCalendar RRULE strings
  ADD COLUMN IF NOT EXISTS recurrence_end_date DATE NULL,
  ADD COLUMN IF NOT EXISTS archived_at TIMESTAMPTZ NULL,
  ADD COLUMN IF NOT EXISTS habit_type public.habit_type NOT NULL DEFAULT 'boolean',
  ADD COLUMN IF NOT EXISTS goal_quantity INTEGER NULL,
  ADD COLUMN IF NOT EXISTS goal_unit TEXT NULL,
  ADD COLUMN IF NOT EXISTS frequency_period public.habit_frequency_period NOT NULL DEFAULT 'day', -- Add frequency tracking
  ADD COLUMN IF NOT EXISTS goal_frequency SMALLINT NOT NULL DEFAULT 1; -- Add frequency tracking

-- Add Indexes
CREATE INDEX IF NOT EXISTS idx_habits_archived_at ON public.habits(archived_at);

COMMENT ON COLUMN public.habits.recurrence_rule IS 'iCalendar RRULE string for recurrence.';
COMMENT ON COLUMN public.habits.archived_at IS 'Timestamp when the habit was archived.';
COMMENT ON COLUMN public.habits.habit_type IS 'Type of habit (e.g., boolean check-in or quantity tracking).';
COMMENT ON COLUMN public.habits.goal_quantity IS 'Target quantity for quantity-based habits.';
COMMENT ON COLUMN public.habits.goal_unit IS 'Unit for quantity-based habits (e.g., glasses, km).';
COMMENT ON COLUMN public.habits.frequency_period IS 'Period for habit frequency (day, week, month).';
COMMENT ON COLUMN public.habits.goal_frequency IS 'How many times per period the habit should be done.';


-- 3. Habit Entries Table Enhancements
ALTER TABLE public.habit_entries
  ADD COLUMN IF NOT EXISTS quantity_value INTEGER NULL,
  ADD COLUMN IF NOT EXISTS notes TEXT NULL;

COMMENT ON COLUMN public.habit_entries.quantity_value IS 'Value recorded for quantity-based habits.';
COMMENT ON COLUMN public.habit_entries.notes IS 'User notes for a specific habit entry.';


-- 4. Goals Table Enhancements
ALTER TABLE public.goals
  ADD COLUMN IF NOT EXISTS archived_at TIMESTAMPTZ NULL,
  ADD COLUMN IF NOT EXISTS sort_order INTEGER NULL;

-- Add Indexes
CREATE INDEX IF NOT EXISTS idx_goals_archived_at ON public.goals(archived_at);
CREATE INDEX IF NOT EXISTS idx_goals_sort_order ON public.goals(sort_order);

COMMENT ON COLUMN public.goals.archived_at IS 'Timestamp when the goal was archived.';
COMMENT ON COLUMN public.goals.sort_order IS 'Manual sort order for goals.';


-- 5. Values Table Enhancements
ALTER TABLE public.values
  ADD COLUMN IF NOT EXISTS sort_order INTEGER NULL;

-- Add Indexes
CREATE INDEX IF NOT EXISTS idx_values_sort_order ON public.values(sort_order);

COMMENT ON COLUMN public.values.sort_order IS 'Manual sort order for values.';


-- 6. Principles Table Enhancements
ALTER TABLE public.principles
  ADD COLUMN IF NOT EXISTS sort_order INTEGER NULL;

-- Add Indexes
CREATE INDEX IF NOT EXISTS idx_principles_sort_order ON public.principles(sort_order);

COMMENT ON COLUMN public.principles.sort_order IS 'Manual sort order for principles.';


-- 7. State Entries Table Enhancements
ALTER TABLE public.state_entries
  ADD COLUMN IF NOT EXISTS notes TEXT NULL;

COMMENT ON COLUMN public.state_entries.notes IS 'User notes for a specific state entry.';


-- 8. Tracked State Definitions Enhancements
ALTER TABLE public.tracked_state_defs
  ADD COLUMN IF NOT EXISTS target_min_value NUMERIC NULL,
  ADD COLUMN IF NOT EXISTS target_max_value NUMERIC NULL;

COMMENT ON COLUMN public.tracked_state_defs.target_min_value IS 'Optional minimum target value for the tracked state.';
COMMENT ON COLUMN public.tracked_state_defs.target_max_value IS 'Optional maximum target value for the tracked state.';


-- 9. Rewards Table Enhancements (Use Enum)

-- Drop the existing text-based CHECK constraint first
-- Note: The constraint name might vary. Find the actual name if this fails.
-- You can find it using SQL: SELECT conname FROM pg_constraint WHERE conrelid = 'public.rewards'::regclass AND contype = 'c' AND conname LIKE '%type%';
-- Assuming a default name pattern here:
ALTER TABLE public.rewards DROP CONSTRAINT IF EXISTS rewards_type_check;

-- Alter rewards type to use ENUM
ALTER TABLE public.rewards
  ALTER COLUMN type TYPE public.reward_type USING type::public.reward_type;


-- === New Tables ===

-- 1. Reminders Table
CREATE TABLE IF NOT EXISTS public.reminders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  related_entity_type TEXT NOT NULL, -- e.g., 'task', 'goal', 'habit'
  related_entity_id UUID NOT NULL, -- FK cannot easily reference multiple tables, handled by app logic/RLS
  reminder_time TIMESTAMPTZ NOT NULL,
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON TABLE public.reminders IS 'Stores scheduled reminders for various entities.';
ALTER TABLE public.reminders ENABLE ROW LEVEL SECURITY;
CREATE INDEX IF NOT EXISTS idx_reminders_user_time ON public.reminders(user_id, reminder_time);
CREATE INDEX IF NOT EXISTS idx_reminders_related_entity ON public.reminders(related_entity_type, related_entity_id);

-- RLS Policies for Reminders
CREATE POLICY "Users can manage their own reminders" ON public.reminders
  FOR ALL
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);


-- 2. Goal Progress Notes Table
CREATE TABLE IF NOT EXISTS public.goal_progress_notes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  goal_id UUID NOT NULL REFERENCES public.goals(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE, -- Denormalized for RLS
  note TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON TABLE public.goal_progress_notes IS 'Stores notes related to goal progress updates.';
ALTER TABLE public.goal_progress_notes ENABLE ROW LEVEL SECURITY;
CREATE INDEX IF NOT EXISTS idx_goal_progress_notes_goal_id ON public.goal_progress_notes(goal_id);

-- RLS Policies for Goal Progress Notes
CREATE POLICY "Users can manage notes for their own goals" ON public.goal_progress_notes
  FOR ALL
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- === Function/Trigger Updates (Example - Needs Review) ===

-- Update function/trigger for habit completion points if habit_type is added
-- (This is just illustrative, review existing functions like award_points_for_habit_completion)
-- Example: Maybe points depend on habit_type or goal_quantity?

-- Update function/trigger for task completion points if priority changes type
-- (Review existing functions like award_points_for_task_completion)

-- Note: Ensure existing RLS policies adequately cover new columns or create specific policies if needed.
-- Note: Consider adding foreign key constraints for related_entity_id in reminders if feasible,
--       otherwise enforce relationship integrity at the application level.
```


# (root files)

### tailwind.config.js
**Path:** tailwind.config.js
**Size:** 3140 bytes

```javascript
/** @type {import('tailwindcss').Config} */
// Import the Zelda theme tokens
const zelda = require('./design-system/tokens');
// Import NativeWind preset
const nativewind = require('nativewind/preset');

module.exports = {
  presets: [nativewind],
  content: [
    "./app/**/*.{js,jsx,ts,tsx}",
    "./components/**/*.{js,jsx,ts,tsx}",
    "./design-system/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {
      fontFamily: {
        'heading': ['HyliaSerif'],
        'body': ['CalamitySans'],
      },
      colors: {
        // Zelda theme colors
        'parchment': zelda.colors.parchment,
        'sheikahCyan': zelda.colors.sheikahCyan,
        'korokGreen': zelda.colors.korokGreen,
        'darkText': zelda.colors.darkText,
        'guardianOrange': zelda.colors.guardianOrange,
        'darkTealBg': zelda.colors.darkTealBg,
        'cyanGlow': zelda.colors.cyanGlow,
        
        // iOS standard colors
        // iOS system colors
        'ios-blue': '#007AFF',
        'ios-dark-blue': '#0A84FF', // dark mode variant
        'ios-red': '#FF3B30',
        'ios-dark-red': '#FF453A', // dark mode variant
        'ios-green': '#34C759',
        'ios-dark-green': '#30D158', // dark mode variant
        'ios-orange': '#FF9500',
        'ios-dark-orange': '#FF9F0A', // dark mode variant
        'ios-purple': '#AF52DE',
        'ios-dark-purple': '#BF5AF2', // dark mode variant
        'ios-yellow': '#FFCC00',
        'ios-dark-yellow': '#FFD60A', // dark mode variant
        'ios-pink': '#FF2D55',
        'ios-dark-pink': '#FF375F', // dark mode variant
        'ios-indigo': '#5856D6',
        'ios-dark-indigo': '#5E5CE6', // dark mode variant
        
        // iOS gray palette
        'ios-gray': {
          1: '#8E8E93',
          2: '#AEAEB2',
          3: '#C7C7CC',
          4: '#D1D1D6',
          5: '#E5E5EA',
          6: '#F2F2F7',
        },
        'ios-dark-gray': {
          1: '#8E8E93',
          2: '#636366',
          3: '#48484A',
          4: '#3A3A3C',
          5: '#2C2C2E',
          6: '#1C1C1E',
        },
        
        // System background colors
        'ios-system': {
          DEFAULT: '#FFFFFF',
          secondary: '#F2F2F7',
          tertiary: '#FFFFFF',
        },
        'ios-dark-system': {
          DEFAULT: '#000000',
          secondary: '#1C1C1E',
          tertiary: '#2C2C2E',
        },
      },
      
      // iOS standard spacing
      spacing: {
        // Added standard iOS spacing if needed beyond Tailwind defaults
      },
      
      // iOS standard border radius
      borderRadius: {
        'ios-small': '4px',
        'ios-regular': '8px',
        'ios-large': '12px',
        'ios-xl': '16px',
      },
      
      // iOS system font weights
      fontWeight: {
        'ios-regular': '400',
        'ios-medium': '500', 
        'ios-semibold': '600',
        'ios-bold': '700',
      },
      
      // iOS shadows
      boxShadow: {
        'ios-small': '0 1px 2px rgba(0, 0, 0, 0.05)',
        'ios-medium': '0 2px 4px rgba(0, 0, 0, 0.1)',
        'ios-large': '0 4px 6px rgba(0, 0, 0, 0.1)',
      },
    },
  },
  plugins: [],
}; ```

### tamagui.config.ts
**Path:** tamagui.config.ts
**Size:** 13089 bytes

```typescript
// tamagui.config.ts
import { createAnimations } from '@tamagui/animations-react-native';
import { createFont, createTamagui, createTokens } from 'tamagui';
import { Platform } from 'react-native';
import * as MotionConstants from '@/constants/motion'; // Import motion constants

// Font definitions - Zelda Theme
// Assumes 'CalamitySans' and 'HyliaSerif' are loaded via useFonts or similar
const headingFont = createFont({
  family: 'HyliaSerif', // Zelda Display Font
  size: {
    // Mapped closer to iOS Dynamic Type: https://developer.apple.com/design/human-interface-guidelines/typography
    1: 13,  // Caption 2
    2: 15,  // Subheadline
    3: 17,  // Body (true default)
    4: 20,  // Title 3
    5: 22,  // Title 2
    6: 28,  // Title 1
    7: 34,  // Large Title
    8: 40,  // Extra Large Title (custom)
    true: 17, // Default size (Body)
  },
  lineHeight: {
    // Approximate line heights based on new sizes
    1: 18, 2: 20, 3: 22, 4: 25, 5: 28, 6: 34, 7: 41, 8: 50, 
    true: 22,
  },
  weight: {
    // Prompt 2 asks for 400-700
    4: '400', // Normal
    6: '600', // Semi-bold/Bold
    7: '700', // Extra-bold/Black
    true: '400',
  },
  letterSpacing: {
    1: 0, 2: 0, 3: -0.5, 4: -0.5, 5: -1, 6: -1, 7: -1.5, 8: -1.5,
    true: 0,
  },
  // Required: Map weights to specific font faces if needed (e.g., 'HyliaSerif-Bold')
  // face: {
  //   400: { normal: 'HyliaSerif-Regular' },
  //   700: { normal: 'HyliaSerif-Bold' },
  // },
});

const bodyFont = createFont({
  family: 'CalamitySans', // Zelda Body Font
  size: {
    // Mapped closer to iOS Dynamic Type
    1: 11,  // Footnote
    2: 12,  // Caption 1
    3: 13,  // Caption 2
    4: 15,  // Subheadline
    5: 17,  // Body (true default)
    6: 20,  // Title 3 (matching headingFont.$4)
    true: 17, // Default body size
  },
  lineHeight: {
    // Approximate line heights
    1: 13, 2: 16, 3: 18, 4: 20, 5: 22, 6: 25,
    true: 22, // Default body line height
  },
  weight: {
    4: '400', // Regular
    5: '500', // Medium (if available)
    7: '700', // Bold (if needed/available)
    true: '400',
  },
  letterSpacing: {
    1: 0.1, 2: 0.1, 3: 0, 4: 0, 5: -0.1, 6: -0.1,
    true: 0,
  },
  // Required: Map weights to specific font faces if needed (e.g., 'CalamitySans-Medium')
  // face: {
  //   400: { normal: 'CalamitySans-Regular' },
  //   500: { normal: 'CalamitySans-Medium' },
  // },
});

const monoFont = createFont({
  family: Platform.select({ web: 'monospace', default: 'SpaceMono' }), // Keep SpaceMono for code
  size: {
    1: 12, 2: 14, 3: 15, 4: 16, 5: 18, 6: 20, true: 15,
  },
  lineHeight: {
    1: 18, 2: 22, 3: 24, 4: 26, 5: 28, 6: 32, true: 24,
  },
  weight: {
    4: '400', // Normal weight
    true: '400',
  },
  letterSpacing: {
    4: 0,
    true: 0,
  },
  face: {
    400: { normal: 'SpaceMono' }, // Map weight 400 to the loaded SpaceMono font
  },
});

// Animation driver using reanimated
const animations = createAnimations({
  fast: {
    type: 'timing',
    duration: MotionConstants.durations.standard,
    // easing: MotionConstants.easings.standard, // Removed as createAnimations defaults work well
  },
  medium: {
    type: 'timing',
    duration: MotionConstants.durations.modal,
  },
  slow: {
    type: 'timing',
    duration: MotionConstants.durations.long,
  },
  bouncy: {
    type: 'spring',
    damping: 9,
    mass: 0.9,
    stiffness: 150,
  },
  lazy: {
    type: 'spring',
    damping: 18,
    stiffness: 50,
  },
  quick: {
    type: 'spring',
    damping: 20,
    mass: 1.2,
    stiffness: 250,
  },
});

// Standard Radix Gray scale (light theme)
const gray = {
  gray1: '#fcfcfc', gray2: '#f8f8f8', gray3: '#f3f3f3', gray4: '#ededed', gray5: '#e8e8e8', gray6: '#e2e2e2', gray7: '#dbdbdb', gray8: '#c7c7c7', gray9: '#8f8f8f', gray10: '#858585', gray11: '#6f6f6f', gray12: '#171717',
};

// Standard Radix Gray scale (dark theme)
const grayDark = {
  gray1: '#191919', gray2: '#212121', gray3: '#282828', gray4: '#303030', gray5: '#393939', gray6: '#424242', gray7: '#4f4f4f', gray8: '#626262', gray9: '#737373', gray10: '#838383', gray11: '#ababab', gray12: '#ededed',
};

// Tokens (refined based on your existing config)
const tokens = createTokens({
  size: {
    0: 0, 1: 4, 2: 8, 3: 12, 4: 16, 5: 20, 6: 24, 7: 28, 8: 32, 9: 36, 10: 40, 11: 44, 12: 48, 13: 52, 14: 56, 15: 60, 16: 64, true: 16,
  },
  space: {
    0: 0, 1: 4, 2: 8, 3: 12, 4: 16, 5: 20, 6: 24, 7: 28, 8: 32, 9: 36, 10: 40, 11: 44, 12: 48, 13: 52, 14: 56, 15: 60, 16: 64, true: 16, '-1': -4, '-2': -8, '-3': -12, '-4': -16,
  },
  radius: {
    0: 0, 1: 3, 2: 5, 3: 8, 4: 10, 5: 14, 6: 16, 7: 20, 8: 24, 9: 28, 10: 32, true: 10, // Updated radius.5 to 14
  },
  zIndex: { 0: 0, 1: 100, 2: 200, 3: 300, 4: 400, 5: 500 },
  color: {
    // Zelda Palette (Prompt 1)
    ...gray, // Add light greys
    ...grayDark, // Add dark greys (will be overridden in dark theme definition)
    parchment: '#FDFFE0',
    sheikahCyan: '#86A5A9',
    korokGreen: '#92C582',
    darkText: '#536F50',
    guardianOrange: '#FF9F0A',
    darkTealBg: '#1A2E3A',
    darkCyanGlow: '#64FFDA',

    // Shadow Colors (Prompt 5)
    shadowColorLight: 'rgba(83, 111, 80, 1)', // dark desaturated text color
    shadowColorDark: 'rgba(0, 0, 0, 1)', // Black base
    white: '#FFFFFF',
    black: '#000000',
  },
});

// Define themes using Zelda Palette
const lightTheme = {
  // Base Colors
  background: tokens.color.parchment,      // Light bg
  backgroundStrong: tokens.color.white,     // Keep white for strong contrast areas if needed
  backgroundTransparent: 'rgba(253, 255, 224, 0)', // Fully transparent parchment
  color: tokens.color.darkText,             // Dark desaturated text
  colorSecondary: tokens.color.darkText,      // Use main text color, maybe slightly lighter if needed later
  colorTertiary: tokens.color.sheikahCyan,    // Use accent for tertiary info?
  borderColor: tokens.color.sheikahCyan,      // Use accent for borders
  borderColorHover: tokens.color.korokGreen,  // Korok green on hover?

  // Theme-specific states (can refine later)
  backgroundHover: tokens.color.parchment,    // Keep parchment, maybe slightly darker/lighter
  backgroundPress: tokens.color.parchment,    // Keep parchment
  backgroundFocus: tokens.color.parchment,    // Keep parchment
  colorHover: tokens.color.korokGreen,        // Korok green text on hover?
  colorPress: tokens.color.korokGreen,
  colorFocus: tokens.color.sheikahCyan,
  borderColorPress: tokens.color.korokGreen,
  borderColorFocus: tokens.color.sheikahCyan,

  // Semantic Tokens (Prompt 4)
  accent: tokens.color.sheikahCyan,
  surfaceSubtle: tokens.color.parchment,    // Base color, apply opacity in component (e.g., rgba(253,255,224,0.8))
  destructive: tokens.color.guardianOrange,

  // Standard Semantic Mapping (can use Zelda colors)
  primary: tokens.color.sheikahCyan,        // Map primary to accent
  secondary: tokens.color.korokGreen,       // Map secondary to korok green?
  success: tokens.color.korokGreen,
  warning: tokens.color.guardianOrange,     // Use guardian orange for warning
  error: tokens.color.guardianOrange,       // Use guardian orange for error
  info: tokens.color.sheikahCyan,

  // Semantic Aliases (Playbook 1.1)
  surface: tokens.color.parchment, // Maps to background
  onSurface: tokens.color.darkText,  // Maps to color
  outline: tokens.color.sheikahCyan, // Maps to borderColor

  // Shadows (Playbook 1.1 & Prompt 5)
  shadowColor: tokens.color.shadowColorLight, // Use darkText color base for shadow
  shadowColorHover: 'rgba(83, 111, 80, 0.15)',
  shadowSm: 'rgba(83, 111, 80, 0.10)', // 10% opacity
  shadowMd: 'rgba(83, 111, 80, 0.15)', // 15% opacity
  shadowLg: 'rgba(83, 111, 80, 0.20)', // 20% opacity

  // Toast Themes (Report Item 6)
  toast_success_background: tokens.color.korokGreen,
  toast_success_color: tokens.color.parchment,
  toast_error_background: tokens.color.guardianOrange,
  toast_error_color: tokens.color.parchment,
  toast_warning_background: tokens.color.guardianOrange, // Often same as error
  toast_warning_color: tokens.color.parchment,
  toast_info_background: tokens.color.sheikahCyan,
  toast_info_color: tokens.color.parchment,
};

const darkTheme: typeof lightTheme = {
  // Base Colors
  ...grayDark, // Override light greys with dark greys
  background: tokens.color.darkTealBg,      // Dark-mode bg
  backgroundStrong: tokens.color.black,       // Black for contrast?
  backgroundTransparent: 'rgba(26, 46, 58, 0)', // Fully transparent dark teal
  color: tokens.color.parchment,          // Use light parchment for text
  colorSecondary: tokens.color.sheikahCyan,   // Sheikah cyan for secondary text
  colorTertiary: tokens.color.korokGreen,     // Korok green for tertiary
  borderColor: tokens.color.sheikahCyan,      // Sheikah cyan borders
  borderColorHover: tokens.color.darkCyanGlow, // Glow cyan on hover?

  // Theme-specific states
  backgroundHover: tokens.color.darkTealBg,   // Keep bg, maybe slightly lighter
  backgroundPress: tokens.color.darkTealBg,
  backgroundFocus: tokens.color.darkTealBg,
  colorHover: tokens.color.darkCyanGlow,
  colorPress: tokens.color.darkCyanGlow,
  colorFocus: tokens.color.darkCyanGlow,
  borderColorPress: tokens.color.darkCyanGlow,
  borderColorFocus: tokens.color.darkCyanGlow,

  // Semantic Tokens (Prompt 4)
  accent: tokens.color.sheikahCyan,
  surfaceSubtle: tokens.color.darkTealBg, // Use dark bg, apply opacity in component
  destructive: tokens.color.guardianOrange,

  // Standard Semantic Mapping
  primary: tokens.color.darkCyanGlow,       // Use glow cyan for primary actions
  secondary: tokens.color.korokGreen,
  success: tokens.color.korokGreen,
  warning: tokens.color.guardianOrange,
  error: tokens.color.guardianOrange,
  info: tokens.color.sheikahCyan,

  // Semantic Aliases (Playbook 1.1)
  surface: tokens.color.darkTealBg,   // Maps to background
  onSurface: tokens.color.parchment,  // Maps to color
  outline: tokens.color.sheikahCyan, // Maps to borderColor

  // Shadows (Playbook 1.1 & Prompt 5)
  shadowColor: tokens.color.shadowColorDark, // Darker shadow for dark mode
  shadowColorHover: 'rgba(0, 0, 0, 0.30)',
  shadowSm: 'rgba(0, 0, 0, 0.20)', // 20% opacity
  shadowMd: 'rgba(0, 0, 0, 0.30)', // 30% opacity
  shadowLg: 'rgba(0, 0, 0, 0.40)', // 40% opacity

  // Toast Themes (Report Item 6)
  toast_success_background: tokens.color.korokGreen,
  toast_success_color: tokens.color.darkTealBg,
  toast_error_background: tokens.color.guardianOrange,
  toast_error_color: tokens.color.darkTealBg,
  toast_warning_background: tokens.color.guardianOrange, // Often same as error
  toast_warning_color: tokens.color.darkTealBg,
  toast_info_background: tokens.color.sheikahCyan,
  toast_info_color: tokens.color.darkTealBg,
};

// Create the Tamagui config
const config = createTamagui({
  animations,
  shouldAddPrefersColorThemes: true,
  themeClassNameOnRoot: true,
  shorthands: {
    // Keep your existing shorthands
    m: 'margin', mt: 'marginTop', mr: 'marginRight', mb: 'marginBottom', ml: 'marginLeft', mx: 'marginHorizontal', my: 'marginVertical',
    p: 'padding', pt: 'paddingTop', pr: 'paddingRight', pb: 'paddingBottom', pl: 'paddingLeft', px: 'paddingHorizontal', py: 'paddingVertical',
    bg: 'backgroundColor', br: 'borderRadius', bw: 'borderWidth', bc: 'borderColor',
    f: 'flex', fd: 'flexDirection', ai: 'alignItems', jc: 'justifyContent', w: 'width', h: 'height',
    ac: 'alignContent',
    als: 'alignSelf',
    btc: 'borderTopColor',
    bbc: 'borderBottomColor',
    blc: 'borderLeftColor',
    brc: 'borderRightColor',
    boc: 'borderColor',
    bs: 'borderStyle',
    dsp: 'display',
    fb: 'flexBasis',
    fg: 'flexGrow',
    fs: 'flexShrink',
    fw: 'flexWrap',
    mah: 'maxHeight',
    maw: 'maxWidth',
    mih: 'minHeight',
    miw: 'minWidth',
    op: 'opacity',
    ov: 'overflow',
    r: 'right',
    shac: 'shadowColor',
    shar: 'shadowRadius',
    shof: 'shadowOffset',
    shop: 'shadowOpacity',
    t: 'top',
    ta: 'textAlign',
    tt: 'textTransform',
    va: 'verticalAlign',
    zi: 'zIndex',
  },
  fonts: {
    // Use Zelda fonts
    heading: headingFont,
    body: bodyFont,
    mono: monoFont, // Keep mono
  },
  themes: {
    light: lightTheme,
    dark: darkTheme,
  },
  tokens,
  media: { // Keep standard media queries
    xs: { maxWidth: 660 }, sm: { maxWidth: 800 }, md: { maxWidth: 1020 }, lg: { maxWidth: 1280 }, xl: { maxWidth: 1420 }, xxl: { maxWidth: 1600 },
    gtXs: { minWidth: 661 }, gtSm: { minWidth: 801 }, gtMd: { minWidth: 1021 }, gtLg: { minWidth: 1281 },
    short: { maxHeight: 820 }, tall: { minHeight: 820 },
    hoverNone: { hover: 'none' }, pointerCoarse: { pointer: 'coarse' },
  },
  settings: {
      allowedStyleValues: 'somewhat-strict',
      autocompleteSpecificTokens: 'except-special',
  },
});

type AppConfig = typeof config;

// Augment Tamagui interface - this is crucial!
declare module '@tamagui/core' {
  // If AppConfig is defined and exported:
  interface TamaguiCustomConfig extends AppConfig {}
}

export default config;```

### testing_strategy.md
**Path:** testing_strategy.md
**Size:** 11132 bytes

```markdown
# Testing Strategy

> “If you don’t like unit testing your product, most likely your customers won’t like to test it either.” – Anonymous

This document codifies **how and why** we test every layer of the Aether iPhone application to enable **Test-Driven Development (TDD)**, short feedback cycles, and confidently ship high-quality code.

---

## 1. Tech-Stack & How the Pieces Interact

| Layer | Primary Tech | Purpose | Notes |
|-------|--------------|---------|-------|
| **UI** | Expo + React Native, Tamagui (design system), React Navigation | Interactive surfaces | Tamagui primitives → feature components → screens → stacks/tabs |
| **State** | TanStack Query, Zustand | Remote & local state | React Query for server cache, Async-Storage persister; Zustand for ephemeral UI state |
| **Networking** | tRPC 11, Supabase JS v2 | RPC & DB access | Procedures call Supabase; auth context injected |
| **Backend** | Supabase Postgres (hosted) | Data persistence | Tested via mocked Supabase client to avoid network |
| **Utility** | date-fns, utils/* | Pure helpers | No side-effects, easiest to unit-test |
| **Tooling** | TypeScript, ESLint, Prettier | Static guarantees | `ts-jest` reuses the same TS config |
| **Testing** | Jest 29, Jest-Expo 52, React-Native-Testing-Library 13, Jest-Mock-Extended 4, MSW 2 | Unit / integration | UI runner vs Node runner share config fragments |

> All technologies above are **typed** and **mock-friendly**, which is critical for TDD.

### 1.1 Supabase Schema & Type-Generation

* **Source of Truth** – `/supabase/schema.sql` maintained via Supabase Studio migrations.
* **Type Generation** – `npm run generate-types` executes `supabase gen types typescript --project-id <id>`. Output lives at `types/supabase.ts` and is imported everywhere (`Database['public']['Tables']['tasks']`).
* **Why** – guarantees compile-time correctness of column names, data shapes, and row-level security (RLS) policies exposed via `insert()/update()`.
* **Testing Impact** – mocks use these generated types so any schema drift instantly breaks tests.

---

## 2. Pyramid of Tests

```
          E2E (future: Detox)
        Integration (tRPC ↔ Supabase, Screen ↔ Store)
      Unit (Components, Hooks, Utils, Routers)
  Static Analysis (TypeScript, ESLint)
```

1. **Static Analysis** – compile & lint gates prevent many runtime errors.
2. **Unit Tests** – fast, deterministic, isolate a single module.
3. **Integration Tests** – wire several modules; catch contract drift.
4. **(Optional) E2E** – device-level confidence once the core is solid.

Coverage goal: **≥90 % lines / 100 % critical paths**.

---

## 3. Testing Concerns by Folder

| Path | What to Test | Example Utilities |
|------|--------------|-------------------|
| `components/ui/primitives` | Rendering, style props, accessibility | Snapshot + RTL queries |
| `components/*` lists/cards | Interaction callbacks, conditional rendering | Fire events, assert mockFn calls |
| `screens/*` | Navigation, data hooks, optimistic updates | Mock React-Navigation & React Query provider |
| `modals/*` | Visibility toggles, onDismiss side-effects | Render with mocked store |
| `hooks/*` | Return value, edge cases | Jest timers for async hooks |
| `stores/*` (Zustand) | Initial state, actions mutate correctly | Wrap in `act()` |
| `server/src/routers` | Input validation, happy/edge/error paths | `createCaller()` with DeepMock Supabase |
| `utils/*` | Pure output given input | Table-driven tests |
| **tRPC ↔ Supabase** | Procedure executes correct query chain, returns typed data, handles errors | DeepMock Supabase, assert `.from('tasks').update(...).eq(...).single()` |

### 3.1 Mapping of Procedures ➟ Tables ➟ UI

| Procedure | Supabase Table/Function | Primary UI Consumer | Key Assertions |
|-----------|-------------------------|---------------------|----------------|
| `tasks.list` | `public.tasks` | `TaskList` screen | Returns tasks belonging to user ordered by `created_at` |
| `tasks.toggleTask` | `public.tasks`, `public.goals` (progress calc) | Checkbox in `TaskListItem` | Updates status, cascades goal progress, optimistic cache update |
| `goals.list` | `public.goals` | `GoalList` screen | Pagination & total progress |
| `dashboard.getWeeklyProgress` | SQL `select_weekly_progress` function | Dashboard chart | Aggregates by date; ensures 7 entries |
| `habits.completeHabit` | `public.habits`, `public.habit_completions` | `HabitCheckItem` | Inserts completion row, updates streak |

For each mapping we create **router unit tests** (mock Supabase) **and** **hook/UI integration tests** (MSW mocks). This guarantees end-to-end correctness without real network.

---

## 4. Bidirectional Coverage Matrix (Screen → DB and DB → Screen)

> To ensure **holistic** coverage we loop through the stack **twice**:
>
> 1. **Screen-centric** – every user-facing route is traced down to the exact DB rows it eventually mutates or reads.
> 2. **Schema-centric** – every table/function is traced upward to the screens that surface or modify its data.
>
>  Any missing arrow in either loop exposes a **testing gap**.

### 4.1 Screen-Centric Trace

| Screen (Route) | Primary Hooks | tRPC Procedure(s) | Supabase Table(s)/Function(s) | Current Tests? |
|---------------|--------------|-------------------|-------------------------------|----------------|
| `(tabs)/home` → `TaskList` | `useTasks()` | `tasks.list`, `tasks.toggleTask` | `public.tasks`, `public.goals` | ✅ (`TaskList`, `TaskListItem`, router tests) |
| `(tabs)/planner` → `PlannerScreen` | `usePlanner()` | `planner.getPlan`, `tasks.create` | `public.tasks`, `public.planner` | ⚠️ **Missing Planner tests** |
| `(tabs)/compass` → `CompassScreen` | `useGoals()` | `goals.list`, `goals.create` | `public.goals` | ⚠️ Only router tests, no UI integration |
| `(tabs)/rewards` → `RewardsScreen` | `useRewards()` | `rewards.list`, `rewards.claim` | `public.rewards`, `public.reward_claims` | ❌ **No tests** |
| `(tabs)/settings` → `SettingsScreen` | — (local) | — | — | n/a |
| `(auth)/signin` | Supabase Auth UI | — | `auth.users` | Jest-Expo snapshot only |
| `planner/*` nested routes | `useTaskForm()` | `tasks.create`, `tasks.update` | `public.tasks` | ✅ unit but ⚠️ missing form validation tests |

### 4.2 Schema-Centric Trace

| Table / Function | Used By Procedure(s) | Surface Screen(s) | Tests Present? |
|------------------|----------------------|-------------------|----------------|
| `public.tasks` | `tasks.*`, `planner.getPlan` | Home, Planner | ✅ many but form gaps |
| `public.goals` | `goals.*`, `tasks.toggleTask` | Compass, Home (goal badges) | ⚠️ missing Compass UI tests |
| `public.habits` & `public.habit_completions` | `habits.*` | Dashboard HabitCheck | ✅ router, ⚠️ UI integration flaky |
| `public.rewards`, `public.reward_claims` | `rewards.*` | Rewards Screen | ❌ no tests |
| `select_weekly_progress()` | `dashboard.getWeeklyProgress` | Dashboard Charts | ✅ router + chart snapshot |
| `auth.users` | Supabase Auth | Auth stack | Manual e2e only |

### 4.3 Gap List & Action Items

1. **PlannerScreen integration** – build MSW mocks for `planner.getPlan`, test drag-and-drop reorder.
2. **CompassScreen goal list** – RTL tests verifying progress bars and empty-state.
3. **Rewards flow** – unit tests for `rewards` router + UI tests for claim interaction.
4. **Task Form validation** – test Zod schema errors render helper text.
5. **HabitCheckItem race condition** – flaky UI test; stabilise with fake timers.
6. **Auth flow** – light coverage acceptable until E2E added.

> All new tests should follow the Contract Flow (4.4) and update this matrix.

---

## 5. Tooling Configuration

### 5.1 Jest Runners

| Runner | Config | Targets |
|--------|--------|---------|
| **UI** | `jest.config.ui.js` (jest-expo preset) | RN components/screens |
| **Server** | `jest.config.server.js` (ts-jest preset) | tRPC routers, utils |

Both share `jest.setup.js` for globals and custom matchers.

### 5.2 Mocking Conventions

| Dependency | Technique | File |
|------------|-----------|------|
| Supabase client | `jest-mock-extended` deep mocks with chainable builders | `__tests__/server/test-helpers.ts` |
| React Navigation | Manual stubs | `jest.setup.js` |
| Tamagui | `@tamagui/core/testing` → **TODO** replace with custom fallback until package publishes CJS build |
| Network / 3rd-party | MSW request handlers | `__tests__/mocks/server.ts` |

### 5.3 Utilities

* **`createTestCaller(userId?)`** – spins up tRPC caller with desired auth context.
* **`resetSupabaseMocks()`** – zeroes call counts between tests.
* **Fixtures** – stored under `__tests__/fixtures` for large JSON blobs.

### 5.4 Contract & Integration Testing Flow

1. **Router → Supabase Contract**
   * Deep-mock Supabase with `jest-mock-extended` typed by `types/supabase.ts`.
   * Use `expect(mock.from('tasks').update).toHaveBeenCalledWith(/* typed */)`.
2. **Hook → Router Contract** (`src/hooks/trpc/*`)
   * Mock tRPC client with MSW; return fixture data that matches Supabase types.
   * Assert React Query cache keys and optimistic rollback.
3. **UI → Hook Contract**
   * Render component with `TestWrapper` (React Query provider + Navigation).
   * Fire events, assert that mutation hook was called and UI updates (loading states, toasts).

> These layers mirror production call-stack: **UI → Hook → tRPC → Supabase**. Each layer is verified in isolation **and** in pairwise combination to spot contract drift early.

---

## 6. Red-Green-Refactor Workflow

1. **Write a failing test first** (red) – describe desired behaviour.
2. **Make it pass** (green) – minimal implementation.
3. **Refactor safely** – rely on green suite; improve design.
4. **Commit** – each passing step; CI gate rejects red.

> The rule of thumb: *No production code without a failing test*.

---

## 7. Continuous Integration

* **GitHub Actions** workflow `ci.yml` (TBD)
  * Install deps with cache.
  * Run `yarn test:ci` (UI & server) and `expo lint`.
  * Upload coverage to Codecov.
* Pull-request status required before merge.

---

## 8. Future Work

1. **E2E with Detox / Maestro** once UI stabilises.
2. **Visual regression** snapshots via Loki.
3. **Performance** tests for large lists with Flash-List.
4. **Contract testing** of Supabase RPC functions with the staging DB.

---

## 9. Appendix – Why This Approach?

* **Type Safety + Unit Tests** catch ~80 % of bugs before runtime.
* **Jest single toolchain** keeps cognitive load low for both Node & RN.
* **Deep mocks** for Supabase isolate server logic from network flakiness while still asserting correct query chains.
* **MSW** enables true integration tests for React Query hooks without hitting real endpoints.
* **Separation of runners** makes RN tests boot faster; Node tests avoid Metro.
* **TDD** enforces design clarity – API surfaces are defined by test expectations.

> This strategy lets us iterate quickly while maintaining iron-clad confidence across the entire stack.
```

### tsconfig.json
**Path:** tsconfig.json
**Size:** 433 bytes

```json
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "baseUrl": ".",
    "jsx": "react-native",
    "paths": {
      "@/*": [
        "./*"
      ],
      "server/*": [
        "./server/*"
      ]
    },
    "types": [
      "./expo-env.d.ts"
    ]
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts",
    "server/**/*.ts",
    "nativewind-env.d.ts"
  ]
}```


# types

### database.types.ts
**Path:** types/database.types.ts
**Size:** 32547 bytes

```typescript
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  public: {
    Tables: {
      badge_definitions: {
        Row: {
          description: string | null
          icon: string
          id: string
          title: string
        }
        Insert: {
          description?: string | null
          icon: string
          id: string
          title: string
        }
        Update: {
          description?: string | null
          icon?: string
          id?: string
          title?: string
        }
        Relationships: []
      }
      goal_progress_notes: {
        Row: {
          created_at: string
          goal_id: string
          id: string
          note: string
          user_id: string
        }
        Insert: {
          created_at?: string
          goal_id: string
          id?: string
          note: string
          user_id: string
        }
        Update: {
          created_at?: string
          goal_id?: string
          id?: string
          note?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "goal_progress_notes_goal_id_fkey"
            columns: ["goal_id"]
            isOneToOne: false
            referencedRelation: "goals"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "goal_progress_notes_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      goal_values: {
        Row: {
          goal_id: string
          user_id: string
          value_id: string
        }
        Insert: {
          goal_id: string
          user_id: string
          value_id: string
        }
        Update: {
          goal_id?: string
          user_id?: string
          value_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "goal_values_goal_id_fkey"
            columns: ["goal_id"]
            isOneToOne: false
            referencedRelation: "goals"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "goal_values_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "goal_values_value_id_fkey"
            columns: ["value_id"]
            isOneToOne: false
            referencedRelation: "values"
            referencedColumns: ["id"]
          },
        ]
      }
      goals: {
        Row: {
          archived_at: string | null
          created_at: string | null
          description: string | null
          id: string
          progress: number | null
          sort_order: number | null
          target_date: string | null
          title: string
          updated_at: string | null
          user_id: string
        }
        Insert: {
          archived_at?: string | null
          created_at?: string | null
          description?: string | null
          id?: string
          progress?: number | null
          sort_order?: number | null
          target_date?: string | null
          title: string
          updated_at?: string | null
          user_id: string
        }
        Update: {
          archived_at?: string | null
          created_at?: string | null
          description?: string | null
          id?: string
          progress?: number | null
          sort_order?: number | null
          target_date?: string | null
          title?: string
          updated_at?: string | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "goals_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      habit_entries: {
        Row: {
          completed: boolean
          created_at: string
          date: string
          habit_id: string
          id: string
          notes: string | null
          quantity_value: number | null
          user_id: string
        }
        Insert: {
          completed?: boolean
          created_at?: string
          date: string
          habit_id: string
          id?: string
          notes?: string | null
          quantity_value?: number | null
          user_id: string
        }
        Update: {
          completed?: boolean
          created_at?: string
          date?: string
          habit_id?: string
          id?: string
          notes?: string | null
          quantity_value?: number | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "habit_entries_habit_id_fkey"
            columns: ["habit_id"]
            isOneToOne: false
            referencedRelation: "habits"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "habit_entries_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      habit_values: {
        Row: {
          habit_id: string
          user_id: string
          value_id: string
        }
        Insert: {
          habit_id: string
          user_id: string
          value_id: string
        }
        Update: {
          habit_id?: string
          user_id?: string
          value_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "habit_values_habit_id_fkey"
            columns: ["habit_id"]
            isOneToOne: false
            referencedRelation: "habits"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "habit_values_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "habit_values_value_id_fkey"
            columns: ["value_id"]
            isOneToOne: false
            referencedRelation: "values"
            referencedColumns: ["id"]
          },
        ]
      }
      habits: {
        Row: {
          archived_at: string | null
          best_streak: number
          created_at: string
          cue: string | null
          frequency_period: Database["public"]["Enums"]["habit_frequency_period"]
          goal_frequency: number
          goal_quantity: number | null
          goal_unit: string | null
          habit_type: Database["public"]["Enums"]["habit_type"]
          id: string
          recurrence_end_date: string | null
          recurrence_rule: string | null
          reward: string | null
          routine: string | null
          streak: number
          title: string
          updated_at: string
          user_id: string
        }
        Insert: {
          archived_at?: string | null
          best_streak?: number
          created_at?: string
          cue?: string | null
          frequency_period?: Database["public"]["Enums"]["habit_frequency_period"]
          goal_frequency?: number
          goal_quantity?: number | null
          goal_unit?: string | null
          habit_type?: Database["public"]["Enums"]["habit_type"]
          id?: string
          recurrence_end_date?: string | null
          recurrence_rule?: string | null
          reward?: string | null
          routine?: string | null
          streak?: number
          title: string
          updated_at?: string
          user_id: string
        }
        Update: {
          archived_at?: string | null
          best_streak?: number
          created_at?: string
          cue?: string | null
          frequency_period?: Database["public"]["Enums"]["habit_frequency_period"]
          goal_frequency?: number
          goal_quantity?: number | null
          goal_unit?: string | null
          habit_type?: Database["public"]["Enums"]["habit_type"]
          id?: string
          recurrence_end_date?: string | null
          recurrence_rule?: string | null
          reward?: string | null
          routine?: string | null
          streak?: number
          title?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "habits_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      key_results: {
        Row: {
          created_at: string
          goal_id: string
          id: string
          progress: number | null
          title: string
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          goal_id: string
          id?: string
          progress?: number | null
          title: string
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          goal_id?: string
          id?: string
          progress?: number | null
          title?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "key_results_goal_id_fkey"
            columns: ["goal_id"]
            isOneToOne: false
            referencedRelation: "goals"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "key_results_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      point_transactions: {
        Row: {
          created_at: string
          id: string
          points: number
          reason: string
          source_id: string | null
          source_type: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          points: number
          reason: string
          source_id?: string | null
          source_type: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          points?: number
          reason?: string
          source_id?: string | null
          source_type?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "point_transactions_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      principle_values: {
        Row: {
          principle_id: string
          user_id: string
          value_id: string
        }
        Insert: {
          principle_id: string
          user_id: string
          value_id: string
        }
        Update: {
          principle_id?: string
          user_id?: string
          value_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "principle_values_principle_id_fkey"
            columns: ["principle_id"]
            isOneToOne: false
            referencedRelation: "principles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "principle_values_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "principle_values_value_id_fkey"
            columns: ["value_id"]
            isOneToOne: false
            referencedRelation: "values"
            referencedColumns: ["id"]
          },
        ]
      }
      principles: {
        Row: {
          body: string
          created_at: string
          id: string
          sort_order: number | null
          title: string
          updated_at: string
          user_id: string
        }
        Insert: {
          body: string
          created_at?: string
          id?: string
          sort_order?: number | null
          title: string
          updated_at?: string
          user_id: string
        }
        Update: {
          body?: string
          created_at?: string
          id?: string
          sort_order?: number | null
          title?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "principles_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      profiles: {
        Row: {
          created_at: string | null
          email: string
          id: string
          lifetime_points: number
          points: number
          username: string | null
        }
        Insert: {
          created_at?: string | null
          email: string
          id: string
          lifetime_points?: number
          points?: number
          username?: string | null
        }
        Update: {
          created_at?: string | null
          email?: string
          id?: string
          lifetime_points?: number
          points?: number
          username?: string | null
        }
        Relationships: []
      }
      reminders: {
        Row: {
          created_at: string
          id: string
          is_active: boolean
          related_entity_id: string
          related_entity_type: string
          reminder_time: string
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          is_active?: boolean
          related_entity_id: string
          related_entity_type: string
          reminder_time: string
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          is_active?: boolean
          related_entity_id?: string
          related_entity_type?: string
          reminder_time?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "reminders_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      rewards: {
        Row: {
          can_earn_multiple: boolean
          created_at: string
          description: string | null
          id: string
          image_url: string | null
          metadata: Json | null
          name: string
          required_points: number
          type: Database["public"]["Enums"]["reward_type"]
          updated_at: string
        }
        Insert: {
          can_earn_multiple?: boolean
          created_at?: string
          description?: string | null
          id?: string
          image_url?: string | null
          metadata?: Json | null
          name: string
          required_points?: number
          type: Database["public"]["Enums"]["reward_type"]
          updated_at?: string
        }
        Update: {
          can_earn_multiple?: boolean
          created_at?: string
          description?: string | null
          id?: string
          image_url?: string | null
          metadata?: Json | null
          name?: string
          required_points?: number
          type?: Database["public"]["Enums"]["reward_type"]
          updated_at?: string
        }
        Relationships: []
      }
      state_entries: {
        Row: {
          definition_id: string
          entry_timestamp: string
          id: string
          notes: string | null
          user_id: string
          value_numeric: number | null
          value_text: string | null
        }
        Insert: {
          definition_id: string
          entry_timestamp?: string
          id?: string
          notes?: string | null
          user_id: string
          value_numeric?: number | null
          value_text?: string | null
        }
        Update: {
          definition_id?: string
          entry_timestamp?: string
          id?: string
          notes?: string | null
          user_id?: string
          value_numeric?: number | null
          value_text?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "state_entries_definition_id_fkey"
            columns: ["definition_id"]
            isOneToOne: false
            referencedRelation: "tracked_state_defs"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "state_entries_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      task_values: {
        Row: {
          task_id: string
          user_id: string
          value_id: string
        }
        Insert: {
          task_id: string
          user_id: string
          value_id: string
        }
        Update: {
          task_id?: string
          user_id?: string
          value_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "task_values_task_id_fkey"
            columns: ["task_id"]
            isOneToOne: false
            referencedRelation: "tasks"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "task_values_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "task_values_value_id_fkey"
            columns: ["value_id"]
            isOneToOne: false
            referencedRelation: "values"
            referencedColumns: ["id"]
          },
        ]
      }
      tasks: {
        Row: {
          archived_at: string | null
          created_at: string | null
          due: string | null
          goal_id: string | null
          id: string
          notes: string | null
          parent_task_id: string | null
          priority: Database["public"]["Enums"]["task_priority"] | null
          recurrence_end_date: string | null
          recurrence_rule: string | null
          sort_order: number | null
          status: Database["public"]["Enums"]["task_status"]
          title: string
          updated_at: string | null
          user_id: string
        }
        Insert: {
          archived_at?: string | null
          created_at?: string | null
          due?: string | null
          goal_id?: string | null
          id?: string
          notes?: string | null
          parent_task_id?: string | null
          priority?: Database["public"]["Enums"]["task_priority"] | null
          recurrence_end_date?: string | null
          recurrence_rule?: string | null
          sort_order?: number | null
          status?: Database["public"]["Enums"]["task_status"]
          title: string
          updated_at?: string | null
          user_id: string
        }
        Update: {
          archived_at?: string | null
          created_at?: string | null
          due?: string | null
          goal_id?: string | null
          id?: string
          notes?: string | null
          parent_task_id?: string | null
          priority?: Database["public"]["Enums"]["task_priority"] | null
          recurrence_end_date?: string | null
          recurrence_rule?: string | null
          sort_order?: number | null
          status?: Database["public"]["Enums"]["task_status"]
          title?: string
          updated_at?: string | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "tasks_goal_id_fkey"
            columns: ["goal_id"]
            isOneToOne: false
            referencedRelation: "goals"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tasks_parent_task_id_fkey"
            columns: ["parent_task_id"]
            isOneToOne: false
            referencedRelation: "tasks"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tasks_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      tracked_state_defs: {
        Row: {
          active: boolean
          created_at: string
          custom_labels: string[] | null
          id: string
          name: string
          priority: number
          scale: Database["public"]["Enums"]["tracked_state_scale"]
          target_max_value: number | null
          target_min_value: number | null
          updated_at: string
          user_id: string
        }
        Insert: {
          active?: boolean
          created_at?: string
          custom_labels?: string[] | null
          id?: string
          name: string
          priority?: number
          scale: Database["public"]["Enums"]["tracked_state_scale"]
          target_max_value?: number | null
          target_min_value?: number | null
          updated_at?: string
          user_id: string
        }
        Update: {
          active?: boolean
          created_at?: string
          custom_labels?: string[] | null
          id?: string
          name?: string
          priority?: number
          scale?: Database["public"]["Enums"]["tracked_state_scale"]
          target_max_value?: number | null
          target_min_value?: number | null
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "tracked_state_defs_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      tracked_state_values: {
        Row: {
          state_id: string
          user_id: string
          value_id: string
        }
        Insert: {
          state_id: string
          user_id: string
          value_id: string
        }
        Update: {
          state_id?: string
          user_id?: string
          value_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "tracked_state_values_state_id_fkey"
            columns: ["state_id"]
            isOneToOne: false
            referencedRelation: "tracked_state_defs"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tracked_state_values_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "tracked_state_values_value_id_fkey"
            columns: ["value_id"]
            isOneToOne: false
            referencedRelation: "values"
            referencedColumns: ["id"]
          },
        ]
      }
      user_badges: {
        Row: {
          badge_id: string
          earned_at: string
          progress: number | null
          user_id: string
        }
        Insert: {
          badge_id: string
          earned_at?: string
          progress?: number | null
          user_id: string
        }
        Update: {
          badge_id?: string
          earned_at?: string
          progress?: number | null
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "user_badges_badge_id_fkey"
            columns: ["badge_id"]
            isOneToOne: false
            referencedRelation: "badge_definitions"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "user_badges_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      user_rewards: {
        Row: {
          created_at: string
          earned_at: string
          id: string
          metadata: Json | null
          points_spent: number
          reward_id: string
          reward_type: string | null
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          earned_at?: string
          id?: string
          metadata?: Json | null
          points_spent?: number
          reward_id: string
          reward_type?: string | null
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          earned_at?: string
          id?: string
          metadata?: Json | null
          points_spent?: number
          reward_id?: string
          reward_type?: string | null
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "user_rewards_reward_id_fkey"
            columns: ["reward_id"]
            isOneToOne: false
            referencedRelation: "rewards"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "user_rewards_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      user_settings: {
        Row: {
          created_at: string
          id: string
          notification_preferences: Json
          ui_preferences: Json
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          notification_preferences?: Json
          ui_preferences?: Json
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          notification_preferences?: Json
          ui_preferences?: Json
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "user_settings_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
      values: {
        Row: {
          color: string | null
          created_at: string
          description: string | null
          domain_id: string | null
          id: string
          sort_order: number | null
          title: string
          updated_at: string
          user_id: string
        }
        Insert: {
          color?: string | null
          created_at?: string
          description?: string | null
          domain_id?: string | null
          id?: string
          sort_order?: number | null
          title: string
          updated_at?: string
          user_id: string
        }
        Update: {
          color?: string | null
          created_at?: string
          description?: string | null
          domain_id?: string | null
          id?: string
          sort_order?: number | null
          title?: string
          updated_at?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "values_user_id_fkey"
            columns: ["user_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
        ]
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      [_ in never]: never
    }
    Enums: {
      habit_frequency_period: "day" | "week" | "month"
      habit_type: "boolean" | "quantity"
      reward_type: "badge" | "achievement" | "item" | "discount"
      task_priority: "low" | "medium" | "high"
      task_status: "todo" | "doing" | "done" | "blocked" | "pending"
      tracked_state_scale: "1-5" | "low-high" | "custom"
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type DefaultSchema = Database[Extract<keyof Database, "public">]

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof (Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        Database[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? (Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      Database[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof Database },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof Database },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends { schema: keyof Database }
  ? Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never

export const Constants = {
  public: {
    Enums: {
      habit_frequency_period: ["day", "week", "month"],
      habit_type: ["boolean", "quantity"],
      reward_type: ["badge", "achievement", "item", "discount"],
      task_priority: ["low", "medium", "high"],
      task_status: ["todo", "doing", "done", "blocked", "pending"],
      tracked_state_scale: ["1-5", "low-high", "custom"],
    },
  },
} as const
```


# utils

### api-types.ts
**Path:** utils/api-types.ts
**Size:** 595 bytes

```typescript
/**
 * This file was auto-generated by the generate-trpc-types script.
 * Do not edit manually! Instead, run the script again.
 */

import type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from '../server/src/router';

/**
 * Inference helper for inputs.
 *
 * @example type HelloInput = RouterInputs['example']['hello']
 */
export type RouterInputs = inferRouterInputs<AppRouter>;

/**
 * Inference helper for outputs.
 *
 * @example type HelloOutput = RouterOutputs['example']['hello']
 */
export type RouterOutputs = inferRouterOutputs<AppRouter>;
```

### auth.ts
**Path:** utils/auth.ts
**Size:** 1268 bytes

```typescript
import { supabase } from './supabase';
import { router } from 'expo-router';

/**
 * Logs the user out and redirects to the login screen
 */
export async function logout() {
  try {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
    
    // Navigate to login screen
    router.replace('/auth/login');
  } catch (error) {
    console.error('Error signing out:', error);
    // Force navigation even if there was an error
    router.replace('/auth/login');
  }
}

/**
 * Gets the current user's profile data
 */
export async function getUserProfile() {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) return null;
    
    // If we have a user, get their profile from the profiles table
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', user.id)
      .single();
    
    if (error) {
      // If profile doesn't exist yet, return basic user info
      return {
        id: user.id,
        email: user.email,
        username: user.user_metadata?.username || 'User',
        created_at: user.created_at,
      };
    }
    
    return data;
  } catch (error) {
    console.error('Error getting user profile:', error);
    return null;
  }
} ```

### colors.ts
**Path:** utils/colors.ts
**Size:** 5038 bytes

```typescript
import { useTheme } from 'tamagui';

/**
 * Semantic color tokens that map to theme variables
 */
export const semanticTokens = {
  // Background colors
  background: {
    /** Main app background */
    app: '$background',
    /** Card/surface background */
    card: '$backgroundHover',
    /** Secondary surface background */
    secondary: '$backgroundPress',
    /** Tertiary surface background */
    tertiary: '$backgroundStrong',
    /** Input background */
    input: '$backgroundTransparent',
  },
  
  // Foreground/content colors
  content: {
    /** Primary text */
    primary: '$color',
    /** Secondary/dimmed text */
    secondary: '$colorTransparent',
    /** Subtle text - least emphasis */
    subtle: '$colorTransparent2',
    /** Disabled text */
    disabled: '$colorTransparent3',
  },
  
  // Border colors
  border: {
    /** Default border */
    default: '$borderColor',
    /** Focused border */
    focus: '$borderColorFocus',
    /** Border for hover state */
    hover: '$borderColorHover',
  },
  
  // Status colors
  status: {
    /** Success indicators */
    success: '$green10',
    /** Error indicators */
    error: '$red10',
    /** Warning indicators */
    warning: '$yellow10',
    /** Information indicators */
    info: '$blue10',
  },
  
  // Brand colors (adjust to match your brand)
  brand: {
    /** Primary brand color */
    primary: '$blue10',
    /** Secondary brand color */
    secondary: '$purple10',
    /** Accent brand color */
    accent: '$green10',
  }
};

/**
 * Hook that provides access to theme-aware colors from the semantic tokens
 * @returns An object with semantic color tokens mapped to actual theme colors
 */
export function useColors() {
  const theme = useTheme();
  
  return {
    background: {
      app: theme?.background?.get() || '#FFFFFF',
      card: theme?.backgroundHover?.get() || '#F3F4F6',
      secondary: theme?.backgroundPress?.get() || '#E5E7EB',
      tertiary: theme?.backgroundStrong?.get() || '#D1D5DB',
      input: theme?.backgroundTransparent?.get() || '#FFFFFF',
    },
    content: {
      primary: theme?.color?.get() || '#111827',
      secondary: theme?.colorTransparent?.get() || '#4B5563',
      subtle: theme?.colorTransparent2?.get() || theme?.colorTransparent?.get() || '#6B7280',
      disabled: theme?.colorTransparent3?.get() || theme?.colorTransparent?.get() || '#9CA3AF',
    },
    border: {
      default: theme?.borderColor?.get() || '#E5E7EB',
      focus: theme?.borderColorFocus?.get() || '#93C5FD',
      hover: theme?.borderColorHover?.get() || '#BFDBFE',
    },
    status: {
      success: theme?.green10?.get() || '#10B981',
      error: theme?.red10?.get() || '#EF4444',
      warning: theme?.yellow10?.get() || '#F59E0B',
      info: theme?.blue10?.get() || '#3B82F6',
    },
    brand: {
      primary: theme?.blue10?.get() || '#3B82F6',
      secondary: theme?.purple10?.get() || '#8B5CF6',
      accent: theme?.green10?.get() || '#10B981',
    }
  };
}

/**
 * Helper function to handle opacity for colors
 * @param hex Hex color code
 * @param alpha Opacity (0-1)
 * @returns RGBA color string
 */
export function withOpacity(hex: string, alpha: number): string {
  // Extract RGB components from hex
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

/**
 * Palette with static color values for when theme context is not available
 * These should be used sparingly, prefer the useColors hook when possible
 */
export const palette = {
  // Main UI colors
  black: '#000000',
  white: '#FFFFFF',
  
  // Grays
  gray: {
    50: '#F9FAFB',
    100: '#F3F4F6',
    200: '#E5E7EB',
    300: '#D1D5DB',
    400: '#9CA3AF',
    500: '#6B7280',
    600: '#4B5563',
    700: '#374151',
    800: '#1F2937',
    900: '#111827',
  },
  
  // Blues
  blue: {
    50: '#EFF6FF',
    100: '#DBEAFE',
    200: '#BFDBFE',
    300: '#93C5FD',
    400: '#60A5FA',
    500: '#3B82F6',
    600: '#2563EB',
    700: '#1D4ED8',
    800: '#1E40AF',
    900: '#1E3A8A',
  },
  
  // Greens
  green: {
    50: '#ECFDF5',
    100: '#D1FAE5',
    200: '#A7F3D0',
    300: '#6EE7B7',
    400: '#34D399',
    500: '#10B981',
    600: '#059669',
    700: '#047857',
    800: '#065F46',
    900: '#064E3B',
  },
  
  // Reds
  red: {
    50: '#FEF2F2',
    100: '#FEE2E2',
    200: '#FECACA',
    300: '#FCA5A5',
    400: '#F87171',
    500: '#EF4444',
    600: '#DC2626',
    700: '#B91C1C',
    800: '#991B1B',
    900: '#7F1D1D',
  },
  
  // Yellows
  yellow: {
    50: '#FFFBEB',
    100: '#FEF3C7',
    200: '#FDE68A',
    300: '#FCD34D',
    400: '#FBBF24',
    500: '#F59E0B',
    600: '#D97706',
    700: '#B45309',
    800: '#92400E',
    900: '#78350F',
  },
  
  // Purples
  purple: {
    50: '#F5F3FF',
    100: '#EDE9FE',
    200: '#DDD6FE',
    300: '#C4B5FD',
    400: '#A78BFA',
    500: '#8B5CF6',
    600: '#7C3AED',
    700: '#6D28D9',
    800: '#5B21B6',
    900: '#4C1D95',
  },
}; ```

### generated-hooks.ts
**Path:** utils/generated-hooks.ts
**Size:** 1330 bytes

```typescript
/**
 * GENERATED FILE - DO NOT EDIT
 * This file is automatically generated by the generate-trpc-client script.
 * To update this file, run: npm run generate-hooks
 */

import { trpc } from './trpc';
import { RouterInputs, RouterOutputs } from '../server/src/types/trpc-types';

/**
 * Type-safe hooks for TRPC procedures
 */

// user hooks
export const useUser = {
  // Add strongly typed hooks here
};

// dashboard hooks
export const useDashboard = {
  // Add strongly typed hooks here
};

// value hooks
export const useValue = {
  // Add strongly typed hooks here
};

// principle hooks
export const usePrinciple = {
  // Add strongly typed hooks here
};

// goal hooks
export const useGoal = {
  // Add strongly typed hooks here
};

// task hooks
export const useTask = {
  // Add strongly typed hooks here
};

// habit hooks
export const useHabit = {
  // Add strongly typed hooks here
};

// state hooks
export const useState = {
  // Add strongly typed hooks here
};

// rewards hooks
export const useRewards = {
  // Add strongly typed hooks here
};

// reminder hooks
export const useReminder = {
  // Add strongly typed hooks here
};

// goalProgressNote hooks
export const useGoalProgressNote = {
  // Add strongly typed hooks here
};


// Example type usage
type GreetingOutput = RouterOutputs['greeting']['hello'];
```

### haptics.ts
**Path:** utils/haptics.ts
**Size:** 1275 bytes

```typescript
import * as Haptics from 'expo-haptics';

/**
 * Haptic feedback utilities for iOS-style tactile feedback
 * Maps directly to iOS UIFeedbackGenerator patterns
 */
export const haptics = {
  /**
   * Light impact - subtle tap for small UI elements (buttons, toggles)
   */
  light: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light),
  
  /**
   * Medium impact - standard tap for medium elements (picker selections)
   */
  medium: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium),
  
  /**
   * Heavy impact - stronger bump for significant actions
   */
  heavy: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy),
  
  /**
   * Selection feedback - subtle tap for navigating through options
   */
  selection: () => Haptics.selectionAsync(),
  
  /**
   * Success notification - double-tap vibration for completed actions
   */
  success: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success),
  
  /**
   * Warning notification - attention-grabbing pattern for warnings
   */
  warning: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning),
  
  /**
   * Error notification - strong buzz pattern for errors
   */
  error: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error),
}; ```

### mock-api.ts
**Path:** utils/mock-api.ts
**Size:** 2338 bytes

```typescript
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

// Initialize tRPC for our mock API
const t = initTRPC.create();

// Export a procedure builder
const router = t.router;
const publicProcedure = t.procedure;

// Example router with some procedures
export const appRouter = router({
  greeting: {
    hello: publicProcedure
      .input(z.object({ name: z.string().optional() }))
      .query(({ input }) => {
        return {
          greeting: `Hello ${input.name ?? 'world'}`,
        };
      }),
    goodbye: publicProcedure
      .query(() => {
        return {
          greeting: 'Goodbye!',
        };
      }),
  },
  user: {
    get: publicProcedure
      .input(z.object({ id: z.string() }))
      .query(({ input }) => {
        return {
          id: input.id,
          name: 'Mock User',
        };
      }),
    list: publicProcedure
      .query(() => {
        return [
          { id: '1', name: 'Mock User 1' },
          { id: '2', name: 'Mock User 2' },
        ];
      }),
  },
  auth: {
    refreshToken: publicProcedure
      .input(z.object({ refreshToken: z.string() }))
      .mutation(async ({ input }) => {
        console.log('Mock API: refreshToken called with', input.refreshToken);
        // Simulate checking refresh token and issuing new ones
        await new Promise(resolve => setTimeout(resolve, 300));
        if (input.refreshToken === 'valid-refresh-token') { // Example valid token
          return {
            accessToken: `mock-access-${Date.now()}`,
            refreshToken: `mock-refresh-${Date.now()}`,
          };
        } else {
          // Throw error for invalid refresh token
          throw new Error('Invalid refresh token'); 
        }
      }),
    // Add login/logout mutations here later
  },
  item: {
    add: publicProcedure
      .input(z.object({ name: z.string() }))
      .mutation(async ({ input }) => {
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 500));
        // In a real backend, save to DB
        console.log('Mock API: Adding item', input);
        return {
          id: Math.random().toString(36).substring(7), // Generate random ID
          name: input.name,
          status: 'added'
        };
      }),
  },
});

// Export type router type
export type AppRouter = typeof appRouter; ```

### nats-client.ts
**Path:** utils/nats-client.ts
**Size:** 4635 bytes

```typescript
import { QueryClient } from '@tanstack/react-query';
import { connect, type ConnectionOptions, type NatsConnection, StringCodec } from 'nats.ws';

// Codec for encoding/decoding NATS messages
const sc = StringCodec();

// Type for cache update handlers
type CacheUpdateHandler = (data: any) => void;

// Global handlers for different subjects
const handlers: Record<string, CacheUpdateHandler[]> = {};

// Connection state
let natsConnection: NatsConnection | null = null;
let queryClient: QueryClient | null = null;
let isConnecting = false;

/**
 * Initialize the NATS client and connect to the server
 */
export async function initNatsClient(
  url: string, 
  qc: QueryClient,
  options: Partial<ConnectionOptions> = {}
): Promise<NatsConnection> {
  if (natsConnection) {
    return natsConnection;
  }
  
  if (isConnecting) {
    throw new Error('NATS connection is already in progress');
  }
  
  isConnecting = true;
  
  try {
    // Set the query client for cache updates
    queryClient = qc;
    
    // Connect to NATS server
    natsConnection = await connect({
      servers: url,
      // Add required polyfills for React Native
      // These would need to be properly implemented in a real app
      ...options,
    });
    
    console.log('Connected to NATS server');
    
    // Setup ping interval to keep connection alive
    const pingInterval = setInterval(() => {
      if (natsConnection && !natsConnection.isClosed) {
        // Note: Using a custom ping mechanism instead of the built-in one
        try {
          const start = Date.now();
          // Simple ping using a request to a dummy subject
          natsConnection.request('_PING_', undefined, { timeout: 1000 })
            .then(() => {
              const latency = Date.now() - start;
              console.log(`NATS server latency: ${latency}ms`);
            })
            .catch((err: Error) => {
              console.error('NATS ping error:', err.message);
            });
        } catch (err) {
          const error = err as Error;
          console.error('NATS ping error:', error.message);
        }
      } else {
        clearInterval(pingInterval);
      }
    }, 30000);
    
    // Handle connection close
    natsConnection.closed().then(() => {
      console.log('NATS connection closed');
      natsConnection = null;
      clearInterval(pingInterval);
      // Could implement reconnection logic here
    });
    
    return natsConnection;
  } catch (error) {
    console.error('Failed to connect to NATS server:', error);
    isConnecting = false;
    throw error;
  }
}

/**
 * Subscribe to a NATS subject and update the React Query cache
 */
export async function subscribeWithCache(
  subject: string,
  queryKey: unknown[],
  updateType: 'invalidate' | 'setData' = 'invalidate'
): Promise<() => void> {
  if (!natsConnection) {
    throw new Error('NATS client not initialized');
  }
  
  if (!queryClient) {
    throw new Error('QueryClient not set');
  }
  
  // Create subscription
  const subscription = natsConnection.subscribe(subject);
  
  // Setup message handler
  (async () => {
    for await (const msg of subscription) {
      try {
        const data = JSON.parse(sc.decode(msg.data));
        
        if (updateType === 'invalidate') {
          // Invalidate the cache for this query key
          queryClient.invalidateQueries({ queryKey });
        } else {
          // Update the cache directly
          queryClient.setQueryData(queryKey, data);
        }
        
        // Call any custom handlers
        if (handlers[subject]) {
          handlers[subject].forEach(handler => handler(data));
        }
      } catch (error) {
        const err = error as Error;
        console.error(`Error handling message for ${subject}:`, err.message);
      }
    }
  })();
  
  // Return unsubscribe function
  return () => {
    subscription.unsubscribe();
  };
}

/**
 * Add a custom handler for a subject
 */
export function addSubjectHandler(subject: string, handler: CacheUpdateHandler): () => void {
  if (!handlers[subject]) {
    handlers[subject] = [];
  }
  
  handlers[subject].push(handler);
  
  // Return a function to remove the handler
  return () => {
    if (handlers[subject]) {
      handlers[subject] = handlers[subject].filter(h => h !== handler);
    }
  };
}

/**
 * Get the NATS connection
 */
export function getNatsConnection(): NatsConnection | null {
  return natsConnection;
}

/**
 * Close the NATS connection
 */
export async function closeNatsConnection(): Promise<void> {
  if (natsConnection) {
    await natsConnection.close();
    natsConnection = null;
  }
} ```

### offline-mutations.ts
**Path:** utils/offline-mutations.ts
**Size:** 4223 bytes

```typescript
import AsyncStorage from '@react-native-async-storage/async-storage';
import {
  QueryClient,
  Mutation,
  MutationCache,
  onlineManager,
} from '@tanstack/react-query';
import {
  persistQueryClient,
  PersistQueryClientOptions,
} from '@tanstack/react-query-persist-client';
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister';
import { useNetInfo, type NetInfoSubscription } from '@react-native-community/netinfo';
import { useEffect, useRef } from 'react';
import NetInfo from '@react-native-community/netinfo';

// Create a persister for React Query (AsyncStorage-based)
export const asyncStoragePersister = createAsyncStoragePersister({
  storage: AsyncStorage,
});

/**
 * React Query persistence options for offline support
 */
export const reactQueryPersistOptions: Omit<PersistQueryClientOptions, 'queryClient'> = {
  persister: asyncStoragePersister,
  // Add custom serialization/deserialization if needed
  // We want to persist mutations especially for offline support
  buster: 'v1',
  dehydrateOptions: {
    shouldDehydrateMutation: () => true,
  },
};

/**
 * Hook to resume paused mutations when the device comes back online
 */
export function useResumeNetworkMutations(queryClient: QueryClient) {
  const netInfo = useNetInfo();
  const previousNetworkState = useRef(netInfo.isConnected);
  
  // Update React Query's online status manager
  useEffect(() => {
    onlineManager.setOnline(netInfo.isConnected === true);
  }, [netInfo.isConnected]);
  
  useEffect(() => {
    const isConnectedNow = netInfo.isConnected === true;
    const wasConnected = previousNetworkState.current === true;
    
    // If we just reconnected to the network
    if (isConnectedNow && !wasConnected) {
      console.log('Internet connection restored, resuming paused mutations');
      
      // Resume any paused mutations
      queryClient.resumePausedMutations().then(() => {
        // After resuming mutations, invalidate queries to refresh data
        queryClient.invalidateQueries();
      }).catch((error: Error) => {
        console.error('Error resuming mutations:', error.message);
      });
    }
    
    // Update our ref
    previousNetworkState.current = isConnectedNow;
  }, [netInfo.isConnected, queryClient]);
}

/**
 * Add a visual flag to offline-created items for UI feedback
 */
export function markItemAsOffline<T>(item: T): T & { isOffline: boolean } {
  return {
    ...item,
    isOffline: true,
  };
}

/**
 * Remove the offline flag from an item once it's synced
 */
export function markItemAsSynced<T extends { isOffline?: boolean }>(item: T): T {
  const result = { ...item };
  delete result.isOffline;
  return result;
}

/**
 * Get all pending mutations from the mutation cache
 */
export function getPendingMutations(mutationCache: MutationCache): Mutation[] {
  return mutationCache.getAll().filter((mutation: any) => 
    mutation?.state?.status === 'loading' || 
    (mutation?.state?.status === 'error' && mutation?.state?.isPaused)
  );
}

/**
 * Configure the query client for offline support and network state management
 */
export function configureQueryClientForOffline(queryClient: QueryClient): NetInfoSubscription {
  // Listen to network status changes and update onlineManager
  const unsubscribe = NetInfo.addEventListener(state => {
    onlineManager.setOnline(state.isConnected === true);
  });
  
  // When a mutation fails due to network error, pause it instead of failing
  queryClient.getMutationCache().config.onError = (error: unknown, _variables: unknown, _context: unknown, mutation: any) => {
    // Check if the error is a network error
    if (
      error instanceof Error && 
      (
        error.message.includes('network') || 
        error.message.includes('Network Error') ||
        error.message.includes('Failed to fetch')
      )
    ) {
      console.log('Network error detected, pausing mutation for later retry');
      
      // Pause the mutation instead of failing permanently
      mutation.state.isPaused = true;
    }
  };
  
  // Set up persistence
  persistQueryClient({
    queryClient,
    ...reactQueryPersistOptions,
  });

  // Return unsubscribe function for cleanup
  return unsubscribe;
} ```

### offline-sync.ts
**Path:** utils/offline-sync.ts
**Size:** 7701 bytes

```typescript
import AsyncStorage from '@react-native-async-storage/async-storage';
import NetInfo from '@react-native-community/netinfo';
import { queryClient } from './query-client';
import { supabase } from './supabase';

// Keys for offline data
const OFFLINE_MUTATIONS_KEY = 'aether-offline-mutations';
const PENDING_ITEMS_KEY = 'aether-pending-items';

// Types
export interface PendingItem {
  id: string;
  type: string;
  data: any;
  createdAt: number;
  isNotSynced: boolean;
}

interface OfflineMutation {
  id: string;
  type: 'create' | 'update' | 'delete';
  entity: string;
  data: any;
  timestamp: number;
}

/**
 * Save a mutation to be processed when back online
 */
export async function saveOfflineMutation(
  type: 'create' | 'update' | 'delete',
  entity: string,
  data: any
): Promise<string> {
  try {
    // Generate a temporary ID for new items
    const id = `temp-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
    
    // Create mutation object
    const mutation: OfflineMutation = {
      id,
      type,
      entity,
      data,
      timestamp: Date.now(),
    };
    
    // Get existing mutations
    const existingMutationsStr = await AsyncStorage.getItem(OFFLINE_MUTATIONS_KEY);
    const existingMutations: OfflineMutation[] = existingMutationsStr 
      ? JSON.parse(existingMutationsStr) 
      : [];
    
    // Add new mutation
    existingMutations.push(mutation);
    
    // Save mutations back to storage
    await AsyncStorage.setItem(OFFLINE_MUTATIONS_KEY, JSON.stringify(existingMutations));
    
    // Also add to pending items for UI
    if (type === 'create' || type === 'update') {
      await addToPendingItems(id, entity, data);
    }
    
    return id;
  } catch (error) {
    console.error('Error saving offline mutation:', error);
    throw error;
  }
}

/**
 * Add an item to the pending items list for UI display
 */
async function addToPendingItems(id: string, type: string, data: any): Promise<void> {
  try {
    const existingItemsStr = await AsyncStorage.getItem(PENDING_ITEMS_KEY);
    const existingItems: PendingItem[] = existingItemsStr 
      ? JSON.parse(existingItemsStr)
      : [];
    
    // Create a pending item
    const pendingItem: PendingItem = {
      id,
      type,
      data,
      createdAt: Date.now(),
      isNotSynced: true,
    };
    
    // Add to list
    existingItems.push(pendingItem);
    
    // Save back to storage
    await AsyncStorage.setItem(PENDING_ITEMS_KEY, JSON.stringify(existingItems));
  } catch (error) {
    console.error('Error adding to pending items:', error);
  }
}

/**
 * Get all pending items for a specific type
 */
export async function getPendingItems(type: string): Promise<PendingItem[]> {
  try {
    const itemsStr = await AsyncStorage.getItem(PENDING_ITEMS_KEY);
    if (!itemsStr) return [];
    
    const items: PendingItem[] = JSON.parse(itemsStr);
    return items.filter(item => item.type === type);
  } catch (error) {
    console.error('Error getting pending items:', error);
    return [];
  }
}

/**
 * Synchronize offline mutations with the server
 */
export async function syncOfflineMutations(): Promise<boolean> {
  try {
    // Check if we're online
    const netInfo = await NetInfo.fetch();
    if (!netInfo.isConnected || netInfo.isInternetReachable === false) {
      console.log('Not connected to the internet, skipping sync');
      return false;
    }
    
    // Get all pending mutations
    const mutationsStr = await AsyncStorage.getItem(OFFLINE_MUTATIONS_KEY);
    if (!mutationsStr) return true; // Nothing to sync
    
    const mutations: OfflineMutation[] = JSON.parse(mutationsStr);
    if (!mutations.length) return true; // Nothing to sync
    
    console.log(`Syncing ${mutations.length} offline mutations...`);
    
    // Process each mutation in order
    const results = await Promise.allSettled(
      mutations.map(async (mutation) => {
        try {
          switch (mutation.type) {
            case 'create':
              return await processMutation('create', mutation);
            case 'update':
              return await processMutation('update', mutation);
            case 'delete':
              return await processMutation('delete', mutation);
            default:
              console.error('Unknown mutation type:', mutation.type);
              return false;
          }
        } catch (error) {
          console.error('Error processing mutation:', error);
          return false;
        }
      })
    );
    
    // Check results
    const allSucceeded = results.every(
      result => result.status === 'fulfilled' && result.value === true
    );
    
    if (allSucceeded) {
      // Clear pending mutations if all succeeded
      await AsyncStorage.removeItem(OFFLINE_MUTATIONS_KEY);
      await AsyncStorage.removeItem(PENDING_ITEMS_KEY);
      
      // Invalidate queries to refresh data
      queryClient.invalidateQueries();
      
      return true;
    } else {
      // Some mutations failed, remove the successful ones
      const successfulMutationIndexes = results.map((result, index) => 
        result.status === 'fulfilled' && result.value === true ? index : -1
      ).filter(index => index !== -1);
      
      const remainingMutations = mutations.filter(
        (_, index) => !successfulMutationIndexes.includes(index)
      );
      
      // Save remaining mutations
      await AsyncStorage.setItem(
        OFFLINE_MUTATIONS_KEY, 
        JSON.stringify(remainingMutations)
      );
      
      // Refresh query data
      queryClient.invalidateQueries();
      
      return false;
    }
  } catch (error) {
    console.error('Error syncing offline mutations:', error);
    return false;
  }
}

/**
 * Process a single mutation against the server
 */
async function processMutation(
  type: 'create' | 'update' | 'delete',
  mutation: OfflineMutation
): Promise<boolean> {
  try {
    // Get the entity table name
    const table = mutation.entity;
    
    switch (type) {
      case 'create': {
        // For create, we remove any temp id and insert the record
        const { id, ...data } = mutation.data;
        const { data: responseData, error } = await supabase
          .from(table)
          .insert(data)
          .select();
          
        if (error) throw error;
        return true;
      }
      
      case 'update': {
        // For update, we update the record by ID
        const { id, ...data } = mutation.data;
        const { error } = await supabase
          .from(table)
          .update(data)
          .eq('id', id);
          
        if (error) throw error;
        return true;
      }
      
      case 'delete': {
        // For delete, we delete the record by ID
        const { error } = await supabase
          .from(table)
          .delete()
          .eq('id', mutation.data.id);
          
        if (error) throw error;
        return true;
      }
      
      default:
        return false;
    }
  } catch (error) {
    console.error('Error processing mutation:', error);
    return false;
  }
}

/**
 * Hook up background sync when app comes online
 */
export function setupBackgroundSync(): () => void {
  // Subscribe to network changes
  const unsubscribe = NetInfo.addEventListener(state => {
    // When we go from offline to online, sync mutations
    if (state.isConnected && state.isInternetReachable !== false) {
      syncOfflineMutations()
        .then(success => {
          console.log('Background sync completed:', success ? 'success' : 'with errors');
        })
        .catch(error => {
          console.error('Background sync failed:', error);
        });
    }
  });
  
  return unsubscribe;
} ```

### query-client.ts
**Path:** utils/query-client.ts
**Size:** 2570 bytes

```typescript
import { QueryClient } from '@tanstack/react-query';
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister';
import AsyncStorage from '@react-native-async-storage/async-storage';
import NetInfo from '@react-native-community/netinfo';
import { onlineManager } from '@tanstack/react-query';

// Create a client
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // Default stale time of 5 minutes
      staleTime: 1000 * 60 * 5,
      // When offline, keep data fresh for 24 hours (cacheTime was renamed to gcTime)
      gcTime: 1000 * 60 * 60 * 24,
      // Retry failed queries 3 times
      retry: 3,
      // Retry with exponential backoff
      retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
      // Don't refetch on window focus for mobile
      refetchOnWindowFocus: false,
      // Show stale data while fetching new data (renamed from keepPreviousData)
      placeholderData: 'keepPrevious',
    },
    mutations: {
      // Retry failed mutations 3 times
      retry: 3,
      // Enable offline mutations
      networkMode: 'offlineFirst',
    },
  },
});

// Create a persister
export const persister = createAsyncStoragePersister({
  storage: AsyncStorage,
  key: 'aether-query-cache-v1',
  // Only persist queries with a longer cacheTime
  throttleTime: 1000,
  // SerDe for serializing/deserializing the data
  serialize: data => JSON.stringify(data),
  deserialize: data => JSON.parse(data),
});

/**
 * Initialize network monitoring for the query client
 * Call this on app startup to enable online/offline detection
 */
export function initializeNetworkMonitoring(): () => void {
  // Subscribe to network status changes
  const unsubscribe = NetInfo.addEventListener(state => {
    onlineManager.setOnline(
      state.isConnected != null && 
      state.isConnected && 
      Boolean(state.isInternetReachable)
    );
  });

  // Initialize once at startup - check if online
  NetInfo.fetch().then(state => {
    onlineManager.setOnline(
      state.isConnected != null && 
      state.isConnected && 
      Boolean(state.isInternetReachable)
    );
  });

  return unsubscribe;
}

/**
 * Resume any paused mutations when the app comes back online
 * 
 * @returns A promise that resolves when mutations are resumed
 */
export async function resumeMutationsAndInvalidate(): Promise<void> {
  try {
    await queryClient.resumePausedMutations();
    queryClient.invalidateQueries();
  } catch (error) {
    console.error('Error resuming mutations:', error);
  }
} ```

### settings.ts
**Path:** utils/settings.ts
**Size:** 1918 bytes

```typescript
import * as SecureStore from 'expo-secure-store';
import { Platform } from 'react-native';

// Settings keys
export const APP_SETTINGS_KEY = 'aether_app_settings';

// Default settings
const DEFAULT_SETTINGS = {
  enableNotifications: true,
  enableDarkMode: null, // null means "use system setting"
  enableOfflineMode: true,
  syncOnCellular: true,
  lastSyncTimestamp: null,
};

// Type for app settings
export type AppSettings = typeof DEFAULT_SETTINGS;

/**
 * Get app settings from secure storage
 */
export async function getSettings(): Promise<AppSettings> {
  try {
    const storedSettings = await SecureStore.getItemAsync(APP_SETTINGS_KEY);
    if (!storedSettings) return DEFAULT_SETTINGS;
    
    return { ...DEFAULT_SETTINGS, ...JSON.parse(storedSettings) };
  } catch (error) {
    console.error('Error getting settings:', error);
    return DEFAULT_SETTINGS;
  }
}

/**
 * Save app settings to secure storage
 */
export async function saveSettings(settings: Partial<AppSettings>): Promise<void> {
  try {
    const currentSettings = await getSettings();
    const newSettings = { ...currentSettings, ...settings };
    
    await SecureStore.setItemAsync(
      APP_SETTINGS_KEY, 
      JSON.stringify(newSettings)
    );
  } catch (error) {
    console.error('Error saving settings:', error);
  }
}

/**
 * Update a single setting
 */
export async function updateSetting<K extends keyof AppSettings>(
  key: K, 
  value: AppSettings[K]
): Promise<void> {
  await saveSettings({ [key]: value } as Partial<AppSettings>);
}

/**
 * Get app version
 */
export function getAppVersion(): string {
  // In a real app, you would use expo-constants to get the app version
  // import Constants from 'expo-constants';
  // return Constants.expoConfig.version;
  return '1.0.0';
}

/**
 * Get platform information
 */
export function getPlatformInfo(): string {
  return `${Platform.OS} ${Platform.Version}`;
} ```

### supabase.ts
**Path:** utils/supabase.ts
**Size:** 1652 bytes

```typescript
import 'react-native-url-polyfill/auto';
import { createClient } from '@supabase/supabase-js';
import * as SecureStore from 'expo-secure-store';

// SecureStore adapter for Supabase auth persistence
const ExpoSecureStoreAdapter = {
  getItem: (key: string) => {
    return SecureStore.getItemAsync(key);
  },
  setItem: (key: string, value: string) => {
    return SecureStore.setItemAsync(key, value);
  },
  removeItem: (key: string) => {
    return SecureStore.deleteItemAsync(key);
  },
};

// Get Supabase URL and anon key from environment variables
// In production, these should be set in app.config.js or via EAS secrets
const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL || '';
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY || '';

if (!supabaseUrl || !supabaseAnonKey) {
  console.warn(
    'Supabase URL or anon key not found. Make sure to set EXPO_PUBLIC_SUPABASE_URL and EXPO_PUBLIC_SUPABASE_ANON_KEY environment variables.'
  );
}

// Create Supabase client
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: ExpoSecureStoreAdapter,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
});

// Helper function to check if user is authenticated
export const isAuthenticated = async () => {
  const { data, error } = await supabase.auth.getSession();
  return !!data.session;
};

// Helper function to get current user
export const getCurrentUser = async () => {
  const { data, error } = await supabase.auth.getUser();
  if (error) {
    console.error('Error getting user:', error.message);
    return null;
  }
  return data.user;
}; ```

### trpc.ts
**Path:** utils/trpc.ts
**Size:** 739 bytes

```typescript
import { createTRPCReact } from '@trpc/react-query';
import { type inferRouterInputs, type inferRouterOutputs } from '@trpc/server';

// Import the real AppRouter type from our server
import { type AppRouter } from '../server/src/router';

// Import types using the updated path
import { RouterInputs as TypedRouterInputs, RouterOutputs as TypedRouterOutputs } from '../server/src/types/trpc-types';

/**
 * tRPC React client
 * The client for consuming your tRPC API from React components
 */
export const trpc = createTRPCReact<AppRouter>();

/**
 * Inference helpers for input/output types
 * Use the pre-defined types from trpc-types.ts
 */
export type RouterInputs = TypedRouterInputs;
export type RouterOutputs = TypedRouterOutputs; ```


# (root files)

### why.txt
**Path:** why.txt
**Size:** 2848 bytes

```
yarn why v1.22.22
[1/4] Why do we have the module "@tamagui/core"...?
[2/4] Initialising dependency graph...
[3/4] Finding dependency...
[4/4] Calculating file sizes...
info => Found "@tamagui/core@1.126.1"
info Has been hoisted to "@tamagui/core"
info Reasons this module exists
   - Specified in "dependencies"
   - Hoisted from "@tamagui#font-inter#@tamagui#core"
   - Hoisted from "@tamagui#lucide-icons#@tamagui#core"
   - Hoisted from "@tamagui#stacks#@tamagui#core"
   - Hoisted from "@tamagui#toast#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#accordion#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#adapt#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#alert-dialog#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#avatar#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#checkbox#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#dialog#@tamagui#core"
   - Hoisted from "@tamagui#toast#@tamagui#dismissable#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#elements#@tamagui#core"
   - Hoisted from "@tamagui#config#@tamagui#font-silkscreen#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#font-size#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#form#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#get-font-sized#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#group#@tamagui#core"
   - Hoisted from "@tamagui#lucide-icons#@tamagui#helpers-icon#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#image#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#linear-gradient#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#popover#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#popper#@tamagui#core"
   - Hoisted from "@tamagui#toast#@tamagui#portal#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#progress#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#radio-group#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#select#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#separator#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#sheet#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#slider#@tamagui#core"
   - Hoisted from "@tamagui#babel-plugin#@tamagui#static#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#switch#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#tooltip#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#accordion#@tamagui#collapsible#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#accordion#@tamagui#collection#@tamagui#core"
   - Hoisted from "@tamagui#babel-plugin#@tamagui#static#@tamagui#config-default#@tamagui#core"
   - Hoisted from "tamagui#@tamagui#radio-group#@tamagui#roving-focus#@tamagui#core"
info Disk size without dependencies: "2.18MB"
info Disk size with unique dependencies: "11.06MB"
info Disk size with transitive dependencies: "12.35MB"
info Number of shared dependencies: 13
Done in 0.74s.
```

---
## Summary Statistics
Total files documented: 197
  -   81 tsx
  -   53 ts
  -   16 js
  -   10 txt
  -    9 md
  -    7 sql
  -    7 json
  -    5 sh
  -    2 gitignore
  -    2 env
  -    1 yml
  -    1 yaml
  -    1 windsurfrules
  -    1 toml
  -    1 example

  ```

- **aether_migration_context.md** (0.0 KB, 0 lines) *(No explicit exports)*
  *(Content not read or file is binary/excluded)*

- **aether_migration_context_full.md** (0.0 KB, 0 lines) *(No explicit exports)*
  *(Content not read or file is binary/excluded)*

- **aether_migration_context_full_20250430_041229.md** (0.0 KB, 0 lines) *(No explicit exports)*
  *(Content not read or file is binary/excluded)*

- **aether_migration_context_full_20250430_041247.md** (0.0 KB, 0 lines) *(No explicit exports)*
  *(Content not read or file is binary/excluded)*

- **aether_migration_context_full_20250430_041307.md** (0.0 KB, 0 lines) *(No explicit exports)*
  *(Content not read or file is binary/excluded)*

- **aether_migration_context_full_20250430_041337.md** (0.0 KB, 0 lines) *(No explicit exports)*
  *(Content not read or file is binary/excluded)*

- **aether_migration_context_full_20250430_041425.md** (0.0 KB, 0 lines) *(No explicit exports)*
  *(Content not read or file is binary/excluded)*

- **aether_migration_context_full_20250430_041425.md.tmp** (0.0 KB, 0 lines) *(No explicit exports)*
  *(Content not read or file is binary/excluded)*

- **aether_styling_context.txt** (70.5 KB, 2247 lines) *(No explicit exports)*

  ```txt
========================================
 AETHERIPHONE STYLING CONTEXT DUMP 
========================================

Date: 2025-04-30T04:20:08.847Z
Purpose: Provide full file context for styling analysis and enhancement suggestions.

========================================
FILE: tamagui.config.ts
----------------------------------------

// tamagui.config.ts
import { createAnimations } from '@tamagui/animations-react-native';
import { createFont, createTamagui, createTokens } from 'tamagui';
import { Platform } from 'react-native';
import * as MotionConstants from '@/constants/motion'; // Import motion constants

// Font definitions - Zelda Theme
// Assumes 'CalamitySans' and 'HyliaSerif' are loaded via useFonts or similar
const headingFont = createFont({
  family: 'HyliaSerif', // Zelda Display Font
  size: {
    // Mapped closer to iOS Dynamic Type: https://developer.apple.com/design/human-interface-guidelines/typography
    1: 13,  // Caption 2
    2: 15,  // Subheadline
    3: 17,  // Body (true default)
    4: 20,  // Title 3
    5: 22,  // Title 2
    6: 28,  // Title 1
    7: 34,  // Large Title
    8: 40,  // Extra Large Title (custom)
    true: 17, // Default size (Body)
  },
  lineHeight: {
    // Approximate line heights based on new sizes
    1: 18, 2: 20, 3: 22, 4: 25, 5: 28, 6: 34, 7: 41, 8: 50, 
    true: 22,
  },
  weight: {
    // Prompt 2 asks for 400-700
    4: '400', // Normal
    6: '600', // Semi-bold/Bold
    7: '700', // Extra-bold/Black
    true: '400',
  },
  letterSpacing: {
    1: 0, 2: 0, 3: -0.5, 4: -0.5, 5: -1, 6: -1, 7: -1.5, 8: -1.5,
    true: 0,
  },
  // Required: Map weights to specific font faces if needed (e.g., 'HyliaSerif-Bold')
  // face: {
  //   400: { normal: 'HyliaSerif-Regular' },
  //   700: { normal: 'HyliaSerif-Bold' },
  // },
});

const bodyFont = createFont({
  family: 'CalamitySans', // Zelda Body Font
  size: {
    // Mapped closer to iOS Dynamic Type
    1: 11,  // Footnote
    2: 12,  // Caption 1
    3: 13,  // Caption 2
    4: 15,  // Subheadline
    5: 17,  // Body (true default)
    6: 20,  // Title 3 (matching headingFont.$4)
    true: 17, // Default body size
  },
  lineHeight: {
    // Approximate line heights
    1: 13, 2: 16, 3: 18, 4: 20, 5: 22, 6: 25,
    true: 22, // Default body line height
  },
  weight: {
    4: '400', // Regular
    5: '500', // Medium (if available)
    7: '700', // Bold (if needed/available)
    true: '400',
  },
  letterSpacing: {
    1: 0.1, 2: 0.1, 3: 0, 4: 0, 5: -0.1, 6: -0.1,
    true: 0,
  },
  // Required: Map weights to specific font faces if needed (e.g., 'CalamitySans-Medium')
  // face: {
  //   400: { normal: 'CalamitySans-Regular' },
  //   500: { normal: 'CalamitySans-Medium' },
  // },
});

const monoFont = createFont({
  family: Platform.select({ web: 'monospace', default: 'SpaceMono' }), // Keep SpaceMono for code
  size: {
    1: 12, 2: 14, 3: 15, 4: 16, 5: 18, 6: 20, true: 15,
  },
  lineHeight: {
    1: 18, 2: 22, 3: 24, 4: 26, 5: 28, 6: 32, true: 24,
  },
  weight: {
    4: '400', // Normal weight
    true: '400',
  },
  letterSpacing: {
    4: 0,
    true: 0,
  },
  face: {
    400: { normal: 'SpaceMono' }, // Map weight 400 to the loaded SpaceMono font
  },
});

// Animation driver using reanimated
const animations = createAnimations({
  fast: {
    type: 'timing',
    duration: MotionConstants.durations.standard,
    // easing: MotionConstants.easings.standard, // Removed as createAnimations defaults work well
  },
  medium: {
    type: 'timing',
    duration: MotionConstants.durations.modal,
  },
  slow: {
    type: 'timing',
    duration: MotionConstants.durations.long,
  },
  bouncy: {
    type: 'spring',
    damping: 9,
    mass: 0.9,
    stiffness: 150,
  },
  lazy: {
    type: 'spring',
    damping: 18,
    stiffness: 50,
  },
  quick: {
    type: 'spring',
    damping: 20,
    mass: 1.2,
    stiffness: 250,
  },
});

// Standard Radix Gray scale (light theme)
const gray = {
  gray1: '#fcfcfc', gray2: '#f8f8f8', gray3: '#f3f3f3', gray4: '#ededed', gray5: '#e8e8e8', gray6: '#e2e2e2', gray7: '#dbdbdb', gray8: '#c7c7c7', gray9: '#8f8f8f', gray10: '#858585', gray11: '#6f6f6f', gray12: '#171717',
};

// Standard Radix Gray scale (dark theme)
const grayDark = {
  gray1: '#191919', gray2: '#212121', gray3: '#282828', gray4: '#303030', gray5: '#393939', gray6: '#424242', gray7: '#4f4f4f', gray8: '#626262', gray9: '#737373', gray10: '#838383', gray11: '#ababab', gray12: '#ededed',
};

// Tokens (refined based on your existing config)
const tokens = createTokens({
  size: {
    0: 0, 1: 4, 2: 8, 3: 12, 4: 16, 5: 20, 6: 24, 7: 28, 8: 32, 9: 36, 10: 40, 11: 44, 12: 48, 13: 52, 14: 56, 15: 60, 16: 64, true: 16,
  },
  space: {
    0: 0, 1: 4, 2: 8, 3: 12, 4: 16, 5: 20, 6: 24, 7: 28, 8: 32, 9: 36, 10: 40, 11: 44, 12: 48, 13: 52, 14: 56, 15: 60, 16: 64, true: 16, '-1': -4, '-2': -8, '-3': -12, '-4': -16,
  },
  radius: {
    0: 0, 1: 3, 2: 5, 3: 8, 4: 10, 5: 14, 6: 16, 7: 20, 8: 24, 9: 28, 10: 32, true: 10, // Updated radius.5 to 14
  },
  zIndex: { 0: 0, 1: 100, 2: 200, 3: 300, 4: 400, 5: 500 },
  color: {
    // Zelda Palette (Prompt 1)
    ...gray, // Add light greys
    ...grayDark, // Add dark greys (will be overridden in dark theme definition)
    parchment: '#FDFFE0',
    sheikahCyan: '#86A5A9',
    korokGreen: '#92C582',
    darkText: '#536F50',
    guardianOrange: '#FF9F0A',
    darkTealBg: '#1A2E3A',
    darkCyanGlow: '#64FFDA',

    // Shadow Colors (Prompt 5)
    shadowColorLight: 'rgba(83, 111, 80, 1)', // dark desaturated text color
    shadowColorDark: 'rgba(0, 0, 0, 1)', // Black base
    white: '#FFFFFF',
    black: '#000000',
  },
});

// Define themes using Zelda Palette
const lightTheme = {
  // Base Colors
  background: tokens.color.parchment,      // Light bg
  backgroundStrong: tokens.color.white,     // Keep white for strong contrast areas if needed
  backgroundTransparent: 'rgba(253, 255, 224, 0)', // Fully transparent parchment
  color: tokens.color.darkText,             // Dark desaturated text
  colorSecondary: tokens.color.darkText,      // Use main text color, maybe slightly lighter if needed later
  colorTertiary: tokens.color.sheikahCyan,    // Use accent for tertiary info?
  borderColor: tokens.color.sheikahCyan,      // Use accent for borders
  borderColorHover: tokens.color.korokGreen,  // Korok green on hover?

  // Theme-specific states (can refine later)
  backgroundHover: tokens.color.parchment,    // Keep parchment, maybe slightly darker/lighter
  backgroundPress: tokens.color.parchment,    // Keep parchment
  backgroundFocus: tokens.color.parchment,    // Keep parchment
  colorHover: tokens.color.korokGreen,        // Korok green text on hover?
  colorPress: tokens.color.korokGreen,
  colorFocus: tokens.color.sheikahCyan,
  borderColorPress: tokens.color.korokGreen,
  borderColorFocus: tokens.color.sheikahCyan,

  // Semantic Tokens (Prompt 4)
  accent: tokens.color.sheikahCyan,
  surfaceSubtle: tokens.color.parchment,    // Base color, apply opacity in component (e.g., rgba(253,255,224,0.8))
  destructive: tokens.color.guardianOrange,

  // Standard Semantic Mapping (can use Zelda colors)
  primary: tokens.color.sheikahCyan,        // Map primary to accent
  secondary: tokens.color.korokGreen,       // Map secondary to korok green?
  success: tokens.color.korokGreen,
  warning: tokens.color.guardianOrange,     // Use guardian orange for warning
  error: tokens.color.guardianOrange,       // Use guardian orange for error
  info: tokens.color.sheikahCyan,

  // Semantic Aliases (Playbook 1.1)
  surface: tokens.color.parchment, // Maps to background
  onSurface: tokens.color.darkText,  // Maps to color
  outline: tokens.color.sheikahCyan, // Maps to borderColor

  // Shadows (Playbook 1.1 & Prompt 5)
  shadowColor: tokens.color.shadowColorLight, // Use darkText color base for shadow
  shadowColorHover: 'rgba(83, 111, 80, 0.15)',
  shadowSm: 'rgba(83, 111, 80, 0.10)', // 10% opacity
  shadowMd: 'rgba(83, 111, 80, 0.15)', // 15% opacity
  shadowLg: 'rgba(83, 111, 80, 0.20)', // 20% opacity

  // Toast Themes (Report Item 6)
  toast_success_background: tokens.color.korokGreen,
  toast_success_color: tokens.color.parchment,
  toast_error_background: tokens.color.guardianOrange,
  toast_error_color: tokens.color.parchment,
  toast_warning_background: tokens.color.guardianOrange, // Often same as error
  toast_warning_color: tokens.color.parchment,
  toast_info_background: tokens.color.sheikahCyan,
  toast_info_color: tokens.color.parchment,
};

const darkTheme: typeof lightTheme = {
  // Base Colors
  ...grayDark, // Override light greys with dark greys
  background: tokens.color.darkTealBg,      // Dark-mode bg
  backgroundStrong: tokens.color.black,       // Black for contrast?
  backgroundTransparent: 'rgba(26, 46, 58, 0)', // Fully transparent dark teal
  color: tokens.color.parchment,          // Use light parchment for text
  colorSecondary: tokens.color.sheikahCyan,   // Sheikah cyan for secondary text
  colorTertiary: tokens.color.korokGreen,     // Korok green for tertiary
  borderColor: tokens.color.sheikahCyan,      // Sheikah cyan borders
  borderColorHover: tokens.color.darkCyanGlow, // Glow cyan on hover?

  // Theme-specific states
  backgroundHover: tokens.color.darkTealBg,   // Keep bg, maybe slightly lighter
  backgroundPress: tokens.color.darkTealBg,
  backgroundFocus: tokens.color.darkTealBg,
  colorHover: tokens.color.darkCyanGlow,
  colorPress: tokens.color.darkCyanGlow,
  colorFocus: tokens.color.darkCyanGlow,
  borderColorPress: tokens.color.darkCyanGlow,
  borderColorFocus: tokens.color.darkCyanGlow,

  // Semantic Tokens (Prompt 4)
  accent: tokens.color.sheikahCyan,
  surfaceSubtle: tokens.color.darkTealBg, // Use dark bg, apply opacity in component
  destructive: tokens.color.guardianOrange,

  // Standard Semantic Mapping
  primary: tokens.color.darkCyanGlow,       // Use glow cyan for primary actions
  secondary: tokens.color.korokGreen,
  success: tokens.color.korokGreen,
  warning: tokens.color.guardianOrange,
  error: tokens.color.guardianOrange,
  info: tokens.color.sheikahCyan,

  // Semantic Aliases (Playbook 1.1)
  surface: tokens.color.darkTealBg,   // Maps to background
  onSurface: tokens.color.parchment,  // Maps to color
  outline: tokens.color.sheikahCyan, // Maps to borderColor

  // Shadows (Playbook 1.1 & Prompt 5)
  shadowColor: tokens.color.shadowColorDark, // Darker shadow for dark mode
  shadowColorHover: 'rgba(0, 0, 0, 0.30)',
  shadowSm: 'rgba(0, 0, 0, 0.20)', // 20% opacity
  shadowMd: 'rgba(0, 0, 0, 0.30)', // 30% opacity
  shadowLg: 'rgba(0, 0, 0, 0.40)', // 40% opacity

  // Toast Themes (Report Item 6)
  toast_success_background: tokens.color.korokGreen,
  toast_success_color: tokens.color.darkTealBg,
  toast_error_background: tokens.color.guardianOrange,
  toast_error_color: tokens.color.darkTealBg,
  toast_warning_background: tokens.color.guardianOrange, // Often same as error
  toast_warning_color: tokens.color.darkTealBg,
  toast_info_background: tokens.color.sheikahCyan,
  toast_info_color: tokens.color.darkTealBg,
};

// Create the Tamagui config
const config = createTamagui({
  animations,
  shouldAddPrefersColorThemes: true,
  themeClassNameOnRoot: true,
  shorthands: {
    // Keep your existing shorthands
    m: 'margin', mt: 'marginTop', mr: 'marginRight', mb: 'marginBottom', ml: 'marginLeft', mx: 'marginHorizontal', my: 'marginVertical',
    p: 'padding', pt: 'paddingTop', pr: 'paddingRight', pb: 'paddingBottom', pl: 'paddingLeft', px: 'paddingHorizontal', py: 'paddingVertical',
    bg: 'backgroundColor', br: 'borderRadius', bw: 'borderWidth', bc: 'borderColor',
    f: 'flex', fd: 'flexDirection', ai: 'alignItems', jc: 'justifyContent', w: 'width', h: 'height',
    ac: 'alignContent',
    als: 'alignSelf',
    btc: 'borderTopColor',
    bbc: 'borderBottomColor',
    blc: 'borderLeftColor',
    brc: 'borderRightColor',
    boc: 'borderColor',
    bs: 'borderStyle',
    dsp: 'display',
    fb: 'flexBasis',
    fg: 'flexGrow',
    fs: 'flexShrink',
    fw: 'flexWrap',
    mah: 'maxHeight',
    maw: 'maxWidth',
    mih: 'minHeight',
    miw: 'minWidth',
    op: 'opacity',
    ov: 'overflow',
    r: 'right',
    shac: 'shadowColor',
    shar: 'shadowRadius',
    shof: 'shadowOffset',
    shop: 'shadowOpacity',
    t: 'top',
    ta: 'textAlign',
    tt: 'textTransform',
    va: 'verticalAlign',
    zi: 'zIndex',
  },
  fonts: {
    // Use Zelda fonts
    heading: headingFont,
    body: bodyFont,
    mono: monoFont, // Keep mono
  },
  themes: {
    light: lightTheme,
    dark: darkTheme,
  },
  tokens,
  media: { // Keep standard media queries
    xs: { maxWidth: 660 }, sm: { maxWidth: 800 }, md: { maxWidth: 1020 }, lg: { maxWidth: 1280 }, xl: { maxWidth: 1420 }, xxl: { maxWidth: 1600 },
    gtXs: { minWidth: 661 }, gtSm: { minWidth: 801 }, gtMd: { minWidth: 1021 }, gtLg: { minWidth: 1281 },
    short: { maxHeight: 820 }, tall: { minHeight: 820 },
    hoverNone: { hover: 'none' }, pointerCoarse: { pointer: 'coarse' },
  },
  settings: {
      allowedStyleValues: 'somewhat-strict',
      autocompleteSpecificTokens: 'except-special',
  },
});

type AppConfig = typeof config;

// Augment Tamagui interface - this is crucial!
declare module '@tamagui/core' {
  // If AppConfig is defined and exported:
  interface TamaguiCustomConfig extends AppConfig {}
}

export default config;

[EOF: tamagui.config.ts]

========================================
FILE: providers/Providers.tsx
----------------------------------------

// providers/Providers.tsx
import { QueryClientProvider } from '@tanstack/react-query';
import { persistQueryClient } from '@tanstack/react-query-persist-client';
import { TamaguiProvider, type TamaguiProviderProps } from 'tamagui';
import { ToastProvider, ToastViewport } from '@tamagui/toast'; // Import from Tamagui Toast
import React, { useEffect, useState, type ReactNode } from 'react';
import { Platform } from 'react-native'; // Import Platform

import config from '../tamagui.config'; // Import your config
import { trpc } from '../utils/trpc'; // Your tRPC hook setup
import { queryClient, persister, initializeNetworkMonitoring, resumeMutationsAndInvalidate } from '@/utils/query-client';
import { useUiStore } from '@/stores/uiStore';
import { supabase } from '@/utils/supabase'; // Needed for auth link
import { createTRPCClient, httpBatchLink, TRPCLink, TRPCClientError } from '@trpc/client'; // Import TRPC Client utils
import { observable } from '@trpc/server/observable';
import type { AppRouter } from '../server/src/router'; // Adjust path if needed
import type { Session } from '@supabase/supabase-js';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

// Setup query client persistence
persistQueryClient({
  queryClient,
  persister,
  maxAge: 1000 * 60 * 60 * 24, // 24 hours
  dehydrateOptions: {
    shouldDehydrateMutation: () => false, // Usually don't dehydrate mutations
  },
});

// New component for the viewport using safe area
const CurrentToastViewport = () => {
  const { top, bottom, left, right } = useSafeAreaInsets();
  return (
    <>
      {/* Adjust positioning based on your desired toast location */}
      <ToastViewport
        name="global_top"
        flexDirection="column" // Stack new toasts below older ones
        top={top + 10} // Add padding below status bar
        left={left + 10} // Add padding from sides
        right={right + 10}
      />
      <ToastViewport
        name="global_bottom"
        flexDirection="column-reverse"
        bottom={bottom + 10}
        left={left + 10}
        right={right + 10}
      />
    </>
  );
};

// Extract tRPC links setup
function getTRPCLinks(getSession: () => Promise<Session | null>): TRPCLink<AppRouter>[] {
  const apiBaseUrl = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api/trpc'; // Default to localhost
  console.log('Using tRPC API URL:', apiBaseUrl);

  return [
    // Link to handle auth token injection and refresh
    (runtime) => {
      return ({ op, next }) => {
        return observable((observer) => {
          getSession().then(session => {
            const headers = (op.context?.headers || {}) as Record<string, string>;
            if (session?.access_token) {
              headers['Authorization'] = `Bearer ${session.access_token}`;
            }

            // Proceed with the request, ensuring context is passed correctly
            next({ ...op, context: { ...op.context, headers } })
              .subscribe({
                next: (value) => observer.next(value),
                error: async (err) => {
                  if (err instanceof TRPCClientError && err.data?.httpStatus === 401) {
                    console.log('tRPC: Token expired or invalid, attempting refresh...');
                    try {
                      // Supabase handles refresh internally if needed when getSession is called
                      const { data, error: refreshError } = await supabase.auth.refreshSession();
                      if (refreshError) throw refreshError;

                      if (data.session) {
                        console.log('tRPC: Session refreshed successfully, retrying request.');
                        const refreshedHeaders = { ...headers, Authorization: `Bearer ${data.session.access_token}` };
                        // Retry with new headers in context
                        next({ ...op, context: { ...op.context, headers: refreshedHeaders } }).subscribe(observer);
                      } else {
                        console.error('tRPC: Session refresh failed, no session returned.');
                        observer.error(err); // Propagate original error if no new session
                        // Optionally trigger logout here
                        supabase.auth.signOut();
                      }
                    } catch (refreshCatchError) {
                      console.error('tRPC: Session refresh catch error:', refreshCatchError);
                      observer.error(err); // Propagate original error
                      supabase.auth.signOut();
                    }
                  } else {
                    observer.error(err); // Propagate non-auth errors
                  }
                },
                complete: () => observer.complete(),
              });
          }).catch(err => {
             console.error('tRPC: Error getting session for headers:', err);
             observer.error(new TRPCClientError('Failed to get session')); // Use TRPCClientError
          });

          // Return cleanup function if needed
          return () => {};
        });
      };
    },
    // The terminating HTTP link
    httpBatchLink({
      url: apiBaseUrl,
       headers() {
         // Headers are injected by the middleware link above
         return {};
       },
      // Add superjson transformer here if you use one
      // transformer: superjson,
    }),
  ];
}

export function Providers({ children }: { children: ReactNode }) {
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';

  // Initialize network monitoring and query client persistence
  useEffect(() => {
    const unsubscribeNetworkMonitoring = initializeNetworkMonitoring();
    resumeMutationsAndInvalidate(); // Try resuming mutations on app load
    return () => {
      unsubscribeNetworkMonitoring();
    };
  }, []);

  // Memoize tRPC client creation
  const [trpcClient] = useState(() =>
    trpc.createClient({
      links: getTRPCLinks(async () => { // Pass session getter to links setup
        const { data } = await supabase.auth.getSession();
        return data.session;
      }),
    })
  );

  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <TamaguiProvider
            config={config}
            defaultTheme={currentTheme}
            // disableInjectCSS // May not be needed depending on setup
        >
          {/* Use Tamagui's ToastProvider */}
          <ToastProvider
            // burntOptions={{ from: 'top' }} // Disabled until native module 'Burnt' is installed
            swipeDirection="horizontal"
            duration={4000}
            native={[]}
          >
            {children}
            {/* Add the safe-area aware ToastViewport */}
            <CurrentToastViewport />
          </ToastProvider>
        </TamaguiProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
}

[EOF: providers/Providers.tsx]

========================================
FILE: stores/uiStore.ts
----------------------------------------

import { create } from 'zustand';

interface UiState {
  isDarkMode: boolean;
  toggleTheme: () => void;
}

// Simple Zustand store for UI state (e.g., theme)
export const useUiStore = create<UiState>((set) => ({
  isDarkMode: false, // Default to light mode
  toggleTheme: () => set((state) => ({ isDarkMode: !state.isDarkMode })),
})); 

[EOF: stores/uiStore.ts]

========================================
FILE: constants/motion.ts
----------------------------------------

import { Easing } from 'react-native-reanimated';

/**
 * Standard animation durations (in milliseconds)
 */
export const durations = {
  /** Ultra-fast for micro-interactions */
  micro: 80,
  /** Tap/press feedback */
  tap: 120,
  /** Default animation speed for most UI transitions */
  standard: 200,
  /** For more noticeable animations */
  medium: 250,
  /** Modal entrances/exits, complex transitions */
  modal: 300,
  /** Full screen transitions */
  screen: 350,
  /** Extended animations for emphasis */
  long: 450,
};

/**
 * Standard easing curves
 */
export const easings = {
  /** Quick acceleration, gradual deceleration - for elements entering the screen */
  enter: Easing.bezier(0.25, 0.1, 0.25, 1.0),
  /** Gradual acceleration, quick deceleration - for elements exiting the screen */
  exit: Easing.bezier(0.25, 0.0, 0.2, 1.0),
  /** For transitions between UI states */
  standard: Easing.bezier(0.4, 0.0, 0.2, 1.0),
  /** Quick in, quick out - for emphasis */
  energetic: Easing.bezier(0.55, 0.0, 0.1, 1.0),
  /** Linear - consistent motion with no acceleration/deceleration */
  linear: Easing.linear,
  /** Slow start, fast finish */
  accelerate: Easing.in(Easing.quad),
  /** Fast start, slow finish */
  decelerate: Easing.out(Easing.quad),
  /** Fast start and end, slower in the middle */
  emphasize: Easing.inOut(Easing.quad),
};

/**
 * Animation presets for common UI patterns
 */
export const presets = {
  fadeIn: {
    duration: durations.standard,
    easing: easings.enter,
  },
  fadeOut: {
    duration: durations.standard,
    easing: easings.exit,
  },
  slideIn: {
    duration: durations.modal,
    easing: easings.enter,
  },
  slideOut: {
    duration: durations.modal,
    easing: easings.exit,
  },
  scaleIn: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  scaleOut: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  tapFeedback: {
    duration: durations.tap,
    easing: easings.emphasize,
  },
  skeleton: {
    duration: durations.long * 2,
    easing: easings.linear,
  },
};

/**
 * Animation values for specific components
 */
export const componentAnimations = {
  toast: {
    show: {
      duration: durations.modal,
      easing: easings.enter,
    },
    hide: {
      duration: durations.standard,
      easing: easings.exit,
    },
  },
  modal: {
    overlay: {
      show: {
        duration: durations.modal,
        easing: easings.standard,
      },
      hide: {
        duration: durations.modal,
        easing: easings.standard,
      },
    },
    content: {
      show: {
        duration: durations.modal,
        easing: easings.enter,
      },
      hide: {
        duration: durations.standard,
        easing: easings.exit,
      },
    },
  },
  button: {
    press: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
    release: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
  },
  navigation: {
    screen: {
      duration: durations.screen,
      easing: easings.standard,
    },
    tab: {
      duration: durations.standard,
      easing: easings.standard,
    },
  },
}; 

[EOF: constants/motion.ts]

========================================
FILE: app/(tabs)/_layout.tsx
----------------------------------------

// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/_layout.tsx
import React from 'react';
import { Tabs } from 'expo-router';
import { Ionicons } from '@expo/vector-icons'; // Example icon library
import { useThemeColor } from '@/hooks/useThemeColor'; // Assuming path alias is set

export default function TabLayout() {
  const tabBarActiveTintColor = useThemeColor({}, 'tabIconSelected');
  const tabBarInactiveTintColor = useThemeColor({}, 'tabIconDefault');
  const backgroundColor = useThemeColor({}, 'background'); // Use standard background color

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: tabBarActiveTintColor,
        tabBarInactiveTintColor: tabBarInactiveTintColor,
        tabBarStyle: {
          backgroundColor: backgroundColor,
          // Add other styles like borderTopColor if needed
        },
        headerShown: false, // We might handle headers inside each screen or using Stack
      }}
    >
      <Tabs.Screen
        name="home/index"
        options={{
          title: 'Home',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="home-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="planner/index"
        options={{
          title: 'Planner',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="calendar-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="compass/index"
        options={{
          title: 'Compass',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="compass-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="rewards/index"
        options={{
          title: 'Rewards',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="gift-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="settings/index"
        options={{
          title: 'Settings',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="settings-outline" size={size} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}


[EOF: app/(tabs)/_layout.tsx]

========================================
FILE: app/(tabs)/home/index.tsx
----------------------------------------

// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/home/index.tsx
import React, { useCallback, useMemo } from 'react';
import { YStack, H1, Text, XStack, Button, ScrollView, Spinner } from 'tamagui';
import { SafeAreaView, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc, RouterOutputs } from '@/utils/trpc';
import DashboardSection from '@/components/dashboard/DashboardSection';
import GoalSummaryCard from '@/components/dashboard/GoalSummaryCard';
import HabitCheckItem from '@/components/dashboard/HabitCheckItem';
import TaskItem from '@/components/dashboard/TaskItem';
import StateIndicator from '@/components/dashboard/StateIndicator';
import DailyProgressBanner from '@/components/dashboard/DailyProgressBanner'; // Import Banner
import EmptyOrSkeleton from '@/components/ui/EmptyOrSkeleton';
import { SkeletonCard, SkeletonRow } from '@/components/ui/Skeleton';
import { useSkeleton } from '@/hooks/useSkeleton';
import { useColorScheme } from '@/hooks/useColorScheme';
import { useToastController } from '@tamagui/toast';
import { BlurView } from 'expo-blur';
import { Plus } from '@tamagui/lucide-icons';
import LottieView from 'lottie-react-native';
import SwipeableRow from '@/components/ui/SwipeableRow'; // Import SwipeableRow

// Types inferred from tRPC Router
type RouterOutput = RouterOutputs['dashboard']['getDashboardData'];
// --- Define types for the STRUCTURE AFTER mapping in useMemo ---
export type DashboardGoal = {
  id: string;
  title: string;
  progress: number;
  tasks: { completed: number; total: number };
  // Include other relevant fields if needed by GoalSummaryCard
  status?: string | null; 
  priority?: number | null;
};
export type DashboardHabit = {
  id: string;
  name: string;
  description?: string | null;
  completed: boolean; // Mapped from completedToday
  streak: number;
  last_entry_id?: string; // Mapped from habit.last_entry_id (null -> undefined)
  habit_type?: string | null;
};
export type DashboardTask = {
  id: string;
  name: string;
  status: string | null; // Allow null
  due_date?: Date | string | null;
  // Include other relevant fields if needed by TaskItem
};
export type DashboardState = {
  id: string;
  name: string | null;
  unit: string | null;
  currentValue: number | string | null;
  lastUpdated: string | null;
  lastEntry: { value: number | null; created_at: Date | string } | null; // Explicitly include lastEntry
};
// --- End mapped type definitions ---

export default function HomeScreen() {
  const colorScheme = useColorScheme();
  const toast = useToastController();
  const utils = trpc.useUtils(); // Get tRPC utils for mutations
  
  // Define types using RouterOutputs for clarity and safety
  // type DashboardGoal = RouterOutputs['dashboard']['getDashboardData']['goals'][number];
  // type DashboardHabit = RouterOutputs['dashboard']['getDashboardData']['habits'][number];
  // type DashboardTask = RouterOutputs['dashboard']['getDashboardData']['tasks'][number];

  // Use tRPC hooks to fetch data - Types are inferred but can be explicitly used
  const { 
    data: dashboardData, 
    isLoading, 
    error, 
    refetch,
    isRefetching 
  } = trpc.dashboard.getDashboardData.useQuery();

  // Define the habit entry mutation hook
  const createHabitEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: () => {
      refetch(); // Refresh data after successful mutation
      // Optional: Add success toast
      // toast.show('Habit updated!', { type: 'success' });
    },
    onError: (error) => {
      // Handle tRPC client error
      toast.show(error.message || 'Failed to update habit', { type: 'error' });
    }
  });

  // Handle errors
  React.useEffect(() => {
    if (error) {
      toast.show(error.message || 'Failed to load dashboard data', { type: 'error' });
    }
  }, [error, toast]);

  // Set up pull-to-refresh
  const onRefresh = useCallback(() => {
    refetch();
  }, [refetch]);

  // Custom skeleton states from your hooks
  const { isLoading: skeletonsLoading, count: skeletonCount = 3 } = {
    isLoading,
    count: 3 // Number of skeleton items to show
  };
  
  // Generate skeleton UI based on loading state
  const renderSkeletons = () => {
    return Array.from({ length: skeletonCount }).map((_, index) => (
      <SkeletonCard key={`skeleton-${index}`} />
    ));
  };

  // Get current date and greeting
  const greeting = getGreeting();
  const currentDate = new Date().toLocaleDateString('en-US', { 
    weekday: 'long', 
    month: 'long', 
    day: 'numeric' 
  });

  const dashboardDataMemo = useMemo(() => {
    // Fix: Add check to ensure dashboardData exists before accessing properties
    if (!dashboardData) {
      return null; // Or return default structure: { goals: [], habits: [], tasks: [], trackedStates: [] }
    }

    // Map and filter data, ensuring structure matches exported types
    return {
      // Filter goals to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      goals: (dashboardData.goals ?? [])
        .filter((goal): goal is typeof goal & { id: string } => !!goal?.id)
        .map((goal) => ({
        // Map to DashboardGoal structure
        id: goal.id, 
        title: goal.title ?? 'Untitled Goal', // Provide default for title
        progress: goal.progress ?? 0, 
        tasks: goal.tasks ?? { completed: 0, total: 0 }, 
        status: goal.status,
        priority: goal.priority,
      })),
      // Filter habits to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      habits: (dashboardData.habits ?? [])
        .filter((habit): habit is typeof habit & { id: string } => !!habit?.id)
        .map((habit) => ({
        // Map to DashboardHabit structure
        id: habit.id, 
        name: habit.name ?? 'Unnamed Habit', // Provide default for name
        description: habit.description,
        completed: habit.completedToday ?? false, // Map completedToday to completed
        streak: habit.streak ?? 0, 
        last_entry_id: habit.last_entry_id ?? undefined, // Map null to undefined
        habit_type: habit.habit_type,
      })),
      // Filter tasks to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      tasks: (dashboardData.tasks ?? [])
        .filter((task): task is typeof task & { id: string } => !!task?.id)
        .map((task) => ({
        // Map to DashboardTask structure
        id: task.id,
        name: task.name ?? 'Untitled Task', // Provide default name
        status: task.status,
        due_date: task.due_date,
      })),
      // Map trackedStates, ensuring lastEntry is preserved
      // Fix: Use nullish coalescing and optional chaining
      trackedStates: (dashboardData.trackedStates ?? [])
        .filter((state): state is typeof state & { id: string } => !!state?.id)
        .map((trackedState) => ({
        // Map to DashboardState structure
        id: trackedState.id,
        name: trackedState.name,
        unit: trackedState.unit,
        currentValue: trackedState.currentValue,
        lastUpdated: trackedState.lastUpdated,
        // Ensure lastEntry structure matches definition or is null
        lastEntry: trackedState.lastEntry ?? null, 
      })),
    };
  }, [dashboardData]);

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <ScrollView 
        showsVerticalScrollIndicator={false}
        contentContainerStyle={{ paddingBottom: 100 }}
        refreshControl={
          <RefreshControl
            refreshing={isRefetching}
            onRefresh={onRefresh}
            tintColor="transparent" // Hide default spinner
            colors={['transparent']} // Hide default spinner (Android)
            progressBackgroundColor="transparent" // Hide default bg (Android)
            refreshingComponent={
              <LottieView
                source={require('@/assets/refresh-sheikah.json')} // ASSUMES this file exists
                autoPlay
                loop
                style={{ width: 48, height: 48, alignSelf: 'center' }} // Center the animation
              />
            }
          />
        }
      >
        <YStack space="$4" paddingHorizontal="$4">
          {/* Header */}
          <YStack space="$1">
            <H1>{greeting}</H1>
            <Text color="$gray10">{currentDate}</Text>
          </YStack>

          {/* Daily Progress Banner */}
          <DailyProgressBanner 
            // tasksCompleted={...} 
            // totalTasks={...} 
            // habitsChecked={...} 
            // totalHabits={...} 
          />

          {/* Goals Section */}
          <DashboardSection 
            title="Goals"
            onSeeAll={() => router.push('/planner')}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load goals"
              />
            ) : !dashboardDataMemo?.goals || dashboardDataMemo.goals.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No goals yet"
                actionText="Create a goal"
                onAction={() => router.push('/planner/add-goal')}
              />
            ) : (
              <YStack space="$3">
                {dashboardDataMemo.goals.slice(0, 3).map((goal) => (
                  <SwipeableRow
                    key={goal.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.goal.delete.mutate({ id: goal.id })
                      console.log('Attempting to delete goal:', goal.id); // Placeholder
                      // utils.goal.delete.mutate({ id: goal.id });
                    }}
                  >
                    <GoalSummaryCard
                      goal={goal}
                      onPress={() => router.push(`/planner/goal/${goal.id}`)}
                    />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>

          {/* Today's Habits */}
          <DashboardSection 
            title="Today's Habits"
            onSeeAll={() => router.push('/planner?tab=habits')}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load habits"
              />
            ) : !dashboardDataMemo?.habits || dashboardDataMemo.habits.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No habits for today"
                actionText="Create a habit"
                onAction={() => router.push('/planner/add-habit')}
              />
            ) : (
              <YStack space="$2">
                {dashboardDataMemo.habits.slice(0, 4).map((habit) => (
                  <SwipeableRow
                    key={habit.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.habit.delete.mutate({ id: habit.id })
                      console.log('Attempting to delete habit:', habit.id); // Placeholder
                      // utils.habit.delete.mutate({ id: habit.id });
                    }}
                  >
                    <HabitCheckItem habit={habit} />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>

          {/* Today's State */}
          <DashboardSection
            title="Today's State"
            // TODO: Add navigation to a dedicated state tracking screen
            onSeeAll={() => console.log('Navigate to State Tracking screen')}
          >
            {isLoading ? (
              renderSkeletons() // Use generic skeletons or specific state skeletons
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load state"
              />
            ) : !dashboardDataMemo?.trackedStates || dashboardDataMemo.trackedStates.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No states being tracked"
                actionText="Track a state"
                // TODO: Navigate to state definition creation screen
                onAction={() => console.log('Navigate to Add State screen')}
              />
            ) : (
              <XStack space="$3" flexWrap="wrap"> 
                {dashboardDataMemo.trackedStates.map((stateData) => (
                  <StateIndicator
                    key={stateData.id}
                    state={stateData} // Pass the whole state object which includes lastEntry
                    lastEntry={stateData.lastEntry} // Pass lastEntry explicitly
                    // TODO: Handle interaction - e.g., navigate to state detail/entry screen
                    onPress={() => console.log('State pressed:', stateData.id)}
                  />
                ))}
              </XStack>
            )}
          </DashboardSection>

          {/* Upcoming Tasks */}
          <DashboardSection 
            title="Upcoming Tasks"
            onSeeAll={() => {/* Navigate to tasks list */}}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load tasks"
              />
            ) : !dashboardDataMemo?.tasks || dashboardDataMemo.tasks.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No upcoming tasks"
                actionText="Create a task"
                onAction={() => {/* Navigate to create task */}}
              />
            ) : (
              <YStack space="$2">
                {dashboardDataMemo.tasks.slice(0, 5).map((task) => (
                  <SwipeableRow
                    key={task.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.task.delete.mutate({ id: task.id })
                      console.log('Attempting to delete task:', task.id); // Placeholder
                      // utils.task.delete.mutate({ id: task.id });
                    }}
                  >
                    <TaskItem
                      task={{
                        // Explicitly pass props matching DashboardTask type
                        id: task.id, // Ensure id is passed
                        name: task.name, // Already defaulted in map
                        status: task.status, // Pass status
                        due_date: task.due_date, // Pass due_date
                      }}
                      isLast={false} // Adjust if needed for styling
                      onPress={() => console.log('Task Item Pressed:', task.id)}
                    />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>
        </YStack>
      </ScrollView>
      <QuickAddFAB />
    </SafeAreaView>
  );
}

// Helper function for greeting
function getGreeting() {
  const hour = new Date().getHours();
  if (hour < 12) return 'Good Morning';
  if (hour < 18) return 'Good Afternoon';
  return 'Good evening';
}

// Quick Add FAB Component
function QuickAddFAB() {
  return (
    <BlurView intensity={40} tint="default" style={{ position:'absolute', bottom:24, right:24, borderRadius:32, overflow: 'hidden' }}>
      <Button
        circular
        size="$5"
        backgroundColor="$accent"
        icon={Plus}
        elevate
        shadowColor="$shadowColor"
        shadowRadius={5}
        shadowOffset={{ width: 0, height: 2 }}
        pressStyle={{ scale: 0.95, opacity: 0.9 }}
        onPress={() => {
          router.push('/planner/add-task');
        }}
      />
    </BlurView>
  );
}


[EOF: app/(tabs)/home/index.tsx]

========================================
FILE: utils/trpc.ts
----------------------------------------

import { createTRPCReact } from '@trpc/react-query';
import { type inferRouterInputs, type inferRouterOutputs } from '@trpc/server';

// Import the real AppRouter type from our server
import { type AppRouter } from '../server/src/router';

// Import types using the updated path
import { RouterInputs as TypedRouterInputs, RouterOutputs as TypedRouterOutputs } from '../server/src/types/trpc-types';

/**
 * tRPC React client
 * The client for consuming your tRPC API from React components
 */
export const trpc = createTRPCReact<AppRouter>();

/**
 * Inference helpers for input/output types
 * Use the pre-defined types from trpc-types.ts
 */
export type RouterInputs = TypedRouterInputs;
export type RouterOutputs = TypedRouterOutputs; 

[EOF: utils/trpc.ts]

========================================
FILE: utils/query-client.ts
----------------------------------------

import { QueryClient } from '@tanstack/react-query';
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister';
import AsyncStorage from '@react-native-async-storage/async-storage';
import NetInfo from '@react-native-community/netinfo';
import { onlineManager } from '@tanstack/react-query';

// Create a client
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // Default stale time of 5 minutes
      staleTime: 1000 * 60 * 5,
      // When offline, keep data fresh for 24 hours (cacheTime was renamed to gcTime)
      gcTime: 1000 * 60 * 60 * 24,
      // Retry failed queries 3 times
      retry: 3,
      // Retry with exponential backoff
      retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
      // Don't refetch on window focus for mobile
      refetchOnWindowFocus: false,
      // Show stale data while fetching new data (renamed from keepPreviousData)
      placeholderData: 'keepPrevious',
    },
    mutations: {
      // Retry failed mutations 3 times
      retry: 3,
      // Enable offline mutations
      networkMode: 'offlineFirst',
    },
  },
});

// Create a persister
export const persister = createAsyncStoragePersister({
  storage: AsyncStorage,
  key: 'aether-query-cache-v1',
  // Only persist queries with a longer cacheTime
  throttleTime: 1000,
  // SerDe for serializing/deserializing the data
  serialize: data => JSON.stringify(data),
  deserialize: data => JSON.parse(data),
});

/**
 * Initialize network monitoring for the query client
 * Call this on app startup to enable online/offline detection
 */
export function initializeNetworkMonitoring(): () => void {
  // Subscribe to network status changes
  const unsubscribe = NetInfo.addEventListener(state => {
    onlineManager.setOnline(
      state.isConnected != null && 
      state.isConnected && 
      Boolean(state.isInternetReachable)
    );
  });

  // Initialize once at startup - check if online
  NetInfo.fetch().then(state => {
    onlineManager.setOnline(
      state.isConnected != null && 
      state.isConnected && 
      Boolean(state.isInternetReachable)
    );
  });

  return unsubscribe;
}

/**
 * Resume any paused mutations when the app comes back online
 * 
 * @returns A promise that resolves when mutations are resumed
 */
export async function resumeMutationsAndInvalidate(): Promise<void> {
  try {
    await queryClient.resumePausedMutations();
    queryClient.invalidateQueries();
  } catch (error) {
    console.error('Error resuming mutations:', error);
  }
} 

[EOF: utils/query-client.ts]

========================================
FILE: components/dashboard/DashboardSection.tsx
----------------------------------------

import React, { ReactNode } from 'react';
import { Text, YStack, XStack, Button, Anchor, H4 } from 'tamagui';
import { router } from 'expo-router';
import { SkeletonRow } from '@/components/ui/Skeleton';
import { SectionError } from '@/components/ui/ErrorBanner';
import { BlurView } from 'expo-blur'; // Import BlurView

interface DashboardSectionProps<T> {
  title: string;
  data?: T[];
  isLoading?: boolean;
  emptyMessage?: string;
  seeAllRoute?: string;
  renderItem?: (item: T) => ReactNode;
  skeletonCount?: number;
  error?: string;
  onRetry?(): void;
  children?: ReactNode;
  onSeeAll?(): void;
}

export default function DashboardSection<T>({ 
  title, 
  data, 
  isLoading, 
  emptyMessage,
  seeAllRoute,
  renderItem,
  skeletonCount = 2,
  error,
  onRetry,
  children,
  onSeeAll
}: DashboardSectionProps<T>) {
  return (
    <YStack space="$2">
      <XStack justifyContent="space-between" alignItems="center" marginBottom="$2" paddingHorizontal="$2">
        <H4>{title}</H4>
        {((data && data.length > 0 && seeAllRoute) || onSeeAll) && (
          <Button 
            chromeless 
            size="$2" 
            onPress={() => {
              if (onSeeAll) {
                onSeeAll();
              } else if (seeAllRoute) {
                // Navigate to route using type assertions
                // Safe because the route will be a tab/screen name within the app
                router.push(seeAllRoute as any);
              }
            }}
          >
            See All
          </Button>
        )}
      </XStack>
      
      {/* Wrap content in BlurView */}
      <BlurView 
        intensity={50} 
        tint="default" 
        style={{ borderRadius: 12, overflow: 'hidden' }} 
      >
        <YStack padding="$3">
          {/* If children are provided, render them */}
          {children ? (
            children
          ) : isLoading ? (
            <SkeletonRow lines={skeletonCount} />
          ) : error ? (
            <SectionError message={error ? String(error) : 'An error occurred'} onRetry={onRetry} />
          ) : data && data.length === 0 ? (
            <YStack alignItems="center" padding="$4">
              <Text color="$gray10">{emptyMessage ?? 'No items found'}</Text>
            </YStack>
          ) : (
            data && renderItem && data.map(renderItem)
          )}
        </YStack>
      </BlurView>
    </YStack>
  );
} 

[EOF: components/dashboard/DashboardSection.tsx]

========================================
FILE: components/dashboard/GoalSummaryCard.tsx
----------------------------------------

import React from 'react';
import { Text, XStack, Button } from 'tamagui';
import ProgressRing from '@/components/aether/ProgressRing';
import { RouterOutputs } from '@/utils/trpc';
import { BlurView } from 'expo-blur'; // Import BlurView

// Define a custom type that includes everything we need
type DashboardGoal = {
  id: string;
  title: string;
  status?: string;
  priority?: number;
  progress: number;
  tasks?: {
    total: number;
    completed: number;
  };
};

interface GoalSummaryCardProps {
  goal: DashboardGoal;
  onPress: () => void;
}

export default function GoalSummaryCard({ goal, onPress }: GoalSummaryCardProps) {
  return (
    <BlurView 
      intensity={50} 
      tint="default" 
      style={{ borderRadius: 12, overflow: 'hidden' }}
    >
      <Button 
        chromeless // Remove default button styling
        padding="$3" 
        onPress={onPress}
        width="100%" // Ensure it fills the BlurView
      >
        <XStack alignItems="center" space="$3" flex={1}> 
          <ProgressRing
            progress={goal.progress}
            size={40}
            primaryColor="$primary"
          />
          <XStack flex={1} flexDirection="column">
            <Text fontSize="$4" fontWeight="500" color="$color">
              {goal.title}
            </Text>
            {goal.tasks && (
              <Text color="$gray9" fontSize="$2">
                {goal.tasks.completed}/{goal.tasks.total} tasks completed
              </Text>
            )}
          </XStack>
        </XStack>
      </Button>
    </BlurView>
  );
}

[EOF: components/dashboard/GoalSummaryCard.tsx]

========================================
FILE: components/dashboard/HabitCheckItem.tsx
----------------------------------------

import React, { useState, useEffect } from 'react';
import { Text, XStack, Button, YStack, useTheme } from 'tamagui';
import * as Haptics from 'expo-haptics';
import { trpc, RouterOutputs } from '@/utils/trpc';

// Custom types that match the backend expectations
type DashboardHabit = {
  id: string;
  name: string;  // Backend returns 'name'
  description?: string;
  habit_type?: string;
  streak?: number;
  completed: boolean; // Backend returns 'completed'
  duration_minutes?: number;
  last_entry_id?: string; // Add last_entry_id property
};

// Types for habit entry mutations
type CreateHabitEntryInput = {
  habit_id: string;
  date: string;
  completed?: boolean;
  quantity_value?: number | null;
  notes?: string | null;
};

type DeleteHabitEntryInput = {
  id: string; // Update property name
};

interface HabitCheckItemProps {
  habit: DashboardHabit;
  onToggle?: (habitId: string, completedToday: boolean) => void; 
}

export default function HabitCheckItem({ habit, onToggle }: HabitCheckItemProps) {
  const [checked, setChecked] = useState(habit.completed);
  const [isUpdating, setIsUpdating] = useState(false);
  const theme = useTheme(); 
  const utils = trpc.useUtils(); 

  // Define specific theme colors with safe access and fallbacks to theme variables
  const green10 = theme?.green10?.val ?? '$green10'; 
  const gray10 = theme?.gray10?.val ?? '$gray10'; 
  const orange10 = theme?.orange10?.val ?? '$orange10'; 


  const createEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: (updatedHabit) => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error creating habit entry:', error);
    }
  });

  const deleteEntryMutation = trpc.habit.deleteHabitEntry.useMutation({
    onSuccess: () => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error deleting habit entry:', error);
    }
  });

  useEffect(() => {
    setChecked(habit.completed);
  }, [habit.completed]);

  const handleToggle = () => {
    const newValue = !checked;
    setChecked(newValue); 
    setIsUpdating(true);

    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);

    const todayDateString = new Date().toISOString().split('T')[0];

    if (newValue) {
      const createInput: CreateHabitEntryInput = {
        habit_id: habit.id,
        date: todayDateString,
        completed: true, 
        quantity_value: null, 
        notes: null, 
      };
      createEntryMutation.mutate(createInput);
    } else {
      if (habit.last_entry_id) { 
        const deleteInput: DeleteHabitEntryInput = {
          id: habit.last_entry_id, 
        };
        deleteEntryMutation.mutate(deleteInput);
      } else {
        console.warn("Attempted to delete habit entry, but last_entry_id is missing.");
      }
    }

    if (onToggle) {
      onToggle(habit.id, newValue);
    }
  };

  const streakColor = checked ? green10 : gray10; // Use safe theme value
  const habitTypeColor = orange10; // Use safe theme value

  return (
    <XStack 
      backgroundColor="$backgroundStrong" // Use theme variable
      padding="$3"
      borderRadius="$4"
      alignItems="center"
      justifyContent="space-between"
      space="$3"
    >
      <YStack flex={1} gap="$1">
        <Text fontSize="$4" fontWeight="500" color="$color"> // Use theme variable
          {habit.name}
        </Text>
        
        {habit.streak != null && habit.streak > 0 && ( // Add null check
          <Text fontSize="$2" color={streakColor}> 
            Streak: {habit.streak ?? 0}
          </Text>
        )}
        {habit.habit_type && (
          <Text fontSize="$2" color={habitTypeColor}> // Use safe theme value
            ({habit.habit_type})
          </Text>
        )}
      </YStack>
      
      <Button
        size="$3"
        variant={checked ? undefined : 'outlined'} // Let variant handle appearance
        // Remove explicit colors - rely on theme/variant
        theme={checked ? 'green' : undefined} // Apply green theme when checked
        onPress={handleToggle}
        disabled={isUpdating} 
        iconAfter={checked ? <Text>✓</Text> : undefined}
      >
        {checked ? "Done" : "Check-in"}
      </Button>
    </XStack>
  );
}

[EOF: components/dashboard/HabitCheckItem.tsx]

========================================
FILE: components/dashboard/StateIndicator.tsx
----------------------------------------

import React from 'react';
// Use Tamagui components
import { Text, XStack, YStack, Card } from 'tamagui'; 
// Import RouterOutputs for inferred types
import { RouterOutputs } from '@/utils/trpc';

// Define prop type using inferred type from router
type DashboardTrackedState = RouterOutputs['dashboard']['getDashboardData']['trackedStates'][number];

interface StateIndicatorProps {
  state: DashboardTrackedState; // Use the inferred type
  onPress: () => void;
  lastEntry: any;
}

export default function StateIndicator({ state, onPress, lastEntry }: StateIndicatorProps) {
  // Format the last updated time
  const formattedTime = state.lastUpdated 
    ? new Date(state.lastUpdated).toLocaleTimeString([], { 
        hour: '2-digit', 
        minute: '2-digit' 
      })
    : 'N/A';
  
  // Use Tamagui Card component
  return (
    <Card 
      onPress={onPress} 
      pressStyle={{ opacity: 0.8 }}
      padding="$3"
      // No explicit background, will use default Card background from theme
    >
      <YStack space="$1"> {/* Main container for text */}
        <XStack flex={1} alignItems="center">
          <Text fontSize="$4" fontWeight="500">{state.name}</Text>
          {lastEntry && (
            <Text fontSize="$2" color="$gray10" marginLeft="$2">
              ({formattedTime})
            </Text>
          )}
        </XStack>
        <XStack alignItems="baseline" space="$2"> {/* Align text by baseline, add space */}
          <Text fontSize="$5" fontWeight="600" color="$color"> {/* Use tokens */}
            {state.currentValue}
          </Text>
        </XStack>
        {!lastEntry && (
          <Text fontSize="$2" color="$gray10" marginTop="$1">
            No data recorded yet.
          </Text>
        )}
      </YStack>
    </Card>
  );
} 

[EOF: components/dashboard/StateIndicator.tsx]

========================================
FILE: components/dashboard/TaskItem.tsx
----------------------------------------

import React from 'react';
// Use Tamagui components
import { Text, XStack, YStack, Checkbox, Spinner } from 'tamagui'; 
import { trpc, RouterOutputs, RouterInputs } from '@/utils/trpc';
import { Check } from '@tamagui/lucide-icons';

// Custom Task type that matches the actual format returned from the backend
type Task = {
  id: string;
  name: string;  // Backend returns 'name' not 'title'
  status: string;
  priority?: number;
  due_date?: string; // Backend returns 'due_date' not 'due'
  notes?: string;
  goal_id?: string;
  // Include other fields as needed
};

interface TaskItemProps {
  task: Task;
  onPress: () => void;
}

export default function TaskItem({ task, onPress }: TaskItemProps) {
  
  // Setup toggleTask mutation with optimistic updates
  const utils = trpc.useContext();
  // Setup mutation for task toggling
  const toggleTaskMutation = trpc.task.toggleTask.useMutation({
    // Optimistically update the UI
    onMutate: async ({ taskId, completed }: { taskId: string; completed?: boolean }) => {
      // Default to toggling the current state if completed is not provided
      const newCompleted = completed !== undefined ? completed : !isCompleted;
      // Cancel outgoing fetches that might overwrite our optimistic update
      await utils.task.getTasks.cancel();
      await utils.dashboard.getDashboardData.cancel();
      
      // Get previous data for potential rollback
      const prevTasksData = utils.task.getTasks.getData();
      const prevDashboardData = utils.dashboard.getDashboardData.getData();
      
      // Optimistically update tasks data if present
      if (prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return old.map((t: any) => {
            if (t.id === taskId) {
              return {
                ...t,
                status: completed ? 'completed' : 'in-progress'
              };
            }
            return t;
          });
        });
      }
      
      // Optimistically update dashboard data if present
      if (prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return {
            ...old,
            tasks: old.tasks.map((t: any) => {
              if (t.id === taskId) {
                return {
                  ...t,
                  status: newCompleted ? 'completed' : 'in-progress'
                };
              }
              return t;
            }),
          };
        });
      }
      
      // Return previous data for rollback
      return { prevTasksData, prevDashboardData };
    },
    
    // If something goes wrong, rollback optimistic updates
    onError: (err: any, variables: any, context: any) => {
      if (context?.prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, context.prevTasksData);
      }
      if (context?.prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, context.prevDashboardData);
      }
      console.error('Error toggling task:', err);
    },
    
    // Always refetch after error or success
    onSettled: () => {
      utils.task.getTasks.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    }
  });

  // Handle checkbox toggle
  const handleToggle = () => {
    toggleTaskMutation.mutate({
      taskId: task.id, // Using taskId as expected by the backend
      completed: !isCompleted
    });
  };

  // Map priority to color
  const priorityColor = task.priority === 1 ? '$brandRed' : 
                        task.priority === 2 ? '$brandYellow' : 
                        '$brandGreen';
  
  // Format due date
  const formattedDate = task.due_date 
    ? new Date(task.due_date).toLocaleDateString(undefined, { 
        month: 'short', 
        day: 'numeric' 
      })
    : null;
    
  // Determine task completion status
  const isCompleted = task.status === 'completed';
  // No need for text style object since we use Tamagui props directly

  
  // Use YStack as the base component
  return (
    <YStack 
      backgroundColor="$backgroundStrong"
      padding="$3"
      borderRadius="$4"
      space="$1" // Add space between XStack and Date Text
    >
      <XStack alignItems="center" space="$2"> {/* Use XStack for horizontal layout */}
        {/* Checkbox for task completion */}
        <Checkbox
          size="$4"
          checked={isCompleted}
          onCheckedChange={handleToggle}
          disabled={toggleTaskMutation.isPending}
        >
          {toggleTaskMutation.isPending ? (
            <Spinner size="small" color="$brandPrimary" />
          ) : (
            <Checkbox.Indicator>
              <Check size={16} />
            </Checkbox.Indicator>
          )}
        </Checkbox>

        {/* Container for task details (clickable) */}
        <XStack flex={1} tag="pressable" onPress={onPress} pressStyle={{ opacity: 0.7 }}>
          {/* Priority Dot using YStack */}
          <YStack 
            width="$2" // Use size token for width
            height="$2" // Use size token for height
            borderRadius="$10" // Use a large radius token
            backgroundColor={priorityColor} 
            marginRight="$2" // Use space token for margin
          />
          <Text 
            fontSize="$4" // Use font size token
            fontWeight={task.priority === 1 ? '600' : '400'} // Keep fontWeight
            color="$color"
            flex={1} // Allow text to take remaining space
            opacity={isCompleted ? 0.7 : 1}
            textDecorationLine={isCompleted ? 'line-through' : undefined} // Proper Tamagui text decoration
          >
            {task.name}
          </Text>
        </XStack>
      </XStack>
      
      {formattedDate && (
        // Removed explicit margin, rely on outer YStack space
        <Text color="$gray9" fontSize="$2">
          Due: {formattedDate}
        </Text>
      )}
    </YStack>
  );
} 

[EOF: components/dashboard/TaskItem.tsx]

========================================
FILE: components/ui/primitives/AetherCard.tsx
----------------------------------------

import React from 'react';
import { Card, CardProps, YStack, styled } from 'tamagui';

type AetherCardVariant = 'default' | 'elevated' | 'outlined';

interface AetherCardProps extends CardProps {
  variant?: AetherCardVariant;
  // Additional props specific to AetherCard
  isInteractive?: boolean;
}

// Create a styled Card component that uses our custom Tamagui theme variables
const StyledCard = styled(Card, {
  name: 'AetherCard',
  backgroundColor: '$cardBackground',
  borderRadius: '$4',
  padding: '$4',
  elevate: true,

  variants: {
    variant: {
      default: {
        // Using our theme tokens
        shadowColor: '$shadowColor',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 3,
        elevation: 2,
      },
      elevated: {
        shadowColor: '$shadowColor',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 6,
        elevation: 4,
      },
      outlined: {
        backgroundColor: 'transparent',
        borderWidth: 1,
        borderColor: '$borderColor',
        shadowOpacity: 0,
        elevation: 0,
      },
    },
    isInteractive: {
      true: {
        pressStyle: {
          backgroundColor: '$cardBackgroundPress',
          opacity: 0.9,
        },
        hoverStyle: {
          backgroundColor: '$cardBackgroundHover',
        },
      },
    },
  } as const,

  defaultVariants: {
    variant: 'default',
    isInteractive: false,
  },
});

/**
 * AetherCard - A stylized card component following Aether design system
 *
 * @param variant - The visual style variant: 'default', 'elevated', or 'outlined'
 * @param isInteractive - Whether the card responds to press/hover states
 */
export function AetherCard({ children, variant, isInteractive, ...props }: AetherCardProps) {
  return (
    <StyledCard variant={variant} isInteractive={isInteractive} {...props}>
      {children}
    </StyledCard>
  );
}


[EOF: components/ui/primitives/AetherCard.tsx]

========================================
FILE: components/ui/primitives/AetherListItem.tsx
----------------------------------------

import React from 'react';
import { XStack, YStack, Text, styled, GetProps, Stack } from 'tamagui';
import { Ionicons } from '@expo/vector-icons';

// Base ListItem container
const ListItemContainer = styled(XStack, {
  name: 'ListItemContainer',
  backgroundColor: '$cardBackground',
  paddingVertical: '$3',
  paddingHorizontal: '$4',
  borderRadius: '$3',
  alignItems: 'center',
  justifyContent: 'space-between',
  borderBottomWidth: 1,
  borderBottomColor: '$borderColor',
  minHeight: 60,
  
  variants: {
    isLast: {
      true: {
        borderBottomWidth: 0,
      },
    },
    interactive: {
      true: {
        pressStyle: {
          backgroundColor: '$backgroundPress',
          opacity: 0.9,
        },
        hoverStyle: {
          backgroundColor: '$backgroundHover',
        },
      },
    },
    variant: {
      default: {},
      header: {
        backgroundColor: '$backgroundStrong',
        borderBottomColor: '$borderColor',
        paddingVertical: '$2',
      },
    },
  } as const,
  
  defaultVariants: {
    isLast: false,
    interactive: true,
    variant: 'default',
  },
});

type ListItemContainerProps = GetProps<typeof ListItemContainer>;

export interface AetherListItemProps extends ListItemContainerProps {
  title: string;
  subtitle?: string;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  showChevron?: boolean;
  badge?: string | number;
}

/**
 * AetherListItem - A consistent list item component for use in lists, menus, and settings
 *
 * @param title - The primary text
 * @param subtitle - Optional secondary text shown below the title
 * @param leftIcon - Optional icon component to show on the left side
 * @param rightIcon - Optional icon component to show on the right side
 * @param showChevron - Whether to show a right chevron (useful for navigation items)
 * @param badge - Optional badge text/number to display
 * @param isLast - Whether this is the last item in a list (removes bottom border)
 * @param interactive - Whether the item should visually respond to touch
 */
export function AetherListItem({
  title,
  subtitle,
  leftIcon,
  rightIcon,
  showChevron = false,
  badge,
  isLast,
  interactive,
  ...props
}: AetherListItemProps) {
  return (
    <ListItemContainer isLast={isLast} interactive={interactive} {...props}>
      {/* Left section with icon and text */}
      <XStack space="$3" flex={1} alignItems="center">
        {leftIcon && (
          <Stack marginRight="$2">{leftIcon}</Stack>
        )}
        
        <YStack>
          <Text fontWeight="500" fontSize="$4">{title}</Text>
          {subtitle && (
            <Text fontSize="$2" color="$gray10">{subtitle}</Text>
          )}
        </YStack>
      </XStack>
      
      {/* Right section with badge, custom icon or chevron */}
      <XStack space="$2" alignItems="center">
        {badge && (
          <XStack 
            backgroundColor="$primary"
            paddingHorizontal="$2"
            paddingVertical="$1"
            borderRadius="$2"
          >
            <Text color="white" fontSize="$1" fontWeight="bold">{badge}</Text>
          </XStack>
        )}
        
        {rightIcon && rightIcon}
        
        {showChevron && (
          <Ionicons name="chevron-forward" size={16} color="$gray10" />
        )}
      </XStack>
    </ListItemContainer>
  );
}


[EOF: components/ui/primitives/AetherListItem.tsx]

========================================
FILE: components/ui/EmptyOrSkeleton.tsx
----------------------------------------

import React from 'react';
import { YStack, Text, Button } from 'tamagui';
import { SkeletonCard, SkeletonRow, SkeletonCircle } from './Skeleton';
import { SectionError } from './ErrorBanner';

export interface EmptyOrSkeletonProps {
  // Loading state
  isLoading?: boolean;
  count?: number;
  type?: 'card' | 'row' | 'circle';
  
  // Empty state
  isEmpty?: boolean;
  text?: string;
  actionText?: string;
  onAction?: () => void;
  
  // Error state
  isError?: boolean;
  onRetry?: () => void;
  
  // Children to render when not in any special state
  children?: React.ReactNode;
}

export const EmptyOrSkeleton = ({
  isLoading = false,
  count = 3,
  type = 'row',
  isEmpty = false,
  text = 'No items found',
  actionText = 'Add New',
  onAction,
  isError = false,
  onRetry,
  children
}: EmptyOrSkeletonProps) => {
  // Generate skeleton based on type
  const renderSkeletons = () => {
    const skeletons = [];
    for (let i = 0; i < count; i++) {
      if (type === 'card') {
        skeletons.push(<SkeletonCard key={i} />);
      } else if (type === 'circle') {
        skeletons.push(<SkeletonCircle key={i} />);
      } else {
        skeletons.push(<SkeletonRow key={i} />);
      }
    }
    return skeletons;
  };

  // Show skeleton if loading
  if (isLoading) {
    return (
      <YStack space="$3">
        {renderSkeletons()}
      </YStack>
    );
  }
  
  // Show error state if there's an error
  if (isError) {
    return (
      <SectionError 
        message={text} 
        onRetry={onRetry} 
      />
    );
  }
  
  // Show empty state if empty
  if (isEmpty) {
    return (
      <YStack
        padding="$4"
        alignItems="center"
        justifyContent="center"
        space="$3"
      >
        <Text textAlign="center" color="$gray11">
          {text}
        </Text>
        {onAction && (
          <Button size="$3" onPress={onAction}>
            {actionText}
          </Button>
        )}
      </YStack>
    );
  }
  
  // Default: return children
  return <>{children}</>;
};


[EOF: components/ui/EmptyOrSkeleton.tsx]


  ```

- **app.json** (1.4 KB, 61 lines) *(No explicit exports)*

  ```json
{
  "expo": {
    "name": "AetherIphone",
    "slug": "AetherIphone",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "aether",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.tybed7.AetherIphone",
      "infoPlist": {
        "ITSAppUsesNonExemptEncryption": false
      }
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.tybed7.AetherIphone"
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff"
        }
      ]
    ],
    "runtimeVersion": {
      "policy": "appVersion"
    },
    "updates": {
      "url": "https://u.expo.dev/d25504b5-1869-4dca-bfe0-9aaf6e86923b"
    },
    "experiments": {
      "typedRoutes": true
    },
    "extra": {
      "router": {
        "origin": false
      },
      "eas": {
        "projectId": "d25504b5-1869-4dca-bfe0-9aaf6e86923b"
      }
    }
  }
}

  ```

- **babel-tap.js** (0.3 KB, 13 lines) *(No explicit exports)*

  ```js
// babel-tap.js
module.exports = function tapPlugin() {
  return {
    name: 'tap-plugin',
    pre(_, { plugins }) {
      console.log(
        '\n🔎  Final plugin order Babel received:\n',
        plugins.map((p) => (typeof p === 'string' ? p : p?.key || p?.name))
      );
    },
  };
};

  ```

- **code-atlas_2025-04-30-10-21-29.md** (322.8 KB, 11384 lines) *(No explicit exports)*

  ```md
# Aether Code Atlas  
_generated 2025-04-30-10-21-29_

## Contents
- [Definitions Table](#definitions-table)
- [Dependency Graph](#dependency-graph)
- [Buckets](#buckets)

## Definitions Table
| File | Exports |
|---|---|
| __tests__/server/test-helpers.ts | createInnerTRPCContext, createTestContext, MockablePostgrestResponse, MockableQueryBuilder, MockableSupabaseClient, MockableTableOperations, mockDeep, mockSupabaseAdmin, resetSupabaseMocks, TableName |
| __tests__/test-utils.tsx | render |
| app/(auth)/_layout.tsx | default |
| app/(auth)/forgot-password.tsx | default |
| app/(auth)/login.tsx | default |
| app/(auth)/register.tsx | default |
| app/(tabs)/_layout.tsx | default |
| app/(tabs)/compass/index.tsx | default |
| app/(tabs)/home/index.tsx | default |
| app/(tabs)/planner/_layout.tsx | default |
| app/(tabs)/planner/add-goal.tsx | default |
| app/(tabs)/planner/add-habit.tsx | default |
| app/(tabs)/planner/add-task.tsx | default |
| app/(tabs)/planner/goal/[id].tsx | default |
| app/(tabs)/planner/habit/[id].tsx | default |
| app/(tabs)/planner/index.tsx | default |
| app/(tabs)/rewards/index.tsx | default |
| app/(tabs)/settings/_layout.tsx | default |
| app/(tabs)/settings/about.tsx | default |
| app/(tabs)/settings/help.tsx | default |
| app/(tabs)/settings/index.tsx | default |
| app/(tabs)/settings/notifications.tsx | default |
| app/(tabs)/settings/privacy.tsx | default |
| app/(tabs)/settings/profile.tsx | default |
| app/(tabs)/settings/security.tsx | default |
| app/_layout.tsx | default |
| app/components/SectionCard.tsx | SectionCard |
| app/components/SwipeableRow.tsx | SwipeableRow |
| app/components/TaskRow.tsx | TaskRow |
| app/compose.tsx | default |
| app/index.tsx | default |
| app/lib/useDashboardQuery.ts | DashboardData, useDashboardQuery |
| app/lib/useToggleTaskStatus.ts | useToggleTaskStatus |
| app/planner/add-habit.tsx | default |
| app/planner/index.tsx | default |
| app/settings/index.tsx | default |
| app/states/[id].tsx | default |
| app/utils/api-types.ts | RouterInputs, RouterOutputs |
| app/values/[id].tsx | default |
| components/EmptyOrSkeleton.tsx | default, EmptyOrSkeletonProps, EmptyStateProps |
| components/aether/ProgressRing.tsx | default |
| components/auth/FloatingInput.tsx | default, FloatingInputProps |
| components/compass/PrincipleCard.tsx | PrincipleCard |
| components/compass/PrinciplesTab.tsx | default |
| components/compass/StateDefinitionCard.tsx | StateDefinitionCard |
| components/dashboard/DailyProgressBanner.tsx | default |
| components/dashboard/DashboardSection.tsx | default |
| components/dashboard/GoalSummaryCard.tsx | default |
| components/dashboard/HabitCheckItem.tsx | default |
| components/dashboard/StateIndicator.tsx | default |
| components/dashboard/TaskItem.tsx | default |
| components/lists/GoalList.tsx | GoalCard, GoalList |
| components/lists/HabitList.tsx | HabitCard, HabitList |
| components/lists/TaskList.tsx | TaskCard, TaskList |
| components/lists/index.ts | GoalCard, GoalList, HabitCard, HabitList, TaskCard, TaskList |
| components/planner/GoalsList.tsx | default, Goal, GoalsListProps |
| components/planner/HabitTracker.tsx | HabitTracker |
| components/planner/HabitsList.tsx | default, Habit, HabitsListProps |
| components/planner/StreakCalendar.tsx | default, StreakCalendarProps |
| components/rewards/ConfettiBurst.tsx | default |
| components/settings/NotificationRow.tsx | default, NotificationRowProps |
| components/settings/ThemePreview.tsx | default, ThemePreviewProps |
| components/ui/Container.tsx | Container, default |
| components/ui/EmptyOrSkeleton.tsx | EmptyOrSkeleton, EmptyOrSkeletonProps |
| components/ui/ErrorBanner.tsx | ErrorBanner, SectionError |
| components/ui/InteractiveCard.tsx | default |
| components/ui/Section.tsx | default |
| components/ui/Skeleton.tsx | Skeleton, SkeletonAvatar, SkeletonCard, SkeletonCircle, SkeletonProfile, SkeletonRow |
| components/ui/SwipeableRow.tsx | default |
| components/ui/primitives/AetherCard.tsx | AetherCard |
| components/ui/primitives/AetherListItem.tsx | AetherListItem, AetherListItemProps |
| components/ui/primitives/SectionHeader.tsx | SectionHeader, SectionHeaderProps |
| components/ui/primitives/index.ts | AetherCard, AetherListItem, AetherListItemProps, SectionHeader, SectionHeaderProps |
| constants/Colors.ts | Colors |
| constants/motion.ts | componentAnimations, durations, easings, presets |
| debug/toast-test.tsx | default |
| design-system/Animations.ts | fadeInUp, korokReveal, sheikahGlow, slideOutLeft, taskComplete |
| design-system/Primitives.tsx | Button, Center, gs, HStack, Pressable, ScrollView, Stack, Text, useColorMode, useColorModeValue, useToast, VStack |
| design-system/theme.glue.ts | glueTheme |
| design-system/tokens.ts | colors, default, fonts, radii, sizes, space |
| hooks/useColorScheme.ts | useColorScheme |
| hooks/useColorScheme.web.ts | useColorScheme |
| hooks/useOfflineSync.ts | useOfflineSync |
| hooks/useSkeleton.ts | SkeletonOptions, useSkeleton |
| hooks/useThemeColor.ts | useThemeColor |
| modals/compose.tsx | default |
| providers/AppProvider.tsx | AppProvider |
| providers/ConfettiProvider.tsx | ConfettiProvider, useConfetti |
| providers/SupabaseProvider.tsx | SupabaseContext, SupabaseProvider, useSupabase |
| providers/TRPCProvider.tsx | trpc, TRPCProvider |
| server/src/context.ts | Context, createContext, supabaseAdmin |
| server/src/router.ts | appRouter, AppRouter, protectedProcedure, publicProcedure, router |
| server/src/routers/dashboardRouter.ts | dashboardRouter |
| server/src/routers/goalProgressNoteRouter.ts | goalProgressNoteRouter |
| server/src/routers/goalRouter.ts | goalRouter |
| server/src/routers/habitRouter.ts | habitRouter |
| server/src/routers/principleRouter.ts | principleRouter |
| server/src/routers/reminderRouter.ts | reminderRouter |
| server/src/routers/rewardsRouter.ts | rewardsRouter |
| server/src/routers/taskRouter.ts | taskRouter |
| server/src/routers/trackedStateRouter.ts | trackedStateRouter |
| server/src/routers/userRouter.ts | userRouter |
| server/src/routers/valueRouter.ts | valueRouter |
| server/src/types/index.ts | Badge, BadgeId, Goal, GoalId, Habit, HabitId, KeyResult, Principle, Task, TaskId, TrackedStateDef, Value, ValueId |
| server/src/types/trpc-types.ts | awardBadgeInput, BadgeDefinition, BadgeDefinition, claimLootInput, createGoalInput, createGoalProgressNoteInput, createHabitEntryInput, createHabitInput, createPrincipleInput, createReminderInput, CreateStateEntryInput, createTaskInput, createTrackedStateDefInput, createValueInput, DeleteGoalProgressNoteInput, DeleteReminderInput, DeleteStateEntryInput, DeleteTrackedStateDefInput, GetGoalProgressNotesInput, GetRemindersForEntityInput, GetStateEntriesInput, GetTrackedStateDefByIdInput, Goal, Goal, GoalProgressNote, GoalProgressNote, greetingInput, greetingOutput, Habit, Habit, HabitEntry, HabitEntry, HabitFrequencyPeriodEnum, HabitTypeEnum, NotificationPrefs, PointTransaction, PointTransaction, Principle, Principle, Reminder, Reminder, Reward, Reward, RewardTypeEnum, RouterInputs, RouterOutputs, StateEntry, StateEntry, Task, Task, TaskPriorityEnum, TaskStatusEnum, TrackedStateDef, TrackedStateDef, UiPrefs, updateGoalInput, updateGoalProgressNoteInput, updateHabitEntryInput, updateHabitInput, updatePrincipleInput, updateProfileInput, updateReminderInput, updateSettingsInput, updateStateEntryInput, updateTaskInput, updateTaskStatusInput, updateTrackedStateDefInput, updateValueInput, UserBadge, UserBadge, UserProfile, UserProfile, UserReward, UserReward, UserSettings, UserSettings, Value, Value |
| stores/uiStore.ts | useUiStore |
| tamagui.config.ts | default |
| types/database.types.ts | CompositeTypes, Constants, Database, Enums, Json, Tables, TablesInsert, TablesUpdate |
| utils/api-types.ts | RouterInputs, RouterOutputs |
| utils/auth.ts | getUserProfile, logout |
| utils/colors.ts | palette, semanticTokens, useColors, withOpacity |
| utils/generated-hooks.ts | useDashboard, useGoal, useGoalProgressNote, useHabit, usePrinciple, useReminder, useRewards, useState, useTask, useUser, useValue |
| utils/haptics.ts | haptics |
| utils/mock-api.ts | appRouter, AppRouter |
| utils/nats-client.ts | addSubjectHandler, closeNatsConnection, getNatsConnection, initNatsClient, subscribeWithCache |
| utils/offline-mutations.ts | asyncStoragePersister, configureQueryClientForOffline, getPendingMutations, markItemAsOffline, markItemAsSynced, reactQueryPersistOptions, useResumeNetworkMutations |
| utils/offline-sync.ts | getPendingItems, PendingItem, saveOfflineMutation, setupBackgroundSync, syncOfflineMutations |
| utils/query-client.ts | queryClient |
| utils/settings.ts | APP_SETTINGS_KEY, AppSettings, getAppVersion, getPlatformInfo, getSettings, saveSettings, updateSetting |
| utils/supabase.ts | getCurrentUser, isAuthenticated, supabase |
| utils/trpc.ts | RouterInputs, RouterOutputs, trpc |

## Dependency Graph

*Note: This graph shows dependencies between local files only.*
```mermaid
graph TD;
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
  <span class="math-inline">{idA}["</span>{file}"] --> <span class="math-inline">{idB}["</span>{imp}"];
```

## Buckets

### .

- **.env**
  *(No explicit exports found)*

- **.env.example**
  *(No explicit exports found)*

- **.eslintrc.js**
  *(No explicit exports found)*

- **.gitignore**
  *(No explicit exports found)*

- **.windsurfrules**
  *(No explicit exports found)*

- **AETHER_TODO.md**
  *(No explicit exports found)*

- **HAHA.js**
  *(No explicit exports found)*

- **README.md**
  *(No explicit exports found)*

- **REFACTORING_PLAN_V2.yaml**
  *(No explicit exports found)*

- **SUPABASE_INTEGRATION.md**
  *(No explicit exports found)*

- **aetherOUT.md**
  *(No explicit exports found)*

- **aether_migration_context.md**
  *(No explicit exports found)*

- **aether_migration_context_full.md**
  *(No explicit exports found)*

- **aether_migration_context_full_20250430_041229.md**
  *(No explicit exports found)*

- **aether_migration_context_full_20250430_041247.md**
  *(No explicit exports found)*

- **aether_migration_context_full_20250430_041307.md**
  *(No explicit exports found)*

- **aether_migration_context_full_20250430_041337.md**
  *(No explicit exports found)*

- **aether_migration_context_full_20250430_041425.md**
  *(No explicit exports found)*

- **aether_migration_context_full_20250430_041425.md.tmp**
  *(No explicit exports found)*

- **aether_styling_context.txt**
  *(No explicit exports found)*

- **app.json**
  *(No explicit exports found)*

- **babel-tap.js**
  *(No explicit exports found)*

- **babel.config.js**
  *(No explicit exports found)*

- **code_atlas.js**
  *(No explicit exports found)*

- **debug_context.txt**
  *(No explicit exports found)*

- **eas.json**
  *(No explicit exports found)*

- **file_hierarchy.txt**
  *(No explicit exports found)*

- **gather_complete_context.sh**
  *(No explicit exports found)*

- **gather_complete_context_fixed.sh**
  *(No explicit exports found)*

- **gather_complete_context_full.sh**
  *(No explicit exports found)*

- **gather_complete_context_improved.sh**
  *(No explicit exports found)*

- **gather_complete_context_v3.sh**
  *(No explicit exports found)*

- **gather_debug_info.js**
  *(No explicit exports found)*

- **gather_implementation_details.sh**
  *(No explicit exports found)*

- **gather_integrated_context.sh**
  *(No explicit exports found)*

- **gather_project_context.sh**
  *(No explicit exports found)*

- **gather_tamagui_styles.sh**
  *(No explicit exports found)*

- **global.css**
  *(No explicit exports found)*

- **implementation_details.txt**
  *(No explicit exports found)*

- **index.js**
  *(No explicit exports found)*

- **jest.config.server.js**
  *(No explicit exports found)*

- **jest.config.ui.js**
  *(No explicit exports found)*

- **jest.server.config.js**
  *(No explicit exports found)*

- **jest.server.setup.js**
  *(No explicit exports found)*

- **jest.setup.js**
  *(No explicit exports found)*

- **metro.config.js**
  *(No explicit exports found)*

- **o3.txt**
  *(No explicit exports found)*

- **package.json**
  *(No explicit exports found)*

- **postcss.config.js**
  *(No explicit exports found)*

- **project.txt**
  *(No explicit exports found)*

- **project_structure.txt**
  *(No explicit exports found)*

- **refactor_checklist.md**
  *(No explicit exports found)*

- **refactoring_plan.md**
  *(No explicit exports found)*

- **styling_report.txt**
  *(No explicit exports found)*

- **tailwind.config.js**
  *(No explicit exports found)*

- **tamagui.config.ts**

  *Exports: `default`*
  ```ts
export default config;
  ```

- **testing_strategy.md**
  *(No explicit exports found)*

- **tsconfig.json**
  *(No explicit exports found)*

- **why.txt**
  *(No explicit exports found)*

### __tests__

- **__tests__/components/dashboard/HabitCheckItem.test.tsx**
  *(No explicit exports found)*

- **__tests__/components/lists/GoalList.test.tsx**
  *(No explicit exports found)*

- **__tests__/components/lists/HabitList.test.tsx**
  *(No explicit exports found)*

- **__tests__/components/lists/TaskList.test.tsx**
  *(No explicit exports found)*

- **__tests__/components/ui/primitives/AetherCard.test.tsx**
  *(No explicit exports found)*

- **__tests__/components/ui/primitives/AetherListItem.test.tsx**
  *(No explicit exports found)*

- **__tests__/server/routers/dashboardRouter.getWeeklyProgress.test.ts**
  *(No explicit exports found)*

- **__tests__/server/routers/dashboardRouter.test.ts**
  *(No explicit exports found)*

- **__tests__/server/routers/habitRouter.test.ts**
  *(No explicit exports found)*

- **__tests__/server/routers/taskRouter.toggleTask.test.ts**
  *(No explicit exports found)*

- **__tests__/server/test-helpers.ts**

  *Exports: `createInnerTRPCContext`*
  ```ts
export function createInnerTRPCContext(opts: {
  userId: string | null;
  supabase?: any; // Keep as any for simplicity
}): Context {
  if (!opts.userId) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
      message: 'User must be authenticated to access this resource',
    });
  }

  return {
    userId: opts.userId,
    supabaseAdmin: opts.supabase || mockSupabaseAdmin,
  };
}
  ```

  *Exports: `createTestContext`*
  ```ts
export function createTestContext(userId: string | null = 'test-user-id', supabase?: any) {
  return createInnerTRPCContext({
    userId,
    supabase,
  });
}
  ```

  *Exports: `MockablePostgrestResponse`*
  ```ts
export type MockablePostgrestResponse<T> = Promise<{
  data: T | null;
  error: any;
  count?: number | null; 
  status?: number;
  statusText?: string;
}>;
  ```

  *Exports: `MockableQueryBuilder`*
  ```ts
export interface MockableQueryBuilder {
  select: (query?: string, options?: { head?: boolean; count?: 'exact' | 'planned' | 'estimated' }) => MockableQueryBuilder;
  eq: (column: string, value: any) => MockableQueryBuilder;
  neq: (column: string, value: any) => MockableQueryBuilder;
  gt: (column: string, value: any) => MockableQueryBuilder;
  gte: (column: string, value: any) => MockableQueryBuilder;
  lt: (column: string, value: any) => MockableQueryBuilder;
  lte: (column: string, value: any) => MockableQueryBuilder;
  like: (column: string, pattern: string) => MockableQueryBuilder;
  ilike: (column: string, pattern: string) => MockableQueryBuilder;
  is: (column: string, value: boolean | null) => MockableQueryBuilder;
  in: (column: string, values: any[]) => MockableQueryBuilder;
  contains: (column: string, value: any) => MockableQueryBuilder;
  containedBy: (column: string, value: any) => MockableQueryBuilder;
  rangeGt: (column: string, range: string) => MockableQueryBuilder;
  rangeGte: (column: string, range: string) => MockableQueryBuilder;
  rangeLt: (column: string, range: string) => MockableQueryBuilder;
  rangeLte: (column: string, range: string) => MockableQueryBuilder;
  rangeAdjacent: (column: string, range: string) => MockableQueryBuilder;
  overlaps: (column: string, value: any) => MockableQueryBuilder;
  textSearch: (column: string, query: string, options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }) => MockableQueryBuilder;
  match: (query: Record<string, unknown>) => MockableQueryBuilder;
  not: (column: string, operator: string, value: any) => MockableQueryBuilder;
  or: (filters: string, options?: { referencedTable?: string }) => MockableQueryBuilder;
  filter: (column: string, operator: string, value: any) => MockableQueryBuilder;
  limit: (count: number, options?: { referencedTable?: string }) => MockableQueryBuilder;
  range: (from: number, to: number, options?: { referencedTable?: string }) => MockableQueryBuilder;
  order: (column: string, options?: { ascending?: boolean; nullsFirst?: boolean; referencedTable?: string }) => MockableQueryBuilder;
}
  ```

  *Exports: `MockableSupabaseClient`*
  ```ts
export interface MockableSupabaseClient {
  // `from` now returns the object with both chainable and terminal methods
  from: (relation: string) => MockableTableOperations;

  // Top-level client methods
  auth: {
    getUser: (
      jwt?: string
    ) => Promise<{ data: { user: User | null }; error: AuthError | null }>;
    // Add other auth methods here if needed by tests (e.g., signUp, signInWithPassword)
  };
  rpc: <T = any>(fn: string, params?: object, options?: { head?: boolean; count?: 'exact' | 'planned' | 'estimated' }) => MockablePostgrestResponse<T>;
  // Add storage interface here if needed by tests
  // storage: { ... };
}
  ```

  *Exports: `MockableTableOperations`*
  ```ts
export interface MockableTableOperations extends MockableQueryBuilder {
  // Terminal methods (return Promises)
  single: <T = any>() => MockablePostgrestResponse<T>;
  maybeSingle: <T = any>() => MockablePostgrestResponse<T>;
  // Note: Insert/Update/Upsert often return arrays in Supabase v2, but the *methods* return the builder
  insert: <T = any>(values: any | any[], options?: any) => MockableTableOperations; 
  upsert: <T = any>(values: any | any[], options?: any) => MockableTableOperations; 
  update: <T = any>(values: any, options?: any) => MockableTableOperations; 
  delete: (options?: any) => MockableTableOperations; 
}
  ```

  *Exports: `mockDeep`*
  ```ts
export { mockDeep };
  ```

  *Exports: `mockSupabaseAdmin`*
  ```ts
const mockSupabaseAdmin = mockDeep<MockableSupabaseClient>();
  ```

  *Exports: `resetSupabaseMocks`*
  ```ts
export function resetSupabaseMocks() {
  // Use mockReset for better compatibility with jest-mock-extended
  mockReset(mockSupabaseAdmin);

  // --- Re-apply default implementations after reset --- 

  // Default: Successful authentication
  mockSupabaseAdmin.auth.getUser.mockResolvedValue({
    data: { user: { id: 'test-user-id', /* other user props */ } as User },
    error: null,
  });

  // Default: Successful RPC call returning null data
  mockSupabaseAdmin.rpc.mockResolvedValue({ 
      data: null, 
      error: null, 
      count: 0, 
      status: 200, 
      statusText: 'OK' 
  });

  // Helper type to create Promise-like chain-terminating objects
  type AsyncResult<T> = Promise<{ data: T | null; error: any; count?: number; status?: number; statusText?: string; }>;

  // Helper function to create a proper mock that handles both chaining AND awaiting
  function createMockWithPromiseCapability<T>(defaultData: T | null = null): any {
    const mockObj = mockDeep<MockableTableOperations>();
    
    // Add an implicit then handler that allows awaiting the mock directly
    // This is what Supabase's actual Query Builder does
    const defaultResponse = { 
      data: defaultData, 
      error: null, 
      count: defaultData && Array.isArray(defaultData) ? defaultData.length : 0,
      status: 200, 
      statusText: 'OK' 
    };
    
    // Allow the mock to be awaited directly
    (mockObj as any).then = jest.fn((onFulfill, onReject) => {
      return Promise.resolve(defaultResponse).then(onFulfill, onReject);
    });
    
    return mockObj;
  }

  // Default behavior for 'from': Return a mock that handles chaining and terminal methods
  mockSupabaseAdmin.from.mockImplementation((relation: string) => {
    // This inner mock needs to satisfy MockableTableOperations
    // AND be awaitable like a promise for terminal operations
    const innerMock = createMockWithPromiseCapability<any[]>([]);

    // --- Configure Default CHAINABLE Methods (Return Self) --- 
    innerMock.select.mockReturnValue(innerMock);
    innerMock.eq.mockReturnValue(innerMock);
    innerMock.neq.mockReturnValue(innerMock);
    innerMock.gt.mockReturnValue(innerMock);
    innerMock.gte.mockReturnValue(innerMock);
    innerMock.lt.mockReturnValue(innerMock);
    innerMock.lte.mockReturnValue(innerMock);
    innerMock.like.mockReturnValue(innerMock);
    innerMock.ilike.mockReturnValue(innerMock);
    innerMock.is.mockReturnValue(innerMock);
    innerMock.in.mockReturnValue(innerMock);
    innerMock.contains.mockReturnValue(innerMock);
    innerMock.containedBy.mockReturnValue(innerMock);
    innerMock.rangeGt.mockReturnValue(innerMock);
    innerMock.rangeGte.mockReturnValue(innerMock);
    innerMock.rangeLt.mockReturnValue(innerMock);
    innerMock.rangeLte.mockReturnValue(innerMock);
    innerMock.rangeAdjacent.mockReturnValue(innerMock);
    innerMock.overlaps.mockReturnValue(innerMock);
    innerMock.textSearch.mockReturnValue(innerMock);
    innerMock.match.mockReturnValue(innerMock);
    innerMock.not.mockReturnValue(innerMock);
    innerMock.or.mockReturnValue(innerMock);
    innerMock.filter.mockReturnValue(innerMock);
    innerMock.limit.mockReturnValue(innerMock);
    innerMock.range.mockReturnValue(innerMock);
    innerMock.order.mockReturnValue(innerMock);

    // --- Configure Default TERMINAL Methods --- 
    // For single-returning methods, default to null
    const singleResponse = { 
      data: null, 
      error: null, 
      status: 200, 
      statusText: 'OK' 
    };
    
    innerMock.single.mockResolvedValue(singleResponse);
    innerMock.maybeSingle.mockResolvedValue(singleResponse);
    
    // For insert/update/upsert operations, return the builder that can be chained further or awaited
    innerMock.insert.mockImplementation(() => {
      const insertMock = createMockWithPromiseCapability();
      insertMock.select.mockReturnValue(insertMock);
      return insertMock;
    });
    
    innerMock.upsert.mockImplementation(() => {
      const upsertMock = createMockWithPromiseCapability();
      upsertMock.select.mockReturnValue(upsertMock);
      return upsertMock;
    });
    
    innerMock.update.mockImplementation(() => {
      const updateMock = createMockWithPromiseCapability();
      updateMock.select.mockReturnValue(updateMock);
      return updateMock;
    });
    
    innerMock.delete.mockImplementation(() => {
      const deleteMock = createMockWithPromiseCapability();
      deleteMock.select.mockReturnValue(deleteMock);
      return deleteMock;
    });

    return innerMock;
  });
}
  ```

  *Exports: `TableName`*
  ```ts
export type TableName = 
| 'users' 
| 'user_profiles' 
| 'user_settings'
| 'values'
| 'principles'
| 'goals' 
| 'tasks'
| 'habits'
| 'habit_entries'
| 'tracked_state_defs' 
| 'state_entries'     
| 'reminders'         
| 'goal_progress_notes'
| 'rewards'           
| 'user_badges';
  ```

- **__tests__/test-utils.tsx**

  *Exports: `render`*
  ```tsx
export { customRender as render };
  ```

### .github

- **.github/workflows/ci.yml**
  *(No explicit exports found)*

### app

- **app/(auth)/_layout.tsx**

  *Exports: `default`*
  ```tsx
export default function AuthLayout() {
  return (
    <Stack>
      <Stack.Screen 
        name="login" 
        options={{ 
          title: 'Sign In',
          headerShown: false
        }} 
      />
      <Stack.Screen 
        name="register" 
        options={{ 
          title: 'Create Account',
          headerShown: false
        }} 
      />
      <Stack.Screen 
        name="forgot-password" 
        options={{ 
          title: 'Reset Password',
          headerShown: false
        }} 
      />
    </Stack>
  );
}
  ```

- **app/(auth)/forgot-password.tsx**

  *Exports: `default`*
  ```tsx
export default function ForgotPasswordScreen() {
  const [email, setEmail] = useState('');
  const [loading, setLoading] = useState(false);
  const [success, setSuccess] = useState(false);
  const toast = useToastController();

  // Send password reset email via Supabase
  const handleResetPassword = async () => {
    if (!email) {
      toast.show('Please enter your email', { type: 'error' });
      return;
    }

    setLoading(true);

    try {
      const { error } = await supabase.auth.resetPasswordForEmail(email, {
        redirectTo: window?.location?.origin ? `${window.location.origin}/update-password` : undefined,
      });

      if (error) throw error;

      setSuccess(true);
      toast.show('Password reset email sent!', { type: 'success' });
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to send reset email';
      toast.show(errorMessage, { type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <YStack flex={1} padding="$4" justifyContent="center" space="$4" backgroundColor="$background">
      <YStack alignItems="center" marginBottom="$6">
        {/* Replace with your app logo */}
        <Image 
          source={require('@/assets/images/icon.png')} 
          width={100} 
          height={100} 
          marginBottom="$6" 
          resizeMode="contain"
        />
        <H1>Reset Password</H1>
        <Text color="$gray10" textAlign="center">
          {success 
            ? 'Check your email for reset instructions' 
            : 'Enter your email to receive reset instructions'}
        </Text>
      </YStack>

      {!success ? (
        <>
          <Input
            placeholder="Email"
            value={email}
            onChangeText={setEmail}
            autoCapitalize="none"
            keyboardType="email-address"
          />

          <Button
            onPress={handleResetPassword}
            disabled={loading}
            backgroundColor="$blue10"
            color="white"
            size="$5"
          >
            {loading ? <Spinner color="white" /> : 'Send Reset Link'}
          </Button>
        </>
      ) : null}

      <YStack paddingTop="$6" alignItems="center">
        <Link href="/(auth)/login">
          <Text color="$blue10">Back to Sign In</Text>
        </Link>
      </YStack>
    </YStack>
  );
}
  ```

- **app/(auth)/login.tsx**

  *Exports: `default`*
  ```tsx
export default function LoginScreen() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const toast = useToastController();

  // Sign in with Supabase authentication
  const handleLogin = async () => {
    if (!email || !password) {
      toast.show('Please enter both email and password', { type: 'error' });
      return;
    }

    setLoading(true);

    try {
      const { error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (error) throw error;

      // Navigate to home screen on successful login
      router.replace('/(tabs)/home');
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Login failed';
      toast.show(errorMessage, { type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <YStack flex={1} padding="$4" justifyContent="center" space="$4" backgroundColor="$background">
      <YStack alignItems="center" marginBottom="$6">
        {/* Replace with your app logo */}
        <Image 
          source={require('@/assets/images/icon.png')} 
          width={100} 
          height={100} 
          marginBottom="$6" 
          resizeMode="contain"
        />
        <H1>Welcome to Aether</H1>
        <Text color="$gray10">Sign in to your account</Text>
      </YStack>

      <Input
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        autoCapitalize="none"
        keyboardType="email-address"
      />

      <Input
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <Button
        onPress={handleLogin}
        disabled={loading}
        backgroundColor="$blue10"
        color="white"
        size="$5"
      >
        {loading ? <Spinner color="white" /> : 'Sign In'}
      </Button>

      <XStack justifyContent="space-between" paddingTop="$2">
        <Link href="/(auth)/forgot-password">
          <Text color="$blue10">Forgot Password?</Text>
        </Link>

        <Link href="/(auth)/register">
          <Text color="$blue10">Create Account</Text>
        </Link>
      </XStack>
    </YStack>
  );
}
  ```

- **app/(auth)/register.tsx**

  *Exports: `default`*
  ```tsx
export default function RegisterScreen() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const toast = useToastController();

  // Create new account with Supabase authentication
  const handleRegister = async () => {
    if (!email || !password) {
      toast.show('Please enter both email and password', { type: 'error' });
      return;
    }

    if (password !== confirmPassword) {
      toast.show('Passwords do not match', { type: 'error' });
      return;
    }

    setLoading(true);

    try {
      const { error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          emailRedirectTo: window?.location?.origin || undefined,
        }
      });

      if (error) throw error;

      // Navigate to home screen on successful registration
      toast.show('Account created successfully!', { type: 'success' });
      router.replace('/(tabs)/home');
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Registration failed';
      toast.show(errorMessage, { type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <YStack flex={1} padding="$4" justifyContent="center" space="$4" backgroundColor="$background">
      <YStack alignItems="center" marginBottom="$6">
        {/* Replace with your app logo */}
        <Image 
          source={require('@/assets/images/icon.png')} 
          width={100} 
          height={100} 
          marginBottom="$6" 
          resizeMode="contain"
        />
        <H1>Create Account</H1>
        <Text color="$gray10">Sign up to get started</Text>
      </YStack>

      <Input
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        autoCapitalize="none"
        keyboardType="email-address"
      />

      <Input
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />
      
      <Input
        placeholder="Confirm Password"
        value={confirmPassword}
        onChangeText={setConfirmPassword}
        secureTextEntry
      />

      <Button
        onPress={handleRegister}
        disabled={loading}
        backgroundColor="$blue10"
        color="white"
        size="$5"
      >
        {loading ? <Spinner color="white" /> : 'Create Account'}
      </Button>

      <XStack justifyContent="center" paddingTop="$2">
        <Text color="$gray10">Already have an account? </Text>
        <Link href="/(auth)/login">
          <Text color="$blue10">Sign In</Text>
        </Link>
      </XStack>
    </YStack>
  );
}
  ```

- **app/(tabs)/_layout.tsx**

  *Exports: `default`*
  ```tsx
export default function TabsLayout() {
  const active = useColorModeValue('#86A5A9', '#64FFDA');
  const inactive = useColorModeValue('#8e8e93', '#626262');
  const bg = useColorModeValue('#FDFFE0', '#1A2E3A');
  const border = useColorModeValue('#E5E5EA', '#2C2C2E');

  return (
    <Tabs
      screenOptions={{
        headerShown: false,
        tabBarActiveTintColor: active,
        tabBarInactiveTintColor: inactive,
        tabBarStyle: { backgroundColor: bg, borderTopColor: border, height: 60 },
      }}
    >
      <Tabs.Screen
        name="home"
        options={{
          title: 'Home',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="home-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="planner"
        options={{
          title: 'Planner',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="calendar-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="compass"
        options={{
          title: 'Compass',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="stats-chart-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="rewards"
        options={{
          title: 'Rewards',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="sparkles-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="settings"
        options={{
          title: 'Settings',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="settings-outline" size={size} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}
  ```

- **app/(tabs)/compass/index.tsx**

  *Exports: `default`*
  ```tsx
export default function CompassScreen() {
  const [activeTab, setActiveTab] = useState<string>('principles');
  const colorScheme = useColorScheme();

  const handleAddPress = () => {
    const route = `/compose?type=${activeTab === 'principles' ? 'value' : 'state'}` as Href;
    router.push(route);
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Compass</Text>
          <Button
            size="$3"
            circular
            onPress={handleAddPress} 
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>

        {/* Tabs */}
        <Tabs
          defaultValue="principles"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {React.cloneElement(tab.icon as React.ReactElement, { color: activeTab === tab.key ? '$colorFocus' : '$color' })}
                  <Text color={activeTab === tab.key ? '$colorFocus' : '$color'}>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>

          {/* Tab Content */}
          <Tabs.Content value="principles" flex={1} key="principles-content">
            <ScrollView>
              <PrinciplesTab />
            </ScrollView>
          </Tabs.Content>

          <Tabs.Content value="states" flex={1} key="states-content">
            <ScrollView>
              <StatesTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/home/index.tsx**

  *Exports: `default`*
  ```tsx
export default function HomeScreen() {
  const router = useRouter();
  const { data, isLoading, isRefetching, refetch } = useDashboardQuery();
  const toggleTask = useToggleTaskStatus();

  const parchment = useColorModeValue('#FDFFE0', '#1A2E3A');

  return (
    <ScrollView
      className="flex-1 px-4"
      style={{ backgroundColor: parchment }}
      refreshControl={<RefreshControl refreshing={isRefetching} onRefresh={refetch} />}
    >
      <Text className="text-2xl font-heading text-darkText mt-6 mb-4">
        Good morning, Link!
      </Text>

      {/* Tasks Section */}
      <SectionCard
        title="Tasks for today"
        action={
          <Button
            className="flex-row items-center"
            onPress={() => router.push('/(tabs)/planner/add-task')}
          >
            <Ionicons name="add" size={18} color="#86A5A9" />
            <Text className="ml-1 text-sheikahCyan">New</Text>
          </Button>
        }
      >
        {isLoading && <Text>Loading…</Text>}
        {!isLoading && (!data?.tasks?.length ? (
          <Text className="text-ios-gray-3">No tasks 🎉</Text>
        ) : (
          data.tasks.map((task) => (
            <SwipeableRow
              key={task.id}
              onComplete={() =>
                toggleTask.mutate({ taskId: task.id, completed: task.status !== 'done' })
              }
            >
              <TaskRow task={task} />
            </SwipeableRow>
          ))
        ))}
      </SectionCard>

      {/* You can add Habits / Goals sections here following the same pattern */}
    </ScrollView>
  );
}
  ```

- **app/(tabs)/planner/_layout.tsx**

  *Exports: `default`*
  ```tsx
export default function PlannerLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      {/* The index screen is the default for the planner tab */}
      <Stack.Screen name="index" />
      {/* Add screens for the sub-pages */}
      <Stack.Screen name="add-task" options={{ presentation: 'modal', title: 'Add Task' }} />
      <Stack.Screen name="add-habit" options={{ presentation: 'modal', title: 'Add Habit' }} />
      <Stack.Screen name="add-goal" options={{ presentation: 'modal', title: 'Add Goal' }} />
      <Stack.Screen name="goal/[id]" options={{ title: 'Goal Details' }} />
      <Stack.Screen name="habit/[id]" options={{ title: 'Habit Details' }} />
    </Stack>
  );
}
  ```

- **app/(tabs)/planner/add-goal.tsx**

  *Exports: `default`*
  ```tsx
export default function AddGoalScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Add New Goal</H1>
        <Text>Goal details form will go here.</Text>
        <Button onPress={() => router.back()}>Cancel</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/planner/add-habit.tsx**

  *Exports: `default`*
  ```tsx
export default function AddHabitScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Add New Habit</H1>
        <Text>Habit details form will go here.</Text>
        <Button onPress={() => router.back()}>Cancel</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/planner/add-task.tsx**

  *Exports: `default`*
  ```tsx
export default function AddTaskScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Add New Task</H1>
        <Text>Task details form will go here.</Text>
        <Button onPress={() => router.back()}>Cancel</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/planner/goal/[id].tsx**

  *Exports: `default`*
  ```tsx
export default function GoalDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const colorScheme = useColorScheme();

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Goal Detail: {id}</H1>
        <Text>Details for goal {id} will be displayed here.</Text>
        {/* Add tRPC query to fetch goal data based on id */}
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/planner/habit/[id].tsx**

  *Exports: `default`*
  ```tsx
export default function HabitDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const colorScheme = useColorScheme();

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Habit Detail: {id}</H1>
        <Text>Details for habit {id} will be displayed here.</Text>
        {/* Add tRPC query to fetch habit data based on id */}
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/planner/index.tsx**

  *Exports: `default`*
  ```tsx
export default function PlannerScreen() {
  const [activeTab, setActiveTab] = useState<string>('goals');
  const colorScheme = useColorScheme();
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Planner</Text>
          <Button
            size="$3"
            circular
            onPress={() => {/* Handle new item */}}
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>
        
        {/* Tabs */}
        <Tabs
          defaultValue="goals"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List 
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {tab.icon}
                  <Text>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>
          
          {/* Tab Content */}
          <Tabs.Content value="goals" flex={1}>
            <ScrollView>
              <GoalsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="habits" flex={1}>
            <ScrollView>
              <HabitsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="calendar" flex={1}>
            <ScrollView>
              <CalendarTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/rewards/index.tsx**

  *Exports: `default`*
  ```tsx
export default function RewardsScreen() {
  const [viewMode, setViewMode] = useState<ViewMode>(ViewMode.Grid);
  const colorScheme = useColorScheme();
  const theme = useTheme();

  // Define fallback colors
  const blue2 = theme?.blue2?.val ?? '#eff6ff';
  const blue5 = theme?.blue5?.val ?? '#60a5fa';
  const blue10 = theme?.blue10?.val ?? '#1e40af';
  const blue11 = theme?.blue11?.val ?? '#1e3a8a';
  const green9 = theme?.green9?.val ?? '#16a34a';

  // Fetch available rewards from tRPC
  const { 
    data: rewards, 
    isLoading, 
    error, 
    refetch 
  } = trpc.rewards.getAvailableRewards.useQuery();

  // Mutation for claiming rewards
  const claimMutation = trpc.rewards.earnReward.useMutation({
    onSuccess: (data) => {
      console.log('Reward claimed successfully:', data);
      // Maybe show confetti?
      Alert.alert('Reward Claimed!', `You spent ${data.reward.points_spent} points. Remaining: ${data.remainingPoints}`);
      refetch(); // Refetch the list of available rewards
    },
    onError: (err) => {
      console.error('Failed to claim reward:', err);
      Alert.alert('Claim Failed', err.message || 'Could not claim reward.');
    }
  });
  
  const handleClaimReward = useCallback((rewardId: string) => {
    if (claimMutation.isPending) return; // Prevent double-clicks
    
    Alert.alert(
      'Confirm Claim',
      'Are you sure you want to spend points on this reward?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Claim', 
          onPress: () => {
            claimMutation.mutate({ rewardId });
          },
          style: 'default'
        }
      ]
    );
  }, [claimMutation]);
  
  const renderItem = ({ item }: { item: RewardItem }) => { // Use inferred type
    // Assuming backend field is image_url, map to imagePath
    const imagePath = item.image_url; 
    // All items from getAvailableRewards are considered claimable (not yet claimed)
    const claimed = false; 
    // Map required_points to pointCost
    const pointCost = item.required_points;

    if (viewMode === ViewMode.Grid) {
      return (
        <Card
          size="$4"
          bordered
          width={160}
          height={200}
          margin="$2"
          overflow="hidden"
          elevation="$2"
          opacity={claimed ? 0.7 : 1}
        >
          <ImageBackground
            source={{ uri: imagePath }}
            style={{ width: '100%', height: 100 }}
          >
            <View style={{ 
              position: 'absolute', 
              top: 5, 
              right: 5, 
              backgroundColor: blue5,
              borderRadius: 10,
              padding: 4
            }}>
              <Text color="white" fontSize="$2" fontWeight="bold">
                {pointCost} pts
              </Text>
            </View>
          </ImageBackground>
          
          <YStack padding="$2" flex={1} justifyContent="space-between">
            <Text fontSize="$4" fontWeight="bold" numberOfLines={1}>
              {item.name}
            </Text>
            
            <Button
              size="$2"
              themeInverse={claimed}
              backgroundColor={claimed ? undefined : blue10}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </YStack>
        </Card>
      );
    } else {
      return (
        <Card
          bordered
          margin="$2"
          padding="$3"
          opacity={claimed ? 0.7 : 1}
        >
          <XStack space="$3" alignItems="center">
            {imagePath && (
              <View style={{ 
                width: 60, 
                height: 60, 
                borderRadius: 8, 
                overflow: 'hidden',
                backgroundColor: theme.gray3.val
              }}>
                <ImageBackground
                  source={{ uri: imagePath }}
                  style={{ width: '100%', height: '100%' }}
                />
              </View>
            )}
            
            <YStack flex={1} space="$1">
              <Text fontSize="$5" fontWeight="bold">{item.name}</Text>
              <Text fontSize="$3" color="$gray11" numberOfLines={2}>{item.description}</Text>
              <Text fontSize="$3" color={blue10} fontWeight="500">{pointCost} points</Text>
            </YStack>
            
            <Button
              size="$3"
              backgroundColor={claimed ? undefined : blue10}
              themeInverse={claimed}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </XStack>
        </Card>
      );
    }
  };
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        <YStack space="$4">
          {/* Header */}
          <XStack justifyContent="space-between" alignItems="center">
            <H1>Rewards</H1>
            
            <XStack space="$2">
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.Grid ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.Grid)}
              >
                <Ionicons 
                  name="grid-outline" 
                  size={22} 
                  color={viewMode === ViewMode.Grid ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
              
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.List ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.List)}
              >
                <Ionicons 
                  name="list-outline" 
                  size={22} 
                  color={viewMode === ViewMode.List ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
            </XStack>
          </XStack>
          
          {/* Stats */}
          <Card padding="$3" backgroundColor={blue2}>
            <XStack justifyContent="space-between" alignItems="center">
              <Text fontSize="$5" fontWeight="bold" color={blue11}>Your Points</Text>
              <Text fontSize="$6" fontWeight="bold" color={blue10}>275</Text>
            </XStack>
          </Card>
        </YStack>
        
        {/* Content Area */} 
        <EmptyOrSkeleton 
          isLoading={isLoading}
          isEmpty={!isLoading && !error && (!rewards || rewards.length === 0)}
          isError={!!error}
          text={error ? error.message : 'No rewards available yet.'} // Use text for error OR empty msg
          onRetry={refetch}
          type={viewMode === ViewMode.Grid ? 'card' : 'row'}
          count={viewMode === ViewMode.Grid ? 6 : 3}
        >
          <FlatList
            key={viewMode} // Change key based on viewMode to force re-render
            data={rewards}
            renderItem={renderItem}
            keyExtractor={(item, index) =>
              `${item?.id ?? `tmp-${index}`}-${viewMode}`   // fall back to index if ID is missing
            }
            
            // Optional: Log corrupt data in development
            onLayout={() => {
              if (__DEV__) {
                const missing = (rewards ?? []).filter(r => !r?.id);
                if (missing.length) console.warn('Rewards missing id:', missing);
              }
            }}
            numColumns={viewMode === ViewMode.Grid ? 2 : 1}
            contentContainerStyle={{ paddingBottom: 50 }} // Add padding at the bottom
            // Optional Optimizations (Patch #6)
            initialNumToRender={8}
            removeClippedSubviews={true} // Note: Can have visual glitches on iOS sometimes
          />
        </EmptyOrSkeleton>

      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/_layout.tsx**

  *Exports: `default`*
  ```tsx
export default function SettingsLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      {/* The index screen is the default for the settings tab */}
      <Stack.Screen name="index" />
      {/* Add screens for the sub-pages */}
      <Stack.Screen name="profile" options={{ title: 'Edit Profile' }} />
      <Stack.Screen name="security" options={{ title: 'Security' }} />
      <Stack.Screen name="privacy" options={{ title: 'Data & Privacy' }} />
      <Stack.Screen name="notifications" options={{ title: 'Notifications' }} />
      <Stack.Screen name="help" options={{ title: 'Help & Support' }} />
      <Stack.Screen name="about" options={{ title: 'About Aether' }} />
    </Stack>
  );
}
  ```

- **app/(tabs)/settings/about.tsx**

  *Exports: `default`*
  ```tsx
export default function AboutScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>About Aether</H1>
        <Text>App version, terms of service, credits, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/help.tsx**

  *Exports: `default`*
  ```tsx
export default function HelpScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Help & Support</H1>
        <Text>FAQ, contact support link, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/index.tsx**

  *Exports: `default`*
  ```tsx
export default function SettingsScreen() {
  const colorScheme = useColorScheme();
  const [notificationsEnabled, setNotificationsEnabled] = useState(true);
  const [trackingEnabled, setTrackingEnabled] = useState(true);
  const { setAccent } = useAccent(); // Get the function to update accent color
  const [selectedAccent, setSelectedAccent] = useState('blue'); // Placeholder state for selected accent

  const handleLogout = async () => {
    Alert.alert(
      'Log Out',
      'Are you sure you want to log out?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Log Out', 
          style: 'destructive',
          onPress: async () => {
            await supabase.auth.signOut();
            router.replace('/(auth)/login');
          }
        }
      ]
    );
  };

  const AccentSelector = ({ currentAccent, onSelect }: { currentAccent: string, onSelect: (accent: string) => void }) => {
    const accents = ['blue', 'green', 'orange', 'red']; // Example accents corresponding to theme names
    return (
      <XStack space="$2">
        {accents.map((accent) => (
          <Button 
            key={accent} 
            onPress={() => {
              onSelect(accent);
              setAccent(accent); // Call setAccent with the selected accent
            }} 
            theme={accent as any} // Preview the theme (cast needed for demo)
            backgroundColor={accent === currentAccent ? '$backgroundStrong' : '$background'}
          >
            {accent.charAt(0).toUpperCase() + accent.slice(1)}
          </Button>
        ))}
      </XStack>
    );
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <ScrollView>
        <YStack flex={1} padding="$4">
          <H1 marginBottom="$4">Settings</H1>
          
          {/* Account Section */}
          <SettingsSection
            title="Account"
            icon={<Ionicons name="person-circle-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Edit Profile"
                icon={<Ionicons name="person-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/profile' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Security"
                icon={<Ionicons name="lock-closed-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/security' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Data & Privacy"
                icon={<Ionicons name="shield-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/privacy' as any)}
              />
            </YStack>
          </SettingsSection>
          
          {/* Appearance Section */}
          <SettingsSection
            title="Appearance"
            icon={<Ionicons name="color-palette-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Theme"
                icon={<Ionicons name="moon-outline" size={20} color="#A0A0A0" />}
                rightElement={<Text color="$gray10">{colorScheme === 'dark' ? 'Dark (System)' : 'Light (System)'}</Text>}
              />
              <SettingsRow
                label="Accent Color"
                icon={<Ionicons name="color-palette-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <AccentSelector 
                    currentAccent={selectedAccent} 
                    onSelect={(accent) => setSelectedAccent(accent)} 
                  />
                }
              />
            </YStack>
          </SettingsSection>
          
          {/* Notifications Section */}
          <SettingsSection
            title="Notifications"
            icon={<Ionicons name="notifications-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Push Notifications"
                icon={<Ionicons name="push-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={notificationsEnabled}
                    onCheckedChange={setNotificationsEnabled}
                  />
                }
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Notification Settings"
                icon={<Ionicons name="options-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/notifications' as any)}
              />
            </YStack>
          </SettingsSection>
          
          {/* Privacy Section */}
          <SettingsSection
            title="Privacy & Data"
            icon={<Ionicons name="analytics-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Analytics Tracking"
                icon={<Ionicons name="trending-up-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={trackingEnabled}
                    onCheckedChange={setTrackingEnabled}
                  />
                }
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Export Data"
                icon={<Ionicons name="download-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => {
                  Alert.alert(
                    'Export Data',
                    'Your data will be prepared for export and sent to your email address.',
                    [
                      { text: 'Cancel', style: 'cancel' },
                      { text: 'Export', onPress: () => {
                        // Would call an API endpoint to initiate export
                        Alert.alert('Export Initiated', 'Check your email for the export file.');
                      }}
                    ]
                  );
                }}
              />
            </YStack>
          </SettingsSection>
          
          {/* Support Section */}
          <SettingsSection
            title="Support & About"
            icon={<Ionicons name="help-circle-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Help Center"
                icon={<Ionicons name="help-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/help' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="About Aether"
                icon={<Ionicons name="information-circle-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/about' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="App Version"
                icon={<Ionicons name="code-outline" size={20} color="#A0A0A0" />}
                rightElement={<Text color="$gray10">1.0.0</Text>}
              />
            </YStack>
          </SettingsSection>
          
          {/* Logout Button */}
          <Button
            marginTop="$6"
            marginBottom="$8"
            size="$4"
            themeInverse
            onPress={handleLogout}
          >
            Log Out
          </Button>
        </YStack>
      </ScrollView>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/notifications.tsx**

  *Exports: `default`*
  ```tsx
export default function NotificationSettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Notification Settings</H1>
        <Text>Granular controls for different notification types.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/privacy.tsx**

  *Exports: `default`*
  ```tsx
export default function PrivacySettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Data & Privacy</H1>
        <Text>Data management options, privacy policy link, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/profile.tsx**

  *Exports: `default`*
  ```tsx
export default function ProfileSettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Edit Profile</H1>
        <Text>Profile editing form will go here.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/security.tsx**

  *Exports: `default`*
  ```tsx
export default function SecuritySettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Security Settings</H1>
        <Text>Password change, 2FA options, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/_layout.tsx**

  *Exports: `default`*
  ```tsx
export default function RootLayout() {
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        <GluestackUIProvider config={glueTheme}>
          <SupabaseProvider>
            <TRPCProvider>
              <Stack screenOptions={{ headerShown: false }} />
            </TRPCProvider>
          </SupabaseProvider>
        </GluestackUIProvider>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}
  ```

- **app/components/SectionCard.tsx**

  *Exports: `SectionCard`*
  ```tsx
const SectionCard: React.FC<SectionCardProps> = ({ title, children }) => {
  return (
    <Stack className="mb-6 overflow-hidden rounded-2xl">
      <BlurView intensity={30} tint="light" className="overflow-hidden rounded-2xl">
        <Stack className="p-4 bg-parchment/50 dark:bg-sheikahCyan/10">
          <Text className="font-heading text-lg mb-2 text-darkText dark:text-parchment">{title}</Text>
          {children}
        </Stack>
      </BlurView>
    </Stack>
  );
};
  ```

- **app/components/SwipeableRow.tsx**

  *Exports: `SwipeableRow`*
  ```tsx
const SwipeableRow = ({ children, onComplete, onDelete }: SwipeableRowProps) => {
  // Render left-swipe (complete) action
  const renderLeftActions = () => {
    if (!onComplete) return null;
    return (
      <View className="flex-row">
        <Button 
          className="w-20 h-full justify-center items-center bg-korokGreen" 
          onPress={onComplete}
          aria-label="Complete task"
        >
          <Ionicons name="checkmark-outline" size={20} color="#FDFFE0" /* parchment */ />
        </Button>
      </View>
    );
  };

  // Render right-swipe (delete) action
  const renderRightActions = () => {
    if (!onDelete) return null;
    return (
      <View className="flex-row justify-end">
        <Button 
          className="w-20 h-full justify-center items-center bg-guardianOrange" 
          onPress={onDelete}
          aria-label="Delete task"
        >
          <Ionicons name="trash-outline" size={20} color="#FDFFE0" /* parchment */ />
        </Button>
      </View>
    );
  };

  return (
    <Swipeable
      renderLeftActions={renderLeftActions}
      renderRightActions={renderRightActions}
      overshootFriction={8}
      containerStyle={{ backgroundColor: 'transparent' }}
    >
      {children}
    </Swipeable>
  );
};
  ```

- **app/components/TaskRow.tsx**

  *Exports: `TaskRow`*
  ```tsx
const TaskRow = memo(({ task }: { task: Task }) => (
  <Stack className="flex-row items-center py-3 px-4 bg-parchment/80 dark:bg-darkTealBg/50">
    {task.status === 'completed' && (
      <Ionicons 
        name="checkmark-circle" 
        size={18} 
        color="#92C582" // korokGreen
        style={{ marginRight: 8 }} 
      />
    )}
    <Text 
      className={`flex-1 ${task.status === 'completed' 
        ? 'text-darkText/50 line-through' 
        : 'text-darkText dark:text-parchment'}`}
    >
      {task.name}
    </Text>
    {task.due_date && (
      <Text className="text-xs text-darkText/70 dark:text-parchment/70">
        {new Date(task.due_date).toLocaleDateString()}
      </Text>
    )}
  </Stack>
));
  ```

- **app/compose.tsx**

  *Exports: `default`*
  ```tsx
export default function ComposeModal() {
  const router = useRouter();
  const params = useLocalSearchParams<{ type: string }>();
  const type = params.type === 'value' || params.type === 'state' ? params.type : undefined;
  const toast = useToastController();
  const utils = trpc.useUtils();

  const isValue = type === 'value';

  // 2️⃣ Define stricter default values using tagged types
  const defaultValueValues: CreateValueInputTagged = {
    __type: 'value',
    title: '', // Use 'title' instead of 'name' - Patch #4
    description: ''
  };
  const defaultStateValues: CreateStateInputTagged = {
    __type: 'state',
    name: '',
    scale: '1-5',
    description: '',
    active: true,
    priority: 50
  };

  // --- Separate useMutation hooks ---
  const createValueMutation = trpc.value.createValue.useMutation({
    onSuccess: (data) => handleSuccess(data),
    onError: (error) => handleError(error),
  });
  const createStateDefMutation = trpc.state.createDefinition.useMutation({
    onSuccess: (data) => handleSuccess(data),
    onError: (error) => handleError(error),
  });

  // --- Form setup ---
  const { control, handleSubmit, formState: { errors }, reset } = useForm<FormValues>({
    // Note: ZodResolver might need specific configuration if schemas differ vastly
    // or consider not using it if relying solely on backend validation for this dynamic form.
    // Use the new stricter default value constants
    defaultValues: isValue ? defaultValueValues : defaultStateValues,
  });

  // Reset form if the type changes dynamically
  React.useEffect(() => {
    // Use the new stricter default value constants for reset
    reset(isValue ? defaultValueValues : defaultStateValues);
  }, [isValue, reset]);

  // --- Shared success/error handlers ---
  const handleSuccess = (data: any) => {
      toast.show('Created successfully!', { native: true });
      haptics.success();
      if (isValue) {
        utils.value.getValues.invalidate();
      } else {
        utils.state.getDefinitions.invalidate();
      }
      if (router.canGoBack()) {
        router.dismiss(); // Apply patch #5 - Use dismiss for modals
      } else {
        router.replace('/(tabs)/compass');
      }
  }

  const handleError = (error: any) => {
       toast.show(`Error: ${error.message}`, { type: 'error', native: true });
       haptics.error();
  }

  // --- Corrected onSubmit ---
  const onSubmit = (formData: FormValues) => {
    // 3️⃣ Use discriminant (__type) for type safety, remove casts
    if (formData.__type === 'value') {
      createValueMutation.mutate(formData);
    } else { // formData.__type === 'state'
      createStateDefMutation.mutate(formData);
    }
  };

  // Handle invalid type parameter gracefully
  if (!type) {
    return (
        <YStack flex={1} justifyContent="center" alignItems="center" padding="$4">
            <Paragraph color="$error">Invalid type specified.</Paragraph> {/* Use $error */}
            <Button onPress={() => router.back()} marginTop="$4">Go Back</Button>
        </YStack>
    );
  }

  // Determine current mutation state for button
  const isPending = isValue ? createValueMutation.isPending : createStateDefMutation.isPending;

  return (
    <ScrollView contentContainerStyle={{ flexGrow: 1 }}>
      <Form onSubmit={handleSubmit(onSubmit)} flex={1} padding="$4" space="$4" backgroundColor="$background">
        <Stack.Screen options={{ title: isValue ? 'Add Principle' : 'Define State' }} />

        {/* Conditionally render form fields */}
        {isValue ? (
          <>
            {/* --- Fields for Principle/Value --- */}
            <YStack space="$2">
              <Label htmlFor="title">Title</Label> {/* Patch #4: name -> title */}
              <Controller
                name="title" /* Patch #4: name -> title */
                control={control}
                rules={{ required: 'Title is required' }} /* Patch #4 */
                render={({ field }) => ( /* Use inferred types from FormValues */
                  <Input
                    id="title"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value}
                    placeholder="Principle Title"
                  />
                )}
              />
              {/* Use $error token */}
              {errors.title && <Paragraph color="$error">{errors.title?.message}</Paragraph>}
            </YStack>

            <YStack space="$2">
              <Label htmlFor="description">Description (Optional)</Label>
              <Controller
                name="description"
                control={control}
                render={({ field }) => ( // Use inferred types
                  <TextArea
                    id="description"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value ?? ''}
                    placeholder="Describe the principle..."
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && <Paragraph color="$error">{errors.description?.message}</Paragraph>}
            </YStack>
          </>
        ) : (
          <>
            {/* --- Fields for State Definition --- */}
            <YStack space="$2">
              <Label htmlFor="name">State Name</Label>
              <Controller
                name="name"
                control={control}
                rules={{ required: 'Name is required' }}
                render={({ field }) => ( // Use inferred types // Explicit type
                  <Input
                    id="name"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value}
                    placeholder="e.g., Energy Level, Mood" />
                )}
              />
              {errors.name && <Paragraph color="$error">{errors.name?.message}</Paragraph>}
            </YStack>

             <YStack space="$2">
               <Label htmlFor="scale">Scale</Label>
               <Controller
                 name="scale"
                 control={control}
                 rules={{ required: 'Scale is required' }}
                 render={({ field }) => ( // Use inferred types
                   <>
                    <Paragraph>Scale Selector Placeholder (Selected: {field.value})</Paragraph>
                    <XStack space="$2">
                      {/* Removed invalid theme prop */}
                      <Button size="$2" onPress={() => field.onChange('1-5')} theme={field.value === '1-5' ? 'active' : undefined}>1-5</Button>
                      <Button size="$2" onPress={() => field.onChange('1-10')} theme={field.value === '1-10' ? 'active' : undefined}>1-10</Button>
                    </XStack>
                   </>
                 )}
               />
                {errors.scale && <Paragraph color="$error">{errors.scale?.message}</Paragraph>}
             </YStack>

             <YStack space="$2">
              <Label htmlFor="description">Description (Optional)</Label>
              <Controller
                name="description"
                control={control}
                render={({ field }) => ( // Use inferred types
                  <TextArea
                    id="description"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value ?? ''}
                    placeholder="Describe when/how to track this state..."
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && <Paragraph color="$error">{errors.description?.message}</Paragraph>}
            </YStack>

            <XStack space="$4" alignItems="center">
               <Label htmlFor="active" flex={1}>Active</Label>
               <Controller
                 name="active"
                 control={control}
                 render={({ field }: { field: ControllerRenderProps<FieldValues, 'active'> }) => ( // Explicit type
                    <Switch
                      id="active"
                      checked={!!field.value} // Use checked
                      onCheckedChange={field.onChange} // Use onCheckedChange
                      size="$3"
                    >
                        <Switch.Thumb animation="quick" />
                    </Switch>
                 )}
               />
            </XStack>
          </>
        )}

        {/* Removed invalid theme prop */}
        <Form.Trigger asChild disabled={isPending}>
          <Button icon={isPending ? <Spinner /> : undefined}>
            {isPending ? 'Saving...' : 'Save'}
          </Button>
        </Form.Trigger>
      </Form>
    </ScrollView>
  );
}
  ```

- **app/index.tsx**

  *Exports: `default`*
  ```tsx
export default function RootIndex() {
  // Redirect directly to a specific tab without causing infinite redirects
  // Use the path that matches how it's accessed in the proper format
  // TypeScript suggests this is the correct format for Expo Router
  return <Redirect href="/(tabs)/home" />;
}
  ```

- **app/lib/useDashboardQuery.ts**

  *Exports: `DashboardData`*
  ```ts
export type DashboardData = RouterOutputs['dashboard']['getDashboardData'];
  ```

  *Exports: `useDashboardQuery`*
  ```ts
const useDashboardQuery = () =>
trpc.dashboard.getDashboardData.useQuery(undefined, { 
  staleTime: 60_000, // 1 minute stale time
  refetchOnMount: 'always', // Always refetch when component mounts
});
  ```

- **app/lib/useToggleTaskStatus.ts**

  *Exports: `useToggleTaskStatus`*
  ```ts
const useToggleTaskStatus = () => {
  const utils = trpc.useUtils();
  
  return trpc.task.toggleTask.useMutation({
    // Optimistically update UI before server responds
    onMutate: async ({ taskId, completed }) => {
      // Cancel any outgoing refetches
      await utils.dashboard.getDashboardData.cancel();
      
      // Snapshot current data for potential rollback
      const previous = utils.dashboard.getDashboardData.getData();
      
      // Optimistically update to the new value
      utils.dashboard.getDashboardData.setData(undefined, (oldData) => {
        if (!oldData) return oldData;
        return {
          ...oldData,
          tasks: oldData.tasks.map((task) => 
            task.id === taskId ? { ...task, status: completed ? 'completed' : 'in-progress' } : task
          ),
        };
      });
      
      return { previous };
    },
    
    // On successful mutation, show success message (silent in production)
    onSuccess: () => {
      if (__DEV__) {
        Alert.alert('Success', 'Task status updated');
      }
    },
    
    // If mutation fails, roll back optimistic update
    onError: (error, variables, context) => {
      if (context?.previous) {
        utils.dashboard.getDashboardData.setData(undefined, context.previous);
      }
      Alert.alert('Error', error.message || 'Failed to update task');
    },
    
    // Regardless of outcome, invalidate queries to refetch data
    onSettled: () => {
      utils.dashboard.getDashboardData.invalidate();
    },
  });
};
  ```

- **app/planner/add-habit.tsx**

  *Exports: `default`*
  ```tsx
export default function AddHabitScreen() {
  return (
    <SafeAreaView style={{ flex: 1 }}>
      <ScrollView>
        <YStack flex={1} padding="$4" space="$4">
          <H1>Add New Habit</H1>
          <Text>Form to add a new habit will go here.</Text>
          <Button onPress={() => router.back()}>Go Back</Button>
        </YStack>
      </ScrollView>
    </SafeAreaView>
  );
}
  ```

- **app/planner/index.tsx**

  *Exports: `default`*
  ```tsx
export default () => <YStack f={1} jc="center" ai="center"><H2>Planner coming soon</H2></YStack>
  ```

- **app/settings/index.tsx**

  *Exports: `default`*
  ```tsx
export default () => <YStack f={1} jc="center" ai="center"><H2>Settings coming soon</H2></YStack>
  ```

- **app/states/[id].tsx**

  *Exports: `default`*
  ```tsx
export default function StateDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const router = useRouter();

  // TODO: Fetch state definition details using trpc.state.getDefinitionById.useQuery({ id })

  return (
    <SafeAreaView style={{ flex: 1 }}>
      <YStack flex={1} padding="$4" space="$4">
        <H2>State Definition Detail</H2>
        <Paragraph>Details for State Definition with ID: {id}</Paragraph>
        {/* TODO: Display actual state definition details and add edit functionality */}
        <Button onPress={() => router.back()}>Go Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/utils/api-types.ts**

  *Exports: `RouterInputs`*
  ```ts
export type RouterInputs = inferRouterInputs<AppRouter>;
  ```

  *Exports: `RouterOutputs`*
  ```ts
export type RouterOutputs = inferRouterOutputs<AppRouter>;
  ```

- **app/values/[id].tsx**

  *Exports: `default`*
  ```tsx
export default function ValueDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const router = useRouter();

  // TODO: Fetch value details using trpc.value.getValueById.useQuery({ id })

  return (
    <SafeAreaView style={{ flex: 1 }}>
      <YStack flex={1} padding="$4" space="$4">
        <H2>Principle Detail</H2>
        <Paragraph>Details for Principle (Value) with ID: {id}</Paragraph>
        {/* TODO: Display actual value details and add edit functionality */}
        <Button onPress={() => router.back()}>Go Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

### assets

- **assets/refresh-sheikah.json**
  *(No explicit exports found)*

### components

- **components/EmptyOrSkeleton.tsx**

  *Exports: `default`*
  ```tsx
export default function EmptyOrSkeleton({
  isLoading,
  isEmpty = false,
  children,
  skeletonCount = 3,
  skeletonHeight = 80,
  skeletonWidth = '100%',
  skeletonGap = 12,
  skeletonBorderRadius = 8,
  customSkeletonComponent,
  customEmptyComponent,
  skeletonOptions,
  title,
  message,
  image,
  containerStyle,
  titleStyle,
  messageStyle,
  imageContainerStyle,
  imageStyle,
  ...stackProps
}: EmptyOrSkeletonProps) {
  // If loading, show skeleton
  if (isLoading) {
    if (customSkeletonComponent) {
      return <>{customSkeletonComponent}</>;
    }
    
    return (
      <YStack space={skeletonGap} width="100%" {...stackProps}>
        {Array.from({ length: skeletonCount }).map((_, index) => (
          <SkeletonPlaceholder
            key={`skeleton-${index}`}
            height={skeletonHeight}
            width={skeletonWidth}
            borderRadius={skeletonBorderRadius}
            options={skeletonOptions}
          />
        ))}
      </YStack>
    );
  }
  
  // If empty, show empty state
  if (isEmpty) {
    if (customEmptyComponent) {
      return <>{customEmptyComponent}</>;
    }
    
    return (
      <EmptyState
        title={title}
        message={message}
        image={image}
        containerStyle={containerStyle}
        titleStyle={titleStyle}
        messageStyle={messageStyle}
        imageContainerStyle={imageContainerStyle}
        imageStyle={imageStyle}
      />
    );
  }
  
  // Otherwise, show children
  return <>{children}</>;
}
  ```

  *Exports: `EmptyOrSkeletonProps`*
  ```tsx
export interface EmptyOrSkeletonProps extends EmptyStateProps, StackProps {
  /** Whether data is loading */
  isLoading: boolean;
  /** Children to display when not loading and not empty */
  children: ReactNode;
  /** Whether the content is empty (no data) */
  isEmpty?: boolean;
  /** Number of skeleton placeholders to display when loading */
  skeletonCount?: number;
  /** Height of each skeleton item */
  skeletonHeight?: number;
  /** Width of each skeleton item (default: 100%) */
  skeletonWidth?: number | string;
  /** Gap between skeleton items */
  skeletonGap?: number;
  /** Border radius for skeleton items */
  skeletonBorderRadius?: number;
  /** Custom skeleton component */
  customSkeletonComponent?: ReactNode;
  /** Options for the skeleton animation */
  skeletonOptions?: SkeletonOptions;
}
  ```

  *Exports: `EmptyStateProps`*
  ```tsx
export interface EmptyStateProps {
  /** Title text for the empty state */
  title?: string;
  /** Subtitle/description text for the empty state */
  message?: string;
  /** Optional image/illustration to display */
  image?: ImageSourcePropType;
  /** Optional custom component to render instead of default empty state */
  customEmptyComponent?: ReactNode;
  /** Style for the container */
  containerStyle?: StyleProp<ViewStyle>;
  /** Style for the title */
  titleStyle?: StyleProp<TextStyle>;
  /** Style for the message */
  messageStyle?: StyleProp<TextStyle>;
  /** Style for the image container */
  imageContainerStyle?: StyleProp<ViewStyle>;
  /** Style for the image */
  imageStyle?: StyleProp<ImageStyle>;
}
  ```

- **components/aether/ProgressRing.tsx**

  *Exports: `default`*
  ```tsx
export default function ProgressRing({
  progress: rawProgress,
  size = 60,
  strokeWidth = 6,
  primaryColor,
  secondaryColor,
  backgroundColor = 'transparent',
}: ProgressRingProps) {
  const theme = useTheme();
  
  // Normalize progress to 0-1 range
  const progress = rawProgress > 1 ? rawProgress / 100 : rawProgress;
  
  // Calculate radius and other dimensions
  const radius = (size - strokeWidth) / 2;
  const circumference = radius * 2 * Math.PI;
  const strokeDashoffset = circumference - progress * circumference;

  // Use theme colors if not explicitly provided
  const primary = primaryColor || theme.blue10.val;
  const secondary = secondaryColor || theme.gray4.val;

  return (
    <Stack width={size} height={size} backgroundColor={backgroundColor} alignItems="center" justifyContent="center">
      <Svg width={size} height={size}>
        {/* Background circle */}
        <Circle
          stroke={secondary}
          fill="none"
          cx={size / 2}
          cy={size / 2}
          r={radius}
          strokeWidth={strokeWidth}
        />
        
        {/* Progress circle */}
        <Circle
          stroke={primary}
          fill="none"
          cx={size / 2}
          cy={size / 2}
          r={radius}
          strokeWidth={strokeWidth}
          strokeDasharray={circumference}
          strokeDashoffset={strokeDashoffset}
          strokeLinecap="round"
          transform={`rotate(-90, ${size / 2}, ${size / 2})`} // Start from top
        />
      </Svg>
    </Stack>
  );
}
  ```

- **components/auth/FloatingInput.tsx**

  *Exports: `default`*
  ```tsx
export default function FloatingInput({
  label,
  value,
  error,
  containerStyle,
  labelStyle,
  errorStyle,
  onFocusChange,
  leftIcon,
  rightIcon,
  adjustLabel = true,
  style,
  ...props
}: FloatingInputProps) {
  const [isFocused, setIsFocused] = useState(false);
  const inputRef = useRef<RNTextInput | null>(null);
  const animatedLabelValue = useSharedValue(value ? 1 : 0);
  const theme = useTheme();
  
  // Handle label animation when focus or value changes
  useEffect(() => {
    animatedLabelValue.value = withTiming(
      (isFocused || !!value) ? 1 : 0,
      {
        duration: 200, // Match durations.standard
        easing: Easing.bezier(0.4, 0.0, 0.2, 1.0),
      }
    );
  }, [isFocused, value, animatedLabelValue]);
  
  // Get dynamic colors from theme
  const colors = {
    input: {
      background: theme.inputBackground?.get() || theme.backgroundHover?.get() || '#F3F4F6',
      text: theme.color?.get() || '#111827',
      border: theme.borderColor?.get() || '#E5E7EB',
      focusBorder: theme.borderColorFocus?.get() || '#93C5FD',
      placeholderText: theme.colorTransparent?.get() || '#6B7280',
    },
    error: theme.red10?.get() || '#EF4444',
  };
  
  // Determine text color based on disabled state
  const textColor = props.editable === false 
    ? theme.colorTransparent?.get() || '#9CA3AF'
    : colors.input.text;
  
  // Handle focus changes
  const handleFocus = (event: any) => {
    setIsFocused(true);
    if (onFocusChange) onFocusChange(true);
    if (props.onFocus) props.onFocus(event);
  };
  
  const handleBlur = (event: any) => {
    setIsFocused(false);
    if (onFocusChange) onFocusChange(false);
    if (props.onBlur) props.onBlur(event);
  };
  
  // Animated styles
  const animatedLabelStyle = useAnimatedStyle(() => {
    return {
      position: 'absolute',
      left: leftIcon ? 40 : 16,
      top: adjustLabel ? 
        (16 + (-24 * animatedLabelValue.value)) : 
        (12 + (-20 * animatedLabelValue.value)),
      fontSize: 16 - (4 * animatedLabelValue.value),
      color: error ? colors.error : 
        animatedLabelValue.value > 0 ? 
          (isFocused ? colors.input.focusBorder : colors.input.placeholderText) : 
          colors.input.placeholderText,
      backgroundColor: animatedLabelValue.value > 0 ? 
        (theme.background?.get() || '#FFFFFF') : 'transparent',
      paddingHorizontal: 4 * animatedLabelValue.value,
      zIndex: 10,
    };
  });
  
  // Focus the input when the component is tapped
  const handleContainerPress = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };
  
  // Prepare input styles - flatten the array and provide default
  const inputStyles = StyleSheet.flatten([
    styles.input, 
    { color: textColor },
    leftIcon && { paddingLeft: 40 },
    rightIcon && { paddingRight: 40 },
    style // Style prop from component props
  ]) || {}; // Provide default empty style object
  
  return (
    <View style={[styles.container, containerStyle]}>
      <View 
        style={[
          styles.inputContainer, 
          { backgroundColor: colors.input.background },
          { borderColor: isFocused ? colors.input.focusBorder : colors.input.border },
          error && { borderColor: colors.error },
        ]} 
        onTouchStart={handleContainerPress}
      >
        {leftIcon && <View style={styles.leftIcon}>{leftIcon}</View>}
        
        <RNTextInput
          ref={inputRef}
          style={inputStyles}
          value={value}
          onFocus={handleFocus}
          onBlur={handleBlur}
          placeholderTextColor={colors.input.placeholderText}
          {...props}
        />
        
        {rightIcon && <View style={styles.rightIcon}>{rightIcon}</View>}
        
        <Animated.Text style={[animatedLabelStyle, labelStyle]}>
          {label}
        </Animated.Text>
      </View>
      
      {error && (
        <Text
          style={[styles.errorText, { color: colors.error }, errorStyle]}
          fontSize="$3"
          marginTop="$1"
        >
          {error}
        </Text>
      )}
    </View>
  );
}
  ```

  *Exports: `FloatingInputProps`*
  ```tsx
export interface FloatingInputProps extends RNTextInputProps {
  /** Label for the input */
  label: string;
  /** Error message to display */
  error?: string;
  /** Container style */
  containerStyle?: object;
  /** Label style */
  labelStyle?: object;
  /** Error style */
  errorStyle?: object;
  /** Tamagui tokens for theming */
  tokens?: ReturnType<typeof getTokens>;
  /** Called when focus changes */
  onFocusChange?: (focused: boolean) => void;
  /** Left icon to display */
  leftIcon?: React.ReactNode;
  /** Right icon to display */
  rightIcon?: React.ReactNode;
  /** Whether to adjust label position */
  adjustLabel?: boolean;
}
  ```

- **components/compass/PrincipleCard.tsx**

  *Exports: `PrincipleCard`*
  ```tsx
export function PrincipleCard({ principle, onPress }: PrincipleCardProps) {
  return (
    <Card
      bordered
      padding="$4"
      elevation="$1"
      pressTheme
      hoverTheme
      onPress={onPress}
      animation="bouncy"
      scale={onPress ? 0.98 : 1} // Only apply scale if pressable
      hoverStyle={onPress ? { scale: 0.99 } : {}}
      pressStyle={onPress ? { scale: 0.96 } : {}}
    >
      <YStack>
        <Text fontSize="$5" fontWeight="bold">
          {principle.name}
        </Text>
        {principle.description && (
          <Text color="$colorFocus" marginTop="$2">
            {principle.description}
          </Text>
        )}
      </YStack>
    </Card>
  );
}
  ```

- **components/compass/PrinciplesTab.tsx**

  *Exports: `default`*
  ```tsx
export default function PrinciplesTab() {
  const { data, isLoading, error, refetch } =
    trpc.value.getValues.useQuery();

  if (isLoading) return <EmptyOrSkeleton isLoading count={3} type="card" />;

  if (error)
    return (
      <EmptyOrSkeleton
        isError
        onRetry={refetch}
        text={error.message ?? 'Failed to load principles'}
      />
    );

  if (!Array.isArray(data) || !data.length)
    return (
      <EmptyOrSkeleton
        isEmpty
        text="No principles yet"
        actionText="Add Principle"
        onAction={() => router.push('/compose?type=value' as Href)}
      />
    );

  return (
    <YStack space="$3">
      {data.map((p: Principle) => (
        <PrincipleCard
          key={p.id}
          principle={p}
          onPress={() => router.push(`/values/${p.id}` as Href)}
        />
      ))}
    </YStack>
  );
}
  ```

- **components/compass/StateDefinitionCard.tsx**

  *Exports: `StateDefinitionCard`*
  ```tsx
export function StateDefinitionCard({ state, onPress }: StateDefinitionCardProps) {
  return (
    <Card
      bordered
      padding="$4"
      elevation="$1"
      pressTheme
      hoverTheme
      onPress={onPress}
      animation="bouncy"
      scale={onPress ? 0.98 : 1} // Only apply scale if pressable
      hoverStyle={onPress ? { scale: 0.99 } : {}}
      pressStyle={onPress ? { scale: 0.96 } : {}}
    >
      <YStack>
        <XStack alignItems="center" space="$3">
          <Text fontSize="$5" fontWeight="bold">
            {state.name}
          </Text>
          {/* Display scale type if available */}
          {state.scale && (
            <Text color="$colorFocus" fontSize="$2">({state.scale})</Text>
          )}
        </XStack>
        {state.description && (
          <Text color="$colorFocus" marginTop="$2">
            {state.description}
          </Text>
        )}
      </YStack>
    </Card>
  );
}
  ```

- **components/dashboard/DailyProgressBanner.tsx**

  *Exports: `default`*
  ```tsx
export default function DailyProgressBanner({ 
  tasksCompleted = 3, // Placeholder
  totalTasks = 5, // Placeholder
  habitsChecked = 2, // Placeholder
  totalHabits = 4 // Placeholder
}: DailyProgressBannerProps) {
  const theme = useTheme();
  const taskProgress = totalTasks > 0 ? (tasksCompleted / totalTasks) * 100 : 0;
  const habitProgress = totalHabits > 0 ? (habitsChecked / totalHabits) * 100 : 0;

  return (
    <BlurView intensity={50} tint="default" style={{ borderRadius: 12, overflow: 'hidden', marginBottom: 16 }}>
      <XStack 
        padding="$3"
        space="$4"
        alignItems="center" 
        backgroundColor="$surfaceSubtle" // Use subtle background from theme
      >
        {/* Tasks Progress */}
        <YStack flex={1} space="$1">
          <XStack space="$2" alignItems="center">
            <CheckSquare size={16} color={theme.accent?.get()} />
            <Text fontSize="$3" fontWeight="bold" color="$onSurface">
              Tasks
            </Text>
          </XStack>
          <Progress size="$1" value={taskProgress}>
            <Progress.Indicator animation="bouncy" backgroundColor="$accent" />
          </Progress>
          <Text fontSize="$1" color="$onSurfaceSubtle">
            {tasksCompleted} / {totalTasks} done
          </Text>
        </YStack>

        {/* Habits Progress */}
        <YStack flex={1} space="$1">
          <XStack space="$2" alignItems="center">
            <Target size={16} color={theme.accent?.get()} />
            <Text fontSize="$3" fontWeight="bold" color="$onSurface">
              Habits
            </Text>
          </XStack>
          <Progress size="$1" value={habitProgress}>
            <Progress.Indicator animation="bouncy" backgroundColor="$accent" />
          </Progress>
          <Text fontSize="$1" color="$onSurfaceSubtle">
            {habitsChecked} / {totalHabits} checked
          </Text>
        </YStack>
      </XStack>
    </BlurView>
  );
}
  ```

- **components/dashboard/DashboardSection.tsx**

  *Exports: `default`*
  ```tsx
export default function DashboardSection<T>({ 
  title, 
  data, 
  isLoading, 
  emptyMessage,
  seeAllRoute,
  renderItem,
  skeletonCount = 2,
  error,
  onRetry,
  children,
  onSeeAll
}: DashboardSectionProps<T>) {
  return (
    <YStack space="$2">
      <XStack justifyContent="space-between" alignItems="center" marginBottom="$2" paddingHorizontal="$2">
        <H4>{title}</H4>
        {((data && data.length > 0 && seeAllRoute) || onSeeAll) && (
          <Button 
            chromeless 
            size="$2" 
            onPress={() => {
              if (onSeeAll) {
                onSeeAll();
              } else if (seeAllRoute) {
                // Navigate to route using type assertions
                // Safe because the route will be a tab/screen name within the app
                router.push(seeAllRoute as any);
              }
            }}
          >
            See All
          </Button>
        )}
      </XStack>
      
      {/* Wrap content in BlurView */}
      <BlurView 
        intensity={50} 
        tint="default" 
        style={{ borderRadius: 12, overflow: 'hidden' }} 
      >
        <YStack padding="$3">
          {/* If children are provided, render them */}
          {children ? (
            children
          ) : isLoading ? (
            <SkeletonRow lines={skeletonCount} />
          ) : error ? (
            <SectionError message={error ? String(error) : 'An error occurred'} onRetry={onRetry} />
          ) : data && data.length === 0 ? (
            <YStack alignItems="center" padding="$4">
              <Text color="$gray10">{emptyMessage ?? 'No items found'}</Text>
            </YStack>
          ) : (
            data && renderItem && data.map(renderItem)
          )}
        </YStack>
      </BlurView>
    </YStack>
  );
}
  ```

- **components/dashboard/GoalSummaryCard.tsx**

  *Exports: `default`*
  ```tsx
export default function GoalSummaryCard({ goal, onPress }: GoalSummaryCardProps) {
  return (
    <BlurView 
      intensity={50} 
      tint="default" 
      style={{ borderRadius: 12, overflow: 'hidden' }}
    >
      <Button 
        chromeless // Remove default button styling
        padding="$3" 
        onPress={onPress}
        width="100%" // Ensure it fills the BlurView
      >
        <XStack alignItems="center" space="$3" flex={1}> 
          <ProgressRing
            progress={goal.progress}
            size={40}
            primaryColor="$primary"
          />
          <XStack flex={1} flexDirection="column">
            <Text fontSize="$4" fontWeight="500" color="$color">
              {goal.title}
            </Text>
            {goal.tasks && (
              <Text color="$gray9" fontSize="$2">
                {goal.tasks.completed}/{goal.tasks.total} tasks completed
              </Text>
            )}
          </XStack>
        </XStack>
      </Button>
    </BlurView>
  );
}
  ```

- **components/dashboard/HabitCheckItem.tsx**

  *Exports: `default`*
  ```tsx
export default function HabitCheckItem({ habit, onToggle }: HabitCheckItemProps) {
  const [checked, setChecked] = useState(habit.completed);
  const [isUpdating, setIsUpdating] = useState(false);
  const theme = useTheme(); 
  const utils = trpc.useUtils(); 

  // Define specific theme colors with safe access and fallbacks to theme variables
  const green10 = theme?.green10?.val ?? '$green10'; 
  const gray10 = theme?.gray10?.val ?? '$gray10'; 
  const orange10 = theme?.orange10?.val ?? '$orange10'; 


  const createEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: (updatedHabit) => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error creating habit entry:', error);
    }
  });

  const deleteEntryMutation = trpc.habit.deleteHabitEntry.useMutation({
    onSuccess: () => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error deleting habit entry:', error);
    }
  });

  useEffect(() => {
    setChecked(habit.completed);
  }, [habit.completed]);

  const handleToggle = () => {
    const newValue = !checked;
    setChecked(newValue); 
    setIsUpdating(true);

    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);

    const todayDateString = new Date().toISOString().split('T')[0];

    if (newValue) {
      const createInput: CreateHabitEntryInput = {
        habit_id: habit.id,
        date: todayDateString,
        completed: true, 
        quantity_value: null, 
        notes: null, 
      };
      createEntryMutation.mutate(createInput);
    } else {
      if (habit.last_entry_id) { 
        const deleteInput: DeleteHabitEntryInput = {
          id: habit.last_entry_id, 
        };
        deleteEntryMutation.mutate(deleteInput);
      } else {
        console.warn("Attempted to delete habit entry, but last_entry_id is missing.");
      }
    }

    if (onToggle) {
      onToggle(habit.id, newValue);
    }
  };

  const streakColor = checked ? green10 : gray10; // Use safe theme value
  const habitTypeColor = orange10; // Use safe theme value

  return (
    <XStack 
      backgroundColor="$backgroundStrong" // Use theme variable
      padding="$3"
      borderRadius="$4"
      alignItems="center"
      justifyContent="space-between"
      space="$3"
    >
      <YStack flex={1} gap="$1">
        <Text fontSize="$4" fontWeight="500" color="$color"> // Use theme variable
          {habit.name}
        </Text>
        
        {habit.streak != null && habit.streak > 0 && ( // Add null check
          <Text fontSize="$2" color={streakColor}> 
            Streak: {habit.streak ?? 0}
          </Text>
        )}
        {habit.habit_type && (
          <Text fontSize="$2" color={habitTypeColor}> // Use safe theme value
            ({habit.habit_type})
          </Text>
        )}
      </YStack>
      
      <Button
        size="$3"
        variant={checked ? undefined : 'outlined'} // Let variant handle appearance
        // Remove explicit colors - rely on theme/variant
        theme={checked ? 'green' : undefined} // Apply green theme when checked
        onPress={handleToggle}
        disabled={isUpdating} 
        iconAfter={checked ? <Text>✓</Text> : undefined}
      >
        {checked ? "Done" : "Check-in"}
      </Button>
    </XStack>
  );
}
  ```

- **components/dashboard/StateIndicator.tsx**

  *Exports: `default`*
  ```tsx
export default function StateIndicator({ state, onPress, lastEntry }: StateIndicatorProps) {
  // Format the last updated time
  const formattedTime = state.lastUpdated 
    ? new Date(state.lastUpdated).toLocaleTimeString([], { 
        hour: '2-digit', 
        minute: '2-digit' 
      })
    : 'N/A';
  
  // Use Tamagui Card component
  return (
    <Card 
      onPress={onPress} 
      pressStyle={{ opacity: 0.8 }}
      padding="$3"
      // No explicit background, will use default Card background from theme
    >
      <YStack space="$1"> {/* Main container for text */}
        <XStack flex={1} alignItems="center">
          <Text fontSize="$4" fontWeight="500">{state.name}</Text>
          {lastEntry && (
            <Text fontSize="$2" color="$gray10" marginLeft="$2">
              ({formattedTime})
            </Text>
          )}
        </XStack>
        <XStack alignItems="baseline" space="$2"> {/* Align text by baseline, add space */}
          <Text fontSize="$5" fontWeight="600" color="$color"> {/* Use tokens */}
            {state.currentValue}
          </Text>
        </XStack>
        {!lastEntry && (
          <Text fontSize="$2" color="$gray10" marginTop="$1">
            No data recorded yet.
          </Text>
        )}
      </YStack>
    </Card>
  );
}
  ```

- **components/dashboard/TaskItem.tsx**

  *Exports: `default`*
  ```tsx
export default function TaskItem({ task, onPress }: TaskItemProps) {
  
  // Setup toggleTask mutation with optimistic updates
  const utils = trpc.useContext();
  // Setup mutation for task toggling
  const toggleTaskMutation = trpc.task.toggleTask.useMutation({
    // Optimistically update the UI
    onMutate: async ({ taskId, completed }: { taskId: string; completed?: boolean }) => {
      // Default to toggling the current state if completed is not provided
      const newCompleted = completed !== undefined ? completed : !isCompleted;
      // Cancel outgoing fetches that might overwrite our optimistic update
      await utils.task.getTasks.cancel();
      await utils.dashboard.getDashboardData.cancel();
      
      // Get previous data for potential rollback
      const prevTasksData = utils.task.getTasks.getData();
      const prevDashboardData = utils.dashboard.getDashboardData.getData();
      
      // Optimistically update tasks data if present
      if (prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return old.map((t: any) => {
            if (t.id === taskId) {
              return {
                ...t,
                status: completed ? 'completed' : 'in-progress'
              };
            }
            return t;
          });
        });
      }
      
      // Optimistically update dashboard data if present
      if (prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return {
            ...old,
            tasks: old.tasks.map((t: any) => {
              if (t.id === taskId) {
                return {
                  ...t,
                  status: newCompleted ? 'completed' : 'in-progress'
                };
              }
              return t;
            }),
          };
        });
      }
      
      // Return previous data for rollback
      return { prevTasksData, prevDashboardData };
    },
    
    // If something goes wrong, rollback optimistic updates
    onError: (err: any, variables: any, context: any) => {
      if (context?.prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, context.prevTasksData);
      }
      if (context?.prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, context.prevDashboardData);
      }
      console.error('Error toggling task:', err);
    },
    
    // Always refetch after error or success
    onSettled: () => {
      utils.task.getTasks.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    }
  });

  // Handle checkbox toggle
  const handleToggle = () => {
    toggleTaskMutation.mutate({
      taskId: task.id, // Using taskId as expected by the backend
      completed: !isCompleted
    });
  };

  // Map priority to color
  const priorityColor = task.priority === 1 ? '$brandRed' : 
                        task.priority === 2 ? '$brandYellow' : 
                        '$brandGreen';
  
  // Format due date
  const formattedDate = task.due_date 
    ? new Date(task.due_date).toLocaleDateString(undefined, { 
        month: 'short', 
        day: 'numeric' 
      })
    : null;
    
  // Determine task completion status
  const isCompleted = task.status === 'completed';
  // No need for text style object since we use Tamagui props directly

  
  // Use YStack as the base component
  return (
    <YStack 
      backgroundColor="$backgroundStrong"
      padding="$3"
      borderRadius="$4"
      space="$1" // Add space between XStack and Date Text
    >
      <XStack alignItems="center" space="$2"> {/* Use XStack for horizontal layout */}
        {/* Checkbox for task completion */}
        <Checkbox
          size="$4"
          checked={isCompleted}
          onCheckedChange={handleToggle}
          disabled={toggleTaskMutation.isPending}
        >
          {toggleTaskMutation.isPending ? (
            <Spinner size="small" color="$brandPrimary" />
          ) : (
            <Checkbox.Indicator>
              <Check size={16} />
            </Checkbox.Indicator>
          )}
        </Checkbox>

        {/* Container for task details (clickable) */}
        <XStack flex={1} tag="pressable" onPress={onPress} pressStyle={{ opacity: 0.7 }}>
          {/* Priority Dot using YStack */}
          <YStack 
            width="$2" // Use size token for width
            height="$2" // Use size token for height
            borderRadius="$10" // Use a large radius token
            backgroundColor={priorityColor} 
            marginRight="$2" // Use space token for margin
          />
          <Text 
            fontSize="$4" // Use font size token
            fontWeight={task.priority === 1 ? '600' : '400'} // Keep fontWeight
            color="$color"
            flex={1} // Allow text to take remaining space
            opacity={isCompleted ? 0.7 : 1}
            textDecorationLine={isCompleted ? 'line-through' : undefined} // Proper Tamagui text decoration
          >
            {task.name}
          </Text>
        </XStack>
      </XStack>
      
      {formattedDate && (
        // Removed explicit margin, rely on outer YStack space
        <Text color="$gray9" fontSize="$2">
          Due: {formattedDate}
        </Text>
      )}
    </YStack>
  );
}
  ```

- **components/lists/GoalList.tsx**

  *Exports: `GoalCard`*
  ```tsx
export function GoalCard({ goal, onPress }: { goal: Goal; onPress: () => void }) {
  // Calculate progress percentage for the progress ring
  const progressPercent = goal.progress ? goal.progress : 0;
  
  // Format the target date
  const formattedDate = goal.target_date
    ? new Date(goal.target_date).toLocaleDateString(undefined, {
        month: 'short',
        day: 'numeric',
      })
    : 'No due date';

  return (
    <AetherCard 
      isInteractive 
      variant="default"
      onPress={onPress}
    >
      <YStack space="$2">
        {/* Title */}
        <YStack>
          <XStack space="$2" alignItems="center">
            <Ionicons name="trophy-outline" size={18} color="$primary" />
            <Text fontSize="$5" fontWeight="bold" color="$color">
              {goal.title}
            </Text>
          </XStack>
        </YStack>
        
        {/* Description if available */}
        {goal.description && (
          <Text color="$colorMuted" fontSize="$3" numberOfLines={2}>
            {goal.description}
          </Text>
        )}
        
        {/* Footer with date and progress */}
        <XStack justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center">
            <Ionicons name="calendar-outline" size={16} color="$colorMuted" />
            <Text fontSize="$2" color="$colorMuted">
              {formattedDate}
            </Text>
          </XStack>
          
          {/* Progress display */}
          <XStack backgroundColor="$background" paddingHorizontal="$2" paddingVertical="$1" borderRadius="$2">
            <Text fontSize="$2" fontWeight="bold" color={progressPercent >= 75 ? '$success' : '$primary'}>
              {progressPercent}%
            </Text>
          </XStack>
        </XStack>
      </YStack>
    </AetherCard>
  );
}
  ```

  *Exports: `GoalList`*
  ```tsx
export function GoalList({ goals, isLoading, isError, refetch, onSelectGoal }: GoalListProps) {
  const renderGoalItem: ListRenderItem<Goal> = ({ item }) => (
    <GoalCard 
      goal={item} 
      onPress={() => {
        if (onSelectGoal) {
          onSelectGoal(item);
        } else {
          // Default navigation
          router.push({ 
            pathname: '/planner/goal/[id]', 
            params: { id: item.id } 
          });
        }
      }} 
    />
  );

  if (isLoading) {
    return <EmptyOrSkeleton isLoading count={3} type="card" />;
  }

  if (isError) {
    return (
      <YStack padding="$4" space="$4" alignItems="center" justifyContent="center">
        <Ionicons name="alert-circle-outline" size={48} color="$error" />
        <YStack>
          <YStack alignItems="center">
            <Text fontSize="$5" fontWeight="bold" color="$color" textAlign="center">
              Unable to load goals
            </Text>
            <Text fontSize="$3" color="$colorMuted" textAlign="center" marginTop="$2">
              Please check your connection and try again
            </Text>
          </YStack>
        </YStack>
        <AetherCard onPress={refetch} isInteractive padding="$3" paddingHorizontal="$5">
          <XStack alignItems="center" space="$2">
            <Ionicons name="refresh-outline" size={18} color="$primary" />
            <Text fontSize="$4" fontWeight="500" color="$primary">
              Retry
            </Text>
          </XStack>
        </AetherCard>
      </YStack>
    );
  }

  if (!goals || goals.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty 
        text="No goals yet" 
        actionText="Create a goal" 
        onAction={() => router.push('/planner/add-goal')} 
      />
    );
  }

  return (
    <FlatList
      data={goals}
      keyExtractor={(item) => item.id}
      renderItem={renderGoalItem}
      contentContainerStyle={{ padding: 16, paddingBottom: 32 }}
      ItemSeparatorComponent={() => <YStack height="$4" />}
      refreshControl={
        <RefreshControl 
          refreshing={isLoading} 
          onRefresh={refetch} 
        />
      }
    />
  );
}
  ```

- **components/lists/HabitList.tsx**

  *Exports: `HabitCard`*
  ```tsx
export function HabitCard({ 
  habit, 
  onPress, 
  onToggle 
}: { 
  habit: Habit; 
  onPress: () => void; 
  onToggle?: (completed: boolean) => void;
}) {
  // Calculate progress streak display
  const streakText = habit.streak === 1 
    ? '1 day'
    : `${habit.streak} days`;

  const bestStreakText = habit.best_streak === 1
    ? '1 day'
    : `${habit.best_streak} days`;

  // Check if the habit has been completed today
  const [isCompleted, setIsCompleted] = React.useState(false); // This would come from habit entries

  const handleToggle = () => {
    const newStatus = !isCompleted;
    setIsCompleted(newStatus);
    if (onToggle) {
      onToggle(newStatus);
    }
  };

  return (
    <AetherCard 
      isInteractive 
      variant="default"
      onPress={onPress}
    >
      <YStack space="$2">
        {/* Title with completion toggle */}
        <XStack space="$3" justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center" flex={1}>
            <Ionicons name="repeat-outline" size={18} color="$primary" />
            <Text fontSize="$5" fontWeight="bold" color="$color" numberOfLines={1} flex={1}>
              {habit.title}
            </Text>
          </XStack>
          
          {/* Toggle button for completing today's habit */}
          <Stack 
            onPress={handleToggle}
            pressStyle={{ opacity: 0.8 }}
          >
            <Ionicons 
              name={isCompleted ? "checkmark-circle" : "checkmark-circle-outline"} 
              size={26} 
              color={isCompleted ? "$success" : "$colorMuted"} 
            />
          </Stack>
        </XStack>
        
        {/* Streak information */}
        <XStack justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center">
            <Ionicons name="flame-outline" size={16} color="$colorMuted" />
            <Text fontSize="$2" color="$colorMuted">
              Current: {streakText}
            </Text>
          </XStack>
          
          <XStack space="$2" alignItems="center">
            <Ionicons name="trophy-outline" size={16} color="$colorMuted" />
            <Text fontSize="$2" color="$colorMuted">
              Best: {bestStreakText}
            </Text>
          </XStack>
        </XStack>
      </YStack>
    </AetherCard>
  );
}
  ```

  *Exports: `HabitList`*
  ```tsx
export function HabitList({ 
  habits, 
  isLoading, 
  isError, 
  refetch, 
  onSelectHabit,
  onToggleHabit 
}: HabitListProps) {
  const renderHabitItem: ListRenderItem<Habit> = ({ item }) => (
    <HabitCard 
      habit={item} 
      onPress={() => {
        if (onSelectHabit) {
          onSelectHabit(item);
        } else {
          // Default navigation
          router.push({ 
            pathname: '/planner/habit/[id]', 
            params: { id: item.id } 
          });
        }
      }}
      onToggle={(completed) => {
        if (onToggleHabit) {
          onToggleHabit(item.id, completed);
        }
      }}
    />
  );

  if (isLoading) {
    return <EmptyOrSkeleton isLoading count={3} type="card" />;
  }

  if (isError) {
    return (
      <YStack padding="$4" space="$4" alignItems="center" justifyContent="center">
        <Ionicons name="alert-circle-outline" size={48} color="$error" />
        <YStack>
          <YStack alignItems="center">
            <Text fontSize="$5" fontWeight="bold" color="$color" textAlign="center">
              Unable to load habits
            </Text>
            <Text fontSize="$3" color="$colorMuted" textAlign="center" marginTop="$2">
              Please check your connection and try again
            </Text>
          </YStack>
        </YStack>
        <AetherCard onPress={refetch} isInteractive padding="$3" paddingHorizontal="$5">
          <XStack alignItems="center" space="$2">
            <Ionicons name="refresh-outline" size={18} color="$primary" />
            <Text fontSize="$4" fontWeight="500" color="$primary">
              Retry
            </Text>
          </XStack>
        </AetherCard>
      </YStack>
    );
  }

  if (!habits || habits.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty 
        text="No habits yet" 
        actionText="Create a habit" 
        onAction={() => router.push('/planner/add-habit')} 
      />
    );
  }

  return (
    <FlatList
      data={habits}
      keyExtractor={(item) => item.id}
      renderItem={renderHabitItem}
      contentContainerStyle={{ padding: 16, paddingBottom: 32 }}
      ItemSeparatorComponent={() => <YStack height="$4" />}
      refreshControl={
        <RefreshControl 
          refreshing={isLoading} 
          onRefresh={refetch} 
        />
      }
    />
  );
}
  ```

- **components/lists/TaskList.tsx**

  *Exports: `TaskCard`*
  ```tsx
export function TaskCard({ 
  task, 
  onPress, 
  onComplete 
}: { 
  task: Task; 
  onPress: () => void; 
  onComplete?: (completed: boolean) => void;
}) {
  // Get the completion status of the task
  const [isCompleted, setIsCompleted] = React.useState(Boolean(task.completed));
  
  // Format the due date
  const formattedDate = task.due
    ? new Date(task.due).toLocaleDateString(undefined, {
        month: 'short',
        day: 'numeric',
      })
    : 'No due date';
    
  // Check if task is overdue
  const isOverdue = task.due && new Date(task.due) < new Date() && !isCompleted;

  const handleToggle = () => {
    const newStatus = !isCompleted;
    setIsCompleted(newStatus);
    if (onComplete) {
      onComplete(newStatus);
    }
  };

  return (
    <AetherCard 
      isInteractive 
      variant="default"
      onPress={onPress}
    >
      <YStack space="$2">
        {/* Title with completion toggle */}
        <XStack space="$3" justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center" flex={1}>
            <Stack 
              onPress={handleToggle}
              pressStyle={{ opacity: 0.8 }}
            >
              <Ionicons 
                name={isCompleted ? "checkmark-circle" : "checkmark-circle-outline"} 
                size={26} 
                color={isCompleted ? "$success" : "$colorMuted"} 
              />
            </Stack>
            <Text 
              fontSize="$5" 
              fontWeight="bold" 
              color={isCompleted ? "$colorMuted" : "$color"} 
              numberOfLines={1} 
              flex={1}
              textDecorationLine={isCompleted ? 'line-through' : 'none'}
            >
              {task.title}
            </Text>
          </XStack>
        </XStack>
        
        {/* Notes if available */}
        {task.notes && !isCompleted && (
          <Text color="$colorMuted" fontSize="$3" numberOfLines={2} paddingLeft="$7">
            {task.notes}
          </Text>
        )}
        
        {/* Footer with due date and goal information */}
        <XStack justifyContent="space-between" alignItems="center" paddingLeft="$7">
          <XStack space="$2" alignItems="center">
            <Ionicons 
              name="calendar-outline" 
              size={16} 
              color={isOverdue ? "$error" : "$colorMuted"} 
            />
            <Text 
              fontSize="$2" 
              color={isOverdue ? "$error" : "$colorMuted"}
              fontWeight={isOverdue ? "bold" : "normal"}
            >
              {isOverdue ? "Overdue: " : ""}{formattedDate}
            </Text>
          </XStack>
          
          {/* If task is linked to a goal, show goal name */}
          {task.goal_id && (
            <XStack 
              backgroundColor="$backgroundStrong" 
              paddingHorizontal="$2" 
              paddingVertical="$1" 
              borderRadius="$2"
            >
              <Text fontSize="$2" color="$primary">
                {task.goal?.title || 'Linked goal'}
              </Text>
            </XStack>
          )}
        </XStack>
      </YStack>
    </AetherCard>
  );
}
  ```

  *Exports: `TaskList`*
  ```tsx
export function TaskList({ 
  tasks, 
  isLoading, 
  isError, 
  refetch, 
  onSelectTask,
  onCompleteTask 
}: TaskListProps) {
  const renderTaskItem: ListRenderItem<Task> = ({ item }) => (
    <TaskCard 
      task={item} 
      onPress={() => {
        if (onSelectTask) {
          onSelectTask(item);
        } else {
          // Default navigation
          router.push({ 
            pathname: '/planner/task/[id]', 
            params: { id: item.id } 
          });
        }
      }}
      onComplete={(completed) => {
        if (onCompleteTask) {
          onCompleteTask(item.id, completed);
        }
      }}
    />
  );

  if (isLoading) {
    return <EmptyOrSkeleton isLoading count={3} type="card" />;
  }

  if (isError) {
    return (
      <YStack padding="$4" space="$4" alignItems="center" justifyContent="center">
        <Ionicons name="alert-circle-outline" size={48} color="$error" />
        <YStack>
          <YStack alignItems="center">
            <Text fontSize="$5" fontWeight="bold" color="$color" textAlign="center">
              Unable to load tasks
            </Text>
            <Text fontSize="$3" color="$colorMuted" textAlign="center" marginTop="$2">
              Please check your connection and try again
            </Text>
          </YStack>
        </YStack>
        <AetherCard onPress={refetch} isInteractive padding="$3" paddingHorizontal="$5">
          <XStack alignItems="center" space="$2">
            <Ionicons name="refresh-outline" size={18} color="$primary" />
            <Text fontSize="$4" fontWeight="500" color="$primary">
              Retry
            </Text>
          </XStack>
        </AetherCard>
      </YStack>
    );
  }

  if (!tasks || tasks.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty 
        text="No tasks yet" 
        actionText="Create a task" 
        onAction={() => router.push('/planner/add-task')} 
      />
    );
  }

  return (
    <FlatList
      data={tasks}
      keyExtractor={(item) => item.id}
      renderItem={renderTaskItem}
      contentContainerStyle={{ padding: 16, paddingBottom: 32 }}
      ItemSeparatorComponent={() => <YStack height="$4" />}
      refreshControl={
        <RefreshControl 
          refreshing={isLoading} 
          onRefresh={refetch} 
        />
      }
    />
  );
}
  ```

- **components/lists/index.ts**

  *Exports: `GoalCard`*
  ```ts
export { GoalList, GoalCard } from './GoalList';
  ```

  *Exports: `GoalList`*
  ```ts
export { GoalList, GoalCard } from './GoalList';
  ```

  *Exports: `HabitCard`*
  ```ts
export { HabitList, HabitCard } from './HabitList';
  ```

  *Exports: `HabitList`*
  ```ts
export { HabitList, HabitCard } from './HabitList';
  ```

  *Exports: `TaskCard`*
  ```ts
export { TaskList, TaskCard } from './TaskList';
  ```

  *Exports: `TaskList`*
  ```ts
export { TaskList, TaskCard } from './TaskList';
  ```

- **components/planner/GoalsList.tsx**

  *Exports: `default`*
  ```tsx
export default function GoalsList({
  goals = [],
  isLoading = false,
  onGoalPress,
  onAddPress,
  style,
}: GoalsListProps) {
  const colors = useColors();
  
  return (
    <YStack flex={1} style={style}>
      <EmptyOrSkeleton
        isLoading={isLoading}
        isEmpty={goals.length === 0}
        skeletonCount={3}
        skeletonHeight={160}
        skeletonBorderRadius={12}
        title="No goals yet"
        message="Create a new goal to track your progress"
      >
        <FlashList
          data={goals}
          renderItem={({ item }) => (
            <GoalCard goal={item} onPress={onGoalPress} />
          )}
          estimatedItemSize={180}
          contentContainerStyle={styles.listContent}
          ItemSeparatorComponent={() => <View style={styles.separator} />}
        />
      </EmptyOrSkeleton>
      
      {onAddPress && (
        <Pressable
          onPress={onAddPress}
          style={({ pressed }) => [
            styles.addButton,
            {
              backgroundColor: colors.brand.primary,
              opacity: pressed ? 0.9 : 1,
              transform: [{ scale: pressed ? 0.97 : 1 }],
            }
          ]}
        >
          <Text fontSize="$4" fontWeight="$3" color="white">
            + Add Goal
          </Text>
        </Pressable>
      )}
    </YStack>
  );
}
  ```

  *Exports: `Goal`*
  ```tsx
export interface Goal {
  id: string;
  title: string;
  description?: string;
  progress: number; // 0 to 1
  deadline?: string; // ISO date string
  userId: string;
  createdAt: string;
  updatedAt: string;
}
  ```

  *Exports: `GoalsListProps`*
  ```tsx
export interface GoalsListProps {
  /** List of goals to display */
  goals?: Goal[];
  /** Whether the data is loading */
  isLoading?: boolean;
  /** Called when a goal is pressed */
  onGoalPress?: (goal: Goal) => void;
  /** Called when the add button is pressed */
  onAddPress?: () => void;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}
  ```

- **components/planner/HabitTracker.tsx**

  *Exports: `HabitTracker`*
  ```tsx
export function HabitTracker({
  habits = [],
  onAddHabit,
  onToggleHabit,
  onHabitPress,
}: HabitTrackerProps) {
  const today = format(new Date(), "yyyy-MM-dd");

  const handleToggleHabit = (habit: Habit) => {
    if (!onToggleHabit) return;
    
    const isCompleted = habit.completedDates.includes(today);
    onToggleHabit(habit.id, today, !isCompleted);
  };

  return (
    <YStack space="$4">
      <XStack justifyContent="space-between" alignItems="center">
        <H4>Habits</H4>
        <Button 
          size="$2" 
          circular 
          icon={<Plus size={16} />} 
          onPress={onAddHabit}
        />
      </XStack>

      {habits.length === 0 ? (
        <YStack 
          p="$4"
          alignItems="center" 
          justifyContent="center" 
          backgroundColor="$gray2" 
          borderRadius="$4"
        >
          <Text color="$gray11" textAlign="center">
            No habits yet. Add your first habit to start tracking.
          </Text>
        </YStack>
      ) : (
        <YStack space="$3">
          {habits.map((habit, index) => (
            <YStack key={habit.id} space="$2">
              {index > 0 && <Separator />}
              <HabitItem 
                habit={habit} 
                onToggle={() => handleToggleHabit(habit)}
                onPress={() => onHabitPress?.(habit)} 
              />
            </YStack>
          ))}
        </YStack>
      )}
    </YStack>
  );
}
  ```

- **components/planner/HabitsList.tsx**

  *Exports: `default`*
  ```tsx
export default function HabitsList({
  habits = [],
  isLoading = false,
  onToggleHabit,
  onHabitPress,
  onAddPress,
  style,
}: HabitsListProps) {
  const colors = useColors();
  
  return (
    <YStack flex={1} style={style}>
      <EmptyOrSkeleton
        isLoading={isLoading}
        isEmpty={habits.length === 0}
        skeletonCount={4}
        skeletonHeight={80}
        skeletonBorderRadius={12}
        title="No habits yet"
        message="Create a habit to track your daily progress"
      >
        <YStack space="$2" padding="$4">
          {habits.map((habit) => (
            <HabitItem
              key={habit.id}
              habit={habit}
              onToggle={onToggleHabit}
              onPress={onHabitPress}
            />
          ))}
        </YStack>
      </EmptyOrSkeleton>
      
      {onAddPress && (
        <Pressable
          onPress={onAddPress}
          style={({ pressed }) => [
            styles.addButton,
            {
              backgroundColor: colors.brand.primary,
              opacity: pressed ? 0.9 : 1,
              transform: [{ scale: pressed ? 0.97 : 1 }],
            }
          ]}
        >
          <Text fontSize="$4" fontWeight="$3" color="white">
            + Add Habit
          </Text>
        </Pressable>
      )}
    </YStack>
  );
}
  ```

  *Exports: `Habit`*
  ```tsx
export interface Habit {
  id: string;
  title: string;
  description?: string;
  frequency: 'daily' | 'weekly' | 'monthly';
  completedToday: boolean;
  streak: number;
  userId: string;
  createdAt: string;
  updatedAt: string;
}
  ```

  *Exports: `HabitsListProps`*
  ```tsx
export interface HabitsListProps {
  /** List of habits to display */
  habits?: Habit[];
  /** Whether the data is loading */
  isLoading?: boolean;
  /** Called when a habit's completion status is toggled */
  onToggleHabit?: (habitId: string, completed: boolean) => Promise<void>;
  /** Called when a habit item is pressed */
  onHabitPress?: (habit: Habit) => void;
  /** Called when the add button is pressed */
  onAddPress?: () => void;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}
  ```

- **components/planner/StreakCalendar.tsx**

  *Exports: `default`*
  ```tsx
export default function StreakCalendar({
  completedDates = [],
  weekCount = 4,
  style,
}: StreakCalendarProps) {
  const today = new Date();

  const completedDatesObjects = useMemo(() => {
    return completedDates.map(dateStr => new Date(dateStr));
  }, [completedDates]);

  // Generate weeks from the current week backwards
  const weeks = useMemo(() => {
    const result = [];
    const day = startOfWeek(today, { weekStartsOn: 0 }); // Sunday as first day

    // Get current week
    const currentWeek = Array(7)
      .fill(null)
      .map((_, i) => {
        const date = addDays(day, i);
        return {
          date,
          completed: completedDatesObjects.some((d) => isSameDay(d, date)),
          isToday: isSameDay(date, today),
          isPast: date < today,
          isFuture: date > today,
        };
      });
    result.push(currentWeek);

    // Get previous weeks
    for (let i = 1; i < weekCount; i++) {
      const startDay = subWeeks(day, i);
      const week = Array(7)
        .fill(null)
        .map((_, j) => {
          const date = addDays(startDay, j);
          return {
            date,
            completed: completedDatesObjects.some((d) => isSameDay(d, date)),
            isToday: false,
            isPast: date < today,
            isFuture: date > today,
          };
        });
      result.push(week);
    }

    // Reverse so most recent week is at the bottom
    return result.reverse();
  }, [completedDatesObjects, weekCount, today]);

  const dayNames = useMemo(() => {
    const firstDayOfWeek = startOfWeek(new Date(), { weekStartsOn: 0 });
    return Array(7)
      .fill(null)
      .map((_, i) => {
        return format(addDays(firstDayOfWeek, i), "EEE").charAt(0);
      });
  }, []);

  return (
    <YStack space="$3" style={style}>
      <Text fontSize="$3" fontWeight="$3" color="$content.primary">
        Activity
      </Text>
      
      <XStack justifyContent="space-between">
        {dayNames.map((day, index) => (
          <Text key={index} color="$gray11" textAlign="center" fontSize="$1">
            {day}
          </Text>
        ))}
      </XStack>
      
      <YStack space="$3">
        {weeks.map((week, weekIndex) => (
          <XStack key={`week-${weekIndex}`} justifyContent="space-between">
            {week.map((day, dayIndex) => (
              <YStack key={`day-${weekIndex}-${dayIndex}`} alignItems="center" space="$1">
                <Text 
                  fontSize="$1" 
                  color={day.isToday ? "$brand.primary" : "$content.subtle"}
                  fontWeight={day.isToday ? '$3' : '$2'}
                >
                  {day.date.getDate()}
                </Text>
                
                {/* Day circle */}
                <DayCircle 
                  completed={day.completed}
                  isToday={day.isToday}
                  isPast={day.isPast}
                  isFuture={day.isFuture}
                />
              </YStack>
            ))}
          </XStack>
        ))}
      </YStack>
      
      {/* Legend */}
      <XStack space="$4" justifyContent="center" marginTop="$2">
        <XStack space="$1" alignItems="center">
          <View
            style={{
              width: 8,
              height: 8,
              borderRadius: 4,
              backgroundColor: "$gray6",
            }}
          />
          <Text fontSize="$2" color="$content.subtle">Not completed</Text>
        </XStack>
        
        <XStack space="$1" alignItems="center">
          <View
            style={{
              width: 8,
              height: 8,
              borderRadius: 4,
              backgroundColor: "$primary9",
            }}
          />
          <Text fontSize="$2" color="$content.subtle">Completed</Text>
        </XStack>
      </XStack>
    </YStack>
  );
}
  ```

  *Exports: `StreakCalendarProps`*
  ```tsx
export interface StreakCalendarProps {
  /** Array of dates (ISO strings) when the habit was completed */
  completedDates: string[];
  /** Number of weeks to display (default: 4) */
  weekCount?: number;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}
  ```

- **components/rewards/ConfettiBurst.tsx**

  *Exports: `default`*
  ```tsx
export default function ConfettiBurst({
  isVisible,
  onComplete,
  count = CONFETTI_COUNT,
  colors = COLORS,
  duration = 2000,
}: ConfettiBurstProps) {
  // Create confetti pieces
  const pieces = React.useMemo(() => {
    const result: ConfettiPiece[] = [];
    
    for (let i = 0; i < count; i++) {
      result.push({
        id: i,
        x: Math.random() * SCREEN_WIDTH,
        y: -20, // Start above the screen
        size: Math.random() * 8 + 4, // Size between 4-12
        color: colors[Math.floor(Math.random() * colors.length)],
        rotation: Math.random() * 360,
        delay: Math.random() * 500, // Random delay up to 500ms
        duration: Math.random() * 1000 + 1500, // Duration between 1.5-2.5s
      });
    }
    
    return result;
  }, [count, colors]);
  
  // Trigger animation complete callback
  const animationComplete = () => {
    if (onComplete) {
      onComplete();
    }
  };
  
  return (
    <>
      {isVisible && (
        <View style={styles.container} pointerEvents="none">
          {pieces.map((piece) => (
            <ConfettiPiece
              key={piece.id}
              piece={piece}
              animationDuration={duration}
              onComplete={animationComplete}
            />
          ))}
        </View>
      )}
    </>
  );
}
  ```

- **components/settings/NotificationRow.tsx**

  *Exports: `default`*
  ```tsx
export default function NotificationRow({
  title,
  description,
  enabled,
  onToggle,
  icon,
  isLoading,
  switchProps,
  style,
}: NotificationRowProps) {
  const colors = useColors();
  
  const handleToggle = (value: boolean) => {
    if (!isLoading) {
      onToggle(value);
    }
  };
  
  return (
    <XStack
      style={[styles.container, style]}
      alignItems="center"
      justifyContent="space-between"
      padding="$4"
      backgroundColor={colors.background.card}
      borderRadius="$4"
    >
      <XStack alignItems="center" space="$3" flex={1}>
        {icon && <XStack opacity={isLoading ? 0.5 : 1}>{icon}</XStack>}
        
        <YStack space="$1" flex={1} opacity={isLoading ? 0.5 : 1}>
          <Text
            fontSize="$4"
            fontWeight="$2"
            color={colors.content.primary}
          >
            {title}
          </Text>
          
          {description && (
            <Text
              fontSize="$3"
              color={colors.content.secondary}
            >
              {description}
            </Text>
          )}
        </YStack>
      </XStack>
      
      <Switch
        size="$2"
        checked={enabled}
        onCheckedChange={handleToggle}
        disabled={isLoading}
        {...switchProps}
      />
    </XStack>
  );
}
  ```

  *Exports: `NotificationRowProps`*
  ```tsx
export interface NotificationRowProps {
  /** Title of the notification setting */
  title: string;
  /** Optional description */
  description?: string;
  /** Whether the notification is turned on */
  enabled: boolean;
  /** Called when the switch is toggled */
  onToggle: (value: boolean) => void;
  /** Icon to display in the row */
  icon?: ReactNode;
  /** Whether the control is in loading state */
  isLoading?: boolean;
  /** Switch props */
  switchProps?: Omit<SwitchProps, 'checked' | 'onCheckedChange'>;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}
  ```

- **components/settings/ThemePreview.tsx**

  *Exports: `default`*
  ```tsx
export default function ThemePreview({
  themeName,
  isSelected,
  onSelect,
  forceDark,
  forceLight,
  style,
}: ThemePreviewProps) {
  const currentTheme = useTheme();
  const previewTheme = forceDark ? 'dark' : forceLight ? 'light' : undefined;
  const colors = useColors();
  
  return (
    <Pressable 
      onPress={onSelect}
      style={({ pressed }) => [
        styles.container,
        {
          transform: [{ scale: pressed ? 0.97 : 1 }],
          borderColor: isSelected ? colors.border.focus : colors.border.default,
          borderWidth: isSelected ? 2 : 1,
        },
        style,
      ]}
    >
      <YStack space="$2">
        <Text
          fontSize="$4"
          fontWeight="$2"
          color={colors.content.primary}
          marginBottom="$1"
        >
          {themeName}
        </Text>
        
        <Theme name={previewTheme}>
          <YStack
            backgroundColor="$cardBackground"
            borderRadius="$3"
            padding="$2"
            space="$2"
          >
            {/* Header Preview */}
            <View 
              style={styles.header}
              backgroundColor="$primary"
            />
            
            {/* Content Preview */}
            <YStack space="$1">
              <View style={styles.textLine} backgroundColor="$color" opacity={0.9} />
              <View style={styles.textLine} backgroundColor="$color" opacity={0.7} width="80%" />
              <View style={styles.textLine} backgroundColor="$color" opacity={0.5} width="60%" />
            </YStack>
            
            {/* Button Preview */}
            <XStack space="$2">
              <View
                style={styles.button}
                backgroundColor="$primary"
              />
              <View
                style={styles.button}
                backgroundColor="$backgroundPress"
              />
            </XStack>
          </YStack>
        </Theme>
        
        {isSelected && (
          <View style={styles.checkContainer}>
            <XStack
              backgroundColor={colors.status.success}
              borderRadius={999}
              alignItems="center"
              justifyContent="center"
              width={24}
              height={24}
            >
              <Check color="white" size={16} />
            </XStack>
          </View>
        )}
      </YStack>
    </Pressable>
  );
}
  ```

  *Exports: `ThemePreviewProps`*
  ```tsx
export interface ThemePreviewProps {
  /** The theme name to display */
  themeName: string;
  /** Whether this theme is currently selected */
  isSelected: boolean;
  /** Called when this theme is selected */
  onSelect: () => void;
  /** Whether to force dark mode for this preview */
  forceDark?: boolean;
  /** Whether to force light mode for this preview */
  forceLight?: boolean;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}
  ```

- **components/ui/Container.tsx**

  *Exports: `Container`*
  ```tsx
const Container: React.FC<ContainerProps> = ({ style, children, ...props }) => {
  const theme = useTheme();
  return (
    <StyledSafeArea
      style={[
        { backgroundColor: theme.background.val },
        style as any
      ]}
      {...props}
    >
      <YStack flex={1}>{children}</YStack>
    </StyledSafeArea>
  );
};
  ```

  *Exports: `default`*
  ```tsx
export default Container;
  ```

- **components/ui/EmptyOrSkeleton.tsx**

  *Exports: `EmptyOrSkeleton`*
  ```tsx
const EmptyOrSkeleton = ({
  isLoading = false,
  count = 3,
  type = 'row',
  isEmpty = false,
  text = 'No items found',
  actionText = 'Add New',
  onAction,
  isError = false,
  onRetry,
  children
}: EmptyOrSkeletonProps) => {
  // Generate skeleton based on type
  const renderSkeletons = () => {
    const skeletons = [];
    for (let i = 0; i < count; i++) {
      if (type === 'card') {
        skeletons.push(<SkeletonCard key={i} />);
      } else if (type === 'circle') {
        skeletons.push(<SkeletonCircle key={i} />);
      } else {
        skeletons.push(<SkeletonRow key={i} />);
      }
    }
    return skeletons;
  };

  // Show skeleton if loading
  if (isLoading) {
    return (
      <YStack space="$3">
        {renderSkeletons()}
      </YStack>
    );
  }
  
  // Show error state if there's an error
  if (isError) {
    return (
      <SectionError 
        message={text} 
        onRetry={onRetry} 
      />
    );
  }
  
  // Show empty state if empty
  if (isEmpty) {
    return (
      <YStack
        padding="$4"
        alignItems="center"
        justifyContent="center"
        space="$3"
      >
        <Text textAlign="center" color="$gray11">
          {text}
        </Text>
        {onAction && (
          <Button size="$3" onPress={onAction}>
            {actionText}
          </Button>
        )}
      </YStack>
    );
  }
  
  // Default: return children
  return <>{children}</>;
};
  ```

  *Exports: `EmptyOrSkeletonProps`*
  ```tsx
export interface EmptyOrSkeletonProps {
  // Loading state
  isLoading?: boolean;
  count?: number;
  type?: 'card' | 'row' | 'circle';
  
  // Empty state
  isEmpty?: boolean;
  text?: string;
  actionText?: string;
  onAction?: () => void;
  
  // Error state
  isError?: boolean;
  onRetry?: () => void;
  
  // Children to render when not in any special state
  children?: React.ReactNode;
}
  ```

- **components/ui/ErrorBanner.tsx**

  *Exports: `ErrorBanner`*
  ```tsx
export function ErrorBanner({ title, message, onRetry }: ErrorBannerProps) {
  const theme = useTheme();

  const red3 = theme?.red3?.val ?? '#fee2e2';
  const red5 = theme?.red5?.val ?? '#f87171';
  const red6 = theme?.red6?.val ?? '#ef4444';
  const red7 = theme?.red7?.val ?? '#dc2626';
  const red10 = theme?.red10?.val ?? '#991b1b';
  const red11 = theme?.red11?.val ?? '#7f1d1d';

  return (
    <YStack 
      backgroundColor={red3} 
      borderColor={red7} 
      borderWidth={1} 
      borderRadius="$3"
      padding="$3"
      space="$2"
      alignItems="center"
    >
      <XStack width="100%" justifyContent="space-between" alignItems="center">
        <H4 color={red11}>{title || 'Error'}</H4> 
        {/* Optional: Add an icon */} 
        {/* <Ionicons name="alert-circle-outline" size={20} color={red10} /> */} 
      </XStack>
      <Text color={red11}>{message}</Text> 
      {onRetry && (
        <Button 
          // theme="red" 
          icon={<Ionicons name="refresh" size={16} color={red11} />} 
          onPress={onRetry}
          size="$2"
          backgroundColor={red5} 
          borderColor={red7} 
          borderWidth={1}
          pressStyle={{ backgroundColor: red6 }}
        >
          <Text color={red11}>Retry</Text>
        </Button>
      )}
    </YStack>
  );
}
  ```

  *Exports: `SectionError`*
  ```tsx
export function SectionError({ message, onRetry }: SectionErrorProps) {
  const theme = useTheme();

  const red3 = theme?.red3?.val ?? '#fee2e2';
  const red5 = theme?.red5?.val ?? '#f87171';
  const red6 = theme?.red6?.val ?? '#ef4444';
  const red7 = theme?.red7?.val ?? '#dc2626';
  const red10 = theme?.red10?.val ?? '#991b1b';
  const red11 = theme?.red11?.val ?? '#7f1d1d';

  return (
    <YStack 
      padding="$3" 
      borderRadius="$3" 
      borderWidth={1} 
      borderColor={red7} 
      backgroundColor={red3} 
      alignItems="center" 
      space="$2"
    >
      <Ionicons name="warning-outline" size={24} color={red10} /> 
      <Text color={red11} textAlign="center"> 
        {message || 'Failed to load this section.'}
      </Text>
      {onRetry && (
        <Button 
          size="$2" 
          // theme="red"
          backgroundColor={red5} 
          icon={<Ionicons name="refresh" size={16} color={red11} />} 
          onPress={onRetry}
          pressStyle={{ backgroundColor: red6 }}
          borderColor={red7} 
          borderWidth={1} 
        >
          <Text color={red11}>Retry</Text>
        </Button>
      )}
    </YStack>
  );
}
  ```

- **components/ui/InteractiveCard.tsx**

  *Exports: `default`*
  ```tsx
export default InteractiveCard;
  ```

- **components/ui/Section.tsx**

  *Exports: `default`*
  ```tsx
export default Section;
  ```

- **components/ui/Skeleton.tsx**

  *Exports: `Skeleton`*
  ```tsx
export function Skeleton({ width = '100%', height = 20, borderRadius = 4 }: SkeletonProps) {
  const colorScheme = useColorScheme();
  
  return (
    <SkeletonBase
      colorMode={colorScheme === 'dark' ? 'dark' : 'light'}
      width={width}
      height={height}
      borderRadius={borderRadius}
    />
  );
}
  ```

  *Exports: `SkeletonAvatar`*
  ```tsx
export function SkeletonAvatar({ size = 40 }: SkeletonAvatarProps) {
  return <Skeleton width={size} height={size} borderRadius={size / 2} />;
}
  ```

  *Exports: `SkeletonCard`*
  ```tsx
export function SkeletonCard({ height = 100, width = '100%' }: SkeletonCardProps) {
  return (
    <YStack space="$2">
      <Skeleton height={height} width={width} borderRadius={8} />
    </YStack>
  );
}
  ```

  *Exports: `SkeletonCircle`*
  ```tsx
export function SkeletonCircle({ size = 60 }: SkeletonCircleProps) {
  return <Skeleton width={size} height={size} borderRadius={size / 2} />;
}
  ```

  *Exports: `SkeletonProfile`*
  ```tsx
export function SkeletonProfile({ avatarSize = 40 }: SkeletonProfileProps) {
  return (
    <XStack space="$3" alignItems="center">
      <SkeletonAvatar size={avatarSize} />
      <YStack space="$1" flex={1}>
        <Skeleton width="60%" height={16} />
        <Skeleton width="40%" height={12} />
      </YStack>
    </XStack>
  );
}
  ```

  *Exports: `SkeletonRow`*
  ```tsx
export function SkeletonRow({ height = 20, width = '100%', lines = 3, spacing = 10 }: SkeletonRowProps) {
  return (
    <YStack space={spacing}>
      {Array.from({ length: lines }).map((_, i) => (
        <Skeleton 
          key={i}
          height={height}
          width={i === lines - 1 && typeof width === 'string' ? '70%' : width}
        />
      ))}
    </YStack>
  );
}
  ```

- **components/ui/SwipeableRow.tsx**

  *Exports: `default`*
  ```tsx
export default function SwipeableRow({ children, onDelete, onComplete }: SwipeableRowProps) {
  const theme = useTheme();

  const renderRightActions = () => {
    if (!onDelete) return null;
    return (
      <XStack flex={1} justifyContent="flex-end">
        <Button
          // size="$3" // Match ListItem size?
          backgroundColor="$destructive"
          borderTopRightRadius="$0" // Flatten edges
          borderBottomRightRadius="$0"
          icon={<Trash color={theme.color?.get()} />} // Use theme color for icon
          onPress={() => {
            Haptics.selectionAsync();
            onDelete();
            // Consider closing the Swipeable here if needed
          }}
          width={80} // Fixed width for the action button
          height="100%" // Fill height
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  const renderLeftActions = () => {
    if (!onComplete) return null;
    return (
      <XStack flex={1} justifyContent="flex-start">
        <Button
          // size="$3"
          backgroundColor="$success"
          borderTopLeftRadius="$0"
          borderBottomLeftRadius="$0"
          icon={<Check color={theme.color?.get()} />}
          onPress={() => {
            Haptics.selectionAsync();
            onComplete();
            // Consider closing the Swipeable here if needed
          }}
          width={80}
          height="100%"
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  return (
    <Swipeable
      renderRightActions={renderRightActions}
      renderLeftActions={renderLeftActions}
      overshootFriction={8} // Standard friction
      containerStyle={{ backgroundColor: '$background' }} // Ensure background matches item
    >
      {children}
    </Swipeable>
  );
}
  ```

- **components/ui/primitives/AetherCard.tsx**

  *Exports: `AetherCard`*
  ```tsx
export function AetherCard({ children, variant, isInteractive, ...props }: AetherCardProps) {
  return (
    <StyledCard variant={variant} isInteractive={isInteractive} {...props}>
      {children}
    </StyledCard>
  );
}
  ```

- **components/ui/primitives/AetherListItem.tsx**

  *Exports: `AetherListItem`*
  ```tsx
export function AetherListItem({
  title,
  subtitle,
  leftIcon,
  rightIcon,
  showChevron = false,
  badge,
  isLast,
  interactive,
  ...props
}: AetherListItemProps) {
  return (
    <ListItemContainer isLast={isLast} interactive={interactive} {...props}>
      {/* Left section with icon and text */}
      <XStack space="$3" flex={1} alignItems="center">
        {leftIcon && (
          <Stack marginRight="$2">{leftIcon}</Stack>
        )}
        
        <YStack>
          <Text fontWeight="500" fontSize="$4">{title}</Text>
          {subtitle && (
            <Text fontSize="$2" color="$gray10">{subtitle}</Text>
          )}
        </YStack>
      </XStack>
      
      {/* Right section with badge, custom icon or chevron */}
      <XStack space="$2" alignItems="center">
        {badge && (
          <XStack 
            backgroundColor="$primary"
            paddingHorizontal="$2"
            paddingVertical="$1"
            borderRadius="$2"
          >
            <Text color="white" fontSize="$1" fontWeight="bold">{badge}</Text>
          </XStack>
        )}
        
        {rightIcon && rightIcon}
        
        {showChevron && (
          <Ionicons name="chevron-forward" size={16} color="$gray10" />
        )}
      </XStack>
    </ListItemContainer>
  );
}
  ```

  *Exports: `AetherListItemProps`*
  ```tsx
export interface AetherListItemProps extends ListItemContainerProps {
  title: string;
  subtitle?: string;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  showChevron?: boolean;
  badge?: string | number;
}
  ```

- **components/ui/primitives/SectionHeader.tsx**

  *Exports: `SectionHeader`*
  ```tsx
export function SectionHeader({ 
  title, 
  actionLabel, 
  onAction, 
  ...props 
}: SectionHeaderProps) {
  return (
    <SectionContainer {...props}>
      <Text 
        fontSize="$5" 
        fontWeight="600" 
        color="$color"
      >
        {title}
      </Text>
      
      {actionLabel && onAction && (
        <Button
          onPress={onAction}
          fontSize="$2"
          backgroundColor="transparent"
          color="$primary"
          paddingHorizontal="$2"
          height="$5"
        >
          {actionLabel}
        </Button>
      )}
    </SectionContainer>
  );
}
  ```

  *Exports: `SectionHeaderProps`*
  ```tsx
export interface SectionHeaderProps extends SectionContainerProps {
  title: string;
  actionLabel?: string;
  onAction?: () => void;
}
  ```

- **components/ui/primitives/index.ts**

  *Exports: `AetherCard`*
  ```ts
export { AetherCard } from './AetherCard';
  ```

  *Exports: `AetherListItem`*
  ```ts
export { AetherListItem, type AetherListItemProps } from './AetherListItem';
  ```

  *Exports: `AetherListItemProps`*
  ```ts
export { AetherListItem, type AetherListItemProps } from './AetherListItem';
  ```

  *Exports: `SectionHeader`*
  ```ts
export { SectionHeader, type SectionHeaderProps } from './SectionHeader';
  ```

  *Exports: `SectionHeaderProps`*
  ```ts
export { SectionHeader, type SectionHeaderProps } from './SectionHeader';
  ```

### constants

- **constants/Colors.ts**

  *Exports: `Colors`*
  ```ts
const Colors = {
  light: {
    text: '#11181C',
    background: '#fff',
    tint: tintColorLight,
    icon: '#687076',
    tabIconDefault: '#687076',
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: '#ECEDEE',
    background: '#151718',
    tint: tintColorDark,
    icon: '#9BA1A6',
    tabIconDefault: '#9BA1A6',
    tabIconSelected: tintColorDark,
  },
};
  ```

- **constants/motion.ts**

  *Exports: `componentAnimations`*
  ```ts
const componentAnimations = {
  toast: {
    show: {
      duration: durations.modal,
      easing: easings.enter,
    },
    hide: {
      duration: durations.standard,
      easing: easings.exit,
    },
  },
  modal: {
    overlay: {
      show: {
        duration: durations.modal,
        easing: easings.standard,
      },
      hide: {
        duration: durations.modal,
        easing: easings.standard,
      },
    },
    content: {
      show: {
        duration: durations.modal,
        easing: easings.enter,
      },
      hide: {
        duration: durations.standard,
        easing: easings.exit,
      },
    },
  },
  button: {
    press: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
    release: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
  },
  navigation: {
    screen: {
      duration: durations.screen,
      easing: easings.standard,
    },
    tab: {
      duration: durations.standard,
      easing: easings.standard,
    },
  },
};
  ```

  *Exports: `durations`*
  ```ts
const durations = {
  /** Ultra-fast for micro-interactions */
  micro: 80,
  /** Tap/press feedback */
  tap: 120,
  /** Default animation speed for most UI transitions */
  standard: 200,
  /** For more noticeable animations */
  medium: 250,
  /** Modal entrances/exits, complex transitions */
  modal: 300,
  /** Full screen transitions */
  screen: 350,
  /** Extended animations for emphasis */
  long: 450,
};
  ```

  *Exports: `easings`*
  ```ts
const easings = {
  /** Quick acceleration, gradual deceleration - for elements entering the screen */
  enter: Easing.bezier(0.25, 0.1, 0.25, 1.0),
  /** Gradual acceleration, quick deceleration - for elements exiting the screen */
  exit: Easing.bezier(0.25, 0.0, 0.2, 1.0),
  /** For transitions between UI states */
  standard: Easing.bezier(0.4, 0.0, 0.2, 1.0),
  /** Quick in, quick out - for emphasis */
  energetic: Easing.bezier(0.55, 0.0, 0.1, 1.0),
  /** Linear - consistent motion with no acceleration/deceleration */
  linear: Easing.linear,
  /** Slow start, fast finish */
  accelerate: Easing.in(Easing.quad),
  /** Fast start, slow finish */
  decelerate: Easing.out(Easing.quad),
  /** Fast start and end, slower in the middle */
  emphasize: Easing.inOut(Easing.quad),
};
  ```

  *Exports: `presets`*
  ```ts
const presets = {
  fadeIn: {
    duration: durations.standard,
    easing: easings.enter,
  },
  fadeOut: {
    duration: durations.standard,
    easing: easings.exit,
  },
  slideIn: {
    duration: durations.modal,
    easing: easings.enter,
  },
  slideOut: {
    duration: durations.modal,
    easing: easings.exit,
  },
  scaleIn: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  scaleOut: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  tapFeedback: {
    duration: durations.tap,
    easing: easings.emphasize,
  },
  skeleton: {
    duration: durations.long * 2,
    easing: easings.linear,
  },
};
  ```

### debug

- **debug/toast-test.tsx**

  *Exports: `default`*
  ```tsx
export default function ToastTestScreen() {
  const { showToast } = useToast();

  const testSuccessToast = () => {
    showToast({
      type: 'success',
      title: 'Success',
      message: 'This is a success toast message',
      duration: 3000,
    });
  };

  const testErrorToast = () => {
    showToast({
      type: 'error',
      title: 'Error',
      message: 'This is an error toast message',
      duration: 3000,
    });
  };

  const testInfoToast = () => {
    showToast({
      type: 'info',
      message: 'This is an info toast without a title',
      duration: 3000,
    });
  };

  return (
    <View style={{ flex: 1 }}>
      <StatusBar style="auto" />
      <YStack
        flex={1}
        padding={20}
        space={16}
        justifyContent="center"
        alignItems="center"
      >
        <Text fontSize={24} fontWeight="bold" marginBottom={20}>
          Toast Test Screen
        </Text>
        
        <Button 
          onPress={testSuccessToast} 
          backgroundColor="$green6" 
          size="$4"
        >
          Show Success Toast
        </Button>
        
        <Button 
          onPress={testErrorToast} 
          backgroundColor="$red6" 
          size="$4"
        >
          Show Error Toast
        </Button>
        
        <Button 
          onPress={testInfoToast} 
          backgroundColor="$blue6" 
          size="$4"
        >
          Show Info Toast
        </Button>
      </YStack>
    </View>
  );
}
  ```

### design-system

- **design-system/Animations.ts**

  *Exports: `fadeInUp`*
  ```ts
const fadeInUp = {
  from: { opacity: 0, translateY: 16 },
  animate: { opacity: 1, translateY: 0 },
  exit: { opacity: 0, translateY: 16 },
  transition: { type: 'timing', duration: 350 },
};
  ```

  *Exports: `korokReveal`*
  ```ts
const korokReveal = {
  from: { opacity: 0, scale: 0.7, rotate: '-10deg' },
  animate: { opacity: 1, scale: 1, rotate: '0deg' },
  transition: { type: 'spring', dampingRatio: 0.6 },
};
  ```

  *Exports: `sheikahGlow`*
  ```ts
const sheikahGlow = {
  from: { opacity: 0.4, scale: 0.95 },
  animate: { opacity: 1, scale: 1 },
  exit: { opacity: 0.4, scale: 0.95 },
  transition: { type: 'timing', duration: 800, loop: true },
};
  ```

  *Exports: `slideOutLeft`*
  ```ts
const slideOutLeft = {
  from: { translateX: 0 },
  animate: { translateX: -100 },
  exit: { translateX: -100 },
  transition: { type: 'spring', dampingRatio: 0.7 },
};
  ```

  *Exports: `taskComplete`*
  ```ts
const taskComplete = {
  from: { opacity: 1, translateX: 0 },
  animate: { opacity: 0.6, translateX: -5 },
  transition: { type: 'spring', dampingRatio: 0.8 },
};
  ```

- **design-system/Primitives.tsx**

  *Exports: `Button`*
  ```tsx
const Button = styled(gs.Button);
  ```

  *Exports: `Center`*
  ```tsx
const Center = styled(gs.Center);
  ```

  *Exports: `gs`*
  ```tsx
export { gs };
  ```

  *Exports: `HStack`*
  ```tsx
const HStack = styled(gs.HStack);
  ```

  *Exports: `Pressable`*
  ```tsx
const Pressable = styled(gs.Pressable);
  ```

  *Exports: `ScrollView`*
  ```tsx
const ScrollView = styled(gs.ScrollView);
  ```

  *Exports: `Stack`*
  ```tsx
const Stack = styled(gs.View);
  ```

  *Exports: `Text`*
  ```tsx
const Text = styled(gs.Text);
  ```

  *Exports: `useColorMode`*
  ```tsx
const useColorMode = gs.useColorMode;
  ```

  *Exports: `useColorModeValue`*
  ```tsx
export function useColorModeValue<T>(light: T, dark: T) {
  const { colorMode } = useColorMode();
  return colorMode === 'dark' ? dark : light;
}
  ```

  *Exports: `useToast`*
  ```tsx
const useToast = gs.useToast;
  ```

  *Exports: `VStack`*
  ```tsx
const VStack = styled(gs.VStack);
  ```

- **design-system/theme.glue.ts**

  *Exports: `glueTheme`*
  ```ts
const glueTheme = {
  ...base,
  tokens: {
    ...base.tokens,
    ...tokens,          // merge Zelda palette
  },
} as const;
  ```

- **design-system/tokens.ts**

  *Exports: `colors`*
  ```ts
const colors = {
  // Zelda theme colors from memories
  'parchment': '#FDFFE0',
  'sheikahCyan': '#86A5A9',
  'korokGreen': '#92C582',
  'darkText': '#536F50',
  'guardianOrange': '#FF9F0A',
  'darkTealBg': '#1A2E3A',
  'cyanGlow': '#64FFDA',
  
  // Semantic aliases
  'surface': '#FDFFE0', // parchment in light mode
  'onSurface': '#536F50', // darkText in light mode
  'outline': '#86A5A9', // sheikahCyan in both modes
  
  // Shadow colors with opacities
  'shadowSm': 'rgba(83, 111, 80, 0.10)', // Light theme
  'shadowMd': 'rgba(83, 111, 80, 0.15)',
  'shadowLg': 'rgba(83, 111, 80, 0.20)',
  'shadowDarkSm': 'rgba(0, 0, 0, 0.20)', // Dark theme
  'shadowDarkMd': 'rgba(0, 0, 0, 0.30)',
  'shadowDarkLg': 'rgba(0, 0, 0, 0.40)',
};
  ```

  *Exports: `default`*
  ```ts
export default {
  colors,
  radii,
  space,
  sizes,
  fonts,
};
  ```

  *Exports: `fonts`*
  ```ts
const fonts = {
  'heading': 'HyliaSerif',
  'body': 'CalamitySans',
  'mono': 'SpaceMono',
};
  ```

  *Exports: `radii`*
  ```ts
const radii = {
  'sm': 4,
  'md': 8,
  'lg': 16,
  'xl': 24,
  'full': 9999,
};
  ```

  *Exports: `sizes`*
  ```ts
const sizes = {
  ...space,
};
  ```

  *Exports: `space`*
  ```ts
const space = {
  '0': 0,
  '0.5': 2,
  '1': 4,
  '2': 8,
  '3': 12,
  '4': 16,
  '5': 20,
  '6': 24,
  '8': 32,
  '10': 40,
  '12': 48,
  '16': 64,
};
  ```

### hooks

- **hooks/useColorScheme.ts**

  *Exports: `useColorScheme`*
  ```ts
export { useColorScheme } from 'react-native';
  ```

- **hooks/useColorScheme.web.ts**

  *Exports: `useColorScheme`*
  ```ts
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}
  ```

- **hooks/useOfflineSync.ts**

  *Exports: `useOfflineSync`*
  ```ts
export function useOfflineSync<T extends { id: string }>(entityType: string) {
  const [isOnline, setIsOnline] = useState(true);
  const [pendingItems, setPendingItems] = useState<PendingItem[]>([]);
  const [isSyncing, setIsSyncing] = useState(false);

  // Load pending items on mount
  useEffect(() => {
    loadPendingItems();
    
    // Set up network status listener
    const unsubscribe = NetInfo.addEventListener(state => {
      const online = state.isConnected !== false && state.isInternetReachable !== false;
      setIsOnline(online);
      
      // If going from offline to online, try to sync
      if (online) {
        syncItems();
      }
    });
    
    // Also set up background sync (network status changes outside this component)
    const unsubscribeBackground = setupBackgroundSync();
    
    return () => {
      unsubscribe();
      unsubscribeBackground();
    };
  }, [entityType]);

  // Load pending items from storage
  const loadPendingItems = useCallback(async () => {
    const items = await getPendingItems(entityType);
    setPendingItems(items);
  }, [entityType]);

  // Create an item (works offline)
  const createItem = useCallback(async (data: Omit<T, 'id'>): Promise<{ id: string, isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, create directly
        // In a real app, you'd use your API client (like supabase) here
        // const { data: newItem, error } = await supabase.from(entityType).insert(data).select();
        // if (error) throw error;
        // return { id: newItem.id, isOffline: false };
        
        // For demo purposes, simulate success
        return { id: `server-${Date.now()}`, isOffline: false };
      } else {
        // If offline, save to be synced later
        const tempId = await saveOfflineMutation('create', entityType, data);
        await loadPendingItems(); // Reload pending items
        return { id: tempId, isOffline: true };
      }
    } catch (error) {
      console.error('Error creating item:', error);
      // If API call fails, save offline
      const tempId = await saveOfflineMutation('create', entityType, data);
      await loadPendingItems(); // Reload pending items
      return { id: tempId, isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Update an item (works offline)
  const updateItem = useCallback(async (item: T): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, update directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).update(item).eq('id', item.id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('update', entityType, item);
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error updating item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('update', entityType, item);
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Delete an item (works offline)
  const deleteItem = useCallback(async (id: string): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, delete directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).delete().eq('id', id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('delete', entityType, { id });
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error deleting item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('delete', entityType, { id });
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Manually trigger sync
  const syncItems = useCallback(async (): Promise<boolean> => {
    if (isSyncing) return false;
    
    setIsSyncing(true);
    try {
      const success = await syncOfflineMutations();
      if (success) {
        await loadPendingItems(); // Reload pending items after successful sync
      }
      return success;
    } catch (error) {
      console.error('Error syncing items:', error);
      return false;
    } finally {
      setIsSyncing(false);
    }
  }, [isSyncing, loadPendingItems]);

  // Check if an item is pending sync
  const isItemPending = useCallback((id: string): boolean => {
    return pendingItems.some(item => item.id === id);
  }, [pendingItems]);

  return {
    isOnline,
    isSyncing,
    pendingItems,
    createItem,
    updateItem,
    deleteItem,
    syncItems,
    isItemPending,
  };
}
  ```

- **hooks/useSkeleton.ts**

  *Exports: `SkeletonOptions`*
  ```ts
export interface SkeletonOptions {
  /**
   * Width of the gradient shimmer (as % of the component width)
   * @default 0.7
   */
  shimmerWidth?: number;
  /**
   * Base color of the skeleton component
   * @default '#E1E9EE'
   */
  baseColor?: string;
  /**
   * Highlight color for the shimmer effect
   * @default '#F2F8FC'
   */
  highlightColor?: string;
  /**
   * Duration for a complete shimmer cycle in ms
   * @default 2000
   */
  duration?: number;
  /**
   * Delay before starting animation in ms
   * @default 0
   */
  delay?: number;
  /**
   * Whether animation should start automatically
   * @default true
   */
  autoStart?: boolean;
  /**
   * Loading state to determine if skeletons should be shown
   * @default false
   */
  isLoading?: boolean;
  /**
   * Number of skeleton items to generate
   * @default 1
   */
  count?: number;
  /**
   * Type of skeleton to generate
   * @default 'card'
   */
  type?: 'card' | 'row' | 'circle';
}
  ```

  *Exports: `useSkeleton`*
  ```ts
export function useSkeleton(options: SkeletonOptions = {}) {
  const {
    shimmerWidth = 0.7,
    baseColor = '#E1E9EE',
    highlightColor = '#F2F8FC',
    duration = durations.long * 2,
    delay = 0,
    autoStart = true,
  } = options;
  
  // Animation value to track shimmer position
  const translateX = useSharedValue(-1);
  
  // Start the animation
  useEffect(() => {
    if (autoStart) {
      translateX.value = withDelay(
        delay,
        withRepeat(
          withSequence(
            withTiming(-1, { duration: 0 }),
            withTiming(1, { 
              duration, 
              easing: easings.linear 
            }),
          ),
          -1, // Infinite repeat
        ),
      );
    }
  }, [translateX, duration, delay, autoStart]);
  
  // Generate the animated styles for the shimmer effect
  const shimmerStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateX: translateX.value * (1 + shimmerWidth) }],
    };
  });
  
  // Create styles for both container and shimmer
  const styles = StyleSheet.create({
    container: {
      backgroundColor: baseColor,
      overflow: 'hidden',
    },
    shimmer: {
      width: `${shimmerWidth * 100}%`,
      height: '100%',
      backgroundColor: highlightColor,
      position: 'absolute',
      top: 0,
      bottom: 0,
      opacity: 0.7,
    },
  });
  
  // Utility function to manually start the animation
  const startAnimation = () => {
    translateX.value = withDelay(
      delay,
      withRepeat(
        withSequence(
          withTiming(-1, { duration: 0 }),
          withTiming(1, { 
            duration, 
            easing: easings.linear 
          }),
        ),
        -1, // Infinite repeat
      ),
    );
  };
  
  // Utility function to stop the animation
  const stopAnimation = () => {
    translateX.value = withTiming(-1, { duration: 200 });
  };
  
  // Generate array of skeletons based on count and type
  const generateSkeletons = () => {
    if (!options.isLoading) return [];
    
    const count = options.count || 1;
    const type = options.type || 'card';
    
    return Array.from({ length: count }).map((_, index) => ({
      key: `skeleton-${index}`,
      type,
    }));
  };
  
  return {
    baseColor,
    shimmerStyle,
    styles,
    startAnimation,
    stopAnimation,
    skeletons: generateSkeletons(),
  };
}
  ```

- **hooks/useThemeColor.ts**

  *Exports: `useThemeColor`*
  ```ts
export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}
  ```

### modals

- **modals/compose.tsx**

  *Exports: `default`*
  ```tsx
export default function ComposeModal() {
  const router = useRouter();

  // Reanimated shared value for tracking vertical translation
  const translateY = useSharedValue(0);
  const context = useSharedValue({ y: 0 });

  // Gesture handler for swipe down
  const gesture = Gesture.Pan()
    .onStart(() => {
      context.value = { y: translateY.value };
    })
    .onUpdate((event) => {
      translateY.value = Math.max(0, context.value.y + event.translationY); // Only allow downward swipe
    })
    .onEnd(() => {
      if (translateY.value > DISMISS_THRESHOLD) {
        // Animate out and navigate back
        translateY.value = withTiming(SCREEN_HEIGHT, { duration: 200 }, () => {
          runOnJS(router.back)();
        });
      } else {
        // Snap back to original position
        translateY.value = withTiming(0, { duration: 150 });
      }
    });

  // Animated style for the view
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateY: translateY.value }],
    };
  });

  return (
    // Wrap with GestureDetector
    <GestureDetector gesture={gesture}>
      {/* Apply animated style and entrance animation */}
      <Animated.View 
        style={[styles.container, animatedStyle]}
        entering={SlideInDown.duration(300)} 
      >
        {/* Optional: Add a small drag handle indicator */}
        <View style={styles.handleIndicator} />

        {/* Use Stack.Screen to configure the modal title */}
        <Stack.Screen 
          options={{
            title: 'Compose New',
            // Ensure header interaction doesn't conflict with gesture
            // headerLeft: () => <Button title="Close" onPress={() => router.back()} />
          }} 
        />
        <Text style={{ fontSize: 20, marginBottom: 20 }}>Swipe Down to Dismiss</Text>
        <Button onPress={() => router.back()}>Close Modal</Button>
      </Animated.View>
    </GestureDetector>
  );
}
  ```

### providers

- **providers/AppProvider.tsx**

  *Exports: `AppProvider`*
  ```tsx
export function AppProvider({ children }: { children: ReactNode }) {
  // Create Query Client
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 1000, // 5 seconds
        retry: Platform.OS === 'web' ? 3 : 1, // Less retries on mobile to save battery
      },
    },
  }));
  
  // Create tRPC client
  const [trpcClient] = useState(() => 
    trpc.createClient({
      links: [
        httpBatchLink({
          url: 'http://localhost:3000/api/trpc',
          fetch: (input, init) => {
            return fetch(input, {
              ...init,
              credentials: 'include',
            });
          },
        }),
      ],
    })
  );
  
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';
  
  // You could add NATS initialization here
  useEffect(() => {
    // Example: Initialize NATS for real-time updates
    // Note: This is commented out since we don't have a real NATS server to connect to
    /*
    try {
      const url = 'ws://localhost:4222';
      initNatsClient(url, queryClient)
        .then(conn => {
          console.log('NATS client initialized successfully');
          // Set up subscriptions to relevant topics
          subscribeWithCache('users.updates', ['users']);
          subscribeWithCache('messages.updates', ['messages']);
        })
        .catch(err => {
          console.error('Failed to initialize NATS client:', err);
        });
    } catch (error) {
      console.error('Error in NATS setup:', error);
    }
    
    // Cleanup on unmount
    return () => {
      closeNatsConnection().catch(err => {
        console.error('Error closing NATS connection:', err);
      });
    };
    */
  }, [queryClient]);
  
  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <NativeWindProvider theme={currentTheme}>
          <TamaguiProvider config={config}>
            {children}
          </TamaguiProvider>
        </NativeWindProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
}
  ```

- **providers/ConfettiProvider.tsx**

  *Exports: `ConfettiProvider`*
  ```tsx
export function ConfettiProvider({ children }: { children: ReactNode }) {
  const [isVisible, setIsVisible] = useState(false);
  const animationTimeout = useRef<NodeJS.Timeout | null>(null);
  
  // Generate confetti pieces data
  const generateConfettiData = useCallback(() => {
    const pieces = [];
    for (let i = 0; i < CONFETTI_COUNT; i++) {
      pieces.push({
        id: i,
        size: Math.random() * 8 + 4, // Size between 4-12
        color: COLORS[Math.floor(Math.random() * COLORS.length)],
        initialX: Math.random() * SCREEN_WIDTH,
        initialY: -20, // Start just above the screen
        duration: Math.random() * 1000 + 2000, // Duration between 2-3 seconds
        delay: Math.random() * 500, // Random delay up to 500ms
      });
    }
    return pieces;
  }, []);

  const [confettiPieces, setConfettiPieces] = useState(generateConfettiData());

  const showConfetti = useCallback(() => {
    // Trigger haptic feedback
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    
    // Clear any existing timeout
    if (animationTimeout.current) {
      clearTimeout(animationTimeout.current);
    }
    
    // Generate new confetti data and show
    setConfettiPieces(generateConfettiData());
    setIsVisible(true);
    
    // Hide confetti after animation completes
    animationTimeout.current = setTimeout(() => {
      setIsVisible(false);
    }, 3500); // Slightly longer than the max animation time to ensure all pieces are gone
  }, [generateConfettiData]);

  return (
    <ConfettiContext.Provider value={{ showConfetti }}>
      {children}
      {isVisible && (
        <View style={styles.confettiContainer} pointerEvents="none">
          {confettiPieces.map((piece) => (
            <ConfettiPiece
              key={piece.id}
              size={piece.size}
              color={piece.color}
              initialX={piece.initialX}
              initialY={piece.initialY}
              duration={piece.duration}
              delay={piece.delay}
            />
          ))}
        </View>
      )}
    </ConfettiContext.Provider>
  );
}
  ```

  *Exports: `useConfetti`*
  ```tsx
const useConfetti = () => useContext(ConfettiContext);
  ```

- **providers/SupabaseProvider.tsx**

  *Exports: `SupabaseContext`*
  ```tsx
const SupabaseContext = createContext(supabase);
  ```

  *Exports: `SupabaseProvider`*
  ```tsx
export function SupabaseProvider({ children }: PropsWithChildren) {
  return (
    <SupabaseContext.Provider value={supabase}>
      {children}
    </SupabaseContext.Provider>
  );
}
  ```

  *Exports: `useSupabase`*
  ```tsx
const useSupabase = () => React.useContext(SupabaseContext);
  ```

- **providers/TRPCProvider.tsx**

  *Exports: `trpc`*
  ```tsx
const trpc = createTRPCReact<AppRouter>();
  ```

  *Exports: `TRPCProvider`*
  ```tsx
export function TRPCProvider({ children }: PropsWithChildren) {
  const url =
    process.env.EXPO_PUBLIC_API_URL ??
    `${process.env.EXPO_PUBLIC_SUPABASE_URL}/functions/trpc`;

  const client = React.useMemo(
    () =>
      trpc.createClient({
        links: [
          httpBatchLink({
            url,
            headers() {
              return {
                // you can inject the supabase JWT here later:
              };
            },
          }),
        ],
      }),
    [url]
  );

  return (
    <trpc.Provider client={client} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </trpc.Provider>
  );
}
  ```

- **providers/index.ts**
  *(No explicit exports found)*

### scripts

- **scripts/code_atlas.cjs**
  *(No explicit exports found)*

- **scripts/generate-all.js**
  *(No explicit exports found)*

- **scripts/generate-trpc-client.js**
  *(No explicit exports found)*

- **scripts/generate-trpc-types.js**
  *(No explicit exports found)*

- **scripts/generate_app_code_overview.sh**
  *(No explicit exports found)*

- **scripts/reset-project.js**
  *(No explicit exports found)*

### server

- **server/.env**
  *(No explicit exports found)*

- **server/package.json**
  *(No explicit exports found)*

- **server/src/context.ts**

  *Exports: `Context`*
  ```ts
export interface Context {
  supabaseAdmin: typeof supabaseAdmin;
  userId: string;
}
  ```

  *Exports: `createContext`*
  ```ts
export async function createContext({ req }: { req: any }): Promise<Context> {
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: 'Missing Authorization header' });
  }
  const token = authHeader.split(' ')[1];
  if (!token) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: 'Invalid Authorization header' });
  }

  // Validate JWT and get user
  const { data, error } = await supabaseAdmin.auth.getUser(token);
  if (error || !data.user) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: error?.message || 'Invalid token' });
  }

  return {
    supabaseAdmin,
    userId: data.user.id,
  };
}
  ```

  *Exports: `supabaseAdmin`*
  ```ts
const supabaseAdmin = createClient(
  supabaseUrl,
  supabaseServiceKey,
  {
    auth: {
        autoRefreshToken: false,
        persistSession: false
    }
  }
);
  ```

- **server/src/index.ts**
  *(No explicit exports found)*

- **server/src/router.ts**

  *Exports: `appRouter`*
  ```ts
const appRouter = router({
  greeting: {
    hello: publicProcedure
      .input(z.object({ name: z.string().optional() }))
      .query(async ({ input }) => {
        return { greeting: `Hello ${input.name ?? 'world'}` };
      }),
    goodbye: publicProcedure
      .query(() => {
        return { greeting: 'Goodbye!' };
      }),
  },
  user: userRouter,
  dashboard: dashboardRouter,
  value: valueRouter,
  principle: principleRouter,
  goal: goalRouter,
  task: taskRouter,
  habit: habitRouter,
  state: trackedStateRouter,
  rewards: rewardsRouter,
  reminder: reminderRouter,
  goalProgressNote: goalProgressNoteRouter,
});
  ```

  *Exports: `AppRouter`*
  ```ts
export type AppRouter = typeof appRouter;
  ```

  *Exports: `protectedProcedure`*
  ```ts
const protectedProcedure = t.procedure.use(({ ctx, next }) => {
  if (!ctx.userId) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }
  return next({ ctx: { supabaseAdmin: ctx.supabaseAdmin, userId: ctx.userId } });
});
  ```

  *Exports: `publicProcedure`*
  ```ts
const publicProcedure = t.procedure;
  ```

  *Exports: `router`*
  ```ts
const router = t.router;
  ```

- **server/src/routers/dashboardRouter.ts**

  *Exports: `dashboardRouter`*
  ```ts
const dashboardRouter = router({
getDashboardData: protectedProcedure
  .input(
    z.object({
      habitLimit: z.number().min(1).default(5),
      goalLimit: z.number().min(1).default(5),
      taskLimit: z.number().min(1).default(10)
    }).optional()
  )
  .query(async ({ ctx, input }) => {
    try {
      // Get limits from input or use defaults
      const habitLimit = input?.habitLimit || 5;
      const goalLimit = input?.goalLimit || 5;
      const taskLimit = input?.taskLimit || 10;

      // --- Fetch Habits ---
      const { data: habits, error: habitsError } = await ctx.supabaseAdmin
        .from('habits')
        .select(HABIT_FIELDS) // Use constant
        .eq('user_id', ctx.userId)
        .is('archived_at', null) // Filter out archived
        .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
        .limit(habitLimit);
      if (habitsError) throw habitsError;

      // --- Fetch Goals ---
      const { data: goals, error: goalsError } = await ctx.supabaseAdmin
        .from('goals')
        .select(GOAL_FIELDS) // Use constant
        .eq('user_id', ctx.userId)
        .is('archived_at', null) // Filter out archived
        .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
        .limit(goalLimit);
      if (goalsError) throw goalsError;

      // --- Fetch Upcoming Tasks (focus on upcoming tasks and prioritize those due soon) ---
      const today = new Date();
      const twoWeeksFromNow = new Date();
      twoWeeksFromNow.setDate(today.getDate() + 14);
      
      // We want to fetch tasks that are:
      // 1. Not completed
      // 2. Due within the next two weeks, or overdue
      // 3. Either unassigned or associated with the dashboard goals
      const { data: tasks, error: tasksError } = await ctx.supabaseAdmin
        .from('tasks')
        .select(TASK_FIELDS) // Use constant
        .eq('user_id', ctx.userId)
        .is('archived_at', null) // Filter out archived
        .neq('status', 'completed') // Use correct enum value
        .or(`due_date.lte.${twoWeeksFromNow.toISOString()},due_date.is.null`)
        .order('due_date', { ascending: true, nullsFirst: false }) // Use 'due_date'
        .limit(taskLimit);
      if (tasksError) throw tasksError;

      // --- Fetch Active Tracked State Definitions ---
      const { data: trackedStateDefinitions, error: statesError } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .select(TRACKED_STATE_DEF_FIELDS) // Use constant
        .eq('user_id', ctx.userId)
        .eq('active', true)
        .order('sort_order', { ascending: true, nullsFirst: false }); // Correct: nullsFirst: false for nulls last
      if (statesError) throw statesError;
      
      // --- Fetch Latest State Entries for Active Definitions ---
      let latestEntriesMap: Record<string, { value: any; created_at: string }> = {};
      const stateDefIds = (trackedStateDefinitions || []).map(s => s.id);

      if (stateDefIds.length > 0) {
        // Use a CTE and ROW_NUMBER() to get the latest entry per state_id
        const { data: latestEntries, error: entriesError } = await ctx.supabaseAdmin.rpc(
          'get_latest_state_entries_for_user', 
          { p_user_id: ctx.userId, p_state_ids: stateDefIds }
        );

        if (entriesError) {
          console.error('Error fetching latest state entries:', entriesError);
          // Decide how to handle this - throw, or continue with empty/default values?
          // For now, log and continue, states will show default value
        } else {
          // Define expected type for entries from RPC
          type LatestEntry = { state_id: string; value: any; created_at: string };
          
          latestEntriesMap = (latestEntries as LatestEntry[] || []).reduce(
            (acc: Record<string, { value: any; created_at: string }>, entry: LatestEntry) => {
            acc[entry.state_id] = { value: entry.value, created_at: entry.created_at };
            return acc;
          }, {} as typeof latestEntriesMap);
        }
      }

      // --- Process Habits for 'completed' flag ---
      const todayStr = new Date().toISOString().split('T')[0];
      const habitIds = (habits || []).map(h => h.id);
      const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
        .from('habit_entries')
        .select('habit_id') // Only need habit_id to check existence
        .eq('user_id', ctx.userId)
        .eq('date', todayStr) // Filter by date
        .in('habit_id', habitIds);
      if (todayEntriesError) throw todayEntriesError;

      const completedHabitIds = new Set((habitEntriesToday || []).map(e => e.habit_id));

      const formattedHabits = (habits || []).map(h => ({
        id: h.id,
        name: h.name, // Use name
        description: h.description, // Pass other potentially useful fields
        habit_type: h.habit_type,
        streak: h.streak,
        // Consider a habit completed if *any* entry exists for today
        completed: completedHabitIds.has(h.id)
      }));

      // --- Process Goals for 'progress' ---
      const goalIds = (goals || []).map(g => g.id);
      let tasksMap: Record<string, { total: number; completed: number }> = {};
      if (goalIds.length > 0) {
        const { data: allTasksForGoals, error: tasksError2 } = await ctx.supabaseAdmin
          .from('tasks')
          .select('goal_id, status')
          .eq('user_id', ctx.userId)
          .in('goal_id', goalIds);
        if (tasksError2) throw tasksError2;

        tasksMap = (allTasksForGoals || []).reduce<Record<string, { total: number; completed: number }>>((acc, task) => {
          if (task.goal_id) { // Ensure goal_id is not null
            const gid = task.goal_id;
            if (!acc[gid]) acc[gid] = { total: 0, completed: 0 };
            acc[gid].total++;
            if (task.status === 'completed') acc[gid].completed++;
          }
          return acc;
        }, {});
      }

      const formattedGoals = (goals || []).map((g) => {
        const { total = 0, completed: comp = 0 } = tasksMap[g.id] || {};
        // Calculate progress based on tasks, ignore goal.progress field for now
        const progress = total > 0 ? comp / total : 0;
        return {
          id: g.id,
          title: g.name, // Changed name to title to match frontend expectations
          status: g.status, // Pass status directly
          priority: g.priority, // Pass priority
          progress: Math.round(progress * 100) / 100, // Keep calculated progress
          tasks: { // Add tasks information expected by GoalSummaryCard
            total: total,
            completed: comp
          }
        };
      });

      // --- Format Tasks (Minimal formatting needed if TASK_FIELDS is correct) ---
      const formattedTasks = (tasks || []).map((t) => ({
        id: t.id,
        name: t.name,
        status: t.status,
        priority: t.priority,
        due_date: t.due_date, // Use due_date
        // Add other fields as needed by the dashboard UI
      }));

      // --- Format Tracked States with Latest Values ---
      const formattedTrackedStates = (trackedStateDefinitions || []).map((def) => {
        const latestEntry = latestEntriesMap[def.id];
        return {
          id: def.id,
          name: def.name,
          unit: def.unit, // Use 'unit' field
          currentValue: latestEntry ? latestEntry.value : null, // Default to null
          lastUpdated: latestEntry ? latestEntry.created_at : null,
        };
      });

      // Return formatted data including trackedStates
      return {
        habits: formattedHabits,
        goals: formattedGoals,
        tasks: tasks || [], // Ensure tasks is always an array
        trackedStates: formattedTrackedStates, // Use the newly formatted array
      };
    } catch (error: any) {
      console.error('Dashboard data fetch error:', error);
      
      // Handle specific error types with appropriate error codes
      if (error.code === '42P01') { // Table doesn't exist
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Database schema error',
        });
      }
      
      if (error.code === '23505') { // Unique violation
        throw new TRPCError({
          code: 'CONFLICT',
          message: 'Resource already exists',
        });
      }
      
      // Default error handling
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch dashboard data',
      });
    }
  }),

getWeeklyProgress: protectedProcedure
  .input(z.object({
    daysToInclude: z.number().min(1).optional().default(7),
    includeRawData: z.boolean().optional().default(false),
  }).optional())
  .query(async ({ ctx, input }) => {
    try {
      // Calculate date range based on input or default to past week
      const daysToInclude = input?.daysToInclude || 7;
      const includeRawData = input?.includeRawData || false;
      
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(endDate.getDate() - (daysToInclude - 1));
      
      const todayStr = endDate.toISOString().split('T')[0];
      const startDateStr = startDate.toISOString().split('T')[0];
      
      // Generate array of all dates in the range for daily aggregation
      const dateRange: string[] = [];
      const tempDate = new Date(startDate);
      while (tempDate <= endDate) {
        dateRange.push(tempDate.toISOS... /* snippet truncated */
  ```

- **server/src/routers/goalProgressNoteRouter.ts**

  *Exports: `goalProgressNoteRouter`*
  ```ts
const goalProgressNoteRouter = router({
  // Get all notes for a specific goal
  getNotesForGoal: protectedProcedure
    .input(GetGoalProgressNotesInput)
    .query(async ({ ctx, input }) => {
      try {
        // First, ensure the goal exists and belongs to the user
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        // Fetch the notes for that goal
        const { data, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .eq('user_id', ctx.userId) // Redundant check, but good practice
          .eq('goal_id', input.goal_id)
          .order('created_at', { ascending: false }); // Newest first

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal progress notes',
        });
      }
    }),

  createNote: protectedProcedure
    .input(createGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Ensure the goal exists and belongs to the user before adding a note
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        const { data: note, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return note;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal progress note',
        });
      }
    }),

  updateNote: protectedProcedure
    .input(updateGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership of the note
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { data: updatedNote, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return updatedNote;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal progress note',
        });
      }
    }),

  deleteNote: protectedProcedure
    .input(DeleteGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal progress note',
        });
      }
    }),
});
  ```

- **server/src/routers/goalRouter.ts**

  *Exports: `goalRouter`*
  ```ts
const goalRouter = router({
  getGoals: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;

        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals',
        });
      }
    }),

  getGoalById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!goal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found',
          });
        }

        return goal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal',
        });
      }
    }),

  createGoal: protectedProcedure
    .input(createGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return goal;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal',
        });
      }
    }),

  updateGoal: protectedProcedure
    .input(updateGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to update it',
          });
        }

        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal',
        });
      }
    }),

  deleteGoal: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to delete it',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goals')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal',
        });
      }
    }),

  listActive: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals (in listActive stub)',
        });
      }
    }),

  listArchived: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived goals',
        });
      }
    }),

  archiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') { 
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive goal',
        });
      }
    }),

  unarchiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive goal',
        });
      }
    }),
});
  ```

- **server/src/routers/habitRouter.ts**

  *Exports: `habitRouter`*
  ```ts
const habitRouter = router({
getHabits: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      const { data: habits, error: habitsError } = await ctx.supabaseAdmin
        .from('habits')
        .select(HABIT_FIELDS)
        .eq('user_id', ctx.userId)
        .is('archived_at', null)
        .order('sort_order', { ascending: true, nullsFirst: false })
        .order('created_at', { ascending: false });

      if (habitsError) throw habitsError;
      if (!habits) return [];

      const todayStr = new Date().toISOString().split('T')[0];

      const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
        .from('habit_entries')
        .select('habit_id')
        .eq('user_id', ctx.userId)
        .eq('date', todayStr)
        .in('habit_id', habits.map(h => h.id));

      if (todayEntriesError) throw todayEntriesError;

      const completedMap = (habitEntriesToday || []).reduce<Record<string, boolean>>((acc, entry) => {
        acc[entry.habit_id] = true;
        return acc;
      }, {});

      const formattedHabits = habits.map(h => ({
        ...h,
        completedToday: !!completedMap[h.id]
      }));

      return formattedHabits;
    } catch (error: any) {
      throw new TRPCError({ 
        code: 'INTERNAL_SERVER_ERROR', 
        message: error.message || 'Failed to fetch habits'
      });
    }
  }),

getHabitById: protectedProcedure
  .input(z.object({ id: z.string().uuid() }))
  .query(async ({ ctx, input }) => {
    const { data, error } = await ctx.supabaseAdmin
      .from("habits")
      .select(HABIT_FIELDS)
      .eq("id", input.id)
      .eq("user_id", ctx.userId)
      .single();

    if (error) throw new TRPCError({ 
      code: error.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
      message: error.message 
    });
    return data;
  }),

createHabit: protectedProcedure
  .input(createHabitInput)
  .mutation(async ({ ctx, input }) => {
    const { data, error } = await ctx.supabaseAdmin
      .from("habits")
      .insert({
        ...input,
        user_id: ctx.userId,
        streak: 0,
        best_streak: 0
      })
      .select(HABIT_FIELDS)
      .single();

    if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
    return data;
  }),

updateHabit: protectedProcedure
  .input(updateHabitInput)
  .mutation(async ({ ctx, input }) => {
    const { id, ...updateData } = input;

    const { data: habit, error: fetchError } = await ctx.supabaseAdmin
      .from("habits")
      .select("id")
      .eq("id", id)
      .eq("user_id", ctx.userId)
      .single();

    if (fetchError) throw new TRPCError({ 
      code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
      message: "Habit not found or access denied" 
    });

    const { data, error } = await ctx.supabaseAdmin
      .from("habits")
      .update(updateData)
      .eq("id", id)
      .eq('user_id', ctx.userId)
      .select(HABIT_FIELDS)
      .single();

    if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
    return data;
  }),

deleteHabit: protectedProcedure
  .input(z.object({ id: z.string().uuid() }))
  .mutation(async ({ ctx, input }) => {
    const { data: habit, error: fetchError } = await ctx.supabaseAdmin
      .from("habits")
      .select("id")
      .eq("id", input.id)
      .eq("user_id", ctx.userId)
      .single();

    if (fetchError) throw new TRPCError({ 
      code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
      message: "Habit not found or access denied" 
    });

    const { error } = await ctx.supabaseAdmin
      .from("habits")
      .delete()
      .eq("id", input.id);

    if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
    return { id: input.id };
  }),

listArchivedHabits: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      const { data: habits, error } = await ctx.supabaseAdmin
        .from('habits')
        .select(HABIT_FIELDS)
        .eq('user_id', ctx.userId)
        .not('archived_at', 'is', null)
        .order('archived_at', { ascending: false })
        .order('created_at', { ascending: false });

      if (error) throw error;
      return habits || [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch archived habits',
      });
    }
  }),

archiveHabit: protectedProcedure
  .input(z.object({ id: z.string().uuid() }))
  .mutation(async ({ ctx, input }) => {
    try {
      const { data: updatedHabit, error } = await ctx.supabaseAdmin
        .from('habits')
        .update({ archived_at: new Date().toISOString() })
        .eq('id', input.id)
        .eq('user_id', ctx.userId)
        .select(HABIT_FIELDS)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
        }
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      }
      return updatedHabit;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to archive habit' });
    }
  }),

unarchiveHabit: protectedProcedure
  .input(z.object({ id: z.string().uuid() }))
  .mutation(async ({ ctx, input }) => {
    try {
      const { data: updatedHabit, error } = await ctx.supabaseAdmin
        .from('habits')
        .update({ archived_at: null })
        .eq('id', input.id)
        .eq('user_id', ctx.userId)
        .select(HABIT_FIELDS)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
        }
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      }
      return updatedHabit;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to unarchive habit' });
    }
  }),

getHabitEntries: protectedProcedure
  .input(z.object({
    habitId: z.string().uuid(),
    startDate: z.string().optional(), 
    endDate: z.string().optional(),   
  }))
  .query(async ({ ctx, input }) => {
    try {
      const { error: habitError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", input.habitId)
        .eq("user_id", ctx.userId)
        .single();

      if (habitError) {
        if (habitError.code === 'PGRST116') {
           throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
        }
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: habitError.message });
      }

      let query = ctx.supabaseAdmin
        .from('habit_entries')
        .select(HABIT_ENTRY_FIELDS)
        .eq('user_id', ctx.userId)
        .eq('habit_id', input.habitId);

      if (input.startDate) query = query.gte('date', input.startDate);
      if (input.endDate) query = query.lte('date', input.endDate);

      const { data, error: entriesError } = await query.order('date', { ascending: false });

      if (entriesError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: entriesError.message });
      return data || [];
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to fetch habit entries' });
    }
  }),

getHabitEntriesForHabit: protectedProcedure
  .input(z.object({ habitId: z.string().uuid() }))
  .query(async ({ ctx, input }) => {
    // TODO: Implement logic to fetch habit entries for a specific habit
    console.log(`Fetching entries for habit: ${input.habitId}, user: ${ctx.userId}`);
    // Example fetch:
    // const { data, error } = await ctx.supabaseAdmin
    //   .from('habit_entries')
    //   .select(HABIT_ENTRY_FIELDS)
    //   .eq('habit_id', input.habitId)
    //   .eq('user_id', ctx.userId)
    //   .order('date', { ascending: false });
    // if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
    // return data || [];
    throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
  }),

createHabitEntry: protectedProcedure
  .input(createHabitEntryInput)
  .mutation(async ({ ctx, input }) => {
    try {
      const { data, error } = await ctx.supabaseAdmin
        .from('habit_entries')
        .insert({ ...input, user_id: ctx.userId })
        .select(HABIT_ENTRY_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });

      // Update streak after successful insert
      if (data) {
        await calculateAndUpdateStreak(input.habit_id, ctx.userId, ctx.supabaseAdmin);
      }

      return data;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to create habit entry',
      });
    }
  }),

updateHabitEntry: protectedProcedure
  .input(updateHabitEntryInput)
  .mutation(async ({ ctx, input }) => {
    try {
      const { id, ...updateData } = input;

      const { data: habitEntry, error: fetchError } = awa... /* snippet truncated */
  ```

- **server/src/routers/principleRouter.ts**

  *Exports: `principleRouter`*
  ```ts
const principleRouter = router({
  getPrinciples: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: principles, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principles || []; // Return empty array if null
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principles',
        });
      }
    }),

  getPrincipleById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) {
           if (error.code === 'PGRST116') { // Handle not found specifically
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found' });
           }
           throw error; // Rethrow other errors
        }
        // No need for !principle check if .single() is used and error isn't PGRST116

        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principle',
        });
      }
    }),

  createPrinciple: protectedProcedure
    .input(createPrincipleInput) // This Zod schema now expects 'title' and 'body'
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .insert({
            ...input, // Spread validated input, already contains 'title' and 'body'
            user_id: ctx.userId,
          })
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create principle',
        });
      }
    }),

  updatePrinciple: protectedProcedure
    .input(updatePrincipleInput) // This Zod schema now expects 'title' and 'body' (optional)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
           if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to update it' });
           }
           throw fetchError;
        }

        // Update
        const { data: updatedPrinciple, error } = await ctx.supabaseAdmin
          .from('principles')
          .update(updateData) // updateData contains validated 'title'/'body' if provided
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return updatedPrinciple;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update principle',
        });
      }
    }),

  deletePrinciple: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
            if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to delete it' });
           }
           throw fetchError;
        }

        // Delete
        const { error } = await ctx.supabaseAdmin
          .from('principles')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete principle',
        });
      }
    }),
});
  ```

- **server/src/routers/reminderRouter.ts**

  *Exports: `reminderRouter`*
  ```ts
const reminderRouter = router({
  // Get all active reminders for the user (might need refinement later)
  getActiveReminders: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('is_active', true)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch active reminders',
        });
      }
    }),

  // Get reminders linked to a specific entity
  getRemindersForEntity: protectedProcedure
    .input(GetRemindersForEntityInput)
    .query(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('related_entity_type', input.related_entity_type)
          .eq('related_entity_id', input.related_entity_id)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch reminders for entity',
        });
      }
    }),

  createReminder: protectedProcedure
    .input(createReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // TODO: Potentially validate that related_entity_id exists and belongs to user?
        // This requires knowing the related_entity_type and querying the correct table.
        // For now, assume valid input.
        const { data: reminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return reminder;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create reminder',
        });
      }
    }),

  updateReminder: protectedProcedure
    .input(updateReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { data: updatedReminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return updatedReminder;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update reminder',
        });
      }
    }),

  deleteReminder: protectedProcedure
    .input(DeleteReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('reminders')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete reminder',
        });
      }
    }),
});
  ```

- **server/src/routers/rewardsRouter.ts**

  *Exports: `rewardsRouter`*
  ```ts
const rewardsRouter = router({
// Get all rewards for current user
getUserRewards: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      // Select specific fields aligned with our Zod types
      const { data: rewards, error } = await ctx.supabaseAdmin
        .from('user_rewards')
        .select('id, user_id, reward_id, earned_at, rewards(id, name, description, emoji, image_url, required_points, type)')
        .eq('user_id', ctx.userId)
        .order('earned_at', { ascending: false });

      if (error) throw error;
      return rewards || [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch user rewards',
      });
    }
  }),

// Get available rewards that can be earned
getAvailableRewards: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      // Get all rewards with specific fields
      const { data: allRewards, error: rewardsError } = await ctx.supabaseAdmin
        .from('rewards')
        .select('id, name, description, emoji, image_url, required_points, type, can_earn_multiple')
        .order('required_points', { ascending: true });

      if (rewardsError) throw rewardsError;

      // Get already earned rewards
      const { data: earnedRewards, error: earnedError } = await ctx.supabaseAdmin
        .from('user_rewards')
        .select('reward_id')
        .eq('user_id', ctx.userId);

      if (earnedError) throw earnedError;

      // Filter out already earned one-time rewards
      const earnedIds = new Set((earnedRewards || []).map(er => er.reward_id));
      const availableRewards = allRewards?.filter(reward => 
        !earnedIds.has(reward.id) || reward.can_earn_multiple);

      return availableRewards || [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch available rewards',
      });
    }
  }),

// Get user points
getUserPoints: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      const { data: userProfile, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('points, lifetime_points')
        .eq('id', ctx.userId)
        .single();

      if (error) throw error;
      return {
        points: userProfile?.points || 0,
        lifetimePoints: userProfile?.lifetime_points || 0,
      };
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch user points',
      });
    }
  }),

// Earn a reward if eligible
earnReward: protectedProcedure
  .input(claimLootInput)
  .mutation(async ({ ctx, input }) => {
    try {
      // Get the reward details
      const { data: reward, error: rewardError } = await ctx.supabaseAdmin
        .from('rewards')
        .select('*')
        .eq('id', input.rewardId)
        .single();

      if (rewardError || !reward) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Reward not found',
        });
      }

      // Check if user has enough points
      const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
        .from('profiles')
        .select('points')
        .eq('id', ctx.userId)
        .single();

      if (profileError || !userProfile) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch user profile',
        });
      }

      if (userProfile.points < reward.required_points) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: 'Not enough points to earn this reward',
        });
      }

      // If the reward is one-time, check if already earned
      if (!reward.can_earn_multiple) {
        const { data: existingReward, error: existingError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('id')
          .eq('user_id', ctx.userId)
          .eq('reward_id', input.rewardId)
          .single();

        if (existingReward) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'You have already earned this one-time reward',
          });
        }
      }

      // Begin transaction
      // 1. Deduct points from user
      const { error: updateError } = await ctx.supabaseAdmin
        .from('profiles')
        .update({
          points: userProfile.points - reward.required_points,
        })
        .eq('id', ctx.userId);

      if (updateError) throw updateError;

      // 2. Add reward to user's earned rewards
      const { data: userReward, error: insertError } = await ctx.supabaseAdmin
        .from('user_rewards')
        .insert({
          user_id: ctx.userId,
          reward_id: input.rewardId,
          earned_at: new Date().toISOString(),
          points_spent: reward.required_points,
        })
        .select()
        .single();

      if (insertError) {
        // Rollback points if adding reward failed
        await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: userProfile.points,
          })
          .eq('id', ctx.userId);

        throw insertError;
      }

      return {
        success: true,
        reward: userReward,
        remainingPoints: userProfile.points - reward.required_points,
      };
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to earn reward',
      });
    }
  }),

// Award points to user (e.g., for completing habits, tasks)
awardPoints: protectedProcedure
  .input(awardBadgeInput)
  .mutation(async ({ ctx, input }) => {
    try {
      // Get current user points
      const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
        .from('profiles')
        .select('points, lifetime_points')
        .eq('id', ctx.userId)
        .single();

      if (profileError || !userProfile) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch user profile',
        });
      }

      // Get badge details
      const { data: badge, error: badgeError } = await ctx.supabaseAdmin
        .from('rewards')
        .select('*')
        .eq('id', input.badgeId)
        .eq('type', 'badge')
        .single();

      if (badgeError || !badge) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Badge not found',
        });
      }

      // Default points to award
      const pointsToAward = 10;
      const currentPoints = userProfile.points || 0;
      const lifetimePoints = userProfile.lifetime_points || 0;
      const newPoints = currentPoints + pointsToAward;
      const newLifetimePoints = lifetimePoints + pointsToAward;

      // Update user points
      const { error: updateError } = await ctx.supabaseAdmin
        .from('profiles')
        .update({
          points: newPoints,
          lifetime_points: newLifetimePoints,
        })
        .eq('id', ctx.userId);

      if (updateError) throw updateError;

      // Record the point transaction
      const { data: pointTransaction, error: transactionError } = await ctx.supabaseAdmin
        .from('point_transactions')
        .insert({
          user_id: ctx.userId,
          points: pointsToAward,
          reason: `Earned badge: ${badge.name}`,
          source_type: 'badge',
          source_id: input.badgeId,
        })
        .select()
        .single();

      if (transactionError) throw transactionError;

      // Add badge to user's earned rewards
      const { data: userBadge, error: badgeInsertError } = await ctx.supabaseAdmin
        .from('user_rewards')
        .insert({
          user_id: ctx.userId,
          reward_id: input.badgeId,
          reward_type: 'badge',
          earned_at: new Date().toISOString(),
          points_spent: 0, // Badges don't cost points
        })
        .select()
        .single();

      if (badgeInsertError) throw badgeInsertError;

      return {
        success: true,
        previousPoints: currentPoints,
        newPoints,
        pointsAdded: pointsToAward,
        transaction: pointTransaction,
        badge: userBadge,
      };
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to award badge',
      });
    }
  }),

// Get point transaction history
getPointHistory: protectedProcedure
  .input(z.object({
    limit: z.number().optional().default(20),
    cursor: z.string().optional(), // for pagination
  }))
  .query(async ({ ctx, input }) => {
    try {
      let query = ctx.supabaseAdmin
        .from('point_transactions')
        .select('*')
        .eq('user_id', ctx.userId)
        .order('created_at', { ascending: false })
        .limit(input.limit);
        
      // Handle cursor-based pagination
      if (input.cursor) {
        query = query.lt('created_at', input.cursor);
      }
      
      const { data: transactions, error } = await query;

      if (error) throw error;
      
      // Determine if there are more results
      const lastItem = transactions && transactions.length > 0 
        ? transactions[transactions.length - 1] 
        : null;
        
      return {
        items: tran... /* snippet truncated */
  ```

- **server/src/routers/taskRouter.ts**

  *Exports: `taskRouter`*
  ```ts
const taskRouter = router({
getTasks: protectedProcedure // Gets non-archived tasks
  .input(z.object({
    goalId: z.string().uuid().optional(),
    // TODO: Add filters for status, priority, dates etc.?
  }))
  .query(async ({ ctx, input }) => {
    try {
      let query = ctx.supabaseAdmin
        .from('tasks')
        .select(TASK_FIELDS)
        .eq('user_id', ctx.userId)
        .is('archived_at', null); // Filter out archived

      if (input.goalId) {
        query = query.eq('goal_id', input.goalId);
      }

      // TODO: Add complex priority enum sorting? (e.g. high > medium > low)
      const { data: tasks, error } = await query
        .order('sort_order', { ascending: true, nullsFirst: false })
        .order('due_date', { ascending: true, nullsFirst: false }) // Order by due date (nulls last)
        .order('created_at', { ascending: false });

      if (error) throw error;
      // TODO: Parse with Task schema?
      return tasks || [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch tasks',
      });
    }
  }),

getTaskById: protectedProcedure
  .input(z.object({
    id: z.string().uuid(), // Use uuid validation
  }))
  .query(async ({ ctx, input }) => {
    try {
      const { data: task, error } = await ctx.supabaseAdmin
        .from('tasks')
        .select(TASK_FIELDS)
        .eq('id', input.id)
        .eq('user_id', ctx.userId)
        .single();

      if (error) throw error;
      if (!task) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Task not found',
        });
      }

      // TODO: Parse with Task schema?
      return task;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch task',
      });
    }
  }),

createTask: protectedProcedure
  .input(createTaskInput) // Use imported input type
  .mutation(async ({ ctx, input }) => {
    try {
      // Verify goal_id if provided
      if (input.goal_id) {
        const { data: goal, error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId) // Ensure goal belongs to user
          .is('archived_at', null) // Ensure goal is not archived
          .single();

        if (goalError || !goal) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Invalid or archived goal ID',
          });
        }
      }

      // Verify parent_task_id if provided
      if (input.parent_task_id) {
        const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.parent_task_id)
          .eq('user_id', ctx.userId) // Ensure parent belongs to user
          .is('archived_at', null) // Ensure parent is not archived
          .single();

        if (parentError || !parentTask) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Invalid or archived parent task ID',
          });
        }
      }

      const { data: task, error } = await ctx.supabaseAdmin
        .from('tasks')
        .insert({
          ...input, // Spread validated input (includes new fields like parent_task_id, recurrence etc)
          user_id: ctx.userId,
          // Ensure due_date is used if present in input
          due_date: input.due_date ?? null, // Use correct field name
        })
        .select(TASK_FIELDS)
        .single();

      if (error) {
         // Handle specific errors like FK violations?
         console.error("Create task error:", error);
         throw error;
      }
      // TODO: Parse with Task schema?
      return task;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to create task',
      });
    }
  }),

updateTask: protectedProcedure
  .input(updateTaskInput) // Use imported input type
  .mutation(async ({ ctx, input }) => {
    try {
      const { id, ...updateData } = input; // Separate id from update payload

      // Check ownership
      const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
        .from('tasks')
        .select('id, parent_task_id') // Select parent_task_id for cycle check
        .eq('id', id)
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError || !existingTask) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Task not found or you do not have permission to update it',
        });
      }

      // Verify goal_id if being updated
      if (updateData.goal_id) {
        const { data: goal, error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', updateData.goal_id)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .single();

        if (goalError || !goal) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Invalid or archived goal ID',
          });
        }
      }
      // Handle setting goal_id to null
      if (updateData.goal_id === null) {
        updateData.goal_id = null;
      }

      // Verify parent_task_id if being updated
      if (updateData.parent_task_id) {
         // Basic cycle check
         if (updateData.parent_task_id === id) {
           throw new TRPCError({
             code: 'BAD_REQUEST',
             message: 'Task cannot be its own parent',
           });
         }
        const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', updateData.parent_task_id)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .single();

        if (parentError || !parentTask) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Invalid or archived parent task ID',
          });
        }
        // TODO: Add deeper cycle detection if needed (check if new parent is a descendant)
      }
       // Handle setting parent_task_id to null
      if (updateData.parent_task_id === null) {
        updateData.parent_task_id = null;
      }

      // Ensure correct field name for due date if provided
      const payload: Record<string, any> = { ...updateData };
      if ('due_date' in payload) {
        payload.due_date = payload.due_date ?? null;
      }

      const { data: updatedTask, error } = await ctx.supabaseAdmin
        .from('tasks')
        .update(payload) // Pass validated update data
        .eq('id', id)
        .eq('user_id', ctx.userId)
        .select(TASK_FIELDS)
        .single();

      if (error) {
           // Handle specific errors like FK violations?
         console.error("Update task error:", error);
         throw error;
      }
      // TODO: Parse with Task schema?
      return updatedTask;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to update task',
      });
    }
  }),

deleteTask: protectedProcedure
  .input(z.object({
    id: z.string().uuid(), // Use uuid validation
  }))
  .mutation(async ({ ctx, input }) => {
    try {
      // Check ownership
      const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
        .from('tasks')
        .select('id')
        .eq('id', input.id)
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError || !existingTask) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Task not found or you do not have permission to delete it',
        });
      }

      // Delete the task (consider implications for subtasks - maybe archive instead?)
      // For now, direct delete.
      const { error } = await ctx.supabaseAdmin
        .from('tasks')
        .delete()
        .eq('id', input.id)
        .eq('user_id', ctx.userId);

      if (error) throw error;
      return { success: true, id: input.id };
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to delete task',
      });
    }
  }),

// ---- Archive/Unarchive ----
listArchivedTasks: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      const { data: tasks, error } = await ctx.supabaseAdmin
        .from('tasks')
        .select(TASK_FIELDS)
        .eq('user_id', ctx.userId)
        .not('archived_at', 'is', null) // Filter for archived tasks
        .order('archived_at', { ascending: false })
        .order('created_at', { ascending: false });
      if (error) throw error;
      // TODO: Parse with Task schema?
      return tasks || [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch archived tasks',
      });
    }
  }),

archiveTask: protectedProcedure
  .input(z.object({ id: z.string().uuid() }))
  .mutation(async ({ ctx, input }) => {
    // TODO: Consider archivin... /* snippet truncated */
  ```

- **server/src/routers/trackedStateRouter.ts**

  *Exports: `trackedStateRouter`*
  ```ts
const trackedStateRouter = router({
getDefinitions: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      const { data, error } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .select(TRACKED_STATE_DEF_FIELDS)
        .eq('user_id', ctx.userId)
        .eq('active', true)
        .order('priority', { ascending: true, nullsFirst: false }) // Corrected: nullsFirst
        .order('created_at', { ascending: true });

      if (error) throw error;
      return data ?? [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch tracked state definitions',
      });
    }
  }),

getDefinitionById: protectedProcedure
  .input(GetTrackedStateDefByIdInput) // Use correct Zod schema
  .query(async ({ ctx, input }) => {
     try {
      const { data: definition, error } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .select(TRACKED_STATE_DEF_FIELDS)
        .eq('id', input.id) // input.id is now correctly typed
        .eq('user_id', ctx.userId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Tracked state definition not found.' });
        }
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      }
      return definition;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch tracked state definition',
      });
    }
  }),

createDefinition: protectedProcedure
  .input(createTrackedStateDefInput) // Use correct Zod schema
  .mutation(async ({ ctx, input }) => {
     try {
      const { data: definition, error } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .insert({
          ...input, // input is now correctly typed
          user_id: ctx.userId,
        })
        .select(TRACKED_STATE_DEF_FIELDS)
        .single();

      if (error) throw error;
      return definition;
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to create tracked state definition',
      });
    }
  }),

updateDefinition: protectedProcedure
  .input(updateTrackedStateDefInput) // Use correct Zod schema
  .mutation(async ({ ctx, input }) => {
     try {
      const { id, ...updateData } = input; // input is now correctly typed

      const { error: fetchError } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .select('id')
        .eq('id', id)
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError) {
        throw new TRPCError({
          code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
          message: 'Definition not found or access denied.',
        });
      }

      const { data: updatedDefinition, error } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .update(updateData)
        .eq('id', id)
        .eq('user_id', ctx.userId)
        .select(TRACKED_STATE_DEF_FIELDS)
        .single();

      if (error) throw error;
      return updatedDefinition;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to update tracked state definition',
      });
    }
  }),

deleteDefinition: protectedProcedure
  .input(DeleteTrackedStateDefInput) // Use correct Zod schema
  .mutation(async ({ ctx, input }) => {
     try {
      const { error: fetchError } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .select('id')
        .eq('id', input.id) // input.id is now correctly typed
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError) {
        throw new TRPCError({
          code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
          message: 'Definition not found or access denied.',
        });
      }

      const { error } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .delete()
        .eq('id', input.id) // input.id is now correctly typed
        .eq('user_id', ctx.userId);

      if (error) throw error;
      return { success: true, id: input.id }; // input.id is now correctly typed
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to delete tracked state definition',
      });
    }
  }),

// --- State Entry Procedures ---

getEntries: protectedProcedure
  .input(GetStateEntriesInput) // <<<--- ADDED .input() BINDING
  .query(async ({ ctx, input }) => {
    try {
      let query = ctx.supabaseAdmin
        .from('state_entries')
        .select(STATE_ENTRY_FIELDS)
        .eq('user_id', ctx.userId)
        .eq('definition_id', input.tracked_state_def_id); // input is now typed

      if (input.startDate) { // input is now typed
        query = query.gte('entry_timestamp', input.startDate);
      }
      if (input.endDate) { // input is now typed
        query = query.lte('entry_timestamp', input.endDate);
      }

      query = query.order('entry_timestamp', { ascending: false });

      if (input.limit) { // input is now typed
        query = query.limit(input.limit);
      }

      const { data: entries, error } = await query;

      if (error) throw error;
      return entries ?? [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch state entries',
      });
    }
  }),

createEntry: protectedProcedure
  .input(CreateStateEntryInput) // <<<--- ADDED .input() BINDING
  .mutation(async ({ ctx, input }) => {
    try {
      // Check definition ownership (already implemented correctly)
      const { error: defError } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .select('id')
        .eq('id', input.tracked_state_def_id) // input is now typed
        .eq('user_id', ctx.userId)
        .single();

      if (defError) {
        throw new TRPCError({
          code: defError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
          message: 'Tracked state definition not found or invalid.',
        });
      }

      // Insert typed data
      const { data: entry, error } = await ctx.supabaseAdmin
        .from('state_entries')
        .insert({
          user_id: ctx.userId,
          definition_id: input.tracked_state_def_id, // input is now typed
          value_numeric: input.value_numeric,     // input is now typed
          value_text: input.value_text,         // input is now typed
          entry_timestamp: input.entry_timestamp || new Date().toISOString(), // input is now typed
          notes: input.notes,                 // input is now typed
        })
        .select(STATE_ENTRY_FIELDS)
        .single();

      if (error) throw error;
      return entry;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to create state entry',
      });
    }
  }),

updateEntry: protectedProcedure
  .input(updateStateEntryInput) // <<<--- ADDED .input() BINDING
  .mutation(async ({ ctx, input }) => {
    try {
      const { id, ...updateData } = input; // input is now typed

      // Check ownership (already implemented correctly)
      const { error: fetchError } = await ctx.supabaseAdmin
        .from('state_entries')
        .select('id')
        .eq('id', id) // Use id from destructured input
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError) {
        throw new TRPCError({
          code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
          message: 'Entry not found or access denied.',
        });
      }

      // updateData is now correctly typed from the input schema
      const { data: updatedEntry, error } = await ctx.supabaseAdmin
        .from('state_entries')
        .update(updateData)
        .eq('id', id) // Use id from destructured input
        .eq('user_id', ctx.userId)
        .select(STATE_ENTRY_FIELDS)
        .single();

      if (error) throw error;
      return updatedEntry;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to update state entry',
      });
    }
  }),

deleteEntry: protectedProcedure
  .input(DeleteStateEntryInput) // <<<--- ADDED .input() BINDING
  .mutation(async ({ ctx, input }) => {
     try {
      // Check ownership (already implemented correctly)
      const { error: fetchError } = await ctx.supabaseAdmin
        .from('state_entries')
        .select('id')
        .eq('id', input.id) // input is now typed
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError) {
        throw new TRPCError({
          code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
          message: 'Entry not found or access denied.',
        });
      }

      const { error } = await ctx.supabaseAdmin
        .from('state_entries')
        .delete()
       ... /* snippet truncated */
  ```

- **server/src/routers/userRouter.ts**

  *Exports: `userRouter`*
  ```ts
const userRouter = router({
  getProfile: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('id, username, avatar_url, full_name, bio, time_zone, onboarding_completed, created_at, updated_at')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  updateProfile: protectedProcedure
    .input(z.object({
      full_name: z.string().optional(),
      avatar_url: z.string().optional(),
      theme: z.string().optional(),
      time_zone: z.string().optional(),
      display_name: z.string().optional(),
      bio: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update(input)
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getUserSettings: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('id, user_id, notification_preferences, ui_preferences')
        .eq('user_id', ctx.userId)
        .single();
        
      if (error) {
        // If settings don't exist, create default settings
        if (error.code === 'PGRST116') {
          const { data: newSettings, error: createError } = await ctx.supabaseAdmin
            .from('user_settings')
            .insert({
              user_id: ctx.userId,
              notification_preferences: {
                email: true,
                push: true,
                task_reminders: true,
                goal_updates: true,
                habit_reminders: true
              },
              ui_preferences: {
                theme: 'system',
                compact_view: false,
                show_completed_tasks: true
              }
            })
            .select()
            .single();
            
          if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
          return newSettings;
        }
        
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      }
      
      return data;
    }),
    
  updateUserSettings: protectedProcedure
    .input(z.object({
      notification_preferences: z.object({
        email: z.boolean().optional(),
        push: z.boolean().optional(),
        task_reminders: z.boolean().optional(),
        goal_updates: z.boolean().optional(),
        habit_reminders: z.boolean().optional()
      }).optional(),
      ui_preferences: z.object({
        theme: z.string().optional(),
        compact_view: z.boolean().optional(),
        show_completed_tasks: z.boolean().optional()
      }).optional()
    }))
    .mutation(async ({ ctx, input }) => {
      // First check if settings exist
      const { data: existingSettings, error: fetchError } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('id')
        .eq('user_id', ctx.userId)
        .single();
        
      if (fetchError && fetchError.code === 'PGRST116') {
        // Create settings if they don't exist
        const defaultSettings = {
          user_id: ctx.userId,
          notification_preferences: {
            email: true,
            push: true,
            task_reminders: true,
            goal_updates: true,
            habit_reminders: true,
            ...input.notification_preferences
          },
          ui_preferences: {
            theme: 'system',
            compact_view: false,
            show_completed_tasks: true,
            ...input.ui_preferences
          }
        };
        
        const { data, error } = await ctx.supabaseAdmin
          .from('user_settings')
          .insert(defaultSettings)
          .select()
          .single();
          
        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        return data;
      } else if (fetchError) {
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: fetchError.message });
      }
      
      // Update existing settings
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .update(input)
        .eq('user_id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getOnboardingStatus: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('id, onboarding_completed')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { onboardingCompleted: data?.onboarding_completed || false };
    }),
    
  completeOnboarding: protectedProcedure
    .mutation(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update({ onboarding_completed: true })
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { success: true };
    }),
});
  ```

- **server/src/routers/valueRouter.ts**

  *Exports: `valueRouter`*
  ```ts
const valueRouter = router({
  getValues: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: values, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return values;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch values',
        });
      }
    }),

  getValueById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!value) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found',
          });
        }

        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch value',
        });
      }
    }),

  createValue: protectedProcedure
    .input(createValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create value',
        });
      }
    }),

  updateValue: protectedProcedure
    .input(updateValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // First check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to update it',
          });
        }

        // Update the value
        const { data: updatedValue, error } = await ctx.supabaseAdmin
          .from('values')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return updatedValue;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update value',
        });
      }
    }),

  deleteValue: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to delete it',
          });
        }

        // Delete the value
        const { error } = await ctx.supabaseAdmin
          .from('values')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete value',
        });
      }
    }),
});
  ```

- **server/src/types/index.ts**

  *Exports: `Badge`*
  ```ts
export interface Badge {
  id: BadgeId;
  title: string;
  icon: string; // Hero‑icons name or emoji
  earnedAt?: string; // ISO
  progress?: number; // 0‒1 for not‑yet
}
  ```

  *Exports: `BadgeId`*
  ```ts
export type BadgeId = string;
  ```

  *Exports: `Goal`*
  ```ts
export interface Goal {
  id: GoalId;
  title: string;
  description?: string;
  valueIds: ValueId[];
  progress: number; // 0‒1
  keyResults: KeyResult[];
  targetDate?: string; // ISO
}
  ```

  *Exports: `GoalId`*
  ```ts
export type GoalId = string;
  ```

  *Exports: `Habit`*
  ```ts
export interface Habit {
  id: HabitId;
  title: string;
  cue?: string;
  routine?: string;
  reward?: string;
  valueIds: ValueId[];
  streak: number; // current consecutive days
  bestStreak: number;
  history: Record<string, boolean>; // ISO day → done?
}
  ```

  *Exports: `HabitId`*
  ```ts
export type HabitId = string;
  ```

  *Exports: `KeyResult`*
  ```ts
export interface KeyResult {
  id: string;
  title: string;
  progress: number; // 0‒1
}
  ```

  *Exports: `Principle`*
  ```ts
export interface Principle {
  id: string;
  title: string;
  body: string;
  valueIds: ValueId[];
}
  ```

  *Exports: `Task`*
  ```ts
export interface Task {
  id: TaskId;
  title: string;
  notes?: string;
  status: 'todo' | 'doing' | 'done' | 'blocked';
  due?: string; // ISO date
  priority?: 1 | 2 | 3;
  goalId?: GoalId;
  valueIds?: ValueId[];
}
  ```

  *Exports: `TaskId`*
  ```ts
export type TaskId = string;
  ```

  *Exports: `TrackedStateDef`*
  ```ts
export interface TrackedStateDef {
  id: string;
  name: string;
  scale: '1-5' | 'low-high' | 'custom';
  customLabels?: string[];
  valueIds: ValueId[];
}
  ```

  *Exports: `Value`*
  ```ts
export interface Value {
  id: ValueId;
  name: string;
  description?: string;
  color: string; // tailwind color token (e.g. 'indigo-500')
  domainId?: string; // optional grouping
}
  ```

  *Exports: `ValueId`*
  ```ts
export type ValueId = string;
  ```

- **server/src/types/trpc-types.ts**

  *Exports: `awardBadgeInput`*
  ```ts
const awardBadgeInput = z.object({
  badgeId: z.string(), // Matches text ID in badge_definitions
  description: z.string().optional(), // Example custom field if needed
});
  ```

  *Exports: `BadgeDefinition`*
  ```ts
const BadgeDefinition = z.object({
  id: z.string(), // From DB: text primary key
  title: z.string(),
  description: z.string().nullish(),
  icon: z.string(),
});
  ```

  *Exports: `BadgeDefinition`*
  ```ts
export type BadgeDefinition = z.infer<typeof BadgeDefinition>;
  ```

  *Exports: `claimLootInput`*
  ```ts
const claimLootInput = z.object({
  rewardId: z.string().uuid(), // Use rewardId to match router
});
  ```

  *Exports: `createGoalInput`*
  ```ts
const createGoalInput = Goal.omit({ id: true, user_id: true, created_at: true, updated_at: true });
  ```

  *Exports: `createGoalProgressNoteInput`*
  ```ts
const createGoalProgressNoteInput = GoalProgressNote.omit({ id: true, user_id: true, created_at: true });
  ```

  *Exports: `createHabitEntryInput`*
  ```ts
const createHabitEntryInput = HabitEntry.omit({ id: true, user_id: true, created_at: true });
  ```

  *Exports: `createHabitInput`*
  ```ts
const createHabitInput = Habit.omit({ id: true, user_id: true, created_at: true, updated_at: true });
  ```

  *Exports: `createPrincipleInput`*
  ```ts
const createPrincipleInput = Principle.omit({ id: true, user_id: true, created_at: true, updated_at: true });
  ```

  *Exports: `createReminderInput`*
  ```ts
const createReminderInput = Reminder.omit({ id: true, user_id: true, created_at: true, updated_at: true });
  ```

  *Exports: `CreateStateEntryInput`*
  ```ts
const CreateStateEntryInput = StateEntry.omit({ id: true, user_id: true })
.extend({
  tracked_state_def_id: z.string().uuid(), // Ensure this is required
  // Values are optional in base schema
});
  ```

  *Exports: `createTaskInput`*
  ```ts
const createTaskInput = Task.omit({ id: true, user_id: true, created_at: true, updated_at: true });
  ```

  *Exports: `createTrackedStateDefInput`*
  ```ts
const createTrackedStateDefInput = TrackedStateDef.omit({ id: true, user_id: true, created_at: true, updated_at: true });
  ```

  *Exports: `createValueInput`*
  ```ts
const createValueInput = Value.omit({ id: true, user_id: true, created_at: true, updated_at: true });
  ```

  *Exports: `DeleteGoalProgressNoteInput`*
  ```ts
const DeleteGoalProgressNoteInput = z.object({ id: z.string().uuid() });
  ```

  *Exports: `DeleteReminderInput`*
  ```ts
const DeleteReminderInput = z.object({ id: z.string().uuid() });
  ```

  *Exports: `DeleteStateEntryInput`*
  ```ts
const DeleteStateEntryInput = z.object({ id: z.string().uuid() });
  ```

  *Exports: `DeleteTrackedStateDefInput`*
  ```ts
const DeleteTrackedStateDefInput = z.object({ id: z.string().uuid() });
  ```

  *Exports: `GetGoalProgressNotesInput`*
  ```ts
const GetGoalProgressNotesInput = z.object({ goal_id: z.string().uuid() });
  ```

  *Exports: `GetRemindersForEntityInput`*
  ```ts
const GetRemindersForEntityInput = z.object({
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
});
  ```

  *Exports: `GetStateEntriesInput`*
  ```ts
const GetStateEntriesInput = z.object({
  tracked_state_def_id: z.string().uuid(), // Renamed from definition_id to match DB? Check usage.
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  limit: z.number().int().positive().optional(),
});
  ```

  *Exports: `GetTrackedStateDefByIdInput`*
  ```ts
const GetTrackedStateDefByIdInput = z.object({ id: z.string().uuid() });
  ```

  *Exports: `Goal`*
  ```ts
const Goal = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  description: z.string().nullish(),
  progress: z.number().nullish(),
  target_date: z.string().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime().nullish(),
  updated_at: z.string().datetime().nullish(),
});
  ```

  *Exports: `Goal`*
  ```ts
export type Goal = z.infer<typeof Goal>;
  ```

  *Exports: `GoalProgressNote`*
  ```ts
const GoalProgressNote = z.object({
  id: z.string().uuid(),
  goal_id: z.string().uuid(),
  user_id: z.string().uuid(),
  note: z.string(),
  created_at: z.string().datetime(),
});
  ```

  *Exports: `GoalProgressNote`*
  ```ts
export type GoalProgressNote = z.infer<typeof GoalProgressNote>;
  ```

  *Exports: `greetingInput`*
  ```ts
const greetingInput = z.object({ name: z.string().optional() });
  ```

  *Exports: `greetingOutput`*
  ```ts
const greetingOutput = z.object({ greeting: z.string() });
  ```

  *Exports: `Habit`*
  ```ts
const Habit = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  cue: z.string().nullish(),
  routine: z.string().nullish(),
  reward: z.string().nullish(),
  streak: z.number().nonnegative().default(0),
  best_streak: z.number().nonnegative().default(0),
  habit_type: HabitTypeEnum.default('boolean'),
  goal_quantity: z.number().int().nullish(),
  goal_unit: z.string().nullish(),
  frequency_period: HabitFrequencyPeriodEnum.default('day'),
  goal_frequency: z.number().int().positive().default(1),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(), // <<< Added sort_order
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
  ```

  *Exports: `Habit`*
  ```ts
export type Habit = z.infer<typeof Habit>;
  ```

  *Exports: `HabitEntry`*
  ```ts
const HabitEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  habit_id: z.string().uuid(),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be in YYYY-MM-DD format"),
  completed: z.boolean().default(false),
  quantity_value: z.number().int().nullish(),
  notes: z.string().nullish(),
  created_at: z.string().datetime(),
});
  ```

  *Exports: `HabitEntry`*
  ```ts
export type HabitEntry = z.infer<typeof HabitEntry>;
  ```

  *Exports: `HabitFrequencyPeriodEnum`*
  ```ts
const HabitFrequencyPeriodEnum = z.enum(['day', 'week', 'month']);
  ```

  *Exports: `HabitTypeEnum`*
  ```ts
const HabitTypeEnum = z.enum(['boolean', 'quantity']);
  ```

  *Exports: `NotificationPrefs`*
  ```ts
const NotificationPrefs = z.object({
  email: z.boolean().default(true),
  push: z.boolean().default(true),
  task_reminders: z.boolean().default(true),
  goal_updates: z.boolean().default(true),
  habit_reminders: z.boolean().default(true),
});
  ```

  *Exports: `PointTransaction`*
  ```ts
const PointTransaction = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  points: z.number().int(),
  reason: z.string(),
  source_type: z.string(),
  source_id: z.string().uuid().nullish(),
  created_at: z.string().datetime(),
});
  ```

  *Exports: `PointTransaction`*
  ```ts
export type PointTransaction = z.infer<typeof PointTransaction>;
  ```

  *Exports: `Principle`*
  ```ts
const Principle = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), // <<< Changed from 'name' to 'title'
  body: z.string(), // <<< Renamed from description for clarity, matching migration
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
  ```

  *Exports: `Principle`*
  ```ts
export type Principle = z.infer<typeof Principle>;
  ```

  *Exports: `Reminder`*
  ```ts
const Reminder = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
  reminder_time: z.string().datetime(),
  is_active: z.boolean().default(true),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
  ```

  *Exports: `Reminder`*
  ```ts
export type Reminder = z.infer<typeof Reminder>;
  ```

  *Exports: `Reward`*
  ```ts
const Reward = z.object({
  id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullish(),
  type: RewardTypeEnum,
  required_points: z.number().int().nonnegative().default(0),
  can_earn_multiple: z.boolean().default(false),
  image_url: z.string().url().nullish(),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
  ```

  *Exports: `Reward`*
  ```ts
export type Reward = z.infer<typeof Reward>;
  ```

  *Exports: `RewardTypeEnum`*
  ```ts
const RewardTypeEnum = z.enum(['badge', 'achievement', 'item', 'discount']);
  ```

  *Exports: `RouterInputs`*
  ```ts
export type RouterInputs = inferRouterInputs<AppRouter>;
  ```

  *Exports: `RouterOutputs`*
  ```ts
export type RouterOutputs = inferRouterOutputs<AppRouter>;
  ```

  *Exports: `StateEntry`*
  ```ts
const StateEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  definition_id: z.string().uuid(), // <<< Renamed from tracked_state_def_id for consistency? check DB
  value_numeric: z.number().optional().nullable(),
  value_text: z.string().optional().nullable(),
  entry_timestamp: z.string().datetime({ message: "Invalid datetime string. Must be UTC ISO 8601" }).optional(),
  notes: z.string().optional().nullable(), // <<< Added notes
});
  ```

  *Exports: `StateEntry`*
  ```ts
export type StateEntry = z.infer<typeof StateEntry>;
  ```

  *Exports: `Task`*
  ```ts
const Task = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  notes: z.string().nullish(),
  status: TaskStatusEnum.default('todo'),
  priority_enum: TaskPriorityEnum.nullish(), // <<< Renamed from priority
  due_date: z.string().datetime().nullish(),
  goal_id: z.string().uuid().nullish(),
  parent_task_id: z.string().uuid().nullish(),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
  ```

  *Exports: `Task`*
  ```ts
export type Task = z.infer<typeof Task>;
  ```

  *Exports: `TaskPriorityEnum`*
  ```ts
const TaskPriorityEnum = z.enum(['low', 'medium', 'high']);
  ```

  *Exports: `TaskStatusEnum`*
  ```ts
const TaskStatusEnum = z.enum(['todo', 'doing', 'done', 'blocked', 'pending']);
  ```

  *Exports: `TrackedStateDef`*
  ```ts
const TrackedStateDef = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  name: z.string(),
  // category: z.string(), // Category seems removed/replaced in DB schema by scale/custom_labels
  scale: z.enum(['1-5', 'low-high', 'custom']), // <<< Added scale
  custom_labels: z.array(z.string()).nullish(), // <<< Added custom_labels
  unit: z.string().nullish(), // Keep unit if still used alongside scale
  icon: z.string().nullish(), // Keep icon if still used
  target_min_value: z.number().nullish(), // <<< Added
  target_max_value: z.number().nullish(), // <<< Added
  active: z.boolean().default(true), // <<< Added active
  priority: z.number().int().default(1), // <<< Added priority
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
  ```

  *Exports: `TrackedStateDef`*
  ```ts
export type TrackedStateDef = z.infer<typeof TrackedStateDef>;
  ```

  *Exports: `UiPrefs`*
  ```ts
const UiPrefs = z.object({
  theme: z.enum(['system', 'light', 'dark']).default('system'),
  compact_view: z.boolean().default(false),
  show_completed_tasks: z.boolean().default(true),
  first_day_of_week: z.number().int().min(0).max(6).default(0),
});
  ```

  *Exports: `updateGoalInput`*
  ```ts
const updateGoalInput = createGoalInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updateGoalProgressNoteInput`*
  ```ts
const updateGoalProgressNoteInput = createGoalProgressNoteInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updateHabitEntryInput`*
  ```ts
const updateHabitEntryInput = createHabitEntryInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updateHabitInput`*
  ```ts
const updateHabitInput = createHabitInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updatePrincipleInput`*
  ```ts
const updatePrincipleInput = createPrincipleInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updateProfileInput`*
  ```ts
const updateProfileInput = UserProfile.partial().omit({ id: true, created_at: true, updated_at: true });
  ```

  *Exports: `updateReminderInput`*
  ```ts
const updateReminderInput = createReminderInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updateSettingsInput`*
  ```ts
const updateSettingsInput = z.object({
  notification_preferences: NotificationPrefs.partial().optional(),
  ui_preferences: UiPrefs.partial().optional(),
});
  ```

  *Exports: `updateStateEntryInput`*
  ```ts
const updateStateEntryInput = CreateStateEntryInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updateTaskInput`*
  ```ts
const updateTaskInput = createTaskInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updateTaskStatusInput`*
  ```ts
const updateTaskStatusInput = z.object({ id: z.string().uuid(), status: TaskStatusEnum });
  ```

  *Exports: `updateTrackedStateDefInput`*
  ```ts
const updateTrackedStateDefInput = createTrackedStateDefInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `updateValueInput`*
  ```ts
const updateValueInput = createValueInput.partial().extend({ id: z.string().uuid() });
  ```

  *Exports: `UserBadge`*
  ```ts
const UserBadge = z.object({
  // Note: user_badges might be merged into user_rewards with type='badge'
  user_id: z.string().uuid(),
  badge_id: z.string(), // Matches badge_definitions.id (text)
  earned_at: z.string().datetime(),
  progress: z.number().nullish(), // From DB schema
});
  ```

  *Exports: `UserBadge`*
  ```ts
export type UserBadge = z.infer<typeof UserBadge>;
  ```

  *Exports: `UserProfile`*
  ```ts
const UserProfile = z.object({
  id: z.string().uuid(),
  username: z.string().nullish(),
  avatar_url: z.string().url().nullish(),
  full_name: z.string().nullish(),
  bio: z.string().nullish(),
  points: z.number().int().nonnegative().default(0),
  time_zone: z.string().nullish(),
  onboarding_completed: z.boolean().default(false),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
  ```

  *Exports: `UserProfile`*
  ```ts
export type UserProfile = z.infer<typeof UserProfile>;
  ```

  *Exports: `UserReward`*
  ```ts
const UserReward = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  reward_id: z.string().uuid(),
  reward_type: z.string().nullish(), // From DB schema
  earned_at: z.string().datetime(),
  points_spent: z.number().int().nonnegative().default(0),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
  ```

  *Exports: `UserReward`*
  ```ts
export type UserReward = z.infer<typeof UserReward>;
  ```

  *Exports: `UserSettings`*
  ```ts
const UserSettings = z.object({
  id: z.string().uuid().optional(),
  user_id: z.string().uuid(),
  notification_preferences: NotificationPrefs,
  ui_preferences: UiPrefs,
});
  ```

  *Exports: `UserSettings`*
  ```ts
export type UserSettings = z.infer<typeof UserSettings>;
  ```

  *Exports: `Value`*
  ```ts
const Value = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), 
  description: z.string().nullish(),
  color: z.string().nullish(),
  icon: z.string().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
  ```

  *Exports: `Value`*
  ```ts
export type Value = z.infer<typeof Value>;
  ```

- **server/tsconfig.json**
  *(No explicit exports found)*

### stores

- **stores/uiStore.ts**

  *Exports: `useUiStore`*
  ```ts
const useUiStore = create<UiState>((set) => ({
  isDarkMode: false, // Default to light mode
  toggleTheme: () => set((state) => ({ isDarkMode: !state.isDarkMode })),
}));
  ```

### supabase

- **supabase/.gitignore**
  *(No explicit exports found)*

- **supabase/config.toml**
  *(No explicit exports found)*

- **supabase/migrations/20250424033333_initial_schema.sql**
  *(No explicit exports found)*

- **supabase/migrations/20250424035232_add_missing_tables.sql**
  *(No explicit exports found)*

- **supabase/migrations/20250424035717_add_missing_tables.sql**
  *(No explicit exports found)*

- **supabase/migrations/20250425000000_create_user_settings_table.sql**
  *(No explicit exports found)*

- **supabase/migrations/20250426000000_create_rewards_tables.sql**
  *(No explicit exports found)*

- **supabase/migrations/20250428124230_standardize_field_naming.sql**
  *(No explicit exports found)*

- **supabase/migrations/20250428130834_enhance_functional_schema.sql**
  *(No explicit exports found)*

### types

- **types/database.types.ts**

  *Exports: `CompositeTypes`*
  ```ts
export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof Database },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends { schema: keyof Database }
  ? Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never
  ```

  *Exports: `Constants`*
  ```ts
const Constants = {
  public: {
    Enums: {
      habit_frequency_period: ["day", "week", "month"],
      habit_type: ["boolean", "quantity"],
      reward_type: ["badge", "achievement", "item", "discount"],
      task_priority: ["low", "medium", "high"],
      task_status: ["todo", "doing", "done", "blocked", "pending"],
      tracked_state_scale: ["1-5", "low-high", "custom"],
    },
  },
} as const
  ```

  *Exports: `Database`*
  ```ts
export type Database = {
public: {
  Tables: {
    badge_definitions: {
      Row: {
        description: string | null
        icon: string
        id: string
        title: string
      }
      Insert: {
        description?: string | null
        icon: string
        id: string
        title: string
      }
      Update: {
        description?: string | null
        icon?: string
        id?: string
        title?: string
      }
      Relationships: []
    }
    goal_progress_notes: {
      Row: {
        created_at: string
        goal_id: string
        id: string
        note: string
        user_id: string
      }
      Insert: {
        created_at?: string
        goal_id: string
        id?: string
        note: string
        user_id: string
      }
      Update: {
        created_at?: string
        goal_id?: string
        id?: string
        note?: string
        user_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "goal_progress_notes_goal_id_fkey"
          columns: ["goal_id"]
          isOneToOne: false
          referencedRelation: "goals"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "goal_progress_notes_user_id_fkey"
          columns: ["user_id"]
          isOneToOne: false
          referencedRelation: "profiles"
          referencedColumns: ["id"]
        },
      ]
    }
    goal_values: {
      Row: {
        goal_id: string
        user_id: string
        value_id: string
      }
      Insert: {
        goal_id: string
        user_id: string
        value_id: string
      }
      Update: {
        goal_id?: string
        user_id?: string
        value_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "goal_values_goal_id_fkey"
          columns: ["goal_id"]
          isOneToOne: false
          referencedRelation: "goals"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "goal_values_user_id_fkey"
          columns: ["user_id"]
          isOneToOne: false
          referencedRelation: "profiles"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "goal_values_value_id_fkey"
          columns: ["value_id"]
          isOneToOne: false
          referencedRelation: "values"
          referencedColumns: ["id"]
        },
      ]
    }
    goals: {
      Row: {
        archived_at: string | null
        created_at: string | null
        description: string | null
        id: string
        progress: number | null
        sort_order: number | null
        target_date: string | null
        title: string
        updated_at: string | null
        user_id: string
      }
      Insert: {
        archived_at?: string | null
        created_at?: string | null
        description?: string | null
        id?: string
        progress?: number | null
        sort_order?: number | null
        target_date?: string | null
        title: string
        updated_at?: string | null
        user_id: string
      }
      Update: {
        archived_at?: string | null
        created_at?: string | null
        description?: string | null
        id?: string
        progress?: number | null
        sort_order?: number | null
        target_date?: string | null
        title?: string
        updated_at?: string | null
        user_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "goals_user_id_fkey"
          columns: ["user_id"]
          isOneToOne: false
          referencedRelation: "profiles"
          referencedColumns: ["id"]
        },
      ]
    }
    habit_entries: {
      Row: {
        completed: boolean
        created_at: string
        date: string
        habit_id: string
        id: string
        notes: string | null
        quantity_value: number | null
        user_id: string
      }
      Insert: {
        completed?: boolean
        created_at?: string
        date: string
        habit_id: string
        id?: string
        notes?: string | null
        quantity_value?: number | null
        user_id: string
      }
      Update: {
        completed?: boolean
        created_at?: string
        date?: string
        habit_id?: string
        id?: string
        notes?: string | null
        quantity_value?: number | null
        user_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "habit_entries_habit_id_fkey"
          columns: ["habit_id"]
          isOneToOne: false
          referencedRelation: "habits"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "habit_entries_user_id_fkey"
          columns: ["user_id"]
          isOneToOne: false
          referencedRelation: "profiles"
          referencedColumns: ["id"]
        },
      ]
    }
    habit_values: {
      Row: {
        habit_id: string
        user_id: string
        value_id: string
      }
      Insert: {
        habit_id: string
        user_id: string
        value_id: string
      }
      Update: {
        habit_id?: string
        user_id?: string
        value_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "habit_values_habit_id_fkey"
          columns: ["habit_id"]
          isOneToOne: false
          referencedRelation: "habits"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "habit_values_user_id_fkey"
          columns: ["user_id"]
          isOneToOne: false
          referencedRelation: "profiles"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "habit_values_value_id_fkey"
          columns: ["value_id"]
          isOneToOne: false
          referencedRelation: "values"
          referencedColumns: ["id"]
        },
      ]
    }
    habits: {
      Row: {
        archived_at: string | null
        best_streak: number
        created_at: string
        cue: string | null
        frequency_period: Database["public"]["Enums"]["habit_frequency_period"]
        goal_frequency: number
        goal_quantity: number | null
        goal_unit: string | null
        habit_type: Database["public"]["Enums"]["habit_type"]
        id: string
        recurrence_end_date: string | null
        recurrence_rule: string | null
        reward: string | null
        routine: string | null
        streak: number
        title: string
        updated_at: string
        user_id: string
      }
      Insert: {
        archived_at?: string | null
        best_streak?: number
        created_at?: string
        cue?: string | null
        frequency_period?: Database["public"]["Enums"]["habit_frequency_period"]
        goal_frequency?: number
        goal_quantity?: number | null
        goal_unit?: string | null
        habit_type?: Database["public"]["Enums"]["habit_type"]
        id?: string
        recurrence_end_date?: string | null
        recurrence_rule?: string | null
        reward?: string | null
        routine?: string | null
        streak?: number
        title: string
        updated_at?: string
        user_id: string
      }
      Update: {
        archived_at?: string | null
        best_streak?: number
        created_at?: string
        cue?: string | null
        frequency_period?: Database["public"]["Enums"]["habit_frequency_period"]
        goal_frequency?: number
        goal_quantity?: number | null
        goal_unit?: string | null
        habit_type?: Database["public"]["Enums"]["habit_type"]
        id?: string
        recurrence_end_date?: string | null
        recurrence_rule?: string | null
        reward?: string | null
        routine?: string | null
        streak?: number
        title?: string
        updated_at?: string
        user_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "habits_user_id_fkey"
          columns: ["user_id"]
          isOneToOne: false
          referencedRelation: "profiles"
          referencedColumns: ["id"]
        },
      ]
    }
    key_results: {
      Row: {
        created_at: string
        goal_id: string
        id: string
        progress: number | null
        title: string
        updated_at: string
        user_id: string
      }
      Insert: {
        created_at?: string
        goal_id: string
        id?: string
        progress?: number | null
        title: string
        updated_at?: string
        user_id: string
      }
      Update: {
        created_at?: string
        goal_id?: string
        id?: string
        progress?: number | null
        title?: string
        updated_at?: string
        user_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "key_results_goal_id_fkey"
          columns: ["goal_id"]
          isOneToOne: false
          referencedRelation: "goals"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "key_results_user_id_fkey"
          columns: ["user_id"]
          isOneToOne: false
          referencedRelation: "profiles"
          referencedColumns: ["id"]
        },
      ]
    }
    point_transactions: {
      Row: {
        created_at: string
        id: string
        points: number
        reason: string
        source_id: string | null
        source_type: string
   ... /* snippet truncated */
  ```

  *Exports: `Enums`*
  ```ts
export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof Database },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never
  ```

  *Exports: `Json`*
  ```ts
export type Json =
| string
| number
| boolean
| null
| { [key: string]: Json | undefined }
| Json[]
  ```

  *Exports: `Tables`*
  ```ts
export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof (Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        Database[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? (Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      Database[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never
  ```

  *Exports: `TablesInsert`*
  ```ts
export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never
  ```

  *Exports: `TablesUpdate`*
  ```ts
export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never
  ```

### utils

- **utils/api-types.ts**

  *Exports: `RouterInputs`*
  ```ts
export type RouterInputs = inferRouterInputs<AppRouter>;
  ```

  *Exports: `RouterOutputs`*
  ```ts
export type RouterOutputs = inferRouterOutputs<AppRouter>;
  ```

- **utils/auth.ts**

  *Exports: `getUserProfile`*
  ```ts
export async function getUserProfile() {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) return null;
    
    // If we have a user, get their profile from the profiles table
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', user.id)
      .single();
    
    if (error) {
      // If profile doesn't exist yet, return basic user info
      return {
        id: user.id,
        email: user.email,
        username: user.user_metadata?.username || 'User',
        created_at: user.created_at,
      };
    }
    
    return data;
  } catch (error) {
    console.error('Error getting user profile:', error);
    return null;
  }
}
  ```

  *Exports: `logout`*
  ```ts
export async function logout() {
  try {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
    
    // Navigate to login screen
    router.replace('/auth/login');
  } catch (error) {
    console.error('Error signing out:', error);
    // Force navigation even if there was an error
    router.replace('/auth/login');
  }
}
  ```

- **utils/colors.ts**

  *Exports: `palette`*
  ```ts
const palette = {
  // Main UI colors
  black: '#000000',
  white: '#FFFFFF',
  
  // Grays
  gray: {
    50: '#F9FAFB',
    100: '#F3F4F6',
    200: '#E5E7EB',
    300: '#D1D5DB',
    400: '#9CA3AF',
    500: '#6B7280',
    600: '#4B5563',
    700: '#374151',
    800: '#1F2937',
    900: '#111827',
  },
  
  // Blues
  blue: {
    50: '#EFF6FF',
    100: '#DBEAFE',
    200: '#BFDBFE',
    300: '#93C5FD',
    400: '#60A5FA',
    500: '#3B82F6',
    600: '#2563EB',
    700: '#1D4ED8',
    800: '#1E40AF',
    900: '#1E3A8A',
  },
  
  // Greens
  green: {
    50: '#ECFDF5',
    100: '#D1FAE5',
    200: '#A7F3D0',
    300: '#6EE7B7',
    400: '#34D399',
    500: '#10B981',
    600: '#059669',
    700: '#047857',
    800: '#065F46',
    900: '#064E3B',
  },
  
  // Reds
  red: {
    50: '#FEF2F2',
    100: '#FEE2E2',
    200: '#FECACA',
    300: '#FCA5A5',
    400: '#F87171',
    500: '#EF4444',
    600: '#DC2626',
    700: '#B91C1C',
    800: '#991B1B',
    900: '#7F1D1D',
  },
  
  // Yellows
  yellow: {
    50: '#FFFBEB',
    100: '#FEF3C7',
    200: '#FDE68A',
    300: '#FCD34D',
    400: '#FBBF24',
    500: '#F59E0B',
    600: '#D97706',
    700: '#B45309',
    800: '#92400E',
    900: '#78350F',
  },
  
  // Purples
  purple: {
    50: '#F5F3FF',
    100: '#EDE9FE',
    200: '#DDD6FE',
    300: '#C4B5FD',
    400: '#A78BFA',
    500: '#8B5CF6',
    600: '#7C3AED',
    700: '#6D28D9',
    800: '#5B21B6',
    900: '#4C1D95',
  },
};
  ```

  *Exports: `semanticTokens`*
  ```ts
const semanticTokens = {
  // Background colors
  background: {
    /** Main app background */
    app: '$background',
    /** Card/surface background */
    card: '$backgroundHover',
    /** Secondary surface background */
    secondary: '$backgroundPress',
    /** Tertiary surface background */
    tertiary: '$backgroundStrong',
    /** Input background */
    input: '$backgroundTransparent',
  },
  
  // Foreground/content colors
  content: {
    /** Primary text */
    primary: '$color',
    /** Secondary/dimmed text */
    secondary: '$colorTransparent',
    /** Subtle text - least emphasis */
    subtle: '$colorTransparent2',
    /** Disabled text */
    disabled: '$colorTransparent3',
  },
  
  // Border colors
  border: {
    /** Default border */
    default: '$borderColor',
    /** Focused border */
    focus: '$borderColorFocus',
    /** Border for hover state */
    hover: '$borderColorHover',
  },
  
  // Status colors
  status: {
    /** Success indicators */
    success: '$green10',
    /** Error indicators */
    error: '$red10',
    /** Warning indicators */
    warning: '$yellow10',
    /** Information indicators */
    info: '$blue10',
  },
  
  // Brand colors (adjust to match your brand)
  brand: {
    /** Primary brand color */
    primary: '$blue10',
    /** Secondary brand color */
    secondary: '$purple10',
    /** Accent brand color */
    accent: '$green10',
  }
};
  ```

  *Exports: `useColors`*
  ```ts
export function useColors() {
  const theme = useTheme();
  
  return {
    background: {
      app: theme?.background?.get() || '#FFFFFF',
      card: theme?.backgroundHover?.get() || '#F3F4F6',
      secondary: theme?.backgroundPress?.get() || '#E5E7EB',
      tertiary: theme?.backgroundStrong?.get() || '#D1D5DB',
      input: theme?.backgroundTransparent?.get() || '#FFFFFF',
    },
    content: {
      primary: theme?.color?.get() || '#111827',
      secondary: theme?.colorTransparent?.get() || '#4B5563',
      subtle: theme?.colorTransparent2?.get() || theme?.colorTransparent?.get() || '#6B7280',
      disabled: theme?.colorTransparent3?.get() || theme?.colorTransparent?.get() || '#9CA3AF',
    },
    border: {
      default: theme?.borderColor?.get() || '#E5E7EB',
      focus: theme?.borderColorFocus?.get() || '#93C5FD',
      hover: theme?.borderColorHover?.get() || '#BFDBFE',
    },
    status: {
      success: theme?.green10?.get() || '#10B981',
      error: theme?.red10?.get() || '#EF4444',
      warning: theme?.yellow10?.get() || '#F59E0B',
      info: theme?.blue10?.get() || '#3B82F6',
    },
    brand: {
      primary: theme?.blue10?.get() || '#3B82F6',
      secondary: theme?.purple10?.get() || '#8B5CF6',
      accent: theme?.green10?.get() || '#10B981',
    }
  };
}
  ```

  *Exports: `withOpacity`*
  ```ts
export function withOpacity(hex: string, alpha: number): string {
  // Extract RGB components from hex
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}
  ```

- **utils/generated-hooks.ts**

  *Exports: `useDashboard`*
  ```ts
const useDashboard = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useGoal`*
  ```ts
const useGoal = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useGoalProgressNote`*
  ```ts
const useGoalProgressNote = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useHabit`*
  ```ts
const useHabit = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `usePrinciple`*
  ```ts
const usePrinciple = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useReminder`*
  ```ts
const useReminder = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useRewards`*
  ```ts
const useRewards = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useState`*
  ```ts
const useState = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useTask`*
  ```ts
const useTask = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useUser`*
  ```ts
const useUser = {
  // Add strongly typed hooks here
};
  ```

  *Exports: `useValue`*
  ```ts
const useValue = {
  // Add strongly typed hooks here
};
  ```

- **utils/haptics.ts**

  *Exports: `haptics`*
  ```ts
const haptics = {
  /**
   * Light impact - subtle tap for small UI elements (buttons, toggles)
   */
  light: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light),
  
  /**
   * Medium impact - standard tap for medium elements (picker selections)
   */
  medium: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium),
  
  /**
   * Heavy impact - stronger bump for significant actions
   */
  heavy: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy),
  
  /**
   * Selection feedback - subtle tap for navigating through options
   */
  selection: () => Haptics.selectionAsync(),
  
  /**
   * Success notification - double-tap vibration for completed actions
   */
  success: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success),
  
  /**
   * Warning notification - attention-grabbing pattern for warnings
   */
  warning: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning),
  
  /**
   * Error notification - strong buzz pattern for errors
   */
  error: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error),
};
  ```

- **utils/mock-api.ts**

  *Exports: `appRouter`*
  ```ts
const appRouter = router({
  greeting: {
    hello: publicProcedure
      .input(z.object({ name: z.string().optional() }))
      .query(({ input }) => {
        return {
          greeting: `Hello ${input.name ?? 'world'}`,
        };
      }),
    goodbye: publicProcedure
      .query(() => {
        return {
          greeting: 'Goodbye!',
        };
      }),
  },
  user: {
    get: publicProcedure
      .input(z.object({ id: z.string() }))
      .query(({ input }) => {
        return {
          id: input.id,
          name: 'Mock User',
        };
      }),
    list: publicProcedure
      .query(() => {
        return [
          { id: '1', name: 'Mock User 1' },
          { id: '2', name: 'Mock User 2' },
        ];
      }),
  },
  auth: {
    refreshToken: publicProcedure
      .input(z.object({ refreshToken: z.string() }))
      .mutation(async ({ input }) => {
        console.log('Mock API: refreshToken called with', input.refreshToken);
        // Simulate checking refresh token and issuing new ones
        await new Promise(resolve => setTimeout(resolve, 300));
        if (input.refreshToken === 'valid-refresh-token') { // Example valid token
          return {
            accessToken: `mock-access-${Date.now()}`,
            refreshToken: `mock-refresh-${Date.now()}`,
          };
        } else {
          // Throw error for invalid refresh token
          throw new Error('Invalid refresh token'); 
        }
      }),
    // Add login/logout mutations here later
  },
  item: {
    add: publicProcedure
      .input(z.object({ name: z.string() }))
      .mutation(async ({ input }) => {
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 500));
        // In a real backend, save to DB
        console.log('Mock API: Adding item', input);
        return {
          id: Math.random().toString(36).substring(7), // Generate random ID
          name: input.name,
          status: 'added'
        };
      }),
  },
});
  ```

  *Exports: `AppRouter`*
  ```ts
export type AppRouter = typeof appRouter;
  ```

- **utils/nats-client.ts**

  *Exports: `addSubjectHandler`*
  ```ts
export function addSubjectHandler(subject: string, handler: CacheUpdateHandler): () => void {
  if (!handlers[subject]) {
    handlers[subject] = [];
  }
  
  handlers[subject].push(handler);
  
  // Return a function to remove the handler
  return () => {
    if (handlers[subject]) {
      handlers[subject] = handlers[subject].filter(h => h !== handler);
    }
  };
}
  ```

  *Exports: `closeNatsConnection`*
  ```ts
export async function closeNatsConnection(): Promise<void> {
  if (natsConnection) {
    await natsConnection.close();
    natsConnection = null;
  }
}
  ```

  *Exports: `getNatsConnection`*
  ```ts
export function getNatsConnection(): NatsConnection | null {
  return natsConnection;
}
  ```

  *Exports: `initNatsClient`*
  ```ts
export async function initNatsClient(
  url: string, 
  qc: QueryClient,
  options: Partial<ConnectionOptions> = {}
): Promise<NatsConnection> {
  if (natsConnection) {
    return natsConnection;
  }
  
  if (isConnecting) {
    throw new Error('NATS connection is already in progress');
  }
  
  isConnecting = true;
  
  try {
    // Set the query client for cache updates
    queryClient = qc;
    
    // Connect to NATS server
    natsConnection = await connect({
      servers: url,
      // Add required polyfills for React Native
      // These would need to be properly implemented in a real app
      ...options,
    });
    
    console.log('Connected to NATS server');
    
    // Setup ping interval to keep connection alive
    const pingInterval = setInterval(() => {
      if (natsConnection && !natsConnection.isClosed) {
        // Note: Using a custom ping mechanism instead of the built-in one
        try {
          const start = Date.now();
          // Simple ping using a request to a dummy subject
          natsConnection.request('_PING_', undefined, { timeout: 1000 })
            .then(() => {
              const latency = Date.now() - start;
              console.log(`NATS server latency: ${latency}ms`);
            })
            .catch((err: Error) => {
              console.error('NATS ping error:', err.message);
            });
        } catch (err) {
          const error = err as Error;
          console.error('NATS ping error:', error.message);
        }
      } else {
        clearInterval(pingInterval);
      }
    }, 30000);
    
    // Handle connection close
    natsConnection.closed().then(() => {
      console.log('NATS connection closed');
      natsConnection = null;
      clearInterval(pingInterval);
      // Could implement reconnection logic here
    });
    
    return natsConnection;
  } catch (error) {
    console.error('Failed to connect to NATS server:', error);
    isConnecting = false;
    throw error;
  }
}
  ```

  *Exports: `subscribeWithCache`*
  ```ts
export async function subscribeWithCache(
  subject: string,
  queryKey: unknown[],
  updateType: 'invalidate' | 'setData' = 'invalidate'
): Promise<() => void> {
  if (!natsConnection) {
    throw new Error('NATS client not initialized');
  }
  
  if (!queryClient) {
    throw new Error('QueryClient not set');
  }
  
  // Create subscription
  const subscription = natsConnection.subscribe(subject);
  
  // Setup message handler
  (async () => {
    for await (const msg of subscription) {
      try {
        const data = JSON.parse(sc.decode(msg.data));
        
        if (updateType === 'invalidate') {
          // Invalidate the cache for this query key
          queryClient.invalidateQueries({ queryKey });
        } else {
          // Update the cache directly
          queryClient.setQueryData(queryKey, data);
        }
        
        // Call any custom handlers
        if (handlers[subject]) {
          handlers[subject].forEach(handler => handler(data));
        }
      } catch (error) {
        const err = error as Error;
        console.error(`Error handling message for ${subject}:`, err.message);
      }
    }
  })();
  
  // Return unsubscribe function
  return () => {
    subscription.unsubscribe();
  };
}
  ```

- **utils/offline-mutations.ts**

  *Exports: `asyncStoragePersister`*
  ```ts
const asyncStoragePersister = createAsyncStoragePersister({
  storage: AsyncStorage,
});
  ```

  *Exports: `configureQueryClientForOffline`*
  ```ts
export function configureQueryClientForOffline(queryClient: QueryClient): NetInfoSubscription {
  // Listen to network status changes and update onlineManager
  const unsubscribe = NetInfo.addEventListener(state => {
    onlineManager.setOnline(state.isConnected === true);
  });
  
  // When a mutation fails due to network error, pause it instead of failing
  queryClient.getMutationCache().config.onError = (error: unknown, _variables: unknown, _context: unknown, mutation: any) => {
    // Check if the error is a network error
    if (
      error instanceof Error && 
      (
        error.message.includes('network') || 
        error.message.includes('Network Error') ||
        error.message.includes('Failed to fetch')
      )
    ) {
      console.log('Network error detected, pausing mutation for later retry');
      
      // Pause the mutation instead of failing permanently
      mutation.state.isPaused = true;
    }
  };
  
  // Set up persistence
  persistQueryClient({
    queryClient,
    ...reactQueryPersistOptions,
  });

  // Return unsubscribe function for cleanup
  return unsubscribe;
}
  ```

  *Exports: `getPendingMutations`*
  ```ts
export function getPendingMutations(mutationCache: MutationCache): Mutation[] {
  return mutationCache.getAll().filter((mutation: any) => 
    mutation?.state?.status === 'loading' || 
    (mutation?.state?.status === 'error' && mutation?.state?.isPaused)
  );
}
  ```

  *Exports: `markItemAsOffline`*
  ```ts
export function markItemAsOffline<T>(item: T): T & { isOffline: boolean } {
  return {
    ...item,
    isOffline: true,
  };
}
  ```

  *Exports: `markItemAsSynced`*
  ```ts
export function markItemAsSynced<T extends { isOffline?: boolean }>(item: T): T {
  const result = { ...item };
  delete result.isOffline;
  return result;
}
  ```

  *Exports: `reactQueryPersistOptions`*
  ```ts
const reactQueryPersistOptions: Omit<PersistQueryClientOptions, 'queryClient'> = {
  persister: asyncStoragePersister,
  // Add custom serialization/deserialization if needed
  // We want to persist mutations especially for offline support
  buster: 'v1',
  dehydrateOptions: {
    shouldDehydrateMutation: () => true,
  },
};
  ```

  *Exports: `useResumeNetworkMutations`*
  ```ts
export function useResumeNetworkMutations(queryClient: QueryClient) {
  const netInfo = useNetInfo();
  const previousNetworkState = useRef(netInfo.isConnected);
  
  // Update React Query's online status manager
  useEffect(() => {
    onlineManager.setOnline(netInfo.isConnected === true);
  }, [netInfo.isConnected]);
  
  useEffect(() => {
    const isConnectedNow = netInfo.isConnected === true;
    const wasConnected = previousNetworkState.current === true;
    
    // If we just reconnected to the network
    if (isConnectedNow && !wasConnected) {
      console.log('Internet connection restored, resuming paused mutations');
      
      // Resume any paused mutations
      queryClient.resumePausedMutations().then(() => {
        // After resuming mutations, invalidate queries to refresh data
        queryClient.invalidateQueries();
      }).catch((error: Error) => {
        console.error('Error resuming mutations:', error.message);
      });
    }
    
    // Update our ref
    previousNetworkState.current = isConnectedNow;
  }, [netInfo.isConnected, queryClient]);
}
  ```

- **utils/offline-sync.ts**

  *Exports: `getPendingItems`*
  ```ts
export async function getPendingItems(type: string): Promise<PendingItem[]> {
  try {
    const itemsStr = await AsyncStorage.getItem(PENDING_ITEMS_KEY);
    if (!itemsStr) return [];
    
    const items: PendingItem[] = JSON.parse(itemsStr);
    return items.filter(item => item.type === type);
  } catch (error) {
    console.error('Error getting pending items:', error);
    return [];
  }
}
  ```

  *Exports: `PendingItem`*
  ```ts
export interface PendingItem {
  id: string;
  type: string;
  data: any;
  createdAt: number;
  isNotSynced: boolean;
}
  ```

  *Exports: `saveOfflineMutation`*
  ```ts
export async function saveOfflineMutation(
  type: 'create' | 'update' | 'delete',
  entity: string,
  data: any
): Promise<string> {
  try {
    // Generate a temporary ID for new items
    const id = `temp-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
    
    // Create mutation object
    const mutation: OfflineMutation = {
      id,
      type,
      entity,
      data,
      timestamp: Date.now(),
    };
    
    // Get existing mutations
    const existingMutationsStr = await AsyncStorage.getItem(OFFLINE_MUTATIONS_KEY);
    const existingMutations: OfflineMutation[] = existingMutationsStr 
      ? JSON.parse(existingMutationsStr) 
      : [];
    
    // Add new mutation
    existingMutations.push(mutation);
    
    // Save mutations back to storage
    await AsyncStorage.setItem(OFFLINE_MUTATIONS_KEY, JSON.stringify(existingMutations));
    
    // Also add to pending items for UI
    if (type === 'create' || type === 'update') {
      await addToPendingItems(id, entity, data);
    }
    
    return id;
  } catch (error) {
    console.error('Error saving offline mutation:', error);
    throw error;
  }
}
  ```

  *Exports: `setupBackgroundSync`*
  ```ts
export function setupBackgroundSync(): () => void {
  // Subscribe to network changes
  const unsubscribe = NetInfo.addEventListener(state => {
    // When we go from offline to online, sync mutations
    if (state.isConnected && state.isInternetReachable !== false) {
      syncOfflineMutations()
        .then(success => {
          console.log('Background sync completed:', success ? 'success' : 'with errors');
        })
        .catch(error => {
          console.error('Background sync failed:', error);
        });
    }
  });
  
  return unsubscribe;
}
  ```

  *Exports: `syncOfflineMutations`*
  ```ts
export async function syncOfflineMutations(): Promise<boolean> {
  try {
    // Check if we're online
    const netInfo = await NetInfo.fetch();
    if (!netInfo.isConnected || netInfo.isInternetReachable === false) {
      console.log('Not connected to the internet, skipping sync');
      return false;
    }
    
    // Get all pending mutations
    const mutationsStr = await AsyncStorage.getItem(OFFLINE_MUTATIONS_KEY);
    if (!mutationsStr) return true; // Nothing to sync
    
    const mutations: OfflineMutation[] = JSON.parse(mutationsStr);
    if (!mutations.length) return true; // Nothing to sync
    
    console.log(`Syncing ${mutations.length} offline mutations...`);
    
    // Process each mutation in order
    const results = await Promise.allSettled(
      mutations.map(async (mutation) => {
        try {
          switch (mutation.type) {
            case 'create':
              return await processMutation('create', mutation);
            case 'update':
              return await processMutation('update', mutation);
            case 'delete':
              return await processMutation('delete', mutation);
            default:
              console.error('Unknown mutation type:', mutation.type);
              return false;
          }
        } catch (error) {
          console.error('Error processing mutation:', error);
          return false;
        }
      })
    );
    
    // Check results
    const allSucceeded = results.every(
      result => result.status === 'fulfilled' && result.value === true
    );
    
    if (allSucceeded) {
      // Clear pending mutations if all succeeded
      await AsyncStorage.removeItem(OFFLINE_MUTATIONS_KEY);
      await AsyncStorage.removeItem(PENDING_ITEMS_KEY);
      
      // Invalidate queries to refresh data
      queryClient.invalidateQueries();
      
      return true;
    } else {
      // Some mutations failed, remove the successful ones
      const successfulMutationIndexes = results.map((result, index) => 
        result.status === 'fulfilled' && result.value === true ? index : -1
      ).filter(index => index !== -1);
      
      const remainingMutations = mutations.filter(
        (_, index) => !successfulMutationIndexes.includes(index)
      );
      
      // Save remaining mutations
      await AsyncStorage.setItem(
        OFFLINE_MUTATIONS_KEY, 
        JSON.stringify(remainingMutations)
      );
      
      // Refresh query data
      queryClient.invalidateQueries();
      
      return false;
    }
  } catch (error) {
    console.error('Error syncing offline mutations:', error);
    return false;
  }
}
  ```

- **utils/query-client.ts**

  *Exports: `queryClient`*
  ```ts
const queryClient = new QueryClient();
  ```

- **utils/settings.ts**

  *Exports: `APP_SETTINGS_KEY`*
  ```ts
const APP_SETTINGS_KEY = 'aether_app_settings';
  ```

  *Exports: `AppSettings`*
  ```ts
export type AppSettings = typeof DEFAULT_SETTINGS;
  ```

  *Exports: `getAppVersion`*
  ```ts
export function getAppVersion(): string {
  // In a real app, you would use expo-constants to get the app version
  // import Constants from 'expo-constants';
  // return Constants.expoConfig.version;
  return '1.0.0';
}
  ```

  *Exports: `getPlatformInfo`*
  ```ts
export function getPlatformInfo(): string {
  return `${Platform.OS} ${Platform.Version}`;
}
  ```

  *Exports: `getSettings`*
  ```ts
export async function getSettings(): Promise<AppSettings> {
  try {
    const storedSettings = await SecureStore.getItemAsync(APP_SETTINGS_KEY);
    if (!storedSettings) return DEFAULT_SETTINGS;
    
    return { ...DEFAULT_SETTINGS, ...JSON.parse(storedSettings) };
  } catch (error) {
    console.error('Error getting settings:', error);
    return DEFAULT_SETTINGS;
  }
}
  ```

  *Exports: `saveSettings`*
  ```ts
export async function saveSettings(settings: Partial<AppSettings>): Promise<void> {
  try {
    const currentSettings = await getSettings();
    const newSettings = { ...currentSettings, ...settings };
    
    await SecureStore.setItemAsync(
      APP_SETTINGS_KEY, 
      JSON.stringify(newSettings)
    );
  } catch (error) {
    console.error('Error saving settings:', error);
  }
}
  ```

  *Exports: `updateSetting`*
  ```ts
export async function updateSetting<K extends keyof AppSettings>(
  key: K, 
  value: AppSettings[K]
): Promise<void> {
  await saveSettings({ [key]: value } as Partial<AppSettings>);
}
  ```

- **utils/supabase.ts**

  *Exports: `getCurrentUser`*
  ```ts
const getCurrentUser = async () => {
  const { data, error } = await supabase.auth.getUser();
  if (error) {
    console.error('Error getting user:', error.message);
    return null;
  }
  return data.user;
};
  ```

  *Exports: `isAuthenticated`*
  ```ts
const isAuthenticated = async () => {
  const { data, error } = await supabase.auth.getSession();
  return !!data.session;
};
  ```

  *Exports: `supabase`*
  ```ts
const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: ExpoSecureStoreAdapter,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
});
  ```

- **utils/trpc.ts**

  *Exports: `RouterInputs`*
  ```ts
export type RouterInputs = TypedRouterInputs;
  ```

  *Exports: `RouterOutputs`*
  ```ts
export type RouterOutputs = TypedRouterOutputs;
  ```

  *Exports: `trpc`*
  ```ts
const trpc = createTRPCReact<AppRouter>();
  ```

  ```

- **code-atlas_2025-04-30-10-24-57.md** (298.6 KB, 10343 lines) *(No explicit exports)*

  ```md
# Aether Code Atlas  
_generated 2025-04-30-10-24-57_

## Contents
- [Definitions Table](#definitions-table)
- [Dependency Graph](#dependency-graph)
- [External Dependencies](#external-dependencies)
- [TODOs / FIXMEs](#todos-/-fixmes)
- [Buckets](#buckets)

## Definitions Table
| File | Export Name | Type |
|---|---|---|
| __tests__/server/test-helpers.ts | `createInnerTRPCContext` | function |
| __tests__/server/test-helpers.ts | `createTestContext` | function |
| __tests__/server/test-helpers.ts | `MockablePostgrestResponse` | type |
| __tests__/server/test-helpers.ts | `MockableQueryBuilder` | interface |
| __tests__/server/test-helpers.ts | `MockableSupabaseClient` | interface |
| __tests__/server/test-helpers.ts | `MockableTableOperations` | interface |
| __tests__/server/test-helpers.ts | `mockDeep` | re-export |
| __tests__/server/test-helpers.ts | `mockSupabaseAdmin` | unknown |
| __tests__/server/test-helpers.ts | `resetSupabaseMocks` | function |
| __tests__/server/test-helpers.ts | `TableName` | type |
| __tests__/test-utils.tsx | `render` | re-export |
| app/(auth)/_layout.tsx | `default` | function |
| app/(auth)/forgot-password.tsx | `default` | function |
| app/(auth)/login.tsx | `default` | function |
| app/(auth)/register.tsx | `default` | function |
| app/(tabs)/_layout.tsx | `default` | function |
| app/(tabs)/compass/index.tsx | `default` | function |
| app/(tabs)/home/index.tsx | `default` | function |
| app/(tabs)/planner/_layout.tsx | `default` | function |
| app/(tabs)/planner/add-goal.tsx | `default` | function |
| app/(tabs)/planner/add-habit.tsx | `default` | function |
| app/(tabs)/planner/add-task.tsx | `default` | function |
| app/(tabs)/planner/goal/[id].tsx | `default` | function |
| app/(tabs)/planner/habit/[id].tsx | `default` | function |
| app/(tabs)/planner/index.tsx | `default` | function |
| app/(tabs)/rewards/index.tsx | `default` | function |
| app/(tabs)/settings/_layout.tsx | `default` | function |
| app/(tabs)/settings/about.tsx | `default` | function |
| app/(tabs)/settings/help.tsx | `default` | function |
| app/(tabs)/settings/index.tsx | `default` | function |
| app/(tabs)/settings/notifications.tsx | `default` | function |
| app/(tabs)/settings/privacy.tsx | `default` | function |
| app/(tabs)/settings/profile.tsx | `default` | function |
| app/(tabs)/settings/security.tsx | `default` | function |
| app/_layout.tsx | `default` | function |
| app/components/SectionCard.tsx | `SectionCard` | component |
| app/components/SwipeableRow.tsx | `SwipeableRow` | component |
| app/components/TaskRow.tsx | `TaskRow` | component |
| app/compose.tsx | `default` | function |
| app/index.tsx | `default` | function |
| app/lib/useDashboardQuery.ts | `DashboardData` | type |
| app/lib/useDashboardQuery.ts | `useDashboardQuery` | hook |
| app/lib/useToggleTaskStatus.ts | `useToggleTaskStatus` | hook |
| app/planner/add-habit.tsx | `default` | function |
| app/planner/index.tsx | `default` | unknown |
| app/settings/index.tsx | `default` | unknown |
| app/states/[id].tsx | `default` | function |
| app/utils/api-types.ts | `RouterInputs` | type |
| app/utils/api-types.ts | `RouterOutputs` | type |
| app/values/[id].tsx | `default` | function |
| components/EmptyOrSkeleton.tsx | `default` | function |
| components/EmptyOrSkeleton.tsx | `EmptyOrSkeletonProps` | interface |
| components/EmptyOrSkeleton.tsx | `EmptyStateProps` | interface |
| components/aether/ProgressRing.tsx | `default` | function |
| components/auth/FloatingInput.tsx | `default` | function |
| components/auth/FloatingInput.tsx | `FloatingInputProps` | interface |
| components/compass/PrincipleCard.tsx | `PrincipleCard` | function |
| components/compass/PrinciplesTab.tsx | `default` | function |
| components/compass/StateDefinitionCard.tsx | `StateDefinitionCard` | function |
| components/dashboard/DailyProgressBanner.tsx | `default` | function |
| components/dashboard/DashboardSection.tsx | `default` | function |
| components/dashboard/GoalSummaryCard.tsx | `default` | function |
| components/dashboard/HabitCheckItem.tsx | `default` | function |
| components/dashboard/StateIndicator.tsx | `default` | function |
| components/dashboard/TaskItem.tsx | `default` | function |
| components/lists/GoalList.tsx | `GoalCard` | function |
| components/lists/GoalList.tsx | `GoalList` | function |
| components/lists/HabitList.tsx | `HabitCard` | function |
| components/lists/HabitList.tsx | `HabitList` | function |
| components/lists/TaskList.tsx | `TaskCard` | function |
| components/lists/TaskList.tsx | `TaskList` | function |
| components/lists/index.ts | `GoalCard` | re-export |
| components/lists/index.ts | `GoalList` | re-export |
| components/lists/index.ts | `HabitCard` | re-export |
| components/lists/index.ts | `HabitList` | re-export |
| components/lists/index.ts | `TaskCard` | re-export |
| components/lists/index.ts | `TaskList` | re-export |
| components/planner/GoalsList.tsx | `default` | function |
| components/planner/GoalsList.tsx | `Goal` | interface |
| components/planner/GoalsList.tsx | `GoalsListProps` | interface |
| components/planner/HabitTracker.tsx | `HabitTracker` | function |
| components/planner/HabitsList.tsx | `default` | function |
| components/planner/HabitsList.tsx | `Habit` | interface |
| components/planner/HabitsList.tsx | `HabitsListProps` | interface |
| components/planner/StreakCalendar.tsx | `default` | function |
| components/planner/StreakCalendar.tsx | `StreakCalendarProps` | interface |
| components/rewards/ConfettiBurst.tsx | `default` | function |
| components/settings/NotificationRow.tsx | `default` | function |
| components/settings/NotificationRow.tsx | `NotificationRowProps` | interface |
| components/settings/ThemePreview.tsx | `default` | function |
| components/settings/ThemePreview.tsx | `ThemePreviewProps` | interface |
| components/ui/Container.tsx | `Container` | component |
| components/ui/Container.tsx | `default` | unknown |
| components/ui/EmptyOrSkeleton.tsx | `EmptyOrSkeleton` | component |
| components/ui/EmptyOrSkeleton.tsx | `EmptyOrSkeletonProps` | interface |
| components/ui/ErrorBanner.tsx | `ErrorBanner` | function |
| components/ui/ErrorBanner.tsx | `SectionError` | function |
| components/ui/InteractiveCard.tsx | `default` | unknown |
| components/ui/Section.tsx | `default` | unknown |
| components/ui/Skeleton.tsx | `Skeleton` | function |
| components/ui/Skeleton.tsx | `SkeletonAvatar` | function |
| components/ui/Skeleton.tsx | `SkeletonCard` | function |
| components/ui/Skeleton.tsx | `SkeletonCircle` | function |
| components/ui/Skeleton.tsx | `SkeletonProfile` | function |
| components/ui/Skeleton.tsx | `SkeletonRow` | function |
| components/ui/SwipeableRow.tsx | `default` | function |
| components/ui/primitives/AetherCard.tsx | `AetherCard` | function |
| components/ui/primitives/AetherListItem.tsx | `AetherListItem` | function |
| components/ui/primitives/AetherListItem.tsx | `AetherListItemProps` | interface |
| components/ui/primitives/SectionHeader.tsx | `SectionHeader` | function |
| components/ui/primitives/SectionHeader.tsx | `SectionHeaderProps` | interface |
| components/ui/primitives/index.ts | `AetherCard` | re-export |
| components/ui/primitives/index.ts | `AetherListItem` | re-export |
| components/ui/primitives/index.ts | `AetherListItemProps` | re-export |
| components/ui/primitives/index.ts | `SectionHeader` | re-export |
| components/ui/primitives/index.ts | `SectionHeaderProps` | re-export |
| constants/Colors.ts | `Colors` | component |
| constants/motion.ts | `componentAnimations` | unknown |
| constants/motion.ts | `durations` | unknown |
| constants/motion.ts | `easings` | unknown |
| constants/motion.ts | `presets` | unknown |
| debug/toast-test.tsx | `default` | function |
| design-system/Animations.ts | `fadeInUp` | unknown |
| design-system/Animations.ts | `korokReveal` | unknown |
| design-system/Animations.ts | `sheikahGlow` | unknown |
| design-system/Animations.ts | `slideOutLeft` | unknown |
| design-system/Animations.ts | `taskComplete` | unknown |
| design-system/Primitives.tsx | `Button` | component |
| design-system/Primitives.tsx | `Center` | component |
| design-system/Primitives.tsx | `gs` | re-export |
| design-system/Primitives.tsx | `HStack` | component |
| design-system/Primitives.tsx | `Pressable` | component |
| design-system/Primitives.tsx | `ScrollView` | component |
| design-system/Primitives.tsx | `Stack` | component |
| design-system/Primitives.tsx | `Text` | component |
| design-system/Primitives.tsx | `useColorMode` | hook |
| design-system/Primitives.tsx | `useColorModeValue` | function |
| design-system/Primitives.tsx | `useToast` | hook |
| design-system/Primitives.tsx | `VStack` | component |
| design-system/theme.glue.ts | `glueTheme` | unknown |
| design-system/tokens.ts | `colors` | unknown |
| design-system/tokens.ts | `default` | unknown |
| design-system/tokens.ts | `fonts` | unknown |
| design-system/tokens.ts | `radii` | unknown |
| design-system/tokens.ts | `sizes` | unknown |
| design-system/tokens.ts | `space` | unknown |
| hooks/useColorScheme.ts | `useColorScheme` | re-export |
| hooks/useColorScheme.web.ts | `useColorScheme` | function |
| hooks/useOfflineSync.ts | `useOfflineSync` | function |
| hooks/useSkeleton.ts | `SkeletonOptions` | interface |
| hooks/useSkeleton.ts | `useSkeleton` | function |
| hooks/useThemeColor.ts | `useThemeColor` | function |
| modals/compose.tsx | `default` | function |
| providers/AppProvider.tsx | `AppProvider` | function |
| providers/ConfettiProvider.tsx | `ConfettiProvider` | function |
| providers/ConfettiProvider.tsx | `useConfetti` | hook |
| providers/SupabaseProvider.tsx | `SupabaseContext` | component |
| providers/SupabaseProvider.tsx | `SupabaseProvider` | function |
| providers/SupabaseProvider.tsx | `useSupabase` | hook |
| providers/TRPCProvider.tsx | `trpc` | unknown |
| providers/TRPCProvider.tsx | `TRPCProvider` | function |
| server/src/context.ts | `Context` | interface |
| server/src/context.ts | `createContext` | function |
| server/src/context.ts | `supabaseAdmin` | unknown |
| server/src/router.ts | `appRouter` | unknown |
| server/src/router.ts | `AppRouter` | type |
| server/src/router.ts | `protectedProcedure` | unknown |
| server/src/router.ts | `publicProcedure` | unknown |
| server/src/router.ts | `router` | unknown |
| server/src/routers/dashboardRouter.ts | `dashboardRouter` | unknown |
| server/src/routers/goalProgressNoteRouter.ts | `goalProgressNoteRouter` | unknown |
| server/src/routers/goalRouter.ts | `goalRouter` | unknown |
| server/src/routers/habitRouter.ts | `habitRouter` | unknown |
| server/src/routers/principleRouter.ts | `principleRouter` | unknown |
| server/src/routers/reminderRouter.ts | `reminderRouter` | unknown |
| server/src/routers/rewardsRouter.ts | `rewardsRouter` | unknown |
| server/src/routers/taskRouter.ts | `taskRouter` | unknown |
| server/src/routers/trackedStateRouter.ts | `trackedStateRouter` | unknown |
| server/src/routers/userRouter.ts | `userRouter` | unknown |
| server/src/routers/valueRouter.ts | `valueRouter` | unknown |
| server/src/types/index.ts | `Badge` | interface |
| server/src/types/index.ts | `BadgeId` | type |
| server/src/types/index.ts | `Goal` | interface |
| server/src/types/index.ts | `GoalId` | type |
| server/src/types/index.ts | `Habit` | interface |
| server/src/types/index.ts | `HabitId` | type |
| server/src/types/index.ts | `KeyResult` | interface |
| server/src/types/index.ts | `Principle` | interface |
| server/src/types/index.ts | `Task` | interface |
| server/src/types/index.ts | `TaskId` | type |
| server/src/types/index.ts | `TrackedStateDef` | interface |
| server/src/types/index.ts | `Value` | interface |
| server/src/types/index.ts | `ValueId` | type |
| server/src/types/trpc-types.ts | `awardBadgeInput` | unknown |
| server/src/types/trpc-types.ts | `BadgeDefinition` | component |
| server/src/types/trpc-types.ts | `BadgeDefinition` | type |
| server/src/types/trpc-types.ts | `claimLootInput` | unknown |
| server/src/types/trpc-types.ts | `createGoalInput` | unknown |
| server/src/types/trpc-types.ts | `createGoalProgressNoteInput` | unknown |
| server/src/types/trpc-types.ts | `createHabitEntryInput` | unknown |
| server/src/types/trpc-types.ts | `createHabitInput` | unknown |
| server/src/types/trpc-types.ts | `createPrincipleInput` | unknown |
| server/src/types/trpc-types.ts | `createReminderInput` | unknown |
| server/src/types/trpc-types.ts | `CreateStateEntryInput` | component |
| server/src/types/trpc-types.ts | `createTaskInput` | unknown |
| server/src/types/trpc-types.ts | `createTrackedStateDefInput` | unknown |
| server/src/types/trpc-types.ts | `createValueInput` | unknown |
| server/src/types/trpc-types.ts | `DeleteGoalProgressNoteInput` | component |
| server/src/types/trpc-types.ts | `DeleteReminderInput` | component |
| server/src/types/trpc-types.ts | `DeleteStateEntryInput` | component |
| server/src/types/trpc-types.ts | `DeleteTrackedStateDefInput` | component |
| server/src/types/trpc-types.ts | `GetGoalProgressNotesInput` | component |
| server/src/types/trpc-types.ts | `GetRemindersForEntityInput` | component |
| server/src/types/trpc-types.ts | `GetStateEntriesInput` | component |
| server/src/types/trpc-types.ts | `GetTrackedStateDefByIdInput` | component |
| server/src/types/trpc-types.ts | `Goal` | component |
| server/src/types/trpc-types.ts | `Goal` | type |
| server/src/types/trpc-types.ts | `GoalProgressNote` | component |
| server/src/types/trpc-types.ts | `GoalProgressNote` | type |
| server/src/types/trpc-types.ts | `greetingInput` | unknown |
| server/src/types/trpc-types.ts | `greetingOutput` | unknown |
| server/src/types/trpc-types.ts | `Habit` | component |
| server/src/types/trpc-types.ts | `Habit` | type |
| server/src/types/trpc-types.ts | `HabitEntry` | component |
| server/src/types/trpc-types.ts | `HabitEntry` | type |
| server/src/types/trpc-types.ts | `HabitFrequencyPeriodEnum` | component |
| server/src/types/trpc-types.ts | `HabitTypeEnum` | component |
| server/src/types/trpc-types.ts | `NotificationPrefs` | component |
| server/src/types/trpc-types.ts | `PointTransaction` | component |
| server/src/types/trpc-types.ts | `PointTransaction` | type |
| server/src/types/trpc-types.ts | `Principle` | component |
| server/src/types/trpc-types.ts | `Principle` | type |
| server/src/types/trpc-types.ts | `Reminder` | component |
| server/src/types/trpc-types.ts | `Reminder` | type |
| server/src/types/trpc-types.ts | `Reward` | component |
| server/src/types/trpc-types.ts | `Reward` | type |
| server/src/types/trpc-types.ts | `RewardTypeEnum` | component |
| server/src/types/trpc-types.ts | `RouterInputs` | type |
| server/src/types/trpc-types.ts | `RouterOutputs` | type |
| server/src/types/trpc-types.ts | `StateEntry` | component |
| server/src/types/trpc-types.ts | `StateEntry` | type |
| server/src/types/trpc-types.ts | `Task` | component |
| server/src/types/trpc-types.ts | `Task` | type |
| server/src/types/trpc-types.ts | `TaskPriorityEnum` | component |
| server/src/types/trpc-types.ts | `TaskStatusEnum` | component |
| server/src/types/trpc-types.ts | `TrackedStateDef` | component |
| server/src/types/trpc-types.ts | `TrackedStateDef` | type |
| server/src/types/trpc-types.ts | `UiPrefs` | component |
| server/src/types/trpc-types.ts | `updateGoalInput` | unknown |
| server/src/types/trpc-types.ts | `updateGoalProgressNoteInput` | unknown |
| server/src/types/trpc-types.ts | `updateHabitEntryInput` | unknown |
| server/src/types/trpc-types.ts | `updateHabitInput` | unknown |
| server/src/types/trpc-types.ts | `updatePrincipleInput` | unknown |
| server/src/types/trpc-types.ts | `updateProfileInput` | unknown |
| server/src/types/trpc-types.ts | `updateReminderInput` | unknown |
| server/src/types/trpc-types.ts | `updateSettingsInput` | unknown |
| server/src/types/trpc-types.ts | `updateStateEntryInput` | unknown |
| server/src/types/trpc-types.ts | `updateTaskInput` | unknown |
| server/src/types/trpc-types.ts | `updateTaskStatusInput` | unknown |
| server/src/types/trpc-types.ts | `updateTrackedStateDefInput` | unknown |
| server/src/types/trpc-types.ts | `updateValueInput` | unknown |
| server/src/types/trpc-types.ts | `UserBadge` | component |
| server/src/types/trpc-types.ts | `UserBadge` | type |
| server/src/types/trpc-types.ts | `UserProfile` | component |
| server/src/types/trpc-types.ts | `UserProfile` | type |
| server/src/types/trpc-types.ts | `UserReward` | component |
| server/src/types/trpc-types.ts | `UserReward` | type |
| server/src/types/trpc-types.ts | `UserSettings` | component |
| server/src/types/trpc-types.ts | `UserSettings` | type |
| server/src/types/trpc-types.ts | `Value` | component |
| server/src/types/trpc-types.ts | `Value` | type |
| stores/uiStore.ts | `useUiStore` | hook |
| tamagui.config.ts | `default` | unknown |
| types/database.types.ts | `CompositeTypes` | type |
| types/database.types.ts | `Constants` | component |
| types/database.types.ts | `Database` | type |
| types/database.types.ts | `Enums` | type |
| types/database.types.ts | `Json` | type |
| types/database.types.ts | `Tables` | type |
| types/database.types.ts | `TablesInsert` | type |
| types/database.types.ts | `TablesUpdate` | type |
| utils/api-types.ts | `RouterInputs` | type |
| utils/api-types.ts | `RouterOutputs` | type |
| utils/auth.ts | `getUserProfile` | function |
| utils/auth.ts | `logout` | function |
| utils/colors.ts | `palette` | unknown |
| utils/colors.ts | `semanticTokens` | unknown |
| utils/colors.ts | `useColors` | function |
| utils/colors.ts | `withOpacity` | function |
| utils/generated-hooks.ts | `useDashboard` | hook |
| utils/generated-hooks.ts | `useGoal` | hook |
| utils/generated-hooks.ts | `useGoalProgressNote` | hook |
| utils/generated-hooks.ts | `useHabit` | hook |
| utils/generated-hooks.ts | `usePrinciple` | hook |
| utils/generated-hooks.ts | `useReminder` | hook |
| utils/generated-hooks.ts | `useRewards` | hook |
| utils/generated-hooks.ts | `useState` | hook |
| utils/generated-hooks.ts | `useTask` | hook |
| utils/generated-hooks.ts | `useUser` | hook |
| utils/generated-hooks.ts | `useValue` | hook |
| utils/haptics.ts | `haptics` | unknown |
| utils/mock-api.ts | `appRouter` | unknown |
| utils/mock-api.ts | `AppRouter` | type |
| utils/nats-client.ts | `addSubjectHandler` | function |
| utils/nats-client.ts | `closeNatsConnection` | function |
| utils/nats-client.ts | `getNatsConnection` | function |
| utils/nats-client.ts | `initNatsClient` | function |
| utils/nats-client.ts | `subscribeWithCache` | function |
| utils/offline-mutations.ts | `asyncStoragePersister` | unknown |
| utils/offline-mutations.ts | `configureQueryClientForOffline` | function |
| utils/offline-mutations.ts | `getPendingMutations` | function |
| utils/offline-mutations.ts | `markItemAsOffline` | function |
| utils/offline-mutations.ts | `markItemAsSynced` | function |
| utils/offline-mutations.ts | `reactQueryPersistOptions` | unknown |
| utils/offline-mutations.ts | `useResumeNetworkMutations` | function |
| utils/offline-sync.ts | `getPendingItems` | function |
| utils/offline-sync.ts | `PendingItem` | interface |
| utils/offline-sync.ts | `saveOfflineMutation` | function |
| utils/offline-sync.ts | `setupBackgroundSync` | function |
| utils/offline-sync.ts | `syncOfflineMutations` | function |
| utils/query-client.ts | `queryClient` | unknown |
| utils/settings.ts | `APP_SETTINGS_KEY` | component |
| utils/settings.ts | `AppSettings` | type |
| utils/settings.ts | `getAppVersion` | function |
| utils/settings.ts | `getPlatformInfo` | function |
| utils/settings.ts | `getSettings` | function |
| utils/settings.ts | `saveSettings` | function |
| utils/settings.ts | `updateSetting` | function |
| utils/supabase.ts | `getCurrentUser` | unknown |
| utils/supabase.ts | `isAuthenticated` | unknown |
| utils/supabase.ts | `supabase` | unknown |
| utils/trpc.ts | `RouterInputs` | type |
| utils/trpc.ts | `RouterOutputs` | type |
| utils/trpc.ts | `trpc` | unknown |

## Dependency Graph

*Note: This graph shows dependencies between local files only.*
```mermaid
graph TD;
  __tests___components_ui_primitives_AetherCard_test_tsx["__tests__/components/ui/primitives/AetherCard.test.tsx"] --> __tests___test_utils_tsx["__tests__/test-utils.tsx"];
  __tests___server_routers_dashboardRouter_getWeeklyProgress_test_ts["__tests__/server/routers/dashboardRouter.getWeeklyProgress.test.ts"] --> __tests___server_test_helpers_ts["__tests__/server/test-helpers.ts"];
  __tests___server_routers_dashboardRouter_getWeeklyProgress_test_ts["__tests__/server/routers/dashboardRouter.getWeeklyProgress.test.ts"] --> server_src_router_ts["server/src/router.ts"];
  __tests___server_routers_dashboardRouter_test_ts["__tests__/server/routers/dashboardRouter.test.ts"] --> __tests___server_test_helpers_ts["__tests__/server/test-helpers.ts"];
  __tests___server_routers_dashboardRouter_test_ts["__tests__/server/routers/dashboardRouter.test.ts"] --> server_src_router_ts["server/src/router.ts"];
  __tests___server_routers_habitRouter_test_ts["__tests__/server/routers/habitRouter.test.ts"] --> __tests___server_test_helpers_ts["__tests__/server/test-helpers.ts"];
  __tests___server_routers_habitRouter_test_ts["__tests__/server/routers/habitRouter.test.ts"] --> server_src_router_ts["server/src/router.ts"];
  __tests___server_routers_habitRouter_test_ts["__tests__/server/routers/habitRouter.test.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  __tests___server_routers_taskRouter_toggleTask_test_ts["__tests__/server/routers/taskRouter.toggleTask.test.ts"] --> __tests___server_test_helpers_ts["__tests__/server/test-helpers.ts"];
  __tests___server_routers_taskRouter_toggleTask_test_ts["__tests__/server/routers/taskRouter.toggleTask.test.ts"] --> server_src_router_ts["server/src/router.ts"];
  __tests___test_utils_tsx["__tests__/test-utils.tsx"] --> tamagui_config_ts["tamagui.config.ts"];
  app_utils_api_types_ts["app/utils/api-types.ts"] --> server_src_router_ts["server/src/router.ts"];
  components_compass_PrinciplesTab_tsx["components/compass/PrinciplesTab.tsx"] --> components_compass_PrincipleCard_tsx["components/compass/PrincipleCard.tsx"];
  components_planner_HabitTracker_tsx["components/planner/HabitTracker.tsx"] --> components_planner_StreakCalendar_tsx["components/planner/StreakCalendar.tsx"];
  components_ui_EmptyOrSkeleton_tsx["components/ui/EmptyOrSkeleton.tsx"] --> components_ui_Skeleton_tsx["components/ui/Skeleton.tsx"];
  components_ui_EmptyOrSkeleton_tsx["components/ui/EmptyOrSkeleton.tsx"] --> components_ui_ErrorBanner_tsx["components/ui/ErrorBanner.tsx"];
  design_system_theme_glue_ts["design-system/theme.glue.ts"] --> design_system_tokens_ts["design-system/tokens.ts"];
  index_js["index.js"] --> tamagui_config_ts["tamagui.config.ts"];
  providers_AppProvider_tsx["providers/AppProvider.tsx"] --> tamagui_config_ts["tamagui.config.ts"];
  server_src_index_ts["server/src/index.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_index_ts["server/src/index.ts"] --> server_src_context_ts["server/src/context.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_context_ts["server/src/context.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_dashboardRouter_ts["server/src/routers/dashboardRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_valueRouter_ts["server/src/routers/valueRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_principleRouter_ts["server/src/routers/principleRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_goalRouter_ts["server/src/routers/goalRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_taskRouter_ts["server/src/routers/taskRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_habitRouter_ts["server/src/routers/habitRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_trackedStateRouter_ts["server/src/routers/trackedStateRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_userRouter_ts["server/src/routers/userRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_rewardsRouter_ts["server/src/routers/rewardsRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_reminderRouter_ts["server/src/routers/reminderRouter.ts"];
  server_src_router_ts["server/src/router.ts"] --> server_src_routers_goalProgressNoteRouter_ts["server/src/routers/goalProgressNoteRouter.ts"];
  server_src_routers_dashboardRouter_ts["server/src/routers/dashboardRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_goalProgressNoteRouter_ts["server/src/routers/goalProgressNoteRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_goalProgressNoteRouter_ts["server/src/routers/goalProgressNoteRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_routers_goalRouter_ts["server/src/routers/goalRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_goalRouter_ts["server/src/routers/goalRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_routers_habitRouter_ts["server/src/routers/habitRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_habitRouter_ts["server/src/routers/habitRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_routers_principleRouter_ts["server/src/routers/principleRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_principleRouter_ts["server/src/routers/principleRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_routers_reminderRouter_ts["server/src/routers/reminderRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_reminderRouter_ts["server/src/routers/reminderRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_routers_rewardsRouter_ts["server/src/routers/rewardsRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_rewardsRouter_ts["server/src/routers/rewardsRouter.ts"] --> server_src_context_ts["server/src/context.ts"];
  server_src_routers_rewardsRouter_ts["server/src/routers/rewardsRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_routers_taskRouter_ts["server/src/routers/taskRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_taskRouter_ts["server/src/routers/taskRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_routers_trackedStateRouter_ts["server/src/routers/trackedStateRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_trackedStateRouter_ts["server/src/routers/trackedStateRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_routers_userRouter_ts["server/src/routers/userRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_valueRouter_ts["server/src/routers/valueRouter.ts"] --> server_src_router_ts["server/src/router.ts"];
  server_src_routers_valueRouter_ts["server/src/routers/valueRouter.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"] --> server_src_router_ts["server/src/router.ts"];
  utils_api_types_ts["utils/api-types.ts"] --> server_src_router_ts["server/src/router.ts"];
  utils_auth_ts["utils/auth.ts"] --> utils_supabase_ts["utils/supabase.ts"];
  utils_generated_hooks_ts["utils/generated-hooks.ts"] --> utils_trpc_ts["utils/trpc.ts"];
  utils_generated_hooks_ts["utils/generated-hooks.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
  utils_offline_sync_ts["utils/offline-sync.ts"] --> utils_query_client_ts["utils/query-client.ts"];
  utils_offline_sync_ts["utils/offline-sync.ts"] --> utils_supabase_ts["utils/supabase.ts"];
  utils_trpc_ts["utils/trpc.ts"] --> server_src_router_ts["server/src/router.ts"];
  utils_trpc_ts["utils/trpc.ts"] --> server_src_types_trpc_types_ts["server/src/types/trpc-types.ts"];
```

## External Dependencies
- @/app/_layout
- @/app/components/SectionCard
- @/app/components/SwipeableRow
- @/app/components/TaskRow
- @/app/lib/useDashboardQuery
- @/app/lib/useToggleTaskStatus
- @/components/EmptyOrSkeleton
- @/components/aether/ProgressRing
- @/components/compass/PrincipleCard
- @/components/compass/PrinciplesTab
- @/components/compass/StateDefinitionCard
- @/components/dashboard/HabitCheckItem
- @/components/lists/GoalList
- @/components/lists/HabitList
- @/components/lists/TaskList
- @/components/ui/EmptyOrSkeleton
- @/components/ui/ErrorBanner
- @/components/ui/Skeleton
- @/components/ui/iOS/Button
- @/components/ui/nativewind-setup
- @/components/ui/primitives
- @/components/ui/primitives/AetherCard
- @/components/ui/primitives/AetherListItem
- @/constants/Colors
- @/constants/motion
- @/design-system/Primitives
- @/design-system/theme.glue
- @/global.css
- @/hooks/useColorScheme
- @/hooks/useSkeleton
- @/providers/SupabaseProvider
- @/providers/TRPCProvider
- @/providers/ToastProvider
- @/server/src/context
- @/stores/uiStore
- @/utils/api-types
- @/utils/colors
- @/utils/haptics
- @/utils/offline-sync
- @/utils/query-client
- @/utils/supabase
- @/utils/trpc
- @expo/vector-icons
- @gluestack-ui/config
- @gluestack-ui/themed
- @hookform/resolvers/zod
- @jest/globals
- @react-native-async-storage/async-storage
- @react-native-community/netinfo
- @shopify/flash-list
- @supabase/supabase-js
- @tamagui/animations-react-native
- @tamagui/lucide-icons
- @tamagui/toast
- @tanstack/query-async-storage-persister
- @tanstack/react-query
- @tanstack/react-query-persist-client
- @testing-library/react-native
- @trpc/client
- @trpc/react-query
- @trpc/server
- @trpc/server/adapters/express
- cors
- date-fns
- dotenv
- expo-blur
- expo-haptics
- expo-router
- expo-router/entry
- expo-secure-store
- expo-status-bar
- express
- globby
- jest-mock-extended
- nativewind
- nats.ws
- node:child_process
- node:crypto
- node:fs
- node:path
- node:url
- react
- react-hook-form
- react-native
- react-native-gesture-handler
- react-native-gesture-handler/Swipeable
- react-native-reanimated
- react-native-safe-area-context
- react-native-svg
- react-native-url-polyfill/auto
- server/src/router
- tamagui
- zod
- zustand

## TODOs / FIXMEs

**__tests__/server/routers/habitRouter.test.ts**
- (L595) Add describe blocks for archive/unarchive and habit entry procedures

**app/states/[id].tsx**
- (L11) Fetch state definition details using trpc.state.getDefinitionById.useQuery({ id })

**app/values/[id].tsx**
- (L11) Fetch value details using trpc.value.getValueById.useQuery({ id })

**server/src/routers/dashboardRouter.ts**
- (L355) Add logic for 'weekly', 'monthly' etc. as needed

**server/src/routers/habitRouter.ts**
- (L411) Implement logic to fetch habit entries for a specific habit
- (L543) Implement logic to find if entry exists for habitId/date/userId.

**server/src/routers/principleRouter.ts**
- (L22) Parse with Principle schema from trpc-types?
- (L53) Parse with Principle schema from trpc-types?
- (L79) Parse with Principle schema from trpc-types?
- (L120) Parse with Principle schema from trpc-types?

**server/src/routers/reminderRouter.ts**
- (L63) Potentially validate that related_entity_id exists and belongs to user?

**server/src/routers/taskRouter.ts**
- (L67) Add filters for status, priority, dates etc.?
- (L81) Add complex priority enum sorting? (e.g. high > medium > low)
- (L88) Parse with Task schema?
- (L119) Parse with Task schema?
- (L187) Parse with Task schema?
- (L265) Add deeper cycle detection if needed (check if new parent is a descendant)
- (L291) Parse with Task schema?
- (L356) Parse with Task schema?
- (L369) Consider archiving subtasks recursively?
- (L388) Parse with Task schema?
- (L402) Consider check if parent is archived?
- (L421) Parse with Task schema?
- (L458) Parse with Task schema?
- (L490) Parse with Task schema?
- (L515) Parse with Task schema?
- (L540) Parse with Task schema?

**server/src/routers/valueRouter.ts**
- (L18) Parse with Value schema from trpc-types?
- (L49) Parse with Value schema from trpc-types?
- (L75) Parse with Value schema from trpc-types?
- (L116) Parse with Value schema from trpc-types?

## Buckets

### .

- **.env** (0.4 KB, 4 lines)

- **.env.example** (0.1 KB, 2 lines)

- **.eslintrc.js** (0.5 KB, 17 lines)
  *(No explicit exports found)*

- **.gitignore** (0.4 KB, 42 lines)

- **.windsurfrules** (0.0 KB, 1 lines)

- **AETHER_TODO.md** (6.4 KB, 147 lines)

- **HAHA.js** (4.7 KB, 139 lines)
  *(No explicit exports found)*

- **README.md** (2.3 KB, 119 lines)

- **REFACTORING_PLAN_V2.yaml** (13.3 KB, 252 lines)

- **SUPABASE_INTEGRATION.md** (4.7 KB, 173 lines)

- **aetherOUT.md** (1071.6 KB, 32588 lines)

- **aether_migration_context.md** (0.0 KB, 0 lines)

- **aether_migration_context_full.md** (0.0 KB, 0 lines)

- **aether_migration_context_full_20250430_041229.md** (0.0 KB, 0 lines)

- **aether_migration_context_full_20250430_041247.md** (0.0 KB, 0 lines)

- **aether_migration_context_full_20250430_041307.md** (0.0 KB, 0 lines)

- **aether_migration_context_full_20250430_041337.md** (0.0 KB, 0 lines)

- **aether_migration_context_full_20250430_041425.md** (0.0 KB, 0 lines)

- **aether_migration_context_full_20250430_041425.md.tmp** (0.0 KB, 0 lines)

- **aether_styling_context.txt** (70.5 KB, 2247 lines)

- **app.json** (1.4 KB, 61 lines)

- **babel-tap.js** (0.3 KB, 13 lines)
  *(No explicit exports found)*

- **code-atlas_2025-04-30-10-21-29.md** (322.8 KB, 11384 lines)

- **code_atlas.js** (0.0 KB, 0 lines)
  *(No explicit exports found)*

- **debug_context.txt** (35.9 KB, 1048 lines)

- **eas.json** (0.3 KB, 22 lines)

- **file_hierarchy.txt** (5.3 KB, 211 lines)

- **gather_complete_context.sh** (14.0 KB, 349 lines)

- **gather_complete_context_fixed.sh** (14.1 KB, 349 lines)

- **gather_complete_context_full.sh** (20.0 KB, 511 lines)

- **gather_complete_context_improved.sh** (15.3 KB, 375 lines)

- **gather_complete_context_v3.sh** (1.0 KB, 34 lines)

- **gather_debug_info.js** (1.6 KB, 47 lines)
  *(No explicit exports found)*

- **gather_implementation_details.sh** (4.9 KB, 133 lines)

- **gather_integrated_context.sh** (5.6 KB, 180 lines)

- **gather_project_context.sh** (11.6 KB, 285 lines)

- **gather_tamagui_styles.sh** (2.2 KB, 68 lines)

- **global.css** (0.1 KB, 4 lines)

- **implementation_details.txt** (634.7 KB, 18588 lines)

- **index.js** (0.1 KB, 4 lines)
  *(No explicit exports found)*

- **jest.server.config.js** (0.6 KB, 23 lines)
  *(No explicit exports found)*

- **o3.txt** (48.8 KB, 1480 lines)

- **package.json** (2.6 KB, 87 lines)

- **project.txt** (127.5 KB, 3939 lines)

- **project_structure.txt** (6.0 KB, 187 lines)

- **refactor_checklist.md** (5.6 KB, 134 lines)

- **refactoring_plan.md** (8.8 KB, 195 lines)

- **styling_report.txt** (6.9 KB, 235 lines)

- **tailwind.config.js** (3.1 KB, 110 lines)
  *(No explicit exports found)*

- **tamagui.config.ts** (12.8 KB, 365 lines)

  *Exports: `default` (unknown)*
  ```ts
export default config;
  ```

- **testing_strategy.md** (10.9 KB, 205 lines)

- **tsconfig.json** (0.4 KB, 27 lines)

- **why.txt** (2.8 KB, 52 lines)

### __tests__

- **__tests__/components/dashboard/HabitCheckItem.test.tsx** (4.7 KB, 170 lines)
  *(No explicit exports found)*

- **__tests__/components/lists/GoalList.test.tsx** (3.9 KB, 140 lines)
  *(No explicit exports found)*

- **__tests__/components/lists/HabitList.test.tsx** (3.7 KB, 131 lines)
  *(No explicit exports found)*

- **__tests__/components/lists/TaskList.test.tsx** (4.5 KB, 158 lines)
  *(No explicit exports found)*

- **__tests__/components/ui/primitives/AetherCard.test.tsx** (1.7 KB, 61 lines)
  *(No explicit exports found)*

- **__tests__/components/ui/primitives/AetherListItem.test.tsx** (2.0 KB, 79 lines)
  *(No explicit exports found)*

- **__tests__/server/routers/dashboardRouter.getWeeklyProgress.test.ts** (9.1 KB, 232 lines)
  *(No explicit exports found)*

- **__tests__/server/routers/dashboardRouter.test.ts** (8.5 KB, 235 lines)
  *(No explicit exports found)*

- **__tests__/server/routers/habitRouter.test.ts** (31.5 KB, 597 lines) (1 TODOs)
  *(No explicit exports found)*

- **__tests__/server/routers/taskRouter.toggleTask.test.ts** (14.0 KB, 344 lines)
  *(No explicit exports found)*

- **__tests__/server/test-helpers.ts** (10.1 KB, 263 lines)

  *Exports: `createInnerTRPCContext` (function)*
  ```ts
function createInnerTRPCContext(opts: {
  userId: string | null;
  supabase?: any; // Keep as any for simplicity
}): Context {
  if (!opts.userId) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
      message: 'User must be authenticated to access this resource',
    });
  }

  return {
    userId: opts.userId,
    supabaseAdmin: opts.supabase || mockSupabaseAdmin,
  };
}
  ```

  *Exports: `createTestContext` (function)*
  ```ts
function createTestContext(userId: string | null = 'test-user-id', supabase?: any) {
  return createInnerTRPCContext({
    userId,
    supabase,
  });
}
  ```

  *Exports: `MockablePostgrestResponse` (type)*
  ```ts
type MockablePostgrestResponse<T> = Promise<{
  data: T | null;
  error: any;
  count?: number | null; 
  status?: number;
  statusText?: string;
}>;
  ```

  *Exports: `MockableQueryBuilder` (interface)*
  ```ts
interface MockableQueryBuilder {
  select: (query?: string, options?: { head?: boolean; count?: 'exact' | 'planned' | 'estimated' }) => MockableQueryBuilder;
  eq: (column: string, value: any) => MockableQueryBuilder;
  neq: (column: string, value: any) => MockableQueryBuilder;
  gt: (column: string, value: any) => MockableQueryBuilder;
  gte: (column: string, value: any) => MockableQueryBuilder;
  lt: (column: string, value: any) => MockableQueryBuilder;
  lte: (column: string, value: any) => MockableQueryBuilder;
  like: (column: string, pattern: string) => MockableQueryBuilder;
  ilike: (column: string, pattern: string) => MockableQueryBuilder;
  is: (column: string, value: boolean | null) => MockableQueryBuilder;
  in: (column: string, values: any[]) => MockableQueryBuilder;
  contains: (column: string, value: any) => MockableQueryBuilder;
  containedBy: (column: string, value: any) => MockableQueryBuilder;
  rangeGt: (column: string, range: string) => MockableQueryBuilder;
  rangeGte: (column: string, range: string) => MockableQueryBuilder;
  rangeLt: (column: string, range: string) => MockableQueryBuilder;
  rangeLte: (column: string, range: string) => MockableQueryBuilder;
  rangeAdjacent: (column: string, range: string) => MockableQueryBuilder;
  overlaps: (column: string, value: any) => MockableQueryBuilder;
  textSearch: (column: string, query: string, options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }) => MockableQueryBuilder;
  match: (query: Record<string, unknown>) => MockableQueryBuilder;
  not: (column: string, operator: string, value: any) => MockableQueryBuilder;
  or: (filters: string, options?: { referencedTable?: string }) => MockableQueryBuilder;
  filter: (column: string, operator: string, value: any) => MockableQueryBuilder;
  limit: (count: number, options?: { referencedTable?: string }) => MockableQueryBuilder;
  range: (from: number, to: number, options?: { referencedTable?: string }) => MockableQueryBuilder;
  order: (column: string, options?: { ascending?: boolean; nullsFirst?: boolean; referencedTable?: string }) => MockableQueryBuilder;
}
  ```

  *Exports: `MockableSupabaseClient` (interface)*
  ```ts
interface MockableSupabaseClient {
  // `from` now returns the object with both chainable and terminal methods
  from: (relation: string) => MockableTableOperations;

  // Top-level client methods
  auth: {
    getUser: (
      jwt?: string
    ) => Promise<{ data: { user: User | null }; error: AuthError | null }>;
    // Add other auth methods here if needed by tests (e.g., signUp, signInWithPassword)
  };
  rpc: <T = any>(fn: string, params?: object, options?: { head?: boolean; count?: 'exact' | 'planned' | 'estimated' }) => MockablePostgrestResponse<T>;
  // Add storage interface here if needed by tests
  // storage: { ... };
}
  ```

  *Exports: `MockableTableOperations` (interface)*
  ```ts
interface MockableTableOperations extends MockableQueryBuilder {
  // Terminal methods (return Promises)
  single: <T = any>() => MockablePostgrestResponse<T>;
  maybeSingle: <T = any>() => MockablePostgrestResponse<T>;
  // Note: Insert/Update/Upsert often return arrays in Supabase v2, but the *methods* return the builder
  insert: <T = any>(values: any | any[], options?: any) => MockableTableOperations; 
  upsert: <T = any>(values: any | any[], options?: any) => MockableTableOperations; 
  update: <T = any>(values: any, options?: any) => MockableTableOperations; 
  delete: (options?: any) => MockableTableOperations; 
}
  ```

  *Exports: `mockDeep` (re-export)*
  ```ts
export { mockDeep }
  ```

  *Exports: `mockSupabaseAdmin` (unknown)*
  ```ts
mockSupabaseAdmin = mockDeep<MockableSupabaseClient>()
  ```

  *Exports: `resetSupabaseMocks` (function)*
  ```ts
function resetSupabaseMocks() {
  // Use mockReset for better compatibility with jest-mock-extended
  mockReset(mockSupabaseAdmin);

  // --- Re-apply default implementations after reset --- 

  // Default: Successful authentication
  mockSupabaseAdmin.auth.getUser.mockResolvedValue({
    data: { user: { id: 'test-user-id', /* other user props */ } as User },
    error: null,
  });

  // Default: Successful RPC call returning null data
  mockSupabaseAdmin.rpc.mockResolvedValue({ 
      data: null, 
      error: null, 
      count: 0, 
      status: 200, 
      statusText: 'OK' 
  });

  // Helper type to create Promise-like chain-terminating objects
  type AsyncResult<T> = Promise<{ data: T | null; error: any; count?: number; status?: number; statusText?: string; }>;

  // Helper function to create a proper mock that handles both chaining AND awaiting
  function createMockWithPromiseCapability<T>(defaultData: T | null = null): any {
    const mockObj = mockDeep<MockableTableOperations>();
    
    // Add an implicit then handler that allows awaiting the mock directly
    // This is what Supabase's actual Query Builder does
    const defaultResponse = { 
      data: defaultData, 
      error: null, 
      count: defaultData && Array.isArray(defaultData) ? defaultData.length : 0,
      status: 200, 
      statusText: 'OK' 
    };
    
    // Allow the mock to be awaited directly
    (mockObj as any).then = jest.fn((onFulfill, onReject) => {
      return Promise.resolve(defaultResponse).then(onFulfill, onReject);
    });
    
    return mockObj;
  }

  // Default behavior for 'from': Return a mock that handles chaining and terminal methods
  mockSupabaseAdmin.from.mockImplementation((relation: string) => {
    // This inner mock needs to satisfy MockableTableOperations
    // AND be awaitable like a promise for terminal operations
    const innerMock = createMockWithPromiseCapability<any[]>([]);

    // --- Configure Default CHAINABLE Methods (Return Self) --- 
    innerMock.select.mockReturnValue(innerMock);
    innerMock.eq.mockReturnValue(innerMock);
    innerMock.neq.mockReturnValue(innerMock);
    innerMock.gt.mockReturnValue(innerMock);
    innerMock.gte.mockReturnValue(innerMock);
    innerMock.lt.mockReturnValue(innerMock);
    innerMock.lte.mockReturnValue(innerMock);
    innerMock.like.mockReturnValue(innerMock);
    innerMock.ilike.mockReturnValue(innerMock);
    innerMock.is.mockReturnValue(innerMock);
    innerMock.in.mockReturnValue(innerMock);
    innerMock.contains.mockReturnValue(innerMock);
    innerMock.containedBy.mockReturnValue(innerMock);
    innerMock.rangeGt.mockReturnValue(innerMock);
    innerMock.rangeGte.mockReturnValue(innerMock);
    innerMock.rangeLt.mockReturnValue(innerMock);
    innerMock.rangeLte.mockReturnValue(innerMock);
    innerMock.rangeAdjacent.mockReturnValue(innerMock);
    innerMock.overlaps.mockReturnValue(innerMock);
    innerMock.textSearch.mockReturnValue(innerMock);
    innerMock.match.mockReturnValue(innerMock);
    innerMock.not.mockReturnValue(innerMock);
    innerMock.or.mockReturnValue(innerMock);
    innerMock.filter.mockReturnValue(innerMock);
    innerMock.limit.mockReturnValue(innerMock);
    innerMock.range.mockReturnValue(innerMock);
    innerMock.order.mockReturnValue(innerMock);

    // --- Configure Default TERMINAL Methods --- 
    // For single-returning methods, default to null
    const singleResponse = { 
      data: null, 
      error: null, 
      status: 200, 
      statusText: 'OK' 
    };
    
    innerMock.single.mockResolvedValue(singleResponse);
    innerMock.maybeSingle.mockResolvedValue(singleResponse);
    
    // For insert/update/upsert operations, return the builder that can be chained further or awaited
    innerMock.insert.mockImplementation(() => {
      const insertMock = createMockWithPromiseCapability();
      insertMock.select.mockReturnValue(insertMock);
      return insertMock;
    });
    
    innerMock.upsert.mockImplementation(() => {
      const upsertMock = createMockWithPromiseCapability();
      upsertMock.select.mockReturnValue(upsertMock);
      return upsertMock;
    });
    
    innerMock.update.mockImplementation(() => {
      const updateMock = createMockWithPromiseCapability();
      updateMock.select.mockReturnValue(updateMock);
      return updateMock;
    });
    
    innerMock.delete.mockImplementation(() => {
      const deleteMock = createMockWithPromiseCapability();
      deleteMock.select.mockReturnValue(deleteMock);
      return deleteMock;
    });

    return innerMock;
  });
}
  ```

  *Exports: `TableName` (type)*
  ```ts
type TableName = 
| 'users' 
| 'user_profiles' 
| 'user_settings'
| 'values'
| 'principles'
| 'goals' 
| 'tasks'
| 'habits'
| 'habit_entries'
| 'tracked_state_defs' 
| 'state_entries'     
| 'reminders'         
| 'goal_progress_notes'
| 'rewards'           
| 'user_badges';
  ```

- **__tests__/test-utils.tsx** (0.9 KB, 28 lines)

  *Exports: `render` (re-export)*
  ```tsx
export { customRender as render }
  ```

### .github

- **.github/workflows/ci.yml** (1.1 KB, 56 lines)

### app

- **app/(auth)/_layout.tsx** (0.6 KB, 32 lines)

  *Exports: `default` (function)*
  ```tsx
export default function AuthLayout() {
  return (
    <Stack>
      <Stack.Screen 
        name="login" 
        options={{ 
          title: 'Sign In',
          headerShown: false
        }} 
      />
      <Stack.Screen 
        name="register" 
        options={{ 
          title: 'Create Account',
          headerShown: false
        }} 
      />
      <Stack.Screen 
        name="forgot-password" 
        options={{ 
          title: 'Reset Password',
          headerShown: false
        }} 
      />
    </Stack>
  );
}
  ```

- **app/(auth)/forgot-password.tsx** (2.6 KB, 89 lines)

  *Exports: `default` (function)*
  ```tsx
export default function ForgotPasswordScreen() {
  const [email, setEmail] = useState('');
  const [loading, setLoading] = useState(false);
  const [success, setSuccess] = useState(false);
  const toast = useToastController();

  // Send password reset email via Supabase
  const handleResetPassword = async () => {
    if (!email) {
      toast.show('Please enter your email', { type: 'error' });
      return;
    }

    setLoading(true);

    try {
      const { error } = await supabase.auth.resetPasswordForEmail(email, {
        redirectTo: window?.location?.origin ? `${window.location.origin}/update-password` : undefined,
      });

      if (error) throw error;

      setSuccess(true);
      toast.show('Password reset email sent!', { type: 'success' });
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to send reset email';
      toast.show(errorMessage, { type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <YStack flex={1} padding="$4" justifyContent="center" space="$4" backgroundColor="$background">
      <YStack alignItems="center" marginBottom="$6">
        {/* Replace with your app logo */}
        <Image 
          source={require('@/assets/images/icon.png')} 
          width={100} 
          height={100} 
          marginBottom="$6" 
          resizeMode="contain"
        />
        <H1>Reset Password</H1>
        <Text color="$gray10" textAlign="center">
          {success 
            ? 'Check your email for reset instructions' 
            : 'Enter your email to receive reset instructions'}
        </Text>
      </YStack>

      {!success ? (
        <>
          <Input
            placeholder="Email"
            value={email}
            onChangeText={setEmail}
            autoCapitalize="none"
            keyboardType="email-address"
          />

          <Button
            onPress={handleResetPassword}
            disabled={loading}
            backgroundColor="$blue10"
            color="white"
            size="$5"
          >
            {loading ? <Spinner color="white" /> : 'Send Reset Link'}
          </Button>
        </>
      ) : null}

      <YStack paddingTop="$6" alignItems="center">
        <Link href="/(auth)/login">
          <Text color="$blue10">Back to Sign In</Text>
        </Link>
      </YStack>
    </YStack>
  );
}
  ```

- **app/(auth)/login.tsx** (2.5 KB, 93 lines)

  *Exports: `default` (function)*
  ```tsx
export default function LoginScreen() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const toast = useToastController();

  // Sign in with Supabase authentication
  const handleLogin = async () => {
    if (!email || !password) {
      toast.show('Please enter both email and password', { type: 'error' });
      return;
    }

    setLoading(true);

    try {
      const { error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (error) throw error;

      // Navigate to home screen on successful login
      router.replace('/(tabs)/home');
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Login failed';
      toast.show(errorMessage, { type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <YStack flex={1} padding="$4" justifyContent="center" space="$4" backgroundColor="$background">
      <YStack alignItems="center" marginBottom="$6">
        {/* Replace with your app logo */}
        <Image 
          source={require('@/assets/images/icon.png')} 
          width={100} 
          height={100} 
          marginBottom="$6" 
          resizeMode="contain"
        />
        <H1>Welcome to Aether</H1>
        <Text color="$gray10">Sign in to your account</Text>
      </YStack>

      <Input
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        autoCapitalize="none"
        keyboardType="email-address"
      />

      <Input
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <Button
        onPress={handleLogin}
        disabled={loading}
        backgroundColor="$blue10"
        color="white"
        size="$5"
      >
        {loading ? <Spinner color="white" /> : 'Sign In'}
      </Button>

      <XStack justifyContent="space-between" paddingTop="$2">
        <Link href="/(auth)/forgot-password">
          <Text color="$blue10">Forgot Password?</Text>
        </Link>

        <Link href="/(auth)/register">
          <Text color="$blue10">Create Account</Text>
        </Link>
      </XStack>
    </YStack>
  );
}
  ```

- **app/(auth)/register.tsx** (3.0 KB, 107 lines)

  *Exports: `default` (function)*
  ```tsx
export default function RegisterScreen() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const toast = useToastController();

  // Create new account with Supabase authentication
  const handleRegister = async () => {
    if (!email || !password) {
      toast.show('Please enter both email and password', { type: 'error' });
      return;
    }

    if (password !== confirmPassword) {
      toast.show('Passwords do not match', { type: 'error' });
      return;
    }

    setLoading(true);

    try {
      const { error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          emailRedirectTo: window?.location?.origin || undefined,
        }
      });

      if (error) throw error;

      // Navigate to home screen on successful registration
      toast.show('Account created successfully!', { type: 'success' });
      router.replace('/(tabs)/home');
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Registration failed';
      toast.show(errorMessage, { type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <YStack flex={1} padding="$4" justifyContent="center" space="$4" backgroundColor="$background">
      <YStack alignItems="center" marginBottom="$6">
        {/* Replace with your app logo */}
        <Image 
          source={require('@/assets/images/icon.png')} 
          width={100} 
          height={100} 
          marginBottom="$6" 
          resizeMode="contain"
        />
        <H1>Create Account</H1>
        <Text color="$gray10">Sign up to get started</Text>
      </YStack>

      <Input
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        autoCapitalize="none"
        keyboardType="email-address"
      />

      <Input
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />
      
      <Input
        placeholder="Confirm Password"
        value={confirmPassword}
        onChangeText={setConfirmPassword}
        secureTextEntry
      />

      <Button
        onPress={handleRegister}
        disabled={loading}
        backgroundColor="$blue10"
        color="white"
        size="$5"
      >
        {loading ? <Spinner color="white" /> : 'Create Account'}
      </Button>

      <XStack justifyContent="center" paddingTop="$2">
        <Text color="$gray10">Already have an account? </Text>
        <Link href="/(auth)/login">
          <Text color="$blue10">Sign In</Text>
        </Link>
      </XStack>
    </YStack>
  );
}
  ```

- **app/(tabs)/_layout.tsx** (1.9 KB, 69 lines)

  *Exports: `default` (function)*
  ```tsx
export default function TabsLayout() {
  const active = useColorModeValue('#86A5A9', '#64FFDA');
  const inactive = useColorModeValue('#8e8e93', '#626262');
  const bg = useColorModeValue('#FDFFE0', '#1A2E3A');
  const border = useColorModeValue('#E5E5EA', '#2C2C2E');

  return (
    <Tabs
      screenOptions={{
        headerShown: false,
        tabBarActiveTintColor: active,
        tabBarInactiveTintColor: inactive,
        tabBarStyle: { backgroundColor: bg, borderTopColor: border, height: 60 },
      }}
    >
      <Tabs.Screen
        name="home"
        options={{
          title: 'Home',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="home-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="planner"
        options={{
          title: 'Planner',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="calendar-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="compass"
        options={{
          title: 'Compass',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="stats-chart-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="rewards"
        options={{
          title: 'Rewards',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="sparkles-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="settings"
        options={{
          title: 'Settings',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="settings-outline" size={size} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}
  ```

- **app/(tabs)/compass/index.tsx** (4.9 KB, 163 lines)

  *Exports: `default` (function)*
  ```tsx
export default function CompassScreen() {
  const [activeTab, setActiveTab] = useState<string>('principles');
  const colorScheme = useColorScheme();

  const handleAddPress = () => {
    const route = `/compose?type=${activeTab === 'principles' ? 'value' : 'state'}` as Href;
    router.push(route);
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Compass</Text>
          <Button
            size="$3"
            circular
            onPress={handleAddPress} 
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>

        {/* Tabs */}
        <Tabs
          defaultValue="principles"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {React.cloneElement(tab.icon as React.ReactElement, { color: activeTab === tab.key ? '$colorFocus' : '$color' })}
                  <Text color={activeTab === tab.key ? '$colorFocus' : '$color'}>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>

          {/* Tab Content */}
          <Tabs.Content value="principles" flex={1} key="principles-content">
            <ScrollView>
              <PrinciplesTab />
            </ScrollView>
          </Tabs.Content>

          <Tabs.Content value="states" flex={1} key="states-content">
            <ScrollView>
              <StatesTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/home/index.tsx** (2.2 KB, 65 lines)

  *Exports: `default` (function)*
  ```tsx
export default function HomeScreen() {
  const router = useRouter();
  const { data, isLoading, isRefetching, refetch } = useDashboardQuery();
  const toggleTask = useToggleTaskStatus();

  const parchment = useColorModeValue('#FDFFE0', '#1A2E3A');

  return (
    <ScrollView
      className="flex-1 px-4"
      style={{ backgroundColor: parchment }}
      refreshControl={<RefreshControl refreshing={isRefetching} onRefresh={refetch} />}
    >
      <Text className="text-2xl font-heading text-darkText mt-6 mb-4">
        Good morning, Link!
      </Text>

      {/* Tasks Section */}
      <SectionCard
        title="Tasks for today"
        action={
          <Button
            className="flex-row items-center"
            onPress={() => router.push('/(tabs)/planner/add-task')}
          >
            <Ionicons name="add" size={18} color="#86A5A9" />
            <Text className="ml-1 text-sheikahCyan">New</Text>
          </Button>
        }
      >
        {isLoading && <Text>Loading…</Text>}
        {!isLoading && (!data?.tasks?.length ? (
          <Text className="text-ios-gray-3">No tasks 🎉</Text>
        ) : (
          data.tasks.map((task) => (
            <SwipeableRow
              key={task.id}
              onComplete={() =>
                toggleTask.mutate({ taskId: task.id, completed: task.status !== 'done' })
              }
            >
              <TaskRow task={task} />
            </SwipeableRow>
          ))
        ))}
      </SectionCard>

      {/* You can add Habits / Goals sections here following the same pattern */}
    </ScrollView>
  );
}
  ```

- **app/(tabs)/planner/_layout.tsx** (0.9 KB, 19 lines)

  *Exports: `default` (function)*
  ```tsx
export default function PlannerLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      {/* The index screen is the default for the planner tab */}
      <Stack.Screen name="index" />
      {/* Add screens for the sub-pages */}
      <Stack.Screen name="add-task" options={{ presentation: 'modal', title: 'Add Task' }} />
      <Stack.Screen name="add-habit" options={{ presentation: 'modal', title: 'Add Habit' }} />
      <Stack.Screen name="add-goal" options={{ presentation: 'modal', title: 'Add Goal' }} />
      <Stack.Screen name="goal/[id]" options={{ title: 'Goal Details' }} />
      <Stack.Screen name="habit/[id]" options={{ title: 'Habit Details' }} />
    </Stack>
  );
}
  ```

- **app/(tabs)/planner/add-goal.tsx** (0.7 KB, 20 lines)

  *Exports: `default` (function)*
  ```tsx
export default function AddGoalScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Add New Goal</H1>
        <Text>Goal details form will go here.</Text>
        <Button onPress={() => router.back()}>Cancel</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/planner/add-habit.tsx** (0.7 KB, 20 lines)

  *Exports: `default` (function)*
  ```tsx
export default function AddHabitScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Add New Habit</H1>
        <Text>Habit details form will go here.</Text>
        <Button onPress={() => router.back()}>Cancel</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/planner/add-task.tsx** (0.7 KB, 20 lines)

  *Exports: `default` (function)*
  ```tsx
export default function AddTaskScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Add New Task</H1>
        <Text>Task details form will go here.</Text>
        <Button onPress={() => router.back()}>Cancel</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/planner/goal/[id].tsx** (0.8 KB, 23 lines)

  *Exports: `default` (function)*
  ```tsx
export default function GoalDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const colorScheme = useColorScheme();

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Goal Detail: {id}</H1>
        <Text>Details for goal {id} will be displayed here.</Text>
        {/* Add tRPC query to fetch goal data based on id */}
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/planner/habit/[id].tsx** (0.8 KB, 23 lines)

  *Exports: `default` (function)*
  ```tsx
export default function HabitDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const colorScheme = useColorScheme();

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Habit Detail: {id}</H1>
        <Text>Details for habit {id} will be displayed here.</Text>
        {/* Add tRPC query to fetch habit data based on id */}
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/planner/index.tsx** (7.6 KB, 266 lines)

  *Exports: `default` (function)*
  ```tsx
export default function PlannerScreen() {
  const [activeTab, setActiveTab] = useState<string>('goals');
  const colorScheme = useColorScheme();
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Planner</Text>
          <Button
            size="$3"
            circular
            onPress={() => {/* Handle new item */}}
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>
        
        {/* Tabs */}
        <Tabs
          defaultValue="goals"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List 
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {tab.icon}
                  <Text>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>
          
          {/* Tab Content */}
          <Tabs.Content value="goals" flex={1}>
            <ScrollView>
              <GoalsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="habits" flex={1}>
            <ScrollView>
              <HabitsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="calendar" flex={1}>
            <ScrollView>
              <CalendarTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/rewards/index.tsx** (9.0 KB, 257 lines)

  *Exports: `default` (function)*
  ```tsx
export default function RewardsScreen() {
const [viewMode, setViewMode] = useState<ViewMode>(ViewMode.Grid);
const colorScheme = useColorScheme();
const theme = useTheme();

// Define fallback colors
const blue2 = theme?.blue2?.val ?? '#eff6ff';
const blue5 = theme?.blue5?.val ?? '#60a5fa';
const blue10 = theme?.blue10?.val ?? '#1e40af';
const blue11 = theme?.blue11?.val ?? '#1e3a8a';
const green9 = theme?.green9?.val ?? '#16a34a';

// Fetch available rewards from tRPC
const { 
  data: rewards, 
  isLoading, 
  error, 
  refetch 
} = trpc.rewards.getAvailableRewards.useQuery();

// Mutation for claiming rewards
const claimMutation = trpc.rewards.earnReward.useMutation({
  onSuccess: (data) => {
    console.log('Reward claimed successfully:', data);
    // Maybe show confetti?
    Alert.alert('Reward Claimed!', `You spent ${data.reward.points_spent} points. Remaining: ${data.remainingPoints}`);
    refetch(); // Refetch the list of available rewards
  },
  onError: (err) => {
    console.error('Failed to claim reward:', err);
    Alert.alert('Claim Failed', err.message || 'Could not claim reward.');
  }
});

const handleClaimReward = useCallback((rewardId: string) => {
  if (claimMutation.isPending) return; // Prevent double-clicks
  
  Alert.alert(
    'Confirm Claim',
    'Are you sure you want to spend points on this reward?',
    [
      { text: 'Cancel', style: 'cancel' },
      { 
        text: 'Claim', 
        onPress: () => {
          claimMutation.mutate({ rewardId });
        },
        style: 'default'
      }
    ]
  );
}, [claimMutation]);

const renderItem = ({ item }: { item: RewardItem }) => { // Use inferred type
  // Assuming backend field is image_url, map to imagePath
  const imagePath = item.image_url; 
  // All items from getAvailableRewards are considered claimable (not yet claimed)
  const claimed = false; 
  // Map required_points to pointCost
  const pointCost = item.required_points;

  if (viewMode === ViewMode.Grid) {
    return (
      <Card
        size="$4"
        bordered
        width={160}
        height={200}
        margin="$2"
        overflow="hidden"
        elevation="$2"
        opacity={claimed ? 0.7 : 1}
      >
        <ImageBackground
          source={{ uri: imagePath }}
          style={{ width: '100%', height: 100 }}
        >
          <View style={{ 
            position: 'absolute', 
            top: 5, 
            right: 5, 
            backgroundColor: blue5,
            borderRadius: 10,
            padding: 4
          }}>
            <Text color="white" fontSize="$2" fontWeight="bold">
              {pointCost} pts
            </Text>
          </View>
        </ImageBackground>
        
        <YStack padding="$2" flex={1} justifyContent="space-between">
          <Text fontSize="$4" fontWeight="bold" numberOfLines={1}>
            {item.name}
          </Text>
          
          <Button
            size="$2"
            themeInverse={claimed}
            backgroundColor={claimed ? undefined : blue10}
            onPress={() => handleClaimReward(item.id)}
            disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
          >
            {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
          </Button>
        </YStack>
      </Card>
    );
  } else {
    return (
      <Card
        bordered
        margin="$2"
        padding="$3"
        opacity={claimed ? 0.7 : 1}
      >
        <XStack space="$3" alignItems="center">
          {imagePath && (
            <View style={{ 
              width: 60, 
              height: 60, 
              borderRadius: 8, 
              overflow: 'hidden',
              backgroundColor: theme.gray3.val
            }}>
              <ImageBackground
                source={{ uri: imagePath }}
                style={{ width: '100%', height: '100%' }}
              />
            </View>
          )}
          
          <YStack flex={1} space="$1">
            <Text fontSize="$5" fontWeight="bold">{item.name}</Text>
            <Text fontSize="$3" color="$gray11" numberOfLines={2}>{item.description}</Text>
            <Text fontSize="$3" color={blue10} fontWeight="500">{pointCost} points</Text>
          </YStack>
          
          <Button
            size="$3"
            backgroundColor={claimed ? undefined : blue10}
            themeInverse={claimed}
            onPress={() => handleClaimReward(item.id)}
            disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
          >
            {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming..... /* snippet truncated */
  ```

- **app/(tabs)/settings/_layout.tsx** (0.9 KB, 20 lines)

  *Exports: `default` (function)*
  ```tsx
export default function SettingsLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      {/* The index screen is the default for the settings tab */}
      <Stack.Screen name="index" />
      {/* Add screens for the sub-pages */}
      <Stack.Screen name="profile" options={{ title: 'Edit Profile' }} />
      <Stack.Screen name="security" options={{ title: 'Security' }} />
      <Stack.Screen name="privacy" options={{ title: 'Data & Privacy' }} />
      <Stack.Screen name="notifications" options={{ title: 'Notifications' }} />
      <Stack.Screen name="help" options={{ title: 'Help & Support' }} />
      <Stack.Screen name="about" options={{ title: 'About Aether' }} />
    </Stack>
  );
}
  ```

- **app/(tabs)/settings/about.tsx** (0.7 KB, 20 lines)

  *Exports: `default` (function)*
  ```tsx
export default function AboutScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>About Aether</H1>
        <Text>App version, terms of service, credits, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/help.tsx** (0.7 KB, 20 lines)

  *Exports: `default` (function)*
  ```tsx
export default function HelpScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Help & Support</H1>
        <Text>FAQ, contact support link, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/index.tsx** (9.6 KB, 274 lines)

  *Exports: `default` (function)*
  ```tsx
export default function SettingsScreen() {
 const colorScheme = useColorScheme();
 const [notificationsEnabled, setNotificationsEnabled] = useState(true);
 const [trackingEnabled, setTrackingEnabled] = useState(true);
 const { setAccent } = useAccent(); // Get the function to update accent color
 const [selectedAccent, setSelectedAccent] = useState('blue'); // Placeholder state for selected accent

 const handleLogout = async () => {
   Alert.alert(
     'Log Out',
     'Are you sure you want to log out?',
     [
       { text: 'Cancel', style: 'cancel' },
       { 
         text: 'Log Out', 
         style: 'destructive',
         onPress: async () => {
           await supabase.auth.signOut();
           router.replace('/(auth)/login');
         }
       }
     ]
   );
 };

 const AccentSelector = ({ currentAccent, onSelect }: { currentAccent: string, onSelect: (accent: string) => void }) => {
   const accents = ['blue', 'green', 'orange', 'red']; // Example accents corresponding to theme names
   return (
     <XStack space="$2">
       {accents.map((accent) => (
         <Button 
           key={accent} 
           onPress={() => {
             onSelect(accent);
             setAccent(accent); // Call setAccent with the selected accent
           }} 
           theme={accent as any} // Preview the theme (cast needed for demo)
           backgroundColor={accent === currentAccent ? '$backgroundStrong' : '$background'}
         >
           {accent.charAt(0).toUpperCase() + accent.slice(1)}
         </Button>
       ))}
     </XStack>
   );
 };

 return (
   <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
     <ScrollView>
       <YStack flex={1} padding="$4">
         <H1 marginBottom="$4">Settings</H1>
         
         {/* Account Section */}
         <SettingsSection
           title="Account"
           icon={<Ionicons name="person-circle-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
         >
           <YStack>
             <SettingsRow
               label="Edit Profile"
               icon={<Ionicons name="person-outline" size={20} color="#A0A0A0" />}
               showChevron
               onPress={() => router.push('/settings/profile' as any)}
             />
             <Separator marginVertical="$1" />
             <SettingsRow
               label="Security"
               icon={<Ionicons name="lock-closed-outline" size={20} color="#A0A0A0" />}
               showChevron
               onPress={() => router.push('/settings/security' as any)}
             />
             <Separator marginVertical="$1" />
             <SettingsRow
               label="Data & Privacy"
               icon={<Ionicons name="shield-outline" size={20} color="#A0A0A0" />}
               showChevron
               onPress={() => router.push('/settings/privacy' as any)}
             />
           </YStack>
         </SettingsSection>
         
         {/* Appearance Section */}
         <SettingsSection
           title="Appearance"
           icon={<Ionicons name="color-palette-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
         >
           <YStack>
             <SettingsRow
               label="Theme"
               icon={<Ionicons name="moon-outline" size={20} color="#A0A0A0" />}
               rightElement={<Text color="$gray10">{colorScheme === 'dark' ? 'Dark (System)' : 'Light (System)'}</Text>}
             />
             <SettingsRow
               label="Accent Color"
               icon={<Ionicons name="color-palette-outline" size={20} color="#A0A0A0" />}
               rightElement={
                 <AccentSelector 
                   currentAccent={selectedAccent} 
                   onSelect={(accent) => setSelectedAccent(accent)} 
                 />
               }
             />
           </YStack>
         </SettingsSection>
         
         {/* Notifications Section */}
         <SettingsSection
           title="Notifications"
           icon={<Ionicons name="notifications-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
         >
           <YStack>
             <SettingsRow
               label="Push Notifications"
               icon={<Ionicons name="push-outline" size={20} color="#A0A0A0" />}
               rightElement={
                 <Switch
                   size="$3"
                   checked={notificationsEnabled}
                   onCheckedChange={setNotificationsEnabled}
                 />
               }
             />
             <Separator marginVertical="$1" />
             <SettingsRow
               label="Notification Settings"
               icon={<Ionicons name="options-outline" size={20} color="#A0A0A0" />}
               showChevron
               onPress={() => router.push('/settings/notifications' as any)}
... /* snippet truncated */
  ```

- **app/(tabs)/settings/notifications.tsx** (0.7 KB, 20 lines)

  *Exports: `default` (function)*
  ```tsx
export default function NotificationSettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Notification Settings</H1>
        <Text>Granular controls for different notification types.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/privacy.tsx** (0.7 KB, 20 lines)

  *Exports: `default` (function)*
  ```tsx
export default function PrivacySettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Data & Privacy</H1>
        <Text>Data management options, privacy policy link, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/profile.tsx** (0.7 KB, 20 lines)

  *Exports: `default` (function)*
  ```tsx
export default function ProfileSettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Edit Profile</H1>
        <Text>Profile editing form will go here.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/(tabs)/settings/security.tsx** (0.7 KB, 20 lines)

  *Exports: `default` (function)*
  ```tsx
export default function SecuritySettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Security Settings</H1>
        <Text>Password change, 2FA options, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/_layout.tsx** (0.9 KB, 26 lines)

  *Exports: `default` (function)*
  ```tsx
export default function RootLayout() {
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        <GluestackUIProvider config={glueTheme}>
          <SupabaseProvider>
            <TRPCProvider>
              <Stack screenOptions={{ headerShown: false }} />
            </TRPCProvider>
          </SupabaseProvider>
        </GluestackUIProvider>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}
  ```

- **app/components/SectionCard.tsx** (0.7 KB, 23 lines)

  *Exports: `SectionCard` (component)*
  ```tsx
SectionCard: React.FC<SectionCardProps> = ({ title, children }) => {
  return (
    <Stack className="mb-6 overflow-hidden rounded-2xl">
      <BlurView intensity={30} tint="light" className="overflow-hidden rounded-2xl">
        <Stack className="p-4 bg-parchment/50 dark:bg-sheikahCyan/10">
          <Text className="font-heading text-lg mb-2 text-darkText dark:text-parchment">{title}</Text>
          {children}
        </Stack>
      </BlurView>
    </Stack>
  );
}
  ```

- **app/components/SwipeableRow.tsx** (1.6 KB, 58 lines)

  *Exports: `SwipeableRow` (component)*
  ```tsx
SwipeableRow = ({ children, onComplete, onDelete }: SwipeableRowProps) => {
  // Render left-swipe (complete) action
  const renderLeftActions = () => {
    if (!onComplete) return null;
    return (
      <View className="flex-row">
        <Button 
          className="w-20 h-full justify-center items-center bg-korokGreen" 
          onPress={onComplete}
          aria-label="Complete task"
        >
          <Ionicons name="checkmark-outline" size={20} color="#FDFFE0" /* parchment */ />
        </Button>
      </View>
    );
  };

  // Render right-swipe (delete) action
  const renderRightActions = () => {
    if (!onDelete) return null;
    return (
      <View className="flex-row justify-end">
        <Button 
          className="w-20 h-full justify-center items-center bg-guardianOrange" 
          onPress={onDelete}
          aria-label="Delete task"
        >
          <Ionicons name="trash-outline" size={20} color="#FDFFE0" /* parchment */ />
        </Button>
      </View>
    );
  };

  return (
    <Swipeable
      renderLeftActions={renderLeftActions}
      renderRightActions={renderRightActions}
      overshootFriction={8}
      containerStyle={{ backgroundColor: 'transparent' }}
    >
      {children}
    </Swipeable>
  );
}
  ```

- **app/components/TaskRow.tsx** (1.1 KB, 35 lines)

  *Exports: `TaskRow` (component)*
  ```tsx
TaskRow = memo(({ task }: { task: Task }) => (
  <Stack className="flex-row items-center py-3 px-4 bg-parchment/80 dark:bg-darkTealBg/50">
    {task.status === 'completed' && (
      <Ionicons 
        name="checkmark-circle" 
        size={18} 
        color="#92C582" // korokGreen
        style={{ marginRight: 8 }} 
      />
    )}
    <Text 
      className={`flex-1 ${task.status === 'completed' 
        ? 'text-darkText/50 line-through' 
        : 'text-darkText dark:text-parchment'}`}
    >
      {task.name}
    </Text>
    {task.due_date && (
      <Text className="text-xs text-darkText/70 dark:text-parchment/70">
        {new Date(task.due_date).toLocaleDateString()}
      </Text>
    )}
  </Stack>
))
  ```

- **app/compose.tsx** (9.9 KB, 251 lines)

  *Exports: `default` (function)*
  ```tsx
export default function ComposeModal() {
const router = useRouter();
const params = useLocalSearchParams<{ type: string }>();
const type = params.type === 'value' || params.type === 'state' ? params.type : undefined;
const toast = useToastController();
const utils = trpc.useUtils();

const isValue = type === 'value';

// 2️⃣ Define stricter default values using tagged types
const defaultValueValues: CreateValueInputTagged = {
  __type: 'value',
  title: '', // Use 'title' instead of 'name' - Patch #4
  description: ''
};
const defaultStateValues: CreateStateInputTagged = {
  __type: 'state',
  name: '',
  scale: '1-5',
  description: '',
  active: true,
  priority: 50
};

// --- Separate useMutation hooks ---
const createValueMutation = trpc.value.createValue.useMutation({
  onSuccess: (data) => handleSuccess(data),
  onError: (error) => handleError(error),
});
const createStateDefMutation = trpc.state.createDefinition.useMutation({
  onSuccess: (data) => handleSuccess(data),
  onError: (error) => handleError(error),
});

// --- Form setup ---
const { control, handleSubmit, formState: { errors }, reset } = useForm<FormValues>({
  // Note: ZodResolver might need specific configuration if schemas differ vastly
  // or consider not using it if relying solely on backend validation for this dynamic form.
  // Use the new stricter default value constants
  defaultValues: isValue ? defaultValueValues : defaultStateValues,
});

// Reset form if the type changes dynamically
React.useEffect(() => {
  // Use the new stricter default value constants for reset
  reset(isValue ? defaultValueValues : defaultStateValues);
}, [isValue, reset]);

// --- Shared success/error handlers ---
const handleSuccess = (data: any) => {
    toast.show('Created successfully!', { native: true });
    haptics.success();
    if (isValue) {
      utils.value.getValues.invalidate();
    } else {
      utils.state.getDefinitions.invalidate();
    }
    if (router.canGoBack()) {
      router.dismiss(); // Apply patch #5 - Use dismiss for modals
    } else {
      router.replace('/(tabs)/compass');
    }
}

const handleError = (error: any) => {
     toast.show(`Error: ${error.message}`, { type: 'error', native: true });
     haptics.error();
}

// --- Corrected onSubmit ---
const onSubmit = (formData: FormValues) => {
  // 3️⃣ Use discriminant (__type) for type safety, remove casts
  if (formData.__type === 'value') {
    createValueMutation.mutate(formData);
  } else { // formData.__type === 'state'
    createStateDefMutation.mutate(formData);
  }
};

// Handle invalid type parameter gracefully
if (!type) {
  return (
      <YStack flex={1} justifyContent="center" alignItems="center" padding="$4">
          <Paragraph color="$error">Invalid type specified.</Paragraph> {/* Use $error */}
          <Button onPress={() => router.back()} marginTop="$4">Go Back</Button>
      </YStack>
  );
}

// Determine current mutation state for button
const isPending = isValue ? createValueMutation.isPending : createStateDefMutation.isPending;

return (
  <ScrollView contentContainerStyle={{ flexGrow: 1 }}>
    <Form onSubmit={handleSubmit(onSubmit)} flex={1} padding="$4" space="$4" backgroundColor="$background">
      <Stack.Screen options={{ title: isValue ? 'Add Principle' : 'Define State' }} />

      {/* Conditionally render form fields */}
      {isValue ? (
        <>
          {/* --- Fields for Principle/Value --- */}
          <YStack space="$2">
            <Label htmlFor="title">Title</Label> {/* Patch #4: name -> title */}
            <Controller
              name="title" /* Patch #4: name -> title */
              control={control}
              rules={{ required: 'Title is required' }} /* Patch #4 */
              render={({ field }) => ( /* Use inferred types from FormValues */
                <Input
                  id="title"
                  onBlur={field.onBlur}
                  onChangeText={field.onChange} // Use onChangeText
                  value={field.value}
                  placeholder="Principle Title"
                />
              )}
            />
            {/* Use $error token */}
            {errors.title && <Paragraph color="$error">{errors.title?.message}</Paragraph>}
          </YStack>

          <YStack space="$2">
            <Label htmlFor="description">Description (Optional)</Label>
            <Controller
              name="description"
              control={control}
              render={({ field }) => ( // Use inferred types
                <TextArea
                  id="description"
                  onBlur={field.onBlur}
                  onChangeText={field.onChange} // Use onChangeText
                  value={field.value ?? ''}
                  placeholder="Describe... /* snippet truncated */
  ```

- **app/index.tsx** (0.4 KB, 10 lines)

  *Exports: `default` (function)*
  ```tsx
export default function RootIndex() {
  // Redirect directly to a specific tab without causing infinite redirects
  // Use the path that matches how it's accessed in the proper format
  // TypeScript suggests this is the correct format for Expo Router
  return <Redirect href="/(tabs)/home" />;
}
  ```

- **app/lib/useDashboardQuery.ts** (0.5 KB, 15 lines)

  *Exports: `DashboardData` (type)*
  ```ts
type DashboardData = RouterOutputs['dashboard']['getDashboardData'];
  ```

  *Exports: `useDashboardQuery` (hook)*
  ```ts
useDashboardQuery = () =>
trpc.dashboard.getDashboardData.useQuery(undefined, { 
  staleTime: 60_000, // 1 minute stale time
  refetchOnMount: 'always', // Always refetch when component mounts
})
  ```

- **app/lib/useToggleTaskStatus.ts** (1.8 KB, 56 lines)

  *Exports: `useToggleTaskStatus` (hook)*
  ```ts
useToggleTaskStatus = () => {
  const utils = trpc.useUtils();
  
  return trpc.task.toggleTask.useMutation({
    // Optimistically update UI before server responds
    onMutate: async ({ taskId, completed }) => {
      // Cancel any outgoing refetches
      await utils.dashboard.getDashboardData.cancel();
      
      // Snapshot current data for potential rollback
      const previous = utils.dashboard.getDashboardData.getData();
      
      // Optimistically update to the new value
      utils.dashboard.getDashboardData.setData(undefined, (oldData) => {
        if (!oldData) return oldData;
        return {
          ...oldData,
          tasks: oldData.tasks.map((task) => 
            task.id === taskId ? { ...task, status: completed ? 'completed' : 'in-progress' } : task
          ),
        };
      });
      
      return { previous };
    },
    
    // On successful mutation, show success message (silent in production)
    onSuccess: () => {
      if (__DEV__) {
        Alert.alert('Success', 'Task status updated');
      }
    },
    
    // If mutation fails, roll back optimistic update
    onError: (error, variables, context) => {
      if (context?.previous) {
        utils.dashboard.getDashboardData.setData(undefined, context.previous);
      }
      Alert.alert('Error', error.message || 'Failed to update task');
    },
    
    // Regardless of outcome, invalidate queries to refetch data
    onSettled: () => {
      utils.dashboard.getDashboardData.invalidate();
    },
  });
}
  ```

- **app/planner/add-habit.tsx** (0.5 KB, 19 lines)

  *Exports: `default` (function)*
  ```tsx
export default function AddHabitScreen() {
  return (
    <SafeAreaView style={{ flex: 1 }}>
      <ScrollView>
        <YStack flex={1} padding="$4" space="$4">
          <H1>Add New Habit</H1>
          <Text>Form to add a new habit will go here.</Text>
          <Button onPress={() => router.back()}>Go Back</Button>
        </YStack>
      </ScrollView>
    </SafeAreaView>
  );
}
  ```

- **app/planner/index.tsx** (0.2 KB, 4 lines)

  *Exports: `default` (unknown)*
  ```tsx
export default () => <YStack f={1} jc="center" ai="center"><H2>Planner coming soon</H2></YStack>
  ```

- **app/settings/index.tsx** (0.2 KB, 4 lines)

  *Exports: `default` (unknown)*
  ```tsx
export default () => <YStack f={1} jc="center" ai="center"><H2>Settings coming soon</H2></YStack>
  ```

- **app/states/[id].tsx** (0.9 KB, 24 lines) (1 TODOs)

  *Exports: `default` (function)*
  ```tsx
export default function StateDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const router = useRouter();

  // TODO: Fetch state definition details using trpc.state.getDefinitionById.useQuery({ id })

  return (
    <SafeAreaView style={{ flex: 1 }}>
      <YStack flex={1} padding="$4" space="$4">
        <H2>State Definition Detail</H2>
        <Paragraph>Details for State Definition with ID: {id}</Paragraph>
        {/* TODO: Display actual state definition details and add edit functionality */}
        <Button onPress={() => router.back()}>Go Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

- **app/utils/api-types.ts** (0.6 KB, 22 lines)

  *Exports: `RouterInputs` (type)*
  ```ts
type RouterInputs = inferRouterInputs<AppRouter>;
  ```

  *Exports: `RouterOutputs` (type)*
  ```ts
type RouterOutputs = inferRouterOutputs<AppRouter>;
  ```

- **app/values/[id].tsx** (0.8 KB, 24 lines) (1 TODOs)

  *Exports: `default` (function)*
  ```tsx
export default function ValueDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const router = useRouter();

  // TODO: Fetch value details using trpc.value.getValueById.useQuery({ id })

  return (
    <SafeAreaView style={{ flex: 1 }}>
      <YStack flex={1} padding="$4" space="$4">
        <H2>Principle Detail</H2>
        <Paragraph>Details for Principle (Value) with ID: {id}</Paragraph>
        {/* TODO: Display actual value details and add edit functionality */}
        <Button onPress={() => router.back()}>Go Back</Button>
      </YStack>
    </SafeAreaView>
  );
}
  ```

### assets

- **assets/refresh-sheikah.json** (14.8 KB, 1 lines)

### components

- **components/EmptyOrSkeleton.tsx** (5.1 KB, 209 lines)

  *Exports: `default` (function)*
  ```tsx
export default function EmptyOrSkeleton({
  isLoading,
  isEmpty = false,
  children,
  skeletonCount = 3,
  skeletonHeight = 80,
  skeletonWidth = '100%',
  skeletonGap = 12,
  skeletonBorderRadius = 8,
  customSkeletonComponent,
  customEmptyComponent,
  skeletonOptions,
  title,
  message,
  image,
  containerStyle,
  titleStyle,
  messageStyle,
  imageContainerStyle,
  imageStyle,
  ...stackProps
}: EmptyOrSkeletonProps) {
  // If loading, show skeleton
  if (isLoading) {
    if (customSkeletonComponent) {
      return <>{customSkeletonComponent}</>;
    }
    
    return (
      <YStack space={skeletonGap} width="100%" {...stackProps}>
        {Array.from({ length: skeletonCount }).map((_, index) => (
          <SkeletonPlaceholder
            key={`skeleton-${index}`}
            height={skeletonHeight}
            width={skeletonWidth}
            borderRadius={skeletonBorderRadius}
            options={skeletonOptions}
          />
        ))}
      </YStack>
    );
  }
  
  // If empty, show empty state
  if (isEmpty) {
    if (customEmptyComponent) {
      return <>{customEmptyComponent}</>;
    }
    
    return (
      <EmptyState
        title={title}
        message={message}
        image={image}
        containerStyle={containerStyle}
        titleStyle={titleStyle}
        messageStyle={messageStyle}
        imageContainerStyle={imageContainerStyle}
        imageStyle={imageStyle}
      />
    );
  }
  
  // Otherwise, show children
  return <>{children}</>;
}
  ```

  *Exports: `EmptyOrSkeletonProps` (interface)*
  ```tsx
interface EmptyOrSkeletonProps extends EmptyStateProps, StackProps {
  /** Whether data is loading */
  isLoading: boolean;
  /** Children to display when not loading and not empty */
  children: ReactNode;
  /** Whether the content is empty (no data) */
  isEmpty?: boolean;
  /** Number of skeleton placeholders to display when loading */
  skeletonCount?: number;
  /** Height of each skeleton item */
  skeletonHeight?: number;
  /** Width of each skeleton item (default: 100%) */
  skeletonWidth?: number | string;
  /** Gap between skeleton items */
  skeletonGap?: number;
  /** Border radius for skeleton items */
  skeletonBorderRadius?: number;
  /** Custom skeleton component */
  customSkeletonComponent?: ReactNode;
  /** Options for the skeleton animation */
  skeletonOptions?: SkeletonOptions;
}
  ```

  *Exports: `EmptyStateProps` (interface)*
  ```tsx
interface EmptyStateProps {
  /** Title text for the empty state */
  title?: string;
  /** Subtitle/description text for the empty state */
  message?: string;
  /** Optional image/illustration to display */
  image?: ImageSourcePropType;
  /** Optional custom component to render instead of default empty state */
  customEmptyComponent?: ReactNode;
  /** Style for the container */
  containerStyle?: StyleProp<ViewStyle>;
  /** Style for the title */
  titleStyle?: StyleProp<TextStyle>;
  /** Style for the message */
  messageStyle?: StyleProp<TextStyle>;
  /** Style for the image container */
  imageContainerStyle?: StyleProp<ViewStyle>;
  /** Style for the image */
  imageStyle?: StyleProp<ImageStyle>;
}
  ```

- **components/aether/ProgressRing.tsx** (1.9 KB, 69 lines)

  *Exports: `default` (function)*
  ```tsx
export default function ProgressRing({
  progress: rawProgress,
  size = 60,
  strokeWidth = 6,
  primaryColor,
  secondaryColor,
  backgroundColor = 'transparent',
}: ProgressRingProps) {
  const theme = useTheme();
  
  // Normalize progress to 0-1 range
  const progress = rawProgress > 1 ? rawProgress / 100 : rawProgress;
  
  // Calculate radius and other dimensions
  const radius = (size - strokeWidth) / 2;
  const circumference = radius * 2 * Math.PI;
  const strokeDashoffset = circumference - progress * circumference;

  // Use theme colors if not explicitly provided
  const primary = primaryColor || theme.blue10.val;
  const secondary = secondaryColor || theme.gray4.val;

  return (
    <Stack width={size} height={size} backgroundColor={backgroundColor} alignItems="center" justifyContent="center">
      <Svg width={size} height={size}>
        {/* Background circle */}
        <Circle
          stroke={secondary}
          fill="none"
          cx={size / 2}
          cy={size / 2}
          r={radius}
          strokeWidth={strokeWidth}
        />
        
        {/* Progress circle */}
        <Circle
          stroke={primary}
          fill="none"
          cx={size / 2}
          cy={size / 2}
          r={radius}
          strokeWidth={strokeWidth}
          strokeDasharray={circumference}
          strokeDashoffset={strokeDashoffset}
          strokeLinecap="round"
          transform={`rotate(-90, ${size / 2}, ${size / 2})`} // Start from top
        />
      </Svg>
    </Stack>
  );
}
  ```

- **components/auth/FloatingInput.tsx** (5.6 KB, 208 lines)

  *Exports: `default` (function)*
  ```tsx
export default function FloatingInput({
  label,
  value,
  error,
  containerStyle,
  labelStyle,
  errorStyle,
  onFocusChange,
  leftIcon,
  rightIcon,
  adjustLabel = true,
  style,
  ...props
}: FloatingInputProps) {
  const [isFocused, setIsFocused] = useState(false);
  const inputRef = useRef<RNTextInput | null>(null);
  const animatedLabelValue = useSharedValue(value ? 1 : 0);
  const theme = useTheme();
  
  // Handle label animation when focus or value changes
  useEffect(() => {
    animatedLabelValue.value = withTiming(
      (isFocused || !!value) ? 1 : 0,
      {
        duration: 200, // Match durations.standard
        easing: Easing.bezier(0.4, 0.0, 0.2, 1.0),
      }
    );
  }, [isFocused, value, animatedLabelValue]);
  
  // Get dynamic colors from theme
  const colors = {
    input: {
      background: theme.inputBackground?.get() || theme.backgroundHover?.get() || '#F3F4F6',
      text: theme.color?.get() || '#111827',
      border: theme.borderColor?.get() || '#E5E7EB',
      focusBorder: theme.borderColorFocus?.get() || '#93C5FD',
      placeholderText: theme.colorTransparent?.get() || '#6B7280',
    },
    error: theme.red10?.get() || '#EF4444',
  };
  
  // Determine text color based on disabled state
  const textColor = props.editable === false 
    ? theme.colorTransparent?.get() || '#9CA3AF'
    : colors.input.text;
  
  // Handle focus changes
  const handleFocus = (event: any) => {
    setIsFocused(true);
    if (onFocusChange) onFocusChange(true);
    if (props.onFocus) props.onFocus(event);
  };
  
  const handleBlur = (event: any) => {
    setIsFocused(false);
    if (onFocusChange) onFocusChange(false);
    if (props.onBlur) props.onBlur(event);
  };
  
  // Animated styles
  const animatedLabelStyle = useAnimatedStyle(() => {
    return {
      position: 'absolute',
      left: leftIcon ? 40 : 16,
      top: adjustLabel ? 
        (16 + (-24 * animatedLabelValue.value)) : 
        (12 + (-20 * animatedLabelValue.value)),
      fontSize: 16 - (4 * animatedLabelValue.value),
      color: error ? colors.error : 
        animatedLabelValue.value > 0 ? 
          (isFocused ? colors.input.focusBorder : colors.input.placeholderText) : 
          colors.input.placeholderText,
      backgroundColor: animatedLabelValue.value > 0 ? 
        (theme.background?.get() || '#FFFFFF') : 'transparent',
      paddingHorizontal: 4 * animatedLabelValue.value,
      zIndex: 10,
    };
  });
  
  // Focus the input when the component is tapped
  const handleContainerPress = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };
  
  // Prepare input styles - flatten the array and provide default
  const inputStyles = StyleSheet.flatten([
    styles.input, 
    { color: textColor },
    leftIcon && { paddingLeft: 40 },
    rightIcon && { paddingRight: 40 },
    style // Style prop from component props
  ]) || {}; // Provide default empty style object
  
  return (
    <View style={[styles.container, containerStyle]}>
      <View 
        style={[
          styles.inputContainer, 
          { backgroundColor: colors.input.background },
          { borderColor: isFocused ? colors.input.focusBorder : colors.input.border },
          error && { borderColor: colors.error },
        ]} 
        onTouchStart={handleContainerPress}
      >
        {leftIcon && <View style={styles.leftIcon}>{leftIcon}</View>}
        
        <RNTextInput
          ref={inputRef}
          style={inputStyles}
          value={value}
          onFocus={handleFocus}
          onBlur={handleBlur}
          placeholderTextColor={colors.input.placeholderText}
          {...props}
        />
        
        {rightIcon && <View style={styles.rightIcon}>{rightIcon}</View>}
        
        <Animated.Text style={[animatedLabelStyle, labelStyle]}>
          {label}
        </Animated.Text>
      </View>
      
      {error && (
        <Text
          style={[styles.errorText, { color: colors.error }, errorStyle]}
          fontSize="$3"
          marginTop="$1"
        >
          {error}
        </Text>
      )}
    </View>
  );
}
  ```

  *Exports: `FloatingInputProps` (interface)*
  ```tsx
interface FloatingInputProps extends RNTextInputProps {
  /** Label for the input */
  label: string;
  /** Error message to display */
  error?: string;
  /** Container style */
  containerStyle?: object;
  /** Label style */
  labelStyle?: object;
  /** Error style */
  errorStyle?: object;
  /** Tamagui tokens for theming */
  tokens?: ReturnType<typeof getTokens>;
  /** Called when focus changes */
  onFocusChange?: (focused: boolean) => void;
  /** Left icon to display */
  leftIcon?: React.ReactNode;
  /** Right icon to display */
  rightIcon?: React.ReactNode;
  /** Whether to adjust label position */
  adjustLabel?: boolean;
}
  ```

- **components/compass/PrincipleCard.tsx** (1.1 KB, 41 lines)

  *Exports: `PrincipleCard` (function)*
  ```tsx
function PrincipleCard({ principle, onPress }: PrincipleCardProps) {
  return (
    <Card
      bordered
      padding="$4"
      elevation="$1"
      pressTheme
      hoverTheme
      onPress={onPress}
      animation="bouncy"
      scale={onPress ? 0.98 : 1} // Only apply scale if pressable
      hoverStyle={onPress ? { scale: 0.99 } : {}}
      pressStyle={onPress ? { scale: 0.96 } : {}}
    >
      <YStack>
        <Text fontSize="$5" fontWeight="bold">
          {principle.name}
        </Text>
        {principle.description && (
          <Text color="$colorFocus" marginTop="$2">
            {principle.description}
          </Text>
        )}
      </YStack>
    </Card>
  );
}
  ```

- **components/compass/PrinciplesTab.tsx** (1.2 KB, 47 lines)

  *Exports: `default` (function)*
  ```tsx
export default function PrinciplesTab() {
  const { data, isLoading, error, refetch } =
    trpc.value.getValues.useQuery();

  if (isLoading) return <EmptyOrSkeleton isLoading count={3} type="card" />;

  if (error)
    return (
      <EmptyOrSkeleton
        isError
        onRetry={refetch}
        text={error.message ?? 'Failed to load principles'}
      />
    );

  if (!Array.isArray(data) || !data.length)
    return (
      <EmptyOrSkeleton
        isEmpty
        text="No principles yet"
        actionText="Add Principle"
        onAction={() => router.push('/compose?type=value' as Href)}
      />
    );

  return (
    <YStack space="$3">
      {data.map((p: Principle) => (
        <PrincipleCard
          key={p.id}
          principle={p}
          onPress={() => router.push(`/values/${p.id}` as Href)}
        />
      ))}
    </YStack>
  );
}
  ```

- **components/compass/StateDefinitionCard.tsx** (1.3 KB, 47 lines)

  *Exports: `StateDefinitionCard` (function)*
  ```tsx
function StateDefinitionCard({ state, onPress }: StateDefinitionCardProps) {
  return (
    <Card
      bordered
      padding="$4"
      elevation="$1"
      pressTheme
      hoverTheme
      onPress={onPress}
      animation="bouncy"
      scale={onPress ? 0.98 : 1} // Only apply scale if pressable
      hoverStyle={onPress ? { scale: 0.99 } : {}}
      pressStyle={onPress ? { scale: 0.96 } : {}}
    >
      <YStack>
        <XStack alignItems="center" space="$3">
          <Text fontSize="$5" fontWeight="bold">
            {state.name}
          </Text>
          {/* Display scale type if available */}
          {state.scale && (
            <Text color="$colorFocus" fontSize="$2">({state.scale})</Text>
          )}
        </XStack>
        {state.description && (
          <Text color="$colorFocus" marginTop="$2">
            {state.description}
          </Text>
        )}
      </YStack>
    </Card>
  );
}
  ```

- **components/dashboard/DailyProgressBanner.tsx** (2.3 KB, 66 lines)

  *Exports: `default` (function)*
  ```tsx
export default function DailyProgressBanner({ 
  tasksCompleted = 3, // Placeholder
  totalTasks = 5, // Placeholder
  habitsChecked = 2, // Placeholder
  totalHabits = 4 // Placeholder
}: DailyProgressBannerProps) {
  const theme = useTheme();
  const taskProgress = totalTasks > 0 ? (tasksCompleted / totalTasks) * 100 : 0;
  const habitProgress = totalHabits > 0 ? (habitsChecked / totalHabits) * 100 : 0;

  return (
    <BlurView intensity={50} tint="default" style={{ borderRadius: 12, overflow: 'hidden', marginBottom: 16 }}>
      <XStack 
        padding="$3"
        space="$4"
        alignItems="center" 
        backgroundColor="$surfaceSubtle" // Use subtle background from theme
      >
        {/* Tasks Progress */}
        <YStack flex={1} space="$1">
          <XStack space="$2" alignItems="center">
            <CheckSquare size={16} color={theme.accent?.get()} />
            <Text fontSize="$3" fontWeight="bold" color="$onSurface">
              Tasks
            </Text>
          </XStack>
          <Progress size="$1" value={taskProgress}>
            <Progress.Indicator animation="bouncy" backgroundColor="$accent" />
          </Progress>
          <Text fontSize="$1" color="$onSurfaceSubtle">
            {tasksCompleted} / {totalTasks} done
          </Text>
        </YStack>

        {/* Habits Progress */}
        <YStack flex={1} space="$1">
          <XStack space="$2" alignItems="center">
            <Target size={16} color={theme.accent?.get()} />
            <Text fontSize="$3" fontWeight="bold" color="$onSurface">
              Habits
            </Text>
          </XStack>
          <Progress size="$1" value={habitProgress}>
            <Progress.Indicator animation="bouncy" backgroundColor="$accent" />
          </Progress>
          <Text fontSize="$1" color="$onSurfaceSubtle">
            {habitsChecked} / {totalHabits} checked
          </Text>
        </YStack>
      </XStack>
    </BlurView>
  );
}
  ```

- **components/dashboard/DashboardSection.tsx** (2.4 KB, 83 lines)

  *Exports: `default` (function)*
  ```tsx
export default function DashboardSection<T>({ 
  title, 
  data, 
  isLoading, 
  emptyMessage,
  seeAllRoute,
  renderItem,
  skeletonCount = 2,
  error,
  onRetry,
  children,
  onSeeAll
}: DashboardSectionProps<T>) {
  return (
    <YStack space="$2">
      <XStack justifyContent="space-between" alignItems="center" marginBottom="$2" paddingHorizontal="$2">
        <H4>{title}</H4>
        {((data && data.length > 0 && seeAllRoute) || onSeeAll) && (
          <Button 
            chromeless 
            size="$2" 
            onPress={() => {
              if (onSeeAll) {
                onSeeAll();
              } else if (seeAllRoute) {
                // Navigate to route using type assertions
                // Safe because the route will be a tab/screen name within the app
                router.push(seeAllRoute as any);
              }
            }}
          >
            See All
          </Button>
        )}
      </XStack>
      
      {/* Wrap content in BlurView */}
      <BlurView 
        intensity={50} 
        tint="default" 
        style={{ borderRadius: 12, overflow: 'hidden' }} 
      >
        <YStack padding="$3">
          {/* If children are provided, render them */}
          {children ? (
            children
          ) : isLoading ? (
            <SkeletonRow lines={skeletonCount} />
          ) : error ? (
            <SectionError message={error ? String(error) : 'An error occurred'} onRetry={onRetry} />
          ) : data && data.length === 0 ? (
            <YStack alignItems="center" padding="$4">
              <Text color="$gray10">{emptyMessage ?? 'No items found'}</Text>
            </YStack>
          ) : (
            data && renderItem && data.map(renderItem)
          )}
        </YStack>
      </BlurView>
    </YStack>
  );
}
  ```

- **components/dashboard/GoalSummaryCard.tsx** (1.5 KB, 58 lines)

  *Exports: `default` (function)*
  ```tsx
export default function GoalSummaryCard({ goal, onPress }: GoalSummaryCardProps) {
  return (
    <BlurView 
      intensity={50} 
      tint="default" 
      style={{ borderRadius: 12, overflow: 'hidden' }}
    >
      <Button 
        chromeless // Remove default button styling
        padding="$3" 
        onPress={onPress}
        width="100%" // Ensure it fills the BlurView
      >
        <XStack alignItems="center" space="$3" flex={1}> 
          <ProgressRing
            progress={goal.progress}
            size={40}
            primaryColor="$primary"
          />
          <XStack flex={1} flexDirection="column">
            <Text fontSize="$4" fontWeight="500" color="$color">
              {goal.title}
            </Text>
            {goal.tasks && (
              <Text color="$gray9" fontSize="$2">
                {goal.tasks.completed}/{goal.tasks.total} tasks completed
              </Text>
            )}
          </XStack>
        </XStack>
      </Button>
    </BlurView>
  );
}
  ```

- **components/dashboard/HabitCheckItem.tsx** (4.4 KB, 154 lines)

  *Exports: `default` (function)*
  ```tsx
export default function HabitCheckItem({ habit, onToggle }: HabitCheckItemProps) {
  const [checked, setChecked] = useState(habit.completed);
  const [isUpdating, setIsUpdating] = useState(false);
  const theme = useTheme(); 
  const utils = trpc.useUtils(); 

  // Define specific theme colors with safe access and fallbacks to theme variables
  const green10 = theme?.green10?.val ?? '$green10'; 
  const gray10 = theme?.gray10?.val ?? '$gray10'; 
  const orange10 = theme?.orange10?.val ?? '$orange10'; 


  const createEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: (updatedHabit) => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error creating habit entry:', error);
    }
  });

  const deleteEntryMutation = trpc.habit.deleteHabitEntry.useMutation({
    onSuccess: () => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error deleting habit entry:', error);
    }
  });

  useEffect(() => {
    setChecked(habit.completed);
  }, [habit.completed]);

  const handleToggle = () => {
    const newValue = !checked;
    setChecked(newValue); 
    setIsUpdating(true);

    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);

    const todayDateString = new Date().toISOString().split('T')[0];

    if (newValue) {
      const createInput: CreateHabitEntryInput = {
        habit_id: habit.id,
        date: todayDateString,
        completed: true, 
        quantity_value: null, 
        notes: null, 
      };
      createEntryMutation.mutate(createInput);
    } else {
      if (habit.last_entry_id) { 
        const deleteInput: DeleteHabitEntryInput = {
          id: habit.last_entry_id, 
        };
        deleteEntryMutation.mutate(deleteInput);
      } else {
        console.warn("Attempted to delete habit entry, but last_entry_id is missing.");
      }
    }

    if (onToggle) {
      onToggle(habit.id, newValue);
    }
  };

  const streakColor = checked ? green10 : gray10; // Use safe theme value
  const habitTypeColor = orange10; // Use safe theme value

  return (
    <XStack 
      backgroundColor="$backgroundStrong" // Use theme variable
      padding="$3"
      borderRadius="$4"
      alignItems="center"
      justifyContent="space-between"
      space="$3"
    >
      <YStack flex={1} gap="$1">
        <Text fontSize="$4" fontWeight="500" color="$color"> // Use theme variable
          {habit.name}
        </Text>
        
        {habit.streak != null && habit.streak > 0 && ( // Add null check
          <Text fontSize="$2" color={streakColor}> 
            Streak: {habit.streak ?? 0}
          </Text>
        )}
        {habit.habit_type && (
          <Text fontSize="$2" color={habitTypeColor}> // Use safe theme value
            ({habit.habit_type})
          </Text>
        )}
      </YStack>
      
      <Button
        size="$3"
        variant={checked ? undefined : 'outlined'} // Let variant handle appearance
        // Remove explicit colors - rely on theme/variant
        theme={checked ? 'green' : undefined} // Apply green theme when checked
        onPress={handleToggle}
        disabled={isUpdating} 
        iconAfter={checked ? <Text>✓</Text> : undefined}
      >
        {checked ? "Done" : "Check-in"}
      </Button>
    </XStack>
  );
}
  ```

- **components/dashboard/StateIndicator.tsx** (1.7 KB, 55 lines)

  *Exports: `default` (function)*
  ```tsx
export default function StateIndicator({ state, onPress, lastEntry }: StateIndicatorProps) {
  // Format the last updated time
  const formattedTime = state.lastUpdated 
    ? new Date(state.lastUpdated).toLocaleTimeString([], { 
        hour: '2-digit', 
        minute: '2-digit' 
      })
    : 'N/A';
  
  // Use Tamagui Card component
  return (
    <Card 
      onPress={onPress} 
      pressStyle={{ opacity: 0.8 }}
      padding="$3"
      // No explicit background, will use default Card background from theme
    >
      <YStack space="$1"> {/* Main container for text */}
        <XStack flex={1} alignItems="center">
          <Text fontSize="$4" fontWeight="500">{state.name}</Text>
          {lastEntry && (
            <Text fontSize="$2" color="$gray10" marginLeft="$2">
              ({formattedTime})
            </Text>
          )}
        </XStack>
        <XStack alignItems="baseline" space="$2"> {/* Align text by baseline, add space */}
          <Text fontSize="$5" fontWeight="600" color="$color"> {/* Use tokens */}
            {state.currentValue}
          </Text>
        </XStack>
        {!lastEntry && (
          <Text fontSize="$2" color="$gray10" marginTop="$1">
            No data recorded yet.
          </Text>
        )}
      </YStack>
    </Card>
  );
}
  ```

- **components/dashboard/TaskItem.tsx** (5.9 KB, 181 lines)

  *Exports: `default` (function)*
  ```tsx
export default function TaskItem({ task, onPress }: TaskItemProps) {
 
 // Setup toggleTask mutation with optimistic updates
 const utils = trpc.useContext();
 // Setup mutation for task toggling
 const toggleTaskMutation = trpc.task.toggleTask.useMutation({
   // Optimistically update the UI
   onMutate: async ({ taskId, completed }: { taskId: string; completed?: boolean }) => {
     // Default to toggling the current state if completed is not provided
     const newCompleted = completed !== undefined ? completed : !isCompleted;
     // Cancel outgoing fetches that might overwrite our optimistic update
     await utils.task.getTasks.cancel();
     await utils.dashboard.getDashboardData.cancel();
     
     // Get previous data for potential rollback
     const prevTasksData = utils.task.getTasks.getData();
     const prevDashboardData = utils.dashboard.getDashboardData.getData();
     
     // Optimistically update tasks data if present
     if (prevTasksData) {
       utils.task.getTasks.setData({ goalId: undefined } as any, (old: any) => {
         if (!old) return old;
         return old.map((t: any) => {
           if (t.id === taskId) {
             return {
               ...t,
               status: completed ? 'completed' : 'in-progress'
             };
           }
           return t;
         });
       });
     }
     
     // Optimistically update dashboard data if present
     if (prevDashboardData) {
       utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, (old: any) => {
         if (!old) return old;
         return {
           ...old,
           tasks: old.tasks.map((t: any) => {
             if (t.id === taskId) {
               return {
                 ...t,
                 status: newCompleted ? 'completed' : 'in-progress'
               };
             }
             return t;
           }),
         };
       });
     }
     
     // Return previous data for rollback
     return { prevTasksData, prevDashboardData };
   },
   
   // If something goes wrong, rollback optimistic updates
   onError: (err: any, variables: any, context: any) => {
     if (context?.prevTasksData) {
       utils.task.getTasks.setData({ goalId: undefined } as any, context.prevTasksData);
     }
     if (context?.prevDashboardData) {
       utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, context.prevDashboardData);
     }
     console.error('Error toggling task:', err);
   },
   
   // Always refetch after error or success
   onSettled: () => {
     utils.task.getTasks.invalidate();
     utils.dashboard.getDashboardData.invalidate();
   }
 });

 // Handle checkbox toggle
 const handleToggle = () => {
   toggleTaskMutation.mutate({
     taskId: task.id, // Using taskId as expected by the backend
     completed: !isCompleted
   });
 };

 // Map priority to color
 const priorityColor = task.priority === 1 ? '$brandRed' : 
                       task.priority === 2 ? '$brandYellow' : 
                       '$brandGreen';
 
 // Format due date
 const formattedDate = task.due_date 
   ? new Date(task.due_date).toLocaleDateString(undefined, { 
       month: 'short', 
       day: 'numeric' 
     })
   : null;
   
 // Determine task completion status
 const isCompleted = task.status === 'completed';
 // No need for text style object since we use Tamagui props directly

 
 // Use YStack as the base component
 return (
   <YStack 
     backgroundColor="$backgroundStrong"
     padding="$3"
     borderRadius="$4"
     space="$1" // Add space between XStack and Date Text
   >
     <XStack alignItems="center" space="$2"> {/* Use XStack for horizontal layout */}
       {/* Checkbox for task completion */}
       <Checkbox
         size="$4"
         checked={isCompleted}
         onCheckedChange={handleToggle}
         disabled={toggleTaskMutation.isPending}
       >
         {toggleTaskMutation.isPending ? (
           <Spinner size="small" color="$brandPrimary" />
         ) : (
           <Checkbox.Indicator>
             <Check size={16} />
           </Checkbox.Indicator>
         )}
       </Checkbox>

       {/* Container for task details (clickable) */}
       <XStack flex={1} tag="pressable" onPress={onPress} pressStyle={{ opacity: 0.7 }}>
         {/* Priority Dot using YStack */}
         <YStack 
           width="$2" // Use size token for width
           height="$2" // Use size token for height
           borderRadius="$10" // Use a large radius token
           backgroundColor={priorityColor} 
           marginRight="$2" // Use space token for margin
         />
         <Text 
           fontSize="$4" // Use font size token
           fontWeight={task.priority === 1 ? '600' : '400'} // Keep fontWeight
           color="$color"
           flex={1} // Allow text to take remaining space
           opacity={isCompleted ? 0.7 : 1}
... /* snippet truncated */
  ```

- **components/lists/GoalList.tsx** (4.6 KB, 158 lines)

  *Exports: `GoalCard` (function)*
  ```tsx
function GoalCard({ goal, onPress }: { goal: Goal; onPress: () => void }) {
  // Calculate progress percentage for the progress ring
  const progressPercent = goal.progress ? goal.progress : 0;
  
  // Format the target date
  const formattedDate = goal.target_date
    ? new Date(goal.target_date).toLocaleDateString(undefined, {
        month: 'short',
        day: 'numeric',
      })
    : 'No due date';

  return (
    <AetherCard 
      isInteractive 
      variant="default"
      onPress={onPress}
    >
      <YStack space="$2">
        {/* Title */}
        <YStack>
          <XStack space="$2" alignItems="center">
            <Ionicons name="trophy-outline" size={18} color="$primary" />
            <Text fontSize="$5" fontWeight="bold" color="$color">
              {goal.title}
            </Text>
          </XStack>
        </YStack>
        
        {/* Description if available */}
        {goal.description && (
          <Text color="$colorMuted" fontSize="$3" numberOfLines={2}>
            {goal.description}
          </Text>
        )}
        
        {/* Footer with date and progress */}
        <XStack justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center">
            <Ionicons name="calendar-outline" size={16} color="$colorMuted" />
            <Text fontSize="$2" color="$colorMuted">
              {formattedDate}
            </Text>
          </XStack>
          
          {/* Progress display */}
          <XStack backgroundColor="$background" paddingHorizontal="$2" paddingVertical="$1" borderRadius="$2">
            <Text fontSize="$2" fontWeight="bold" color={progressPercent >= 75 ? '$success' : '$primary'}>
              {progressPercent}%
            </Text>
          </XStack>
        </XStack>
      </YStack>
    </AetherCard>
  );
}
  ```

  *Exports: `GoalList` (function)*
  ```tsx
function GoalList({ goals, isLoading, isError, refetch, onSelectGoal }: GoalListProps) {
  const renderGoalItem: ListRenderItem<Goal> = ({ item }) => (
    <GoalCard 
      goal={item} 
      onPress={() => {
        if (onSelectGoal) {
          onSelectGoal(item);
        } else {
          // Default navigation
          router.push({ 
            pathname: '/planner/goal/[id]', 
            params: { id: item.id } 
          });
        }
      }} 
    />
  );

  if (isLoading) {
    return <EmptyOrSkeleton isLoading count={3} type="card" />;
  }

  if (isError) {
    return (
      <YStack padding="$4" space="$4" alignItems="center" justifyContent="center">
        <Ionicons name="alert-circle-outline" size={48} color="$error" />
        <YStack>
          <YStack alignItems="center">
            <Text fontSize="$5" fontWeight="bold" color="$color" textAlign="center">
              Unable to load goals
            </Text>
            <Text fontSize="$3" color="$colorMuted" textAlign="center" marginTop="$2">
              Please check your connection and try again
            </Text>
          </YStack>
        </YStack>
        <AetherCard onPress={refetch} isInteractive padding="$3" paddingHorizontal="$5">
          <XStack alignItems="center" space="$2">
            <Ionicons name="refresh-outline" size={18} color="$primary" />
            <Text fontSize="$4" fontWeight="500" color="$primary">
              Retry
            </Text>
          </XStack>
        </AetherCard>
      </YStack>
    );
  }

  if (!goals || goals.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty 
        text="No goals yet" 
        actionText="Create a goal" 
        onAction={() => router.push('/planner/add-goal')} 
      />
    );
  }

  return (
    <FlatList
      data={goals}
      keyExtractor={(item) => item.id}
      renderItem={renderGoalItem}
      contentContainerStyle={{ padding: 16, paddingBottom: 32 }}
      ItemSeparatorComponent={() => <YStack height="$4" />}
      refreshControl={
        <RefreshControl 
          refreshing={isLoading} 
          onRefresh={refetch} 
        />
      }
    />
  );
}
  ```

- **components/lists/HabitList.tsx** (5.4 KB, 193 lines)

  *Exports: `HabitCard` (function)*
  ```tsx
function HabitCard({ 
  habit, 
  onPress, 
  onToggle 
}: { 
  habit: Habit; 
  onPress: () => void; 
  onToggle?: (completed: boolean) => void;
}) {
  // Calculate progress streak display
  const streakText = habit.streak === 1 
    ? '1 day'
    : `${habit.streak} days`;

  const bestStreakText = habit.best_streak === 1
    ? '1 day'
    : `${habit.best_streak} days`;

  // Check if the habit has been completed today
  const [isCompleted, setIsCompleted] = React.useState(false); // This would come from habit entries

  const handleToggle = () => {
    const newStatus = !isCompleted;
    setIsCompleted(newStatus);
    if (onToggle) {
      onToggle(newStatus);
    }
  };

  return (
    <AetherCard 
      isInteractive 
      variant="default"
      onPress={onPress}
    >
      <YStack space="$2">
        {/* Title with completion toggle */}
        <XStack space="$3" justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center" flex={1}>
            <Ionicons name="repeat-outline" size={18} color="$primary" />
            <Text fontSize="$5" fontWeight="bold" color="$color" numberOfLines={1} flex={1}>
              {habit.title}
            </Text>
          </XStack>
          
          {/* Toggle button for completing today's habit */}
          <Stack 
            onPress={handleToggle}
            pressStyle={{ opacity: 0.8 }}
          >
            <Ionicons 
              name={isCompleted ? "checkmark-circle" : "checkmark-circle-outline"} 
              size={26} 
              color={isCompleted ? "$success" : "$colorMuted"} 
            />
          </Stack>
        </XStack>
        
        {/* Streak information */}
        <XStack justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center">
            <Ionicons name="flame-outline" size={16} color="$colorMuted" />
            <Text fontSize="$2" color="$colorMuted">
              Current: {streakText}
            </Text>
          </XStack>
          
          <XStack space="$2" alignItems="center">
            <Ionicons name="trophy-outline" size={16} color="$colorMuted" />
            <Text fontSize="$2" color="$colorMuted">
              Best: {bestStreakText}
            </Text>
          </XStack>
        </XStack>
      </YStack>
    </AetherCard>
  );
}
  ```

  *Exports: `HabitList` (function)*
  ```tsx
function HabitList({ 
  habits, 
  isLoading, 
  isError, 
  refetch, 
  onSelectHabit,
  onToggleHabit 
}: HabitListProps) {
  const renderHabitItem: ListRenderItem<Habit> = ({ item }) => (
    <HabitCard 
      habit={item} 
      onPress={() => {
        if (onSelectHabit) {
          onSelectHabit(item);
        } else {
          // Default navigation
          router.push({ 
            pathname: '/planner/habit/[id]', 
            params: { id: item.id } 
          });
        }
      }}
      onToggle={(completed) => {
        if (onToggleHabit) {
          onToggleHabit(item.id, completed);
        }
      }}
    />
  );

  if (isLoading) {
    return <EmptyOrSkeleton isLoading count={3} type="card" />;
  }

  if (isError) {
    return (
      <YStack padding="$4" space="$4" alignItems="center" justifyContent="center">
        <Ionicons name="alert-circle-outline" size={48} color="$error" />
        <YStack>
          <YStack alignItems="center">
            <Text fontSize="$5" fontWeight="bold" color="$color" textAlign="center">
              Unable to load habits
            </Text>
            <Text fontSize="$3" color="$colorMuted" textAlign="center" marginTop="$2">
              Please check your connection and try again
            </Text>
          </YStack>
        </YStack>
        <AetherCard onPress={refetch} isInteractive padding="$3" paddingHorizontal="$5">
          <XStack alignItems="center" space="$2">
            <Ionicons name="refresh-outline" size={18} color="$primary" />
            <Text fontSize="$4" fontWeight="500" color="$primary">
              Retry
            </Text>
          </XStack>
        </AetherCard>
      </YStack>
    );
  }

  if (!habits || habits.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty 
        text="No habits yet" 
        actionText="Create a habit" 
        onAction={() => router.push('/planner/add-habit')} 
      />
    );
  }

  return (
    <FlatList
      data={habits}
      keyExtractor={(item) => item.id}
      renderItem={renderHabitItem}
      contentContainerStyle={{ padding: 16, paddingBottom: 32 }}
      ItemSeparatorComponent={() => <YStack height="$4" />}
      refreshControl={
        <RefreshControl 
          refreshing={isLoading} 
          onRefresh={refetch} 
        />
      }
    />
  );
}
  ```

- **components/lists/TaskList.tsx** (6.2 KB, 221 lines)

  *Exports: `TaskCard` (function)*
  ```tsx
function TaskCard({ 
  task, 
  onPress, 
  onComplete 
}: { 
  task: Task; 
  onPress: () => void; 
  onComplete?: (completed: boolean) => void;
}) {
  // Get the completion status of the task
  const [isCompleted, setIsCompleted] = React.useState(Boolean(task.completed));
  
  // Format the due date
  const formattedDate = task.due
    ? new Date(task.due).toLocaleDateString(undefined, {
        month: 'short',
        day: 'numeric',
      })
    : 'No due date';
    
  // Check if task is overdue
  const isOverdue = task.due && new Date(task.due) < new Date() && !isCompleted;

  const handleToggle = () => {
    const newStatus = !isCompleted;
    setIsCompleted(newStatus);
    if (onComplete) {
      onComplete(newStatus);
    }
  };

  return (
    <AetherCard 
      isInteractive 
      variant="default"
      onPress={onPress}
    >
      <YStack space="$2">
        {/* Title with completion toggle */}
        <XStack space="$3" justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center" flex={1}>
            <Stack 
              onPress={handleToggle}
              pressStyle={{ opacity: 0.8 }}
            >
              <Ionicons 
                name={isCompleted ? "checkmark-circle" : "checkmark-circle-outline"} 
                size={26} 
                color={isCompleted ? "$success" : "$colorMuted"} 
              />
            </Stack>
            <Text 
              fontSize="$5" 
              fontWeight="bold" 
              color={isCompleted ? "$colorMuted" : "$color"} 
              numberOfLines={1} 
              flex={1}
              textDecorationLine={isCompleted ? 'line-through' : 'none'}
            >
              {task.title}
            </Text>
          </XStack>
        </XStack>
        
        {/* Notes if available */}
        {task.notes && !isCompleted && (
          <Text color="$colorMuted" fontSize="$3" numberOfLines={2} paddingLeft="$7">
            {task.notes}
          </Text>
        )}
        
        {/* Footer with due date and goal information */}
        <XStack justifyContent="space-between" alignItems="center" paddingLeft="$7">
          <XStack space="$2" alignItems="center">
            <Ionicons 
              name="calendar-outline" 
              size={16} 
              color={isOverdue ? "$error" : "$colorMuted"} 
            />
            <Text 
              fontSize="$2" 
              color={isOverdue ? "$error" : "$colorMuted"}
              fontWeight={isOverdue ? "bold" : "normal"}
            >
              {isOverdue ? "Overdue: " : ""}{formattedDate}
            </Text>
          </XStack>
          
          {/* If task is linked to a goal, show goal name */}
          {task.goal_id && (
            <XStack 
              backgroundColor="$backgroundStrong" 
              paddingHorizontal="$2" 
              paddingVertical="$1" 
              borderRadius="$2"
            >
              <Text fontSize="$2" color="$primary">
                {task.goal?.title || 'Linked goal'}
              </Text>
            </XStack>
          )}
        </XStack>
      </YStack>
    </AetherCard>
  );
}
  ```

  *Exports: `TaskList` (function)*
  ```tsx
function TaskList({ 
  tasks, 
  isLoading, 
  isError, 
  refetch, 
  onSelectTask,
  onCompleteTask 
}: TaskListProps) {
  const renderTaskItem: ListRenderItem<Task> = ({ item }) => (
    <TaskCard 
      task={item} 
      onPress={() => {
        if (onSelectTask) {
          onSelectTask(item);
        } else {
          // Default navigation
          router.push({ 
            pathname: '/planner/task/[id]', 
            params: { id: item.id } 
          });
        }
      }}
      onComplete={(completed) => {
        if (onCompleteTask) {
          onCompleteTask(item.id, completed);
        }
      }}
    />
  );

  if (isLoading) {
    return <EmptyOrSkeleton isLoading count={3} type="card" />;
  }

  if (isError) {
    return (
      <YStack padding="$4" space="$4" alignItems="center" justifyContent="center">
        <Ionicons name="alert-circle-outline" size={48} color="$error" />
        <YStack>
          <YStack alignItems="center">
            <Text fontSize="$5" fontWeight="bold" color="$color" textAlign="center">
              Unable to load tasks
            </Text>
            <Text fontSize="$3" color="$colorMuted" textAlign="center" marginTop="$2">
              Please check your connection and try again
            </Text>
          </YStack>
        </YStack>
        <AetherCard onPress={refetch} isInteractive padding="$3" paddingHorizontal="$5">
          <XStack alignItems="center" space="$2">
            <Ionicons name="refresh-outline" size={18} color="$primary" />
            <Text fontSize="$4" fontWeight="500" color="$primary">
              Retry
            </Text>
          </XStack>
        </AetherCard>
      </YStack>
    );
  }

  if (!tasks || tasks.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty 
        text="No tasks yet" 
        actionText="Create a task" 
        onAction={() => router.push('/planner/add-task')} 
      />
    );
  }

  return (
    <FlatList
      data={tasks}
      keyExtractor={(item) => item.id}
      renderItem={renderTaskItem}
      contentContainerStyle={{ padding: 16, paddingBottom: 32 }}
      ItemSeparatorComponent={() => <YStack height="$4" />}
      refreshControl={
        <RefreshControl 
          refreshing={isLoading} 
          onRefresh={refetch} 
        />
      }
    />
  );
}
  ```

- **components/lists/index.ts** (0.3 KB, 7 lines)

  *Exports: `GoalCard` (re-export)*
  ```ts
export { GoalCard }
  ```

  *Exports: `GoalList` (re-export)*
  ```ts
export { GoalList }
  ```

  *Exports: `HabitCard` (re-export)*
  ```ts
export { HabitCard }
  ```

  *Exports: `HabitList` (re-export)*
  ```ts
export { HabitList }
  ```

  *Exports: `TaskCard` (re-export)*
  ```ts
export { TaskCard }
  ```

  *Exports: `TaskList` (re-export)*
  ```ts
export { TaskList }
  ```

- **components/planner/GoalsList.tsx** (5.3 KB, 198 lines)

  *Exports: `default` (function)*
  ```tsx
export default function GoalsList({
  goals = [],
  isLoading = false,
  onGoalPress,
  onAddPress,
  style,
}: GoalsListProps) {
  const colors = useColors();
  
  return (
    <YStack flex={1} style={style}>
      <EmptyOrSkeleton
        isLoading={isLoading}
        isEmpty={goals.length === 0}
        skeletonCount={3}
        skeletonHeight={160}
        skeletonBorderRadius={12}
        title="No goals yet"
        message="Create a new goal to track your progress"
      >
        <FlashList
          data={goals}
          renderItem={({ item }) => (
            <GoalCard goal={item} onPress={onGoalPress} />
          )}
          estimatedItemSize={180}
          contentContainerStyle={styles.listContent}
          ItemSeparatorComponent={() => <View style={styles.separator} />}
        />
      </EmptyOrSkeleton>
      
      {onAddPress && (
        <Pressable
          onPress={onAddPress}
          style={({ pressed }) => [
            styles.addButton,
            {
              backgroundColor: colors.brand.primary,
              opacity: pressed ? 0.9 : 1,
              transform: [{ scale: pressed ? 0.97 : 1 }],
            }
          ]}
        >
          <Text fontSize="$4" fontWeight="$3" color="white">
            + Add Goal
          </Text>
        </Pressable>
      )}
    </YStack>
  );
}
  ```

  *Exports: `Goal` (interface)*
  ```tsx
interface Goal {
  id: string;
  title: string;
  description?: string;
  progress: number; // 0 to 1
  deadline?: string; // ISO date string
  userId: string;
  createdAt: string;
  updatedAt: string;
}
  ```

  *Exports: `GoalsListProps` (interface)*
  ```tsx
interface GoalsListProps {
  /** List of goals to display */
  goals?: Goal[];
  /** Whether the data is loading */
  isLoading?: boolean;
  /** Called when a goal is pressed */
  onGoalPress?: (goal: Goal) => void;
  /** Called when the add button is pressed */
  onAddPress?: () => void;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}
  ```

- **components/planner/HabitTracker.tsx** (3.4 KB, 135 lines)

  *Exports: `HabitTracker` (function)*
  ```tsx
function HabitTracker({
  habits = [],
  onAddHabit,
  onToggleHabit,
  onHabitPress,
}: HabitTrackerProps) {
  const today = format(new Date(), "yyyy-MM-dd");

  const handleToggleHabit = (habit: Habit) => {
    if (!onToggleHabit) return;
    
    const isCompleted = habit.completedDates.includes(today);
    onToggleHabit(habit.id, today, !isCompleted);
  };

  return (
    <YStack space="$4">
      <XStack justifyContent="space-between" alignItems="center">
        <H4>Habits</H4>
        <Button 
          size="$2" 
          circular 
          icon={<Plus size={16} />} 
          onPress={onAddHabit}
        />
      </XStack>

      {habits.length === 0 ? (
        <YStack 
          p="$4"
          alignItems="center" 
          justifyContent="center" 
          backgroundColor="$gray2" 
          borderRadius="$4"
        >
          <Text color="$gray11" textAlign="center">
            No habits yet. Add your first habit to start tracking.
          </Text>
        </YStack>
      ) : (
        <YStack space="$3">
          {habits.map((habit, index) => (
            <YStack key={habit.id} space="$2">
              {index > 0 && <Separator />}
              <HabitItem 
                habit={habit} 
                onToggle={() => handleToggleHabit(habit)}
                onPress={() => onHabitPress?.(habit)} 
              />
            </YStack>
          ))}
        </YStack>
      )}
    </YStack>
  );
}
  ```

- **components/planner/HabitsList.tsx** (5.7 KB, 220 lines)

  *Exports: `default` (function)*
  ```tsx
export default function HabitsList({
  habits = [],
  isLoading = false,
  onToggleHabit,
  onHabitPress,
  onAddPress,
  style,
}: HabitsListProps) {
  const colors = useColors();
  
  return (
    <YStack flex={1} style={style}>
      <EmptyOrSkeleton
        isLoading={isLoading}
        isEmpty={habits.length === 0}
        skeletonCount={4}
        skeletonHeight={80}
        skeletonBorderRadius={12}
        title="No habits yet"
        message="Create a habit to track your daily progress"
      >
        <YStack space="$2" padding="$4">
          {habits.map((habit) => (
            <HabitItem
              key={habit.id}
              habit={habit}
              onToggle={onToggleHabit}
              onPress={onHabitPress}
            />
          ))}
        </YStack>
      </EmptyOrSkeleton>
      
      {onAddPress && (
        <Pressable
          onPress={onAddPress}
          style={({ pressed }) => [
            styles.addButton,
            {
              backgroundColor: colors.brand.primary,
              opacity: pressed ? 0.9 : 1,
              transform: [{ scale: pressed ? 0.97 : 1 }],
            }
          ]}
        >
          <Text fontSize="$4" fontWeight="$3" color="white">
            + Add Habit
          </Text>
        </Pressable>
      )}
    </YStack>
  );
}
  ```

  *Exports: `Habit` (interface)*
  ```tsx
interface Habit {
  id: string;
  title: string;
  description?: string;
  frequency: 'daily' | 'weekly' | 'monthly';
  completedToday: boolean;
  streak: number;
  userId: string;
  createdAt: string;
  updatedAt: string;
}
  ```

  *Exports: `HabitsListProps` (interface)*
  ```tsx
interface HabitsListProps {
  /** List of habits to display */
  habits?: Habit[];
  /** Whether the data is loading */
  isLoading?: boolean;
  /** Called when a habit's completion status is toggled */
  onToggleHabit?: (habitId: string, completed: boolean) => Promise<void>;
  /** Called when a habit item is pressed */
  onHabitPress?: (habit: Habit) => void;
  /** Called when the add button is pressed */
  onAddPress?: () => void;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}
  ```

- **components/planner/StreakCalendar.tsx** (5.0 KB, 189 lines)

  *Exports: `default` (function)*
  ```tsx
export default function StreakCalendar({
  completedDates = [],
  weekCount = 4,
  style,
}: StreakCalendarProps) {
  const today = new Date();

  const completedDatesObjects = useMemo(() => {
    return completedDates.map(dateStr => new Date(dateStr));
  }, [completedDates]);

  // Generate weeks from the current week backwards
  const weeks = useMemo(() => {
    const result = [];
    const day = startOfWeek(today, { weekStartsOn: 0 }); // Sunday as first day

    // Get current week
    const currentWeek = Array(7)
      .fill(null)
      .map((_, i) => {
        const date = addDays(day, i);
        return {
          date,
          completed: completedDatesObjects.some((d) => isSameDay(d, date)),
          isToday: isSameDay(date, today),
          isPast: date < today,
          isFuture: date > today,
        };
      });
    result.push(currentWeek);

    // Get previous weeks
    for (let i = 1; i < weekCount; i++) {
      const startDay = subWeeks(day, i);
      const week = Array(7)
        .fill(null)
        .map((_, j) => {
          const date = addDays(startDay, j);
          return {
            date,
            completed: completedDatesObjects.some((d) => isSameDay(d, date)),
            isToday: false,
            isPast: date < today,
            isFuture: date > today,
          };
        });
      result.push(week);
    }

    // Reverse so most recent week is at the bottom
    return result.reverse();
  }, [completedDatesObjects, weekCount, today]);

  const dayNames = useMemo(() => {
    const firstDayOfWeek = startOfWeek(new Date(), { weekStartsOn: 0 });
    return Array(7)
      .fill(null)
      .map((_, i) => {
        return format(addDays(firstDayOfWeek, i), "EEE").charAt(0);
      });
  }, []);

  return (
    <YStack space="$3" style={style}>
      <Text fontSize="$3" fontWeight="$3" color="$content.primary">
        Activity
      </Text>
      
      <XStack justifyContent="space-between">
        {dayNames.map((day, index) => (
          <Text key={index} color="$gray11" textAlign="center" fontSize="$1">
            {day}
          </Text>
        ))}
      </XStack>
      
      <YStack space="$3">
        {weeks.map((week, weekIndex) => (
          <XStack key={`week-${weekIndex}`} justifyContent="space-between">
            {week.map((day, dayIndex) => (
              <YStack key={`day-${weekIndex}-${dayIndex}`} alignItems="center" space="$1">
                <Text 
                  fontSize="$1" 
                  color={day.isToday ? "$brand.primary" : "$content.subtle"}
                  fontWeight={day.isToday ? '$3' : '$2'}
                >
                  {day.date.getDate()}
                </Text>
                
                {/* Day circle */}
                <DayCircle 
                  completed={day.completed}
                  isToday={day.isToday}
                  isPast={day.isPast}
                  isFuture={day.isFuture}
                />
              </YStack>
            ))}
          </XStack>
        ))}
      </YStack>
      
      {/* Legend */}
      <XStack space="$4" justifyContent="center" marginTop="$2">
        <XStack space="$1" alignItems="center">
          <View
            style={{
              width: 8,
              height: 8,
              borderRadius: 4,
              backgroundColor: "$gray6",
            }}
          />
          <Text fontSize="$2" color="$content.subtle">Not completed</Text>
        </XStack>
        
        <XStack space="$1" alignItems="center">
          <View
            style={{
              width: 8,
              height: 8,
              borderRadius: 4,
              backgroundColor: "$primary9",
            }}
          />
          <Text fontSize="$2" color="$content.subtle">Completed</Text>
        </XStack>
      </XStack>
    </YStack>
  );
}
  ```

  *Exports: `StreakCalendarProps` (interface)*
  ```tsx
interface StreakCalendarProps {
  /** Array of dates (ISO strings) when the habit was completed */
  completedDates: string[];
  /** Number of weeks to display (default: 4) */
  weekCount?: number;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}
  ```

- **components/rewards/ConfettiBurst.tsx** (5.4 KB, 224 lines)

  *Exports: `default` (function)*
  ```tsx
export default function ConfettiBurst({
  isVisible,
  onComplete,
  count = CONFETTI_COUNT,
  colors = COLORS,
  duration = 2000,
}: ConfettiBurstProps) {
  // Create confetti pieces
  const pieces = React.useMemo(() => {
    const result: ConfettiPiece[] = [];
    
    for (let i = 0; i < count; i++) {
      result.push({
        id: i,
        x: Math.random() * SCREEN_WIDTH,
        y: -20, // Start above the screen
        size: Math.random() * 8 + 4, // Size between 4-12
        color: colors[Math.floor(Math.random() * colors.length)],
        rotation: Math.random() * 360,
        delay: Math.random() * 500, // Random delay up to 500ms
        duration: Math.random() * 1000 + 1500, // Duration between 1.5-2.5s
      });
    }
    
    return result;
  }, [count, colors]);
  
  // Trigger animation complete callback
  const animationComplete = () => {
    if (onComplete) {
      onComplete();
    }
  };
  
  return (
    <>
      {isVisible && (
        <View style={styles.container} pointerEvents="none">
          {pieces.map((piece) => (
            <ConfettiPiece
              key={piece.id}
              piece={piece}
              animationDuration={duration}
              onComplete={animationComplete}
            />
          ))}
        </View>
      )}
    </>
  );
}
  ```

- **components/settings/NotificationRow.tsx** (2.2 KB, 93 lines)

  *Exports: `default` (function)*
  ```tsx
export default function NotificationRow({
  title,
  description,
  enabled,
  onToggle,
  icon,
  isLoading,
  switchProps,
  style,
}: NotificationRowProps) {
  const colors = useColors();
  
  const handleToggle = (value: boolean) => {
    if (!isLoading) {
      onToggle(value);
    }
  };
  
  return (
    <XStack
      style={[styles.container, style]}
      alignItems="center"
      justifyContent="space-between"
      padding="$4"
      backgroundColor={colors.background.card}
      borderRadius="$4"
    >
      <XStack alignItems="center" space="$3" flex={1}>
        {icon && <XStack opacity={isLoading ? 0.5 : 1}>{icon}</XStack>}
        
        <YStack space="$1" flex={1} opacity={isLoading ? 0.5 : 1}>
          <Text
            fontSize="$4"
            fontWeight="$2"
            color={colors.content.primary}
          >
            {title}
          </Text>
          
          {description && (
            <Text
              fontSize="$3"
              color={colors.content.secondary}
            >
              {description}
            </Text>
          )}
        </YStack>
      </XStack>
      
      <Switch
        size="$2"
        checked={enabled}
        onCheckedChange={handleToggle}
        disabled={isLoading}
        {...switchProps}
      />
    </XStack>
  );
}
  ```

  *Exports: `NotificationRowProps` (interface)*
  ```tsx
interface NotificationRowProps {
  /** Title of the notification setting */
  title: string;
  /** Optional description */
  description?: string;
  /** Whether the notification is turned on */
  enabled: boolean;
  /** Called when the switch is toggled */
  onToggle: (value: boolean) => void;
  /** Icon to display in the row */
  icon?: ReactNode;
  /** Whether the control is in loading state */
  isLoading?: boolean;
  /** Switch props */
  switchProps?: Omit<SwitchProps, 'checked' | 'onCheckedChange'>;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}
  ```

- **components/settings/ThemePreview.tsx** (3.6 KB, 140 lines)

  *Exports: `default` (function)*
  ```tsx
export default function ThemePreview({
  themeName,
  isSelected,
  onSelect,
  forceDark,
  forceLight,
  style,
}: ThemePreviewProps) {
  const currentTheme = useTheme();
  const previewTheme = forceDark ? 'dark' : forceLight ? 'light' : undefined;
  const colors = useColors();
  
  return (
    <Pressable 
      onPress={onSelect}
      style={({ pressed }) => [
        styles.container,
        {
          transform: [{ scale: pressed ? 0.97 : 1 }],
          borderColor: isSelected ? colors.border.focus : colors.border.default,
          borderWidth: isSelected ? 2 : 1,
        },
        style,
      ]}
    >
      <YStack space="$2">
        <Text
          fontSize="$4"
          fontWeight="$2"
          color={colors.content.primary}
          marginBottom="$1"
        >
          {themeName}
        </Text>
        
        <Theme name={previewTheme}>
          <YStack
            backgroundColor="$cardBackground"
            borderRadius="$3"
            padding="$2"
            space="$2"
          >
            {/* Header Preview */}
            <View 
              style={styles.header}
              backgroundColor="$primary"
            />
            
            {/* Content Preview */}
            <YStack space="$1">
              <View style={styles.textLine} backgroundColor="$color" opacity={0.9} />
              <View style={styles.textLine} backgroundColor="$color" opacity={0.7} width="80%" />
              <View style={styles.textLine} backgroundColor="$color" opacity={0.5} width="60%" />
            </YStack>
            
            {/* Button Preview */}
            <XStack space="$2">
              <View
                style={styles.button}
                backgroundColor="$primary"
              />
              <View
                style={styles.button}
                backgroundColor="$backgroundPress"
              />
            </XStack>
          </YStack>
        </Theme>
        
        {isSelected && (
          <View style={styles.checkContainer}>
            <XStack
              backgroundColor={colors.status.success}
              borderRadius={999}
              alignItems="center"
              justifyContent="center"
              width={24}
              height={24}
            >
              <Check color="white" size={16} />
            </XStack>
          </View>
        )}
      </YStack>
    </Pressable>
  );
}
  ```

  *Exports: `ThemePreviewProps` (interface)*
  ```tsx
interface ThemePreviewProps {
  /** The theme name to display */
  themeName: string;
  /** Whether this theme is currently selected */
  isSelected: boolean;
  /** Called when this theme is selected */
  onSelect: () => void;
  /** Whether to force dark mode for this preview */
  forceDark?: boolean;
  /** Whether to force light mode for this preview */
  forceLight?: boolean;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}
  ```

- **components/ui/Container.tsx** (0.7 KB, 30 lines)

  *Exports: `Container` (component)*
  ```tsx
Container: React.FC<ContainerProps> = ({ style, children, ...props }) => {
  const theme = useTheme();
  return (
    <StyledSafeArea
      style={[
        { backgroundColor: theme.background.val },
        style as any
      ]}
      {...props}
    >
      <YStack flex={1}>{children}</YStack>
    </StyledSafeArea>
  );
}
  ```

  *Exports: `default` (unknown)*
  ```tsx
export default Container;
  ```

- **components/ui/EmptyOrSkeleton.tsx** (2.0 KB, 96 lines)

  *Exports: `EmptyOrSkeleton` (component)*
  ```tsx
EmptyOrSkeleton = ({
  isLoading = false,
  count = 3,
  type = 'row',
  isEmpty = false,
  text = 'No items found',
  actionText = 'Add New',
  onAction,
  isError = false,
  onRetry,
  children
}: EmptyOrSkeletonProps) => {
  // Generate skeleton based on type
  const renderSkeletons = () => {
    const skeletons = [];
    for (let i = 0; i < count; i++) {
      if (type === 'card') {
        skeletons.push(<SkeletonCard key={i} />);
      } else if (type === 'circle') {
        skeletons.push(<SkeletonCircle key={i} />);
      } else {
        skeletons.push(<SkeletonRow key={i} />);
      }
    }
    return skeletons;
  };

  // Show skeleton if loading
  if (isLoading) {
    return (
      <YStack space="$3">
        {renderSkeletons()}
      </YStack>
    );
  }
  
  // Show error state if there's an error
  if (isError) {
    return (
      <SectionError 
        message={text} 
        onRetry={onRetry} 
      />
    );
  }
  
  // Show empty state if empty
  if (isEmpty) {
    return (
      <YStack
        padding="$4"
        alignItems="center"
        justifyContent="center"
        space="$3"
      >
        <Text textAlign="center" color="$gray11">
          {text}
        </Text>
        {onAction && (
          <Button size="$3" onPress={onAction}>
            {actionText}
          </Button>
        )}
      </YStack>
    );
  }
  
  // Default: return children
  return <>{children}</>;
}
  ```

  *Exports: `EmptyOrSkeletonProps` (interface)*
  ```tsx
interface EmptyOrSkeletonProps {
  // Loading state
  isLoading?: boolean;
  count?: number;
  type?: 'card' | 'row' | 'circle';
  
  // Empty state
  isEmpty?: boolean;
  text?: string;
  actionText?: string;
  onAction?: () => void;
  
  // Error state
  isError?: boolean;
  onRetry?: () => void;
  
  // Children to render when not in any special state
  children?: React.ReactNode;
}
  ```

- **components/ui/ErrorBanner.tsx** (2.7 KB, 101 lines)

  *Exports: `ErrorBanner` (function)*
  ```tsx
function ErrorBanner({ title, message, onRetry }: ErrorBannerProps) {
  const theme = useTheme();

  const red3 = theme?.red3?.val ?? '#fee2e2';
  const red5 = theme?.red5?.val ?? '#f87171';
  const red6 = theme?.red6?.val ?? '#ef4444';
  const red7 = theme?.red7?.val ?? '#dc2626';
  const red10 = theme?.red10?.val ?? '#991b1b';
  const red11 = theme?.red11?.val ?? '#7f1d1d';

  return (
    <YStack 
      backgroundColor={red3} 
      borderColor={red7} 
      borderWidth={1} 
      borderRadius="$3"
      padding="$3"
      space="$2"
      alignItems="center"
    >
      <XStack width="100%" justifyContent="space-between" alignItems="center">
        <H4 color={red11}>{title || 'Error'}</H4> 
        {/* Optional: Add an icon */} 
        {/* <Ionicons name="alert-circle-outline" size={20} color={red10} /> */} 
      </XStack>
      <Text color={red11}>{message}</Text> 
      {onRetry && (
        <Button 
          // theme="red" 
          icon={<Ionicons name="refresh" size={16} color={red11} />} 
          onPress={onRetry}
          size="$2"
          backgroundColor={red5} 
          borderColor={red7} 
          borderWidth={1}
          pressStyle={{ backgroundColor: red6 }}
        >
          <Text color={red11}>Retry</Text>
        </Button>
      )}
    </YStack>
  );
}
  ```

  *Exports: `SectionError` (function)*
  ```tsx
function SectionError({ message, onRetry }: SectionErrorProps) {
  const theme = useTheme();

  const red3 = theme?.red3?.val ?? '#fee2e2';
  const red5 = theme?.red5?.val ?? '#f87171';
  const red6 = theme?.red6?.val ?? '#ef4444';
  const red7 = theme?.red7?.val ?? '#dc2626';
  const red10 = theme?.red10?.val ?? '#991b1b';
  const red11 = theme?.red11?.val ?? '#7f1d1d';

  return (
    <YStack 
      padding="$3" 
      borderRadius="$3" 
      borderWidth={1} 
      borderColor={red7} 
      backgroundColor={red3} 
      alignItems="center" 
      space="$2"
    >
      <Ionicons name="warning-outline" size={24} color={red10} /> 
      <Text color={red11} textAlign="center"> 
        {message || 'Failed to load this section.'}
      </Text>
      {onRetry && (
        <Button 
          size="$2" 
          // theme="red"
          backgroundColor={red5} 
          icon={<Ionicons name="refresh" size={16} color={red11} />} 
          onPress={onRetry}
          pressStyle={{ backgroundColor: red6 }}
          borderColor={red7} 
          borderWidth={1} 
        >
          <Text color={red11}>Retry</Text>
        </Button>
      )}
    </YStack>
  );
}
  ```

- **components/ui/InteractiveCard.tsx** (0.6 KB, 29 lines)

  *Exports: `default` (unknown)*
  ```tsx
export default InteractiveCard;
  ```

- **components/ui/Section.tsx** (0.5 KB, 24 lines)

  *Exports: `default` (unknown)*
  ```tsx
export default Section;
  ```

- **components/ui/Skeleton.tsx** (2.6 KB, 113 lines)

  *Exports: `Skeleton` (function)*
  ```tsx
function Skeleton({ width = '100%', height = 20, borderRadius = 4 }: SkeletonProps) {
  const colorScheme = useColorScheme();
  
  return (
    <SkeletonBase
      colorMode={colorScheme === 'dark' ? 'dark' : 'light'}
      width={width}
      height={height}
      borderRadius={borderRadius}
    />
  );
}
  ```

  *Exports: `SkeletonAvatar` (function)*
  ```tsx
function SkeletonAvatar({ size = 40 }: SkeletonAvatarProps) {
  return <Skeleton width={size} height={size} borderRadius={size / 2} />;
}
  ```

  *Exports: `SkeletonCard` (function)*
  ```tsx
function SkeletonCard({ height = 100, width = '100%' }: SkeletonCardProps) {
  return (
    <YStack space="$2">
      <Skeleton height={height} width={width} borderRadius={8} />
    </YStack>
  );
}
  ```

  *Exports: `SkeletonCircle` (function)*
  ```tsx
function SkeletonCircle({ size = 60 }: SkeletonCircleProps) {
  return <Skeleton width={size} height={size} borderRadius={size / 2} />;
}
  ```

  *Exports: `SkeletonProfile` (function)*
  ```tsx
function SkeletonProfile({ avatarSize = 40 }: SkeletonProfileProps) {
  return (
    <XStack space="$3" alignItems="center">
      <SkeletonAvatar size={avatarSize} />
      <YStack space="$1" flex={1}>
        <Skeleton width="60%" height={16} />
        <Skeleton width="40%" height={12} />
      </YStack>
    </XStack>
  );
}
  ```

  *Exports: `SkeletonRow` (function)*
  ```tsx
function SkeletonRow({ height = 20, width = '100%', lines = 3, spacing = 10 }: SkeletonRowProps) {
  return (
    <YStack space={spacing}>
      {Array.from({ length: lines }).map((_, i) => (
        <Skeleton 
          key={i}
          height={height}
          width={i === lines - 1 && typeof width === 'string' ? '70%' : width}
        />
      ))}
    </YStack>
  );
}
  ```

- **components/ui/SwipeableRow.tsx** (2.2 KB, 76 lines)

  *Exports: `default` (function)*
  ```tsx
export default function SwipeableRow({ children, onDelete, onComplete }: SwipeableRowProps) {
  const theme = useTheme();

  const renderRightActions = () => {
    if (!onDelete) return null;
    return (
      <XStack flex={1} justifyContent="flex-end">
        <Button
          // size="$3" // Match ListItem size?
          backgroundColor="$destructive"
          borderTopRightRadius="$0" // Flatten edges
          borderBottomRightRadius="$0"
          icon={<Trash color={theme.color?.get()} />} // Use theme color for icon
          onPress={() => {
            Haptics.selectionAsync();
            onDelete();
            // Consider closing the Swipeable here if needed
          }}
          width={80} // Fixed width for the action button
          height="100%" // Fill height
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  const renderLeftActions = () => {
    if (!onComplete) return null;
    return (
      <XStack flex={1} justifyContent="flex-start">
        <Button
          // size="$3"
          backgroundColor="$success"
          borderTopLeftRadius="$0"
          borderBottomLeftRadius="$0"
          icon={<Check color={theme.color?.get()} />}
          onPress={() => {
            Haptics.selectionAsync();
            onComplete();
            // Consider closing the Swipeable here if needed
          }}
          width={80}
          height="100%"
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  return (
    <Swipeable
      renderRightActions={renderRightActions}
      renderLeftActions={renderLeftActions}
      overshootFriction={8} // Standard friction
      containerStyle={{ backgroundColor: '$background' }} // Ensure background matches item
    >
      {children}
    </Swipeable>
  );
}
  ```

- **components/ui/primitives/AetherCard.tsx** (1.9 KB, 77 lines)

  *Exports: `AetherCard` (function)*
  ```tsx
function AetherCard({ children, variant, isInteractive, ...props }: AetherCardProps) {
  return (
    <StyledCard variant={variant} isInteractive={isInteractive} {...props}>
      {children}
    </StyledCard>
  );
}
  ```

- **components/ui/primitives/AetherListItem.tsx** (3.3 KB, 124 lines)

  *Exports: `AetherListItem` (function)*
  ```tsx
function AetherListItem({
  title,
  subtitle,
  leftIcon,
  rightIcon,
  showChevron = false,
  badge,
  isLast,
  interactive,
  ...props
}: AetherListItemProps) {
  return (
    <ListItemContainer isLast={isLast} interactive={interactive} {...props}>
      {/* Left section with icon and text */}
      <XStack space="$3" flex={1} alignItems="center">
        {leftIcon && (
          <Stack marginRight="$2">{leftIcon}</Stack>
        )}
        
        <YStack>
          <Text fontWeight="500" fontSize="$4">{title}</Text>
          {subtitle && (
            <Text fontSize="$2" color="$gray10">{subtitle}</Text>
          )}
        </YStack>
      </XStack>
      
      {/* Right section with badge, custom icon or chevron */}
      <XStack space="$2" alignItems="center">
        {badge && (
          <XStack 
            backgroundColor="$primary"
            paddingHorizontal="$2"
            paddingVertical="$1"
            borderRadius="$2"
          >
            <Text color="white" fontSize="$1" fontWeight="bold">{badge}</Text>
          </XStack>
        )}
        
        {rightIcon && rightIcon}
        
        {showChevron && (
          <Ionicons name="chevron-forward" size={16} color="$gray10" />
        )}
      </XStack>
    </ListItemContainer>
  );
}
  ```

  *Exports: `AetherListItemProps` (interface)*
  ```tsx
interface AetherListItemProps extends ListItemContainerProps {
  title: string;
  subtitle?: string;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  showChevron?: boolean;
  badge?: string | number;
}
  ```

- **components/ui/primitives/SectionHeader.tsx** (1.4 KB, 62 lines)

  *Exports: `SectionHeader` (function)*
  ```tsx
function SectionHeader({ 
  title, 
  actionLabel, 
  onAction, 
  ...props 
}: SectionHeaderProps) {
  return (
    <SectionContainer {...props}>
      <Text 
        fontSize="$5" 
        fontWeight="600" 
        color="$color"
      >
        {title}
      </Text>
      
      {actionLabel && onAction && (
        <Button
          onPress={onAction}
          fontSize="$2"
          backgroundColor="transparent"
          color="$primary"
          paddingHorizontal="$2"
          height="$5"
        >
          {actionLabel}
        </Button>
      )}
    </SectionContainer>
  );
}
  ```

  *Exports: `SectionHeaderProps` (interface)*
  ```tsx
interface SectionHeaderProps extends SectionContainerProps {
  title: string;
  actionLabel?: string;
  onAction?: () => void;
}
  ```

- **components/ui/primitives/index.ts** (0.3 KB, 7 lines)

  *Exports: `AetherCard` (re-export)*
  ```ts
export { AetherCard }
  ```

  *Exports: `AetherListItem` (re-export)*
  ```ts
export { AetherListItem }
  ```

  *Exports: `AetherListItemProps` (re-export)*
  ```ts
export { AetherListItemProps }
  ```

  *Exports: `SectionHeader` (re-export)*
  ```ts
export { SectionHeader }
  ```

  *Exports: `SectionHeaderProps` (re-export)*
  ```ts
export { SectionHeaderProps }
  ```

### constants

- **constants/Colors.ts** (0.7 KB, 27 lines)

  *Exports: `Colors` (component)*
  ```ts
Colors = {
  light: {
    text: '#11181C',
    background: '#fff',
    tint: tintColorLight,
    icon: '#687076',
    tabIconDefault: '#687076',
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: '#ECEDEE',
    background: '#151718',
    tint: tintColorDark,
    icon: '#9BA1A6',
    tabIconDefault: '#9BA1A6',
    tabIconSelected: tintColorDark,
  },
}
  ```

- **constants/motion.ts** (3.1 KB, 139 lines)

  *Exports: `componentAnimations` (unknown)*
  ```ts
componentAnimations = {
  toast: {
    show: {
      duration: durations.modal,
      easing: easings.enter,
    },
    hide: {
      duration: durations.standard,
      easing: easings.exit,
    },
  },
  modal: {
    overlay: {
      show: {
        duration: durations.modal,
        easing: easings.standard,
      },
      hide: {
        duration: durations.modal,
        easing: easings.standard,
      },
    },
    content: {
      show: {
        duration: durations.modal,
        easing: easings.enter,
      },
      hide: {
        duration: durations.standard,
        easing: easings.exit,
      },
    },
  },
  button: {
    press: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
    release: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
  },
  navigation: {
    screen: {
      duration: durations.screen,
      easing: easings.standard,
    },
    tab: {
      duration: durations.standard,
      easing: easings.standard,
    },
  },
}
  ```

  *Exports: `durations` (unknown)*
  ```ts
durations = {
  /** Ultra-fast for micro-interactions */
  micro: 80,
  /** Tap/press feedback */
  tap: 120,
  /** Default animation speed for most UI transitions */
  standard: 200,
  /** For more noticeable animations */
  medium: 250,
  /** Modal entrances/exits, complex transitions */
  modal: 300,
  /** Full screen transitions */
  screen: 350,
  /** Extended animations for emphasis */
  long: 450,
}
  ```

  *Exports: `easings` (unknown)*
  ```ts
easings = {
  /** Quick acceleration, gradual deceleration - for elements entering the screen */
  enter: Easing.bezier(0.25, 0.1, 0.25, 1.0),
  /** Gradual acceleration, quick deceleration - for elements exiting the screen */
  exit: Easing.bezier(0.25, 0.0, 0.2, 1.0),
  /** For transitions between UI states */
  standard: Easing.bezier(0.4, 0.0, 0.2, 1.0),
  /** Quick in, quick out - for emphasis */
  energetic: Easing.bezier(0.55, 0.0, 0.1, 1.0),
  /** Linear - consistent motion with no acceleration/deceleration */
  linear: Easing.linear,
  /** Slow start, fast finish */
  accelerate: Easing.in(Easing.quad),
  /** Fast start, slow finish */
  decelerate: Easing.out(Easing.quad),
  /** Fast start and end, slower in the middle */
  emphasize: Easing.inOut(Easing.quad),
}
  ```

  *Exports: `presets` (unknown)*
  ```ts
presets = {
  fadeIn: {
    duration: durations.standard,
    easing: easings.enter,
  },
  fadeOut: {
    duration: durations.standard,
    easing: easings.exit,
  },
  slideIn: {
    duration: durations.modal,
    easing: easings.enter,
  },
  slideOut: {
    duration: durations.modal,
    easing: easings.exit,
  },
  scaleIn: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  scaleOut: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  tapFeedback: {
    duration: durations.tap,
    easing: easings.emphasize,
  },
  skeleton: {
    duration: durations.long * 2,
    easing: easings.linear,
  },
}
  ```

### debug

- **debug/toast-test.tsx** (1.7 KB, 76 lines)

  *Exports: `default` (function)*
  ```tsx
export default function ToastTestScreen() {
  const { showToast } = useToast();

  const testSuccessToast = () => {
    showToast({
      type: 'success',
      title: 'Success',
      message: 'This is a success toast message',
      duration: 3000,
    });
  };

  const testErrorToast = () => {
    showToast({
      type: 'error',
      title: 'Error',
      message: 'This is an error toast message',
      duration: 3000,
    });
  };

  const testInfoToast = () => {
    showToast({
      type: 'info',
      message: 'This is an info toast without a title',
      duration: 3000,
    });
  };

  return (
    <View style={{ flex: 1 }}>
      <StatusBar style="auto" />
      <YStack
        flex={1}
        padding={20}
        space={16}
        justifyContent="center"
        alignItems="center"
      >
        <Text fontSize={24} fontWeight="bold" marginBottom={20}>
          Toast Test Screen
        </Text>
        
        <Button 
          onPress={testSuccessToast} 
          backgroundColor="$green6" 
          size="$4"
        >
          Show Success Toast
        </Button>
        
        <Button 
          onPress={testErrorToast} 
          backgroundColor="$red6" 
          size="$4"
        >
          Show Error Toast
        </Button>
        
        <Button 
          onPress={testInfoToast} 
          backgroundColor="$blue6" 
          size="$4"
        >
          Show Info Toast
        </Button>
      </YStack>
    </View>
  );
}
  ```

### design-system

- **design-system/Animations.ts** (1.2 KB, 41 lines)

  *Exports: `fadeInUp` (unknown)*
  ```ts
fadeInUp = {
  from: { opacity: 0, translateY: 16 },
  animate: { opacity: 1, translateY: 0 },
  exit: { opacity: 0, translateY: 16 },
  transition: { type: 'timing', duration: 350 },
}
  ```

  *Exports: `korokReveal` (unknown)*
  ```ts
korokReveal = {
  from: { opacity: 0, scale: 0.7, rotate: '-10deg' },
  animate: { opacity: 1, scale: 1, rotate: '0deg' },
  transition: { type: 'spring', dampingRatio: 0.6 },
}
  ```

  *Exports: `sheikahGlow` (unknown)*
  ```ts
sheikahGlow = {
  from: { opacity: 0.4, scale: 0.95 },
  animate: { opacity: 1, scale: 1 },
  exit: { opacity: 0.4, scale: 0.95 },
  transition: { type: 'timing', duration: 800, loop: true },
}
  ```

  *Exports: `slideOutLeft` (unknown)*
  ```ts
slideOutLeft = {
  from: { translateX: 0 },
  animate: { translateX: -100 },
  exit: { translateX: -100 },
  transition: { type: 'spring', dampingRatio: 0.7 },
}
  ```

  *Exports: `taskComplete` (unknown)*
  ```ts
taskComplete = {
  from: { opacity: 1, translateX: 0 },
  animate: { opacity: 0.6, translateX: -5 },
  transition: { type: 'spring', dampingRatio: 0.8 },
}
  ```

- **design-system/Primitives.tsx** (0.9 KB, 30 lines)

  *Exports: `Button` (component)*
  ```tsx
Button = styled(gs.Button)
  ```

  *Exports: `Center` (component)*
  ```tsx
Center = styled(gs.Center)
  ```

  *Exports: `gs` (re-export)*
  ```tsx
export { gs }
  ```

  *Exports: `HStack` (component)*
  ```tsx
HStack = styled(gs.HStack)
  ```

  *Exports: `Pressable` (component)*
  ```tsx
Pressable = styled(gs.Pressable)
  ```

  *Exports: `ScrollView` (component)*
  ```tsx
ScrollView = styled(gs.ScrollView)
  ```

  *Exports: `Stack` (component)*
  ```tsx
Stack = styled(gs.View)
  ```

  *Exports: `Text` (component)*
  ```tsx
Text = styled(gs.Text)
  ```

  *Exports: `useColorMode` (hook)*
  ```tsx
useColorMode = gs.useColorMode
  ```

  *Exports: `useColorModeValue` (function)*
  ```tsx
function useColorModeValue<T>(light: T, dark: T) {
  const { colorMode } = useColorMode();
  return colorMode === 'dark' ? dark : light;
}
  ```

  *Exports: `useToast` (hook)*
  ```tsx
useToast = gs.useToast
  ```

  *Exports: `VStack` (component)*
  ```tsx
VStack = styled(gs.VStack)
  ```

- **design-system/theme.glue.ts** (0.2 KB, 11 lines)

  *Exports: `glueTheme` (unknown)*
  ```ts
glueTheme = {
  ...base,
  tokens: {
    ...base.tokens,
    ...tokens,          // merge Zelda palette
  },
} as const
  ```

- **design-system/tokens.ts** (1.3 KB, 69 lines)

  *Exports: `colors` (unknown)*
  ```ts
colors = {
  // Zelda theme colors from memories
  'parchment': '#FDFFE0',
  'sheikahCyan': '#86A5A9',
  'korokGreen': '#92C582',
  'darkText': '#536F50',
  'guardianOrange': '#FF9F0A',
  'darkTealBg': '#1A2E3A',
  'cyanGlow': '#64FFDA',
  
  // Semantic aliases
  'surface': '#FDFFE0', // parchment in light mode
  'onSurface': '#536F50', // darkText in light mode
  'outline': '#86A5A9', // sheikahCyan in both modes
  
  // Shadow colors with opacities
  'shadowSm': 'rgba(83, 111, 80, 0.10)', // Light theme
  'shadowMd': 'rgba(83, 111, 80, 0.15)',
  'shadowLg': 'rgba(83, 111, 80, 0.20)',
  'shadowDarkSm': 'rgba(0, 0, 0, 0.20)', // Dark theme
  'shadowDarkMd': 'rgba(0, 0, 0, 0.30)',
  'shadowDarkLg': 'rgba(0, 0, 0, 0.40)',
}
  ```

  *Exports: `default` (unknown)*
  ```ts
export default {
  colors,
  radii,
  space,
  sizes,
  fonts,
};
  ```

  *Exports: `fonts` (unknown)*
  ```ts
fonts = {
  'heading': 'HyliaSerif',
  'body': 'CalamitySans',
  'mono': 'SpaceMono',
}
  ```

  *Exports: `radii` (unknown)*
  ```ts
radii = {
  'sm': 4,
  'md': 8,
  'lg': 16,
  'xl': 24,
  'full': 9999,
}
  ```

  *Exports: `sizes` (unknown)*
  ```ts
sizes = {
  ...space,
}
  ```

  *Exports: `space` (unknown)*
  ```ts
space = {
  '0': 0,
  '0.5': 2,
  '1': 4,
  '2': 8,
  '3': 12,
  '4': 16,
  '5': 20,
  '6': 24,
  '8': 32,
  '10': 40,
  '12': 48,
  '16': 64,
}
  ```

### hooks

- **hooks/useColorScheme.ts** (0.0 KB, 2 lines)

  *Exports: `useColorScheme` (re-export)*
  ```ts
export { useColorScheme }
  ```

- **hooks/useColorScheme.web.ts** (0.5 KB, 22 lines)

  *Exports: `useColorScheme` (function)*
  ```ts
function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}
  ```

- **hooks/useOfflineSync.ts** (6.1 KB, 172 lines)

  *Exports: `useOfflineSync` (function)*
  ```ts
function useOfflineSync<T extends { id: string }>(entityType: string) {
const [isOnline, setIsOnline] = useState(true);
const [pendingItems, setPendingItems] = useState<PendingItem[]>([]);
const [isSyncing, setIsSyncing] = useState(false);

// Load pending items on mount
useEffect(() => {
  loadPendingItems();
  
  // Set up network status listener
  const unsubscribe = NetInfo.addEventListener(state => {
    const online = state.isConnected !== false && state.isInternetReachable !== false;
    setIsOnline(online);
    
    // If going from offline to online, try to sync
    if (online) {
      syncItems();
    }
  });
  
  // Also set up background sync (network status changes outside this component)
  const unsubscribeBackground = setupBackgroundSync();
  
  return () => {
    unsubscribe();
    unsubscribeBackground();
  };
}, [entityType]);

// Load pending items from storage
const loadPendingItems = useCallback(async () => {
  const items = await getPendingItems(entityType);
  setPendingItems(items);
}, [entityType]);

// Create an item (works offline)
const createItem = useCallback(async (data: Omit<T, 'id'>): Promise<{ id: string, isOffline: boolean }> => {
  try {
    // Check if we're online
    const networkState = await NetInfo.fetch();
    const online = networkState.isConnected && networkState.isInternetReachable !== false;
    
    if (online) {
      // If online, create directly
      // In a real app, you'd use your API client (like supabase) here
      // const { data: newItem, error } = await supabase.from(entityType).insert(data).select();
      // if (error) throw error;
      // return { id: newItem.id, isOffline: false };
      
      // For demo purposes, simulate success
      return { id: `server-${Date.now()}`, isOffline: false };
    } else {
      // If offline, save to be synced later
      const tempId = await saveOfflineMutation('create', entityType, data);
      await loadPendingItems(); // Reload pending items
      return { id: tempId, isOffline: true };
    }
  } catch (error) {
    console.error('Error creating item:', error);
    // If API call fails, save offline
    const tempId = await saveOfflineMutation('create', entityType, data);
    await loadPendingItems(); // Reload pending items
    return { id: tempId, isOffline: true };
  }
}, [entityType, loadPendingItems]);

// Update an item (works offline)
const updateItem = useCallback(async (item: T): Promise<{ isOffline: boolean }> => {
  try {
    // Check if we're online
    const networkState = await NetInfo.fetch();
    const online = networkState.isConnected && networkState.isInternetReachable !== false;
    
    if (online) {
      // If online, update directly
      // In a real app, you'd use your API client (like supabase) here
      // const { error } = await supabase.from(entityType).update(item).eq('id', item.id);
      // if (error) throw error;
      // return { isOffline: false };
      
      // For demo purposes, simulate success
      return { isOffline: false };
    } else {
      // If offline, save to be synced later
      await saveOfflineMutation('update', entityType, item);
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  } catch (error) {
    console.error('Error updating item:', error);
    // If API call fails, save offline
    await saveOfflineMutation('update', entityType, item);
    await loadPendingItems(); // Reload pending items
    return { isOffline: true };
  }
}, [entityType, loadPendingItems]);

// Delete an item (works offline)
const deleteItem = useCallback(async (id: string): Promise<{ isOffline: boolean }> => {
  try {
    // Check if we're online
    const networkState = await NetInfo.fetch();
    const online = networkState.isConnected && networkState.isInternetReachable !== false;
    
    if (online) {
      // If online, delete directly
      // In a real app, you'd use your API client (like supabase) here
      // const { error } = await supabase.from(entityType).delete().eq('id', id);
      // if (error) throw error;
      // return { isOffline: false };
      
      // For demo purposes, simulate success
      return { isOffline: false };
    } else {
      // If offline, save to be synced later
      await saveOfflineMutation('delete', entityType, { id });
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  } catch (error) {
    console.error('Error deleting item:', error);
    // If API call fails, save offline
    await saveOfflineMutation('delete', entityType, { id });
    await loadPendingItems(); // Reload pending items
    return { isOffline: true };
  }
}, [entityType, loadPendingItems]);

// Manually trigger sync
const syncI... /* snippet truncated */
  ```

- **hooks/useSkeleton.ts** (3.6 KB, 164 lines)

  *Exports: `SkeletonOptions` (interface)*
  ```ts
interface SkeletonOptions {
  /**
   * Width of the gradient shimmer (as % of the component width)
   * @default 0.7
   */
  shimmerWidth?: number;
  /**
   * Base color of the skeleton component
   * @default '#E1E9EE'
   */
  baseColor?: string;
  /**
   * Highlight color for the shimmer effect
   * @default '#F2F8FC'
   */
  highlightColor?: string;
  /**
   * Duration for a complete shimmer cycle in ms
   * @default 2000
   */
  duration?: number;
  /**
   * Delay before starting animation in ms
   * @default 0
   */
  delay?: number;
  /**
   * Whether animation should start automatically
   * @default true
   */
  autoStart?: boolean;
  /**
   * Loading state to determine if skeletons should be shown
   * @default false
   */
  isLoading?: boolean;
  /**
   * Number of skeleton items to generate
   * @default 1
   */
  count?: number;
  /**
   * Type of skeleton to generate
   * @default 'card'
   */
  type?: 'card' | 'row' | 'circle';
}
  ```

  *Exports: `useSkeleton` (function)*
  ```ts
function useSkeleton(options: SkeletonOptions = {}) {
  const {
    shimmerWidth = 0.7,
    baseColor = '#E1E9EE',
    highlightColor = '#F2F8FC',
    duration = durations.long * 2,
    delay = 0,
    autoStart = true,
  } = options;
  
  // Animation value to track shimmer position
  const translateX = useSharedValue(-1);
  
  // Start the animation
  useEffect(() => {
    if (autoStart) {
      translateX.value = withDelay(
        delay,
        withRepeat(
          withSequence(
            withTiming(-1, { duration: 0 }),
            withTiming(1, { 
              duration, 
              easing: easings.linear 
            }),
          ),
          -1, // Infinite repeat
        ),
      );
    }
  }, [translateX, duration, delay, autoStart]);
  
  // Generate the animated styles for the shimmer effect
  const shimmerStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateX: translateX.value * (1 + shimmerWidth) }],
    };
  });
  
  // Create styles for both container and shimmer
  const styles = StyleSheet.create({
    container: {
      backgroundColor: baseColor,
      overflow: 'hidden',
    },
    shimmer: {
      width: `${shimmerWidth * 100}%`,
      height: '100%',
      backgroundColor: highlightColor,
      position: 'absolute',
      top: 0,
      bottom: 0,
      opacity: 0.7,
    },
  });
  
  // Utility function to manually start the animation
  const startAnimation = () => {
    translateX.value = withDelay(
      delay,
      withRepeat(
        withSequence(
          withTiming(-1, { duration: 0 }),
          withTiming(1, { 
            duration, 
            easing: easings.linear 
          }),
        ),
        -1, // Infinite repeat
      ),
    );
  };
  
  // Utility function to stop the animation
  const stopAnimation = () => {
    translateX.value = withTiming(-1, { duration: 200 });
  };
  
  // Generate array of skeletons based on count and type
  const generateSkeletons = () => {
    if (!options.isLoading) return [];
    
    const count = options.count || 1;
    const type = options.type || 'card';
    
    return Array.from({ length: count }).map((_, index) => ({
      key: `skeleton-${index}`,
      type,
    }));
  };
  
  return {
    baseColor,
    shimmerStyle,
    styles,
    startAnimation,
    stopAnimation,
    skeletons: generateSkeletons(),
  };
}
  ```

- **hooks/useThemeColor.ts** (0.5 KB, 22 lines)

  *Exports: `useThemeColor` (function)*
  ```ts
function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}
  ```

### modals

- **modals/compose.tsx** (3.1 KB, 101 lines)

  *Exports: `default` (function)*
  ```tsx
export default function ComposeModal() {
  const router = useRouter();

  // Reanimated shared value for tracking vertical translation
  const translateY = useSharedValue(0);
  const context = useSharedValue({ y: 0 });

  // Gesture handler for swipe down
  const gesture = Gesture.Pan()
    .onStart(() => {
      context.value = { y: translateY.value };
    })
    .onUpdate((event) => {
      translateY.value = Math.max(0, context.value.y + event.translationY); // Only allow downward swipe
    })
    .onEnd(() => {
      if (translateY.value > DISMISS_THRESHOLD) {
        // Animate out and navigate back
        translateY.value = withTiming(SCREEN_HEIGHT, { duration: 200 }, () => {
          runOnJS(router.back)();
        });
      } else {
        // Snap back to original position
        translateY.value = withTiming(0, { duration: 150 });
      }
    });

  // Animated style for the view
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateY: translateY.value }],
    };
  });

  return (
    // Wrap with GestureDetector
    <GestureDetector gesture={gesture}>
      {/* Apply animated style and entrance animation */}
      <Animated.View 
        style={[styles.container, animatedStyle]}
        entering={SlideInDown.duration(300)} 
      >
        {/* Optional: Add a small drag handle indicator */}
        <View style={styles.handleIndicator} />

        {/* Use Stack.Screen to configure the modal title */}
        <Stack.Screen 
          options={{
            title: 'Compose New',
            // Ensure header interaction doesn't conflict with gesture
            // headerLeft: () => <Button title="Close" onPress={() => router.back()} />
          }} 
        />
        <Text style={{ fontSize: 20, marginBottom: 20 }}>Swipe Down to Dismiss</Text>
        <Button onPress={() => router.back()}>Close Modal</Button>
      </Animated.View>
    </GestureDetector>
  );
}
  ```

### providers

- **providers/AppProvider.tsx** (2.7 KB, 93 lines)

  *Exports: `AppProvider` (function)*
  ```tsx
function AppProvider({ children }: { children: ReactNode }) {
  // Create Query Client
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 1000, // 5 seconds
        retry: Platform.OS === 'web' ? 3 : 1, // Less retries on mobile to save battery
      },
    },
  }));
  
  // Create tRPC client
  const [trpcClient] = useState(() => 
    trpc.createClient({
      links: [
        httpBatchLink({
          url: 'http://localhost:3000/api/trpc',
          fetch: (input, init) => {
            return fetch(input, {
              ...init,
              credentials: 'include',
            });
          },
        }),
      ],
    })
  );
  
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';
  
  // You could add NATS initialization here
  useEffect(() => {
    // Example: Initialize NATS for real-time updates
    // Note: This is commented out since we don't have a real NATS server to connect to
    /*
    try {
      const url = 'ws://localhost:4222';
      initNatsClient(url, queryClient)
        .then(conn => {
          console.log('NATS client initialized successfully');
          // Set up subscriptions to relevant topics
          subscribeWithCache('users.updates', ['users']);
          subscribeWithCache('messages.updates', ['messages']);
        })
        .catch(err => {
          console.error('Failed to initialize NATS client:', err);
        });
    } catch (error) {
      console.error('Error in NATS setup:', error);
    }
    
    // Cleanup on unmount
    return () => {
      closeNatsConnection().catch(err => {
        console.error('Error closing NATS connection:', err);
      });
    };
    */
  }, [queryClient]);
  
  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <NativeWindProvider theme={currentTheme}>
          <TamaguiProvider config={config}>
            {children}
          </TamaguiProvider>
        </NativeWindProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
}
  ```

- **providers/ConfettiProvider.tsx** (4.9 KB, 181 lines)

  *Exports: `ConfettiProvider` (function)*
  ```tsx
function ConfettiProvider({ children }: { children: ReactNode }) {
  const [isVisible, setIsVisible] = useState(false);
  const animationTimeout = useRef<NodeJS.Timeout | null>(null);
  
  // Generate confetti pieces data
  const generateConfettiData = useCallback(() => {
    const pieces = [];
    for (let i = 0; i < CONFETTI_COUNT; i++) {
      pieces.push({
        id: i,
        size: Math.random() * 8 + 4, // Size between 4-12
        color: COLORS[Math.floor(Math.random() * COLORS.length)],
        initialX: Math.random() * SCREEN_WIDTH,
        initialY: -20, // Start just above the screen
        duration: Math.random() * 1000 + 2000, // Duration between 2-3 seconds
        delay: Math.random() * 500, // Random delay up to 500ms
      });
    }
    return pieces;
  }, []);

  const [confettiPieces, setConfettiPieces] = useState(generateConfettiData());

  const showConfetti = useCallback(() => {
    // Trigger haptic feedback
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    
    // Clear any existing timeout
    if (animationTimeout.current) {
      clearTimeout(animationTimeout.current);
    }
    
    // Generate new confetti data and show
    setConfettiPieces(generateConfettiData());
    setIsVisible(true);
    
    // Hide confetti after animation completes
    animationTimeout.current = setTimeout(() => {
      setIsVisible(false);
    }, 3500); // Slightly longer than the max animation time to ensure all pieces are gone
  }, [generateConfettiData]);

  return (
    <ConfettiContext.Provider value={{ showConfetti }}>
      {children}
      {isVisible && (
        <View style={styles.confettiContainer} pointerEvents="none">
          {confettiPieces.map((piece) => (
            <ConfettiPiece
              key={piece.id}
              size={piece.size}
              color={piece.color}
              initialX={piece.initialX}
              initialY={piece.initialY}
              duration={piece.duration}
              delay={piece.delay}
            />
          ))}
        </View>
      )}
    </ConfettiContext.Provider>
  );
}
  ```

  *Exports: `useConfetti` (hook)*
  ```tsx
useConfetti = () => useContext(ConfettiContext)
  ```

- **providers/SupabaseProvider.tsx** (0.4 KB, 14 lines)

  *Exports: `SupabaseContext` (component)*
  ```tsx
SupabaseContext = createContext(supabase)
  ```

  *Exports: `SupabaseProvider` (function)*
  ```tsx
function SupabaseProvider({ children }: PropsWithChildren) {
  return (
    <SupabaseContext.Provider value={supabase}>
      {children}
    </SupabaseContext.Provider>
  );
}
  ```

  *Exports: `useSupabase` (hook)*
  ```tsx
useSupabase = () => React.useContext(SupabaseContext)
  ```

- **providers/TRPCProvider.tsx** (1.1 KB, 39 lines)

  *Exports: `trpc` (unknown)*
  ```tsx
trpc = createTRPCReact<AppRouter>()
  ```

  *Exports: `TRPCProvider` (function)*
  ```tsx
function TRPCProvider({ children }: PropsWithChildren) {
  const url =
    process.env.EXPO_PUBLIC_API_URL ??
    `${process.env.EXPO_PUBLIC_SUPABASE_URL}/functions/trpc`;

  const client = React.useMemo(
    () =>
      trpc.createClient({
        links: [
          httpBatchLink({
            url,
            headers() {
              return {
                // you can inject the supabase JWT here later:
              };
            },
          }),
        ],
      }),
    [url]
  );

  return (
    <trpc.Provider client={client} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </trpc.Provider>
  );
}
  ```

- **providers/index.ts** (0.1 KB, 4 lines)
  *(No explicit exports found)*

### scripts

- **scripts/code_atlas.cjs** (15.1 KB, 405 lines)

- **scripts/generate-all.js** (1.1 KB, 32 lines)
  *(No explicit exports found)*

- **scripts/generate-trpc-client.js** (2.1 KB, 77 lines)
  *(No explicit exports found)*

- **scripts/generate-trpc-types.js** (1.1 KB, 43 lines)
  *(No explicit exports found)*

- **scripts/generate_app_code_overview.sh** (2.3 KB, 80 lines)

- **scripts/reset-project.js** (3.5 KB, 113 lines)
  *(No explicit exports found)*

### server

- **server/.env** (0.4 KB, 4 lines)

- **server/package.json** (0.7 KB, 28 lines)

- **server/src/context.ts** (1.8 KB, 61 lines)

  *Exports: `Context` (interface)*
  ```ts
interface Context {
  supabaseAdmin: typeof supabaseAdmin;
  userId: string;
}
  ```

  *Exports: `createContext` (function)*
  ```ts
async function createContext({ req }: { req: any }): Promise<Context> {
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: 'Missing Authorization header' });
  }
  const token = authHeader.split(' ')[1];
  if (!token) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: 'Invalid Authorization header' });
  }

  // Validate JWT and get user
  const { data, error } = await supabaseAdmin.auth.getUser(token);
  if (error || !data.user) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: error?.message || 'Invalid token' });
  }

  return {
    supabaseAdmin,
    userId: data.user.id,
  };
}
  ```

  *Exports: `supabaseAdmin` (unknown)*
  ```ts
supabaseAdmin = createClient(
  supabaseUrl,
  supabaseServiceKey,
  {
    auth: {
        autoRefreshToken: false,
        persistSession: false
    }
  }
)
  ```

- **server/src/index.ts** (0.9 KB, 31 lines)
  *(No explicit exports found)*

- **server/src/router.ts** (2.0 KB, 61 lines)

  *Exports: `appRouter` (unknown)*
  ```ts
appRouter = router({
  greeting: {
    hello: publicProcedure
      .input(z.object({ name: z.string().optional() }))
      .query(async ({ input }) => {
        return { greeting: `Hello ${input.name ?? 'world'}` };
      }),
    goodbye: publicProcedure
      .query(() => {
        return { greeting: 'Goodbye!' };
      }),
  },
  user: userRouter,
  dashboard: dashboardRouter,
  value: valueRouter,
  principle: principleRouter,
  goal: goalRouter,
  task: taskRouter,
  habit: habitRouter,
  state: trackedStateRouter,
  rewards: rewardsRouter,
  reminder: reminderRouter,
  goalProgressNote: goalProgressNoteRouter,
})
  ```

  *Exports: `AppRouter` (type)*
  ```ts
type AppRouter = typeof appRouter;
  ```

  *Exports: `protectedProcedure` (unknown)*
  ```ts
protectedProcedure = t.procedure.use(({ ctx, next }) => {
  if (!ctx.userId) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }
  return next({ ctx: { supabaseAdmin: ctx.supabaseAdmin, userId: ctx.userId } });
})
  ```

  *Exports: `publicProcedure` (unknown)*
  ```ts
publicProcedure = t.procedure
  ```

  *Exports: `router` (unknown)*
  ```ts
router = t.router
  ```

- **server/src/routers/dashboardRouter.ts** (20.9 KB, 492 lines) (1 TODOs)

  *Exports: `dashboardRouter` (unknown)*
  ```ts
dashboardRouter = router({
getDashboardData: protectedProcedure
  .input(
    z.object({
      habitLimit: z.number().min(1).default(5),
      goalLimit: z.number().min(1).default(5),
      taskLimit: z.number().min(1).default(10)
    }).optional()
  )
  .query(async ({ ctx, input }) => {
    try {
      // Get limits from input or use defaults
      const habitLimit = input?.habitLimit || 5;
      const goalLimit = input?.goalLimit || 5;
      const taskLimit = input?.taskLimit || 10;

      // --- Fetch Habits ---
      const { data: habits, error: habitsError } = await ctx.supabaseAdmin
        .from('habits')
        .select(HABIT_FIELDS) // Use constant
        .eq('user_id', ctx.userId)
        .is('archived_at', null) // Filter out archived
        .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
        .limit(habitLimit);
      if (habitsError) throw habitsError;

      // --- Fetch Goals ---
      const { data: goals, error: goalsError } = await ctx.supabaseAdmin
        .from('goals')
        .select(GOAL_FIELDS) // Use constant
        .eq('user_id', ctx.userId)
        .is('archived_at', null) // Filter out archived
        .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
        .limit(goalLimit);
      if (goalsError) throw goalsError;

      // --- Fetch Upcoming Tasks (focus on upcoming tasks and prioritize those due soon) ---
      const today = new Date();
      const twoWeeksFromNow = new Date();
      twoWeeksFromNow.setDate(today.getDate() + 14);
      
      // We want to fetch tasks that are:
      // 1. Not completed
      // 2. Due within the next two weeks, or overdue
      // 3. Either unassigned or associated with the dashboard goals
      const { data: tasks, error: tasksError } = await ctx.supabaseAdmin
        .from('tasks')
        .select(TASK_FIELDS) // Use constant
        .eq('user_id', ctx.userId)
        .is('archived_at', null) // Filter out archived
        .neq('status', 'completed') // Use correct enum value
        .or(`due_date.lte.${twoWeeksFromNow.toISOString()},due_date.is.null`)
        .order('due_date', { ascending: true, nullsFirst: false }) // Use 'due_date'
        .limit(taskLimit);
      if (tasksError) throw tasksError;

      // --- Fetch Active Tracked State Definitions ---
      const { data: trackedStateDefinitions, error: statesError } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .select(TRACKED_STATE_DEF_FIELDS) // Use constant
        .eq('user_id', ctx.userId)
        .eq('active', true)
        .order('sort_order', { ascending: true, nullsFirst: false }); // Correct: nullsFirst: false for nulls last
      if (statesError) throw statesError;
      
      // --- Fetch Latest State Entries for Active Definitions ---
      let latestEntriesMap: Record<string, { value: any; created_at: string }> = {};
      const stateDefIds = (trackedStateDefinitions || []).map(s => s.id);

      if (stateDefIds.length > 0) {
        // Use a CTE and ROW_NUMBER() to get the latest entry per state_id
        const { data: latestEntries, error: entriesError } = await ctx.supabaseAdmin.rpc(
          'get_latest_state_entries_for_user', 
          { p_user_id: ctx.userId, p_state_ids: stateDefIds }
        );

        if (entriesError) {
          console.error('Error fetching latest state entries:', entriesError);
          // Decide how to handle this - throw, or continue with empty/default values?
          // For now, log and continue, states will show default value
        } else {
          // Define expected type for entries from RPC
          type LatestEntry = { state_id: string; value: any; created_at: string };
          
          latestEntriesMap = (latestEntries as LatestEntry[] || []).reduce(
            (acc: Record<string, { value: any; created_at: string }>, entry: LatestEntry) => {
            acc[entry.state_id] = { value: entry.value, created_at: entry.created_at };
            return acc;
          }, {} as typeof latestEntriesMap);
        }
      }

      // --- Process Habits for 'completed' flag ---
      const todayStr = new Date().toISOString().split('T')[0];
      const habitIds = (habits || []).map(h => h.id);
      const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
        .from('habit_entries')
        .select('habit_id') // Only need habit_id to check existence
        .eq('user_id', ctx.userId)
        .eq('date', todayStr) // Filter by date
        .in('habit_id', habitIds);
      if (todayEntriesError) throw todayEntriesError;

      const completedHabitIds = new Set((habitEntriesToday || []).map(e => e.habit_id));

      const formattedHabits = (habits || []).map(h => ({... /* snippet truncated */
  ```

- **server/src/routers/goalProgressNoteRouter.ts** (5.2 KB, 168 lines)

  *Exports: `goalProgressNoteRouter` (unknown)*
  ```ts
goalProgressNoteRouter = router({
  // Get all notes for a specific goal
  getNotesForGoal: protectedProcedure
    .input(GetGoalProgressNotesInput)
    .query(async ({ ctx, input }) => {
      try {
        // First, ensure the goal exists and belongs to the user
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        // Fetch the notes for that goal
        const { data, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .eq('user_id', ctx.userId) // Redundant check, but good practice
          .eq('goal_id', input.goal_id)
          .order('created_at', { ascending: false }); // Newest first

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal progress notes',
        });
      }
    }),

  createNote: protectedProcedure
    .input(createGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Ensure the goal exists and belongs to the user before adding a note
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        const { data: note, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return note;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal progress note',
        });
      }
    }),

  updateNote: protectedProcedure
    .input(updateGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership of the note
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { data: updatedNote, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return updatedNote;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal progress note',
        });
      }
    }),

  deleteNote: protectedProcedure
    .input(DeleteGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal progress note',
        });
      }
    }),
})
  ```

- **server/src/routers/goalRouter.ts** (7.6 KB, 265 lines)

  *Exports: `goalRouter` (unknown)*
  ```ts
goalRouter = router({
getGoals: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      const { data: goals, error } = await ctx.supabaseAdmin
        .from('goals')
        .select(GOAL_FIELDS)
        .eq('user_id', ctx.userId)
        .is('archived_at', null)
        .order('sort_order', { ascending: true, nullsFirst: false })
        .order('created_at', { ascending: false });

      if (error) throw error;

      return goals || [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch goals',
      });
    }
  }),

getGoalById: protectedProcedure
  .input(z.object({
    id: z.string().uuid(),
  }))
  .query(async ({ ctx, input }) => {
    try {
      const { data: goal, error } = await ctx.supabaseAdmin
        .from('goals')
        .select(GOAL_FIELDS)
        .eq('id', input.id)
        .eq('user_id', ctx.userId)
        .single();

      if (error) throw error;
      if (!goal) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Goal not found',
        });
      }

      return goal;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch goal',
      });
    }
  }),

createGoal: protectedProcedure
  .input(createGoalInput)
  .mutation(async ({ ctx, input }) => {
    try {
      const { data: goal, error } = await ctx.supabaseAdmin
        .from('goals')
        .insert({
          ...input,
          user_id: ctx.userId,
        })
        .select(GOAL_FIELDS)
        .single();

      if (error) throw error;
      return goal;
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to create goal',
      });
    }
  }),

updateGoal: protectedProcedure
  .input(updateGoalInput)
  .mutation(async ({ ctx, input }) => {
    try {
      const { id, ...updateData } = input;

      const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
        .from('goals')
        .select('id')
        .eq('id', id)
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError || !existingGoal) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Goal not found or you do not have permission to update it',
        });
      }

      const { data: updatedGoal, error } = await ctx.supabaseAdmin
        .from('goals')
        .update(updateData)
        .eq('id', id)
        .eq('user_id', ctx.userId)
        .select(GOAL_FIELDS)
        .single();

      if (error) throw error;
      return updatedGoal;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to update goal',
      });
    }
  }),

deleteGoal: protectedProcedure
  .input(z.object({
    id: z.string().uuid(),
  }))
  .mutation(async ({ ctx, input }) => {
    try {
      const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
        .from('goals')
        .select('id')
        .eq('id', input.id)
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError || !existingGoal) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Goal not found or you do not have permission to delete it',
        });
      }

      const { error } = await ctx.supabaseAdmin
        .from('goals')
        .delete()
        .eq('id', input.id)
        .eq('user_id', ctx.userId);

      if (error) throw error;
      return { success: true, id: input.id };
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to delete goal',
      });
    }
  }),

listActive: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      const { data: goals, error } = await ctx.supabaseAdmin
        .from('goals')
        .select(GOAL_FIELDS)
        .eq('user_id', ctx.userId)
        .is('archived_at', null)
        .order('sort_order', { ascending: true, nullsFirst: false })
        .order('created_at', { ascending: false });
      if (error) throw error;
      return goals || [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch goals (in listActive stub)',
      });
    }
  }),

listArchived: protectedProcedure
  .query(async ({ ctx }) => {
... /* snippet truncated */
  ```

- **server/src/routers/habitRouter.ts** (21.7 KB, 578 lines) (2 TODOs)

  *Exports: `habitRouter` (unknown)*
  ```ts
habitRouter = router({
getHabits: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      const { data: habits, error: habitsError } = await ctx.supabaseAdmin
        .from('habits')
        .select(HABIT_FIELDS)
        .eq('user_id', ctx.userId)
        .is('archived_at', null)
        .order('sort_order', { ascending: true, nullsFirst: false })
        .order('created_at', { ascending: false });

      if (habitsError) throw habitsError;
      if (!habits) return [];

      const todayStr = new Date().toISOString().split('T')[0];

      const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
        .from('habit_entries')
        .select('habit_id')
        .eq('user_id', ctx.userId)
        .eq('date', todayStr)
        .in('habit_id', habits.map(h => h.id));

      if (todayEntriesError) throw todayEntriesError;

      const completedMap = (habitEntriesToday || []).reduce<Record<string, boolean>>((acc, entry) => {
        acc[entry.habit_id] = true;
        return acc;
      }, {});

      const formattedHabits = habits.map(h => ({
        ...h,
        completedToday: !!completedMap[h.id]
      }));

      return formattedHabits;
    } catch (error: any) {
      throw new TRPCError({ 
        code: 'INTERNAL_SERVER_ERROR', 
        message: error.message || 'Failed to fetch habits'
      });
    }
  }),

getHabitById: protectedProcedure
  .input(z.object({ id: z.string().uuid() }))
  .query(async ({ ctx, input }) => {
    const { data, error } = await ctx.supabaseAdmin
      .from("habits")
      .select(HABIT_FIELDS)
      .eq("id", input.id)
      .eq("user_id", ctx.userId)
      .single();

    if (error) throw new TRPCError({ 
      code: error.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
      message: error.message 
    });
    return data;
  }),

createHabit: protectedProcedure
  .input(createHabitInput)
  .mutation(async ({ ctx, input }) => {
    const { data, error } = await ctx.supabaseAdmin
      .from("habits")
      .insert({
        ...input,
        user_id: ctx.userId,
        streak: 0,
        best_streak: 0
      })
      .select(HABIT_FIELDS)
      .single();

    if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
    return data;
  }),

updateHabit: protectedProcedure
  .input(updateHabitInput)
  .mutation(async ({ ctx, input }) => {
    const { id, ...updateData } = input;

    const { data: habit, error: fetchError } = await ctx.supabaseAdmin
      .from("habits")
      .select("id")
      .eq("id", id)
      .eq("user_id", ctx.userId)
      .single();

    if (fetchError) throw new TRPCError({ 
      code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
      message: "Habit not found or access denied" 
    });

    const { data, error } = await ctx.supabaseAdmin
      .from("habits")
      .update(updateData)
      .eq("id", id)
      .eq('user_id', ctx.userId)
      .select(HABIT_FIELDS)
      .single();

    if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
    return data;
  }),

deleteHabit: protectedProcedure
  .input(z.object({ id: z.string().uuid() }))
  .mutation(async ({ ctx, input }) => {
    const { data: habit, error: fetchError } = await ctx.supabaseAdmin
      .from("habits")
      .select("id")
      .eq("id", input.id)
      .eq("user_id", ctx.userId)
      .single();

    if (fetchError) throw new TRPCError({ 
      code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
      message: "Habit not found or access denied" 
    });

    const { error } = await ctx.supabaseAdmin
      .from("habits")
      .delete()
      .eq("id", input.id);

    if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
    return { id: input.id };
  }),

listArchivedHabits: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      const { data: habits, error } = await ctx.supabaseAdmin
        .from('habits')
        .select(HABIT_FIELDS)
        .eq('user_id', ctx.userId)
        .not('archived_at', 'is', null)
        .order('archived_at', { ascending: false })
        .order('created_at', { ascending: false });

      if (error) throw error;
      return habits || [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch archived habits',
      });
    }
  }),

archiveHabit: protectedProcedure
  .input(z.object({ id: z.string().uuid() }))
  .mutation(async ({ ctx, input }) => {
    try {
      const { data: updatedHabit, error } = await ctx.supabaseAdmin
        .from('habits')
        .update({ arch... /* snippet truncated */
  ```

- **server/src/routers/principleRouter.ts** (5.7 KB, 171 lines) (4 TODOs)

  *Exports: `principleRouter` (unknown)*
  ```ts
principleRouter = router({
getPrinciples: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      const { data: principles, error } = await ctx.supabaseAdmin
        .from('principles')
        .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
        .eq('user_id', ctx.userId)
        .order('sort_order', { ascending: true, nullsFirst: false })
        .order('created_at', { ascending: false });

      if (error) throw error;
      // TODO: Parse with Principle schema from trpc-types?
      return principles || []; // Return empty array if null
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch principles',
      });
    }
  }),

getPrincipleById: protectedProcedure
  .input(z.object({
    id: z.string().uuid(),
  }))
  .query(async ({ ctx, input }) => {
    try {
      const { data: principle, error } = await ctx.supabaseAdmin
        .from('principles')
        .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
        .eq('id', input.id)
        .eq('user_id', ctx.userId)
        .single();

      if (error) {
         if (error.code === 'PGRST116') { // Handle not found specifically
           throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found' });
         }
         throw error; // Rethrow other errors
      }
      // No need for !principle check if .single() is used and error isn't PGRST116

      // TODO: Parse with Principle schema from trpc-types?
      return principle;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;

      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch principle',
      });
    }
  }),

createPrinciple: protectedProcedure
  .input(createPrincipleInput) // This Zod schema now expects 'title' and 'body'
  .mutation(async ({ ctx, input }) => {
    try {
      const { data: principle, error } = await ctx.supabaseAdmin
        .from('principles')
        .insert({
          ...input, // Spread validated input, already contains 'title' and 'body'
          user_id: ctx.userId,
        })
        .select(PRINCIPLE_FIELDS) // Use the constant
        .single();

      if (error) throw error;
      // TODO: Parse with Principle schema from trpc-types?
      return principle;
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to create principle',
      });
    }
  }),

updatePrinciple: protectedProcedure
  .input(updatePrincipleInput) // This Zod schema now expects 'title' and 'body' (optional)
  .mutation(async ({ ctx, input }) => {
    try {
      const { id, ...updateData } = input;

      // Check ownership
      const { data: existing, error: fetchError } = await ctx.supabaseAdmin
        .from('principles')
        .select('id')
        .eq('id', id)
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError) {
         if (fetchError.code === 'PGRST116') {
           throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to update it' });
         }
         throw fetchError;
      }

      // Update
      const { data: updatedPrinciple, error } = await ctx.supabaseAdmin
        .from('principles')
        .update(updateData) // updateData contains validated 'title'/'body' if provided
        .eq('id', id)
        .eq('user_id', ctx.userId)
        .select(PRINCIPLE_FIELDS) // Use the constant
        .single();

      if (error) throw error;
      // TODO: Parse with Principle schema from trpc-types?
      return updatedPrinciple;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;

      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to update principle',
      });
    }
  }),

deletePrinciple: protectedProcedure
  .input(z.object({
    id: z.string().uuid(),
  }))
  .mutation(async ({ ctx, input }) => {
    try {
      // Check ownership
      const { data: existing, error: fetchError } = await ctx.supabaseAdmin
        .from('principles')
        .select('id')
        .eq('id', input.id)
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError) {
          if (fetchError.code === 'PGRST116') {
           throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to delete it' });
         }
         throw fetchError;
      }

      // Delete
      const { error } = await ctx.supabaseAdmin
        .from('principles')
        .delete()
        .eq('id', input.id)
        .eq('user... /* snippet truncated */
  ```

- **server/src/routers/reminderRouter.ts** (4.9 KB, 161 lines) (1 TODOs)

  *Exports: `reminderRouter` (unknown)*
  ```ts
reminderRouter = router({
  // Get all active reminders for the user (might need refinement later)
  getActiveReminders: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('is_active', true)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch active reminders',
        });
      }
    }),

  // Get reminders linked to a specific entity
  getRemindersForEntity: protectedProcedure
    .input(GetRemindersForEntityInput)
    .query(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('related_entity_type', input.related_entity_type)
          .eq('related_entity_id', input.related_entity_id)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch reminders for entity',
        });
      }
    }),

  createReminder: protectedProcedure
    .input(createReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // TODO: Potentially validate that related_entity_id exists and belongs to user?
        // This requires knowing the related_entity_type and querying the correct table.
        // For now, assume valid input.
        const { data: reminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return reminder;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create reminder',
        });
      }
    }),

  updateReminder: protectedProcedure
    .input(updateReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { data: updatedReminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return updatedReminder;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update reminder',
        });
      }
    }),

  deleteReminder: protectedProcedure
    .input(DeleteReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('reminders')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete reminder',
        });
      }
    }),
})
  ```

- **server/src/routers/rewardsRouter.ts** (10.4 KB, 336 lines)

  *Exports: `rewardsRouter` (unknown)*
  ```ts
rewardsRouter = router({
// Get all rewards for current user
getUserRewards: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      // Select specific fields aligned with our Zod types
      const { data: rewards, error } = await ctx.supabaseAdmin
        .from('user_rewards')
        .select('id, user_id, reward_id, earned_at, rewards(id, name, description, emoji, image_url, required_points, type)')
        .eq('user_id', ctx.userId)
        .order('earned_at', { ascending: false });

      if (error) throw error;
      return rewards || [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch user rewards',
      });
    }
  }),

// Get available rewards that can be earned
getAvailableRewards: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      // Get all rewards with specific fields
      const { data: allRewards, error: rewardsError } = await ctx.supabaseAdmin
        .from('rewards')
        .select('id, name, description, emoji, image_url, required_points, type, can_earn_multiple')
        .order('required_points', { ascending: true });

      if (rewardsError) throw rewardsError;

      // Get already earned rewards
      const { data: earnedRewards, error: earnedError } = await ctx.supabaseAdmin
        .from('user_rewards')
        .select('reward_id')
        .eq('user_id', ctx.userId);

      if (earnedError) throw earnedError;

      // Filter out already earned one-time rewards
      const earnedIds = new Set((earnedRewards || []).map(er => er.reward_id));
      const availableRewards = allRewards?.filter(reward => 
        !earnedIds.has(reward.id) || reward.can_earn_multiple);

      return availableRewards || [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch available rewards',
      });
    }
  }),

// Get user points
getUserPoints: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      const { data: userProfile, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('points, lifetime_points')
        .eq('id', ctx.userId)
        .single();

      if (error) throw error;
      return {
        points: userProfile?.points || 0,
        lifetimePoints: userProfile?.lifetime_points || 0,
      };
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch user points',
      });
    }
  }),

// Earn a reward if eligible
earnReward: protectedProcedure
  .input(claimLootInput)
  .mutation(async ({ ctx, input }) => {
    try {
      // Get the reward details
      const { data: reward, error: rewardError } = await ctx.supabaseAdmin
        .from('rewards')
        .select('*')
        .eq('id', input.rewardId)
        .single();

      if (rewardError || !reward) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Reward not found',
        });
      }

      // Check if user has enough points
      const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
        .from('profiles')
        .select('points')
        .eq('id', ctx.userId)
        .single();

      if (profileError || !userProfile) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch user profile',
        });
      }

      if (userProfile.points < reward.required_points) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: 'Not enough points to earn this reward',
        });
      }

      // If the reward is one-time, check if already earned
      if (!reward.can_earn_multiple) {
        const { data: existingReward, error: existingError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('id')
          .eq('user_id', ctx.userId)
          .eq('reward_id', input.rewardId)
          .single();

        if (existingReward) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'You have already earned this one-time reward',
          });
        }
      }

      // Begin transaction
      // 1. Deduct points from user
      const { error: updateError } = await ctx.supabaseAdmin
        .from('profiles')
        .update({
          points: userProfile.points - reward.required_points,
        })
        .eq('id', ctx.userId);

      if (updateError) throw updateError;

      // 2. Add reward to user's earned rewards
      const { data: userReward, error: insertError } = await ctx.supabaseAdmin
        .from('user_rewards')
        .insert({
          user_id: ctx... /* snippet truncated */
  ```

- **server/src/routers/taskRouter.ts** (21.0 KB, 616 lines) (16 TODOs)

  *Exports: `taskRouter` (unknown)*
  ```ts
taskRouter = router({
getTasks: protectedProcedure // Gets non-archived tasks
  .input(z.object({
    goalId: z.string().uuid().optional(),
    // TODO: Add filters for status, priority, dates etc.?
  }))
  .query(async ({ ctx, input }) => {
    try {
      let query = ctx.supabaseAdmin
        .from('tasks')
        .select(TASK_FIELDS)
        .eq('user_id', ctx.userId)
        .is('archived_at', null); // Filter out archived

      if (input.goalId) {
        query = query.eq('goal_id', input.goalId);
      }

      // TODO: Add complex priority enum sorting? (e.g. high > medium > low)
      const { data: tasks, error } = await query
        .order('sort_order', { ascending: true, nullsFirst: false })
        .order('due_date', { ascending: true, nullsFirst: false }) // Order by due date (nulls last)
        .order('created_at', { ascending: false });

      if (error) throw error;
      // TODO: Parse with Task schema?
      return tasks || [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch tasks',
      });
    }
  }),

getTaskById: protectedProcedure
  .input(z.object({
    id: z.string().uuid(), // Use uuid validation
  }))
  .query(async ({ ctx, input }) => {
    try {
      const { data: task, error } = await ctx.supabaseAdmin
        .from('tasks')
        .select(TASK_FIELDS)
        .eq('id', input.id)
        .eq('user_id', ctx.userId)
        .single();

      if (error) throw error;
      if (!task) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Task not found',
        });
      }

      // TODO: Parse with Task schema?
      return task;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch task',
      });
    }
  }),

createTask: protectedProcedure
  .input(createTaskInput) // Use imported input type
  .mutation(async ({ ctx, input }) => {
    try {
      // Verify goal_id if provided
      if (input.goal_id) {
        const { data: goal, error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId) // Ensure goal belongs to user
          .is('archived_at', null) // Ensure goal is not archived
          .single();

        if (goalError || !goal) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Invalid or archived goal ID',
          });
        }
      }

      // Verify parent_task_id if provided
      if (input.parent_task_id) {
        const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.parent_task_id)
          .eq('user_id', ctx.userId) // Ensure parent belongs to user
          .is('archived_at', null) // Ensure parent is not archived
          .single();

        if (parentError || !parentTask) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Invalid or archived parent task ID',
          });
        }
      }

      const { data: task, error } = await ctx.supabaseAdmin
        .from('tasks')
        .insert({
          ...input, // Spread validated input (includes new fields like parent_task_id, recurrence etc)
          user_id: ctx.userId,
          // Ensure due_date is used if present in input
          due_date: input.due_date ?? null, // Use correct field name
        })
        .select(TASK_FIELDS)
        .single();

      if (error) {
         // Handle specific errors like FK violations?
         console.error("Create task error:", error);
         throw error;
      }
      // TODO: Parse with Task schema?
      return task;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to create task',
      });
    }
  }),

updateTask: protectedProcedure
  .input(updateTaskInput) // Use imported input type
  .mutation(async ({ ctx, input }) => {
    try {
      const { id, ...updateData } = input; // Separate id from update payload

      // Check ownership
      const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
        .from('tasks')
        .select('id, parent_task_id') // Select parent_task_id for cycle check
        .eq('id', id)
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError || !existingTask) {
        throw new TRPCError({
          code: 'NOT_FOUND',
       ... /* snippet truncated */
  ```

- **server/src/routers/trackedStateRouter.ts** (11.2 KB, 325 lines)

  *Exports: `trackedStateRouter` (unknown)*
  ```ts
trackedStateRouter = router({
getDefinitions: protectedProcedure
  .query(async ({ ctx }) => {
    try {
      const { data, error } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .select(TRACKED_STATE_DEF_FIELDS)
        .eq('user_id', ctx.userId)
        .eq('active', true)
        .order('priority', { ascending: true, nullsFirst: false }) // Corrected: nullsFirst
        .order('created_at', { ascending: true });

      if (error) throw error;
      return data ?? [];
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch tracked state definitions',
      });
    }
  }),

getDefinitionById: protectedProcedure
  .input(GetTrackedStateDefByIdInput) // Use correct Zod schema
  .query(async ({ ctx, input }) => {
     try {
      const { data: definition, error } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .select(TRACKED_STATE_DEF_FIELDS)
        .eq('id', input.id) // input.id is now correctly typed
        .eq('user_id', ctx.userId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Tracked state definition not found.' });
        }
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      }
      return definition;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to fetch tracked state definition',
      });
    }
  }),

createDefinition: protectedProcedure
  .input(createTrackedStateDefInput) // Use correct Zod schema
  .mutation(async ({ ctx, input }) => {
     try {
      const { data: definition, error } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .insert({
          ...input, // input is now correctly typed
          user_id: ctx.userId,
        })
        .select(TRACKED_STATE_DEF_FIELDS)
        .single();

      if (error) throw error;
      return definition;
    } catch (error: any) {
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to create tracked state definition',
      });
    }
  }),

updateDefinition: protectedProcedure
  .input(updateTrackedStateDefInput) // Use correct Zod schema
  .mutation(async ({ ctx, input }) => {
     try {
      const { id, ...updateData } = input; // input is now correctly typed

      const { error: fetchError } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .select('id')
        .eq('id', id)
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError) {
        throw new TRPCError({
          code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
          message: 'Definition not found or access denied.',
        });
      }

      const { data: updatedDefinition, error } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .update(updateData)
        .eq('id', id)
        .eq('user_id', ctx.userId)
        .select(TRACKED_STATE_DEF_FIELDS)
        .single();

      if (error) throw error;
      return updatedDefinition;
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to update tracked state definition',
      });
    }
  }),

deleteDefinition: protectedProcedure
  .input(DeleteTrackedStateDefInput) // Use correct Zod schema
  .mutation(async ({ ctx, input }) => {
     try {
      const { error: fetchError } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .select('id')
        .eq('id', input.id) // input.id is now correctly typed
        .eq('user_id', ctx.userId)
        .single();

      if (fetchError) {
        throw new TRPCError({
          code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
          message: 'Definition not found or access denied.',
        });
      }

      const { error } = await ctx.supabaseAdmin
        .from('tracked_state_defs')
        .delete()
        .eq('id', input.id) // input.id is now correctly typed
        .eq('user_id', ctx.userId);

      if (error) throw error;
      return { success: true, id: input.id }; // input.id is now correctly typed
    } catch (error: any) {
      if (error instanceof TRPCError) throw error;
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: error.message || 'Failed to delete tracked state definition',
      });
    }
  }),

// --- State Entry Procedures --... /* snippet truncated */
  ```

- **server/src/routers/userRouter.ts** (5.6 KB, 171 lines)

  *Exports: `userRouter` (unknown)*
  ```ts
userRouter = router({
getProfile: protectedProcedure
  .query(async ({ ctx }) => {
    const { data, error } = await ctx.supabaseAdmin
      .from('profiles')
      .select('id, username, avatar_url, full_name, bio, time_zone, onboarding_completed, created_at, updated_at')
      .eq('id', ctx.userId)
      .single();
      
    if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
    return data;
  }),
  
updateProfile: protectedProcedure
  .input(z.object({
    full_name: z.string().optional(),
    avatar_url: z.string().optional(),
    theme: z.string().optional(),
    time_zone: z.string().optional(),
    display_name: z.string().optional(),
    bio: z.string().optional(),
  }))
  .mutation(async ({ ctx, input }) => {
    const { data, error } = await ctx.supabaseAdmin
      .from('profiles')
      .update(input)
      .eq('id', ctx.userId)
      .select()
      .single();
      
    if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
    return data;
  }),
  
getUserSettings: protectedProcedure
  .query(async ({ ctx }) => {
    const { data, error } = await ctx.supabaseAdmin
      .from('user_settings')
      .select('id, user_id, notification_preferences, ui_preferences')
      .eq('user_id', ctx.userId)
      .single();
      
    if (error) {
      // If settings don't exist, create default settings
      if (error.code === 'PGRST116') {
        const { data: newSettings, error: createError } = await ctx.supabaseAdmin
          .from('user_settings')
          .insert({
            user_id: ctx.userId,
            notification_preferences: {
              email: true,
              push: true,
              task_reminders: true,
              goal_updates: true,
              habit_reminders: true
            },
            ui_preferences: {
              theme: 'system',
              compact_view: false,
              show_completed_tasks: true
            }
          })
          .select()
          .single();
          
        if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
        return newSettings;
      }
      
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
    }
    
    return data;
  }),
  
updateUserSettings: protectedProcedure
  .input(z.object({
    notification_preferences: z.object({
      email: z.boolean().optional(),
      push: z.boolean().optional(),
      task_reminders: z.boolean().optional(),
      goal_updates: z.boolean().optional(),
      habit_reminders: z.boolean().optional()
    }).optional(),
    ui_preferences: z.object({
      theme: z.string().optional(),
      compact_view: z.boolean().optional(),
      show_completed_tasks: z.boolean().optional()
    }).optional()
  }))
  .mutation(async ({ ctx, input }) => {
    // First check if settings exist
    const { data: existingSettings, error: fetchError } = await ctx.supabaseAdmin
      .from('user_settings')
      .select('id')
      .eq('user_id', ctx.userId)
      .single();
      
    if (fetchError && fetchError.code === 'PGRST116') {
      // Create settings if they don't exist
      const defaultSettings = {
        user_id: ctx.userId,
        notification_preferences: {
          email: true,
          push: true,
          task_reminders: true,
          goal_updates: true,
          habit_reminders: true,
          ...input.notification_preferences
        },
        ui_preferences: {
          theme: 'system',
          compact_view: false,
          show_completed_tasks: true,
          ...input.ui_preferences
        }
      };
      
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .insert(defaultSettings)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    } else if (fetchError) {
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: fetchError.message });
    }
    
    // Update existing settings
    const { data, error } = await ctx.supabaseAdmin
      .from('user_settings')
      .update(input)
      .eq('user_id', ctx.userId)
      .select()
      .single();
      
    if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
    return data;
  }),
  
getOnboardingStatus: protectedProcedure
  .query(async ({ ctx }) => {
    const { data, error } = await ctx.supabaseAdmin
      .from('profiles')
      .select('id, onboarding_completed')
      .eq('id', ctx.userId)
      .single();
      
    if (error) throw new TRPCError({ code: 'INTE... /* snippet truncated */
  ```

- **server/src/routers/valueRouter.ts** (5.0 KB, 167 lines) (4 TODOs)

  *Exports: `valueRouter` (unknown)*
  ```ts
valueRouter = router({
  getValues: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: values, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return values;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch values',
        });
      }
    }),

  getValueById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!value) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found',
          });
        }

        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch value',
        });
      }
    }),

  createValue: protectedProcedure
    .input(createValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create value',
        });
      }
    }),

  updateValue: protectedProcedure
    .input(updateValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // First check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to update it',
          });
        }

        // Update the value
        const { data: updatedValue, error } = await ctx.supabaseAdmin
          .from('values')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return updatedValue;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update value',
        });
      }
    }),

  deleteValue: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to delete it',
          });
        }

        // Delete the value
        const { error } = await ctx.supabaseAdmin
          .from('values')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete value',
        });
      }
    }),
})
  ```

- **server/src/types/index.ts** (1.5 KB, 75 lines)

  *Exports: `Badge` (interface)*
  ```ts
interface Badge {
  id: BadgeId;
  title: string;
  icon: string; // Hero‑icons name or emoji
  earnedAt?: string; // ISO
  progress?: number; // 0‒1 for not‑yet
}
  ```

  *Exports: `BadgeId` (type)*
  ```ts
type BadgeId = string;
  ```

  *Exports: `Goal` (interface)*
  ```ts
interface Goal {
  id: GoalId;
  title: string;
  description?: string;
  valueIds: ValueId[];
  progress: number; // 0‒1
  keyResults: KeyResult[];
  targetDate?: string; // ISO
}
  ```

  *Exports: `GoalId` (type)*
  ```ts
type GoalId = string;
  ```

  *Exports: `Habit` (interface)*
  ```ts
interface Habit {
  id: HabitId;
  title: string;
  cue?: string;
  routine?: string;
  reward?: string;
  valueIds: ValueId[];
  streak: number; // current consecutive days
  bestStreak: number;
  history: Record<string, boolean>; // ISO day → done?
}
  ```

  *Exports: `HabitId` (type)*
  ```ts
type HabitId = string;
  ```

  *Exports: `KeyResult` (interface)*
  ```ts
interface KeyResult {
  id: string;
  title: string;
  progress: number; // 0‒1
}
  ```

  *Exports: `Principle` (interface)*
  ```ts
interface Principle {
  id: string;
  title: string;
  body: string;
  valueIds: ValueId[];
}
  ```

  *Exports: `Task` (interface)*
  ```ts
interface Task {
  id: TaskId;
  title: string;
  notes?: string;
  status: 'todo' | 'doing' | 'done' | 'blocked';
  due?: string; // ISO date
  priority?: 1 | 2 | 3;
  goalId?: GoalId;
  valueIds?: ValueId[];
}
  ```

  *Exports: `TaskId` (type)*
  ```ts
type TaskId = string;
  ```

  *Exports: `TrackedStateDef` (interface)*
  ```ts
interface TrackedStateDef {
  id: string;
  name: string;
  scale: '1-5' | 'low-high' | 'custom';
  customLabels?: string[];
  valueIds: ValueId[];
}
  ```

  *Exports: `Value` (interface)*
  ```ts
interface Value {
  id: ValueId;
  name: string;
  description?: string;
  color: string; // tailwind color token (e.g. 'indigo-500')
  domainId?: string; // optional grouping
}
  ```

  *Exports: `ValueId` (type)*
  ```ts
type ValueId = string;
  ```

- **server/src/types/trpc-types.ts** (14.2 KB, 360 lines)

  *Exports: `awardBadgeInput` (unknown)*
  ```ts
awardBadgeInput = z.object({
  badgeId: z.string(), // Matches text ID in badge_definitions
  description: z.string().optional(), // Example custom field if needed
})
  ```

  *Exports: `BadgeDefinition` (component)*
  ```ts
BadgeDefinition = z.object({
  id: z.string(), // From DB: text primary key
  title: z.string(),
  description: z.string().nullish(),
  icon: z.string(),
})
  ```

  *Exports: `BadgeDefinition` (type)*
  ```ts
type BadgeDefinition = z.infer<typeof BadgeDefinition>;
  ```

  *Exports: `claimLootInput` (unknown)*
  ```ts
claimLootInput = z.object({
  rewardId: z.string().uuid(), // Use rewardId to match router
})
  ```

  *Exports: `createGoalInput` (unknown)*
  ```ts
createGoalInput = Goal.omit({ id: true, user_id: true, created_at: true, updated_at: true })
  ```

  *Exports: `createGoalProgressNoteInput` (unknown)*
  ```ts
createGoalProgressNoteInput = GoalProgressNote.omit({ id: true, user_id: true, created_at: true })
  ```

  *Exports: `createHabitEntryInput` (unknown)*
  ```ts
createHabitEntryInput = HabitEntry.omit({ id: true, user_id: true, created_at: true })
  ```

  *Exports: `createHabitInput` (unknown)*
  ```ts
createHabitInput = Habit.omit({ id: true, user_id: true, created_at: true, updated_at: true })
  ```

  *Exports: `createPrincipleInput` (unknown)*
  ```ts
createPrincipleInput = Principle.omit({ id: true, user_id: true, created_at: true, updated_at: true })
  ```

  *Exports: `createReminderInput` (unknown)*
  ```ts
createReminderInput = Reminder.omit({ id: true, user_id: true, created_at: true, updated_at: true })
  ```

  *Exports: `CreateStateEntryInput` (component)*
  ```ts
CreateStateEntryInput = StateEntry.omit({ id: true, user_id: true })
.extend({
  tracked_state_def_id: z.string().uuid(), // Ensure this is required
  // Values are optional in base schema
})
  ```

  *Exports: `createTaskInput` (unknown)*
  ```ts
createTaskInput = Task.omit({ id: true, user_id: true, created_at: true, updated_at: true })
  ```

  *Exports: `createTrackedStateDefInput` (unknown)*
  ```ts
createTrackedStateDefInput = TrackedStateDef.omit({ id: true, user_id: true, created_at: true, updated_at: true })
  ```

  *Exports: `createValueInput` (unknown)*
  ```ts
createValueInput = Value.omit({ id: true, user_id: true, created_at: true, updated_at: true })
  ```

  *Exports: `DeleteGoalProgressNoteInput` (component)*
  ```ts
DeleteGoalProgressNoteInput = z.object({ id: z.string().uuid() })
  ```

  *Exports: `DeleteReminderInput` (component)*
  ```ts
DeleteReminderInput = z.object({ id: z.string().uuid() })
  ```

  *Exports: `DeleteStateEntryInput` (component)*
  ```ts
DeleteStateEntryInput = z.object({ id: z.string().uuid() })
  ```

  *Exports: `DeleteTrackedStateDefInput` (component)*
  ```ts
DeleteTrackedStateDefInput = z.object({ id: z.string().uuid() })
  ```

  *Exports: `GetGoalProgressNotesInput` (component)*
  ```ts
GetGoalProgressNotesInput = z.object({ goal_id: z.string().uuid() })
  ```

  *Exports: `GetRemindersForEntityInput` (component)*
  ```ts
GetRemindersForEntityInput = z.object({
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
})
  ```

  *Exports: `GetStateEntriesInput` (component)*
  ```ts
GetStateEntriesInput = z.object({
  tracked_state_def_id: z.string().uuid(), // Renamed from definition_id to match DB? Check usage.
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  limit: z.number().int().positive().optional(),
})
  ```

  *Exports: `GetTrackedStateDefByIdInput` (component)*
  ```ts
GetTrackedStateDefByIdInput = z.object({ id: z.string().uuid() })
  ```

  *Exports: `Goal` (component)*
  ```ts
Goal = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  description: z.string().nullish(),
  progress: z.number().nullish(),
  target_date: z.string().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime().nullish(),
  updated_at: z.string().datetime().nullish(),
})
  ```

  *Exports: `Goal` (type)*
  ```ts
type Goal = z.infer<typeof Goal>;
  ```

  *Exports: `GoalProgressNote` (component)*
  ```ts
GoalProgressNote = z.object({
  id: z.string().uuid(),
  goal_id: z.string().uuid(),
  user_id: z.string().uuid(),
  note: z.string(),
  created_at: z.string().datetime(),
})
  ```

  *Exports: `GoalProgressNote` (type)*
  ```ts
type GoalProgressNote = z.infer<typeof GoalProgressNote>;
  ```

  *Exports: `greetingInput` (unknown)*
  ```ts
greetingInput = z.object({ name: z.string().optional() })
  ```

  *Exports: `greetingOutput` (unknown)*
  ```ts
greetingOutput = z.object({ greeting: z.string() })
  ```

  *Exports: `Habit` (component)*
  ```ts
Habit = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  cue: z.string().nullish(),
  routine: z.string().nullish(),
  reward: z.string().nullish(),
  streak: z.number().nonnegative().default(0),
  best_streak: z.number().nonnegative().default(0),
  habit_type: HabitTypeEnum.default('boolean'),
  goal_quantity: z.number().int().nullish(),
  goal_unit: z.string().nullish(),
  frequency_period: HabitFrequencyPeriodEnum.default('day'),
  goal_frequency: z.number().int().positive().default(1),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(), // <<< Added sort_order
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
})
  ```

  *Exports: `Habit` (type)*
  ```ts
type Habit = z.infer<typeof Habit>;
  ```

  *Exports: `HabitEntry` (component)*
  ```ts
HabitEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  habit_id: z.string().uuid(),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be in YYYY-MM-DD format"),
  completed: z.boolean().default(false),
  quantity_value: z.number().int().nullish(),
  notes: z.string().nullish(),
  created_at: z.string().datetime(),
})
  ```

  *Exports: `HabitEntry` (type)*
  ```ts
type HabitEntry = z.infer<typeof HabitEntry>;
  ```

  *Exports: `HabitFrequencyPeriodEnum` (component)*
  ```ts
HabitFrequencyPeriodEnum = z.enum(['day', 'week', 'month'])
  ```

  *Exports: `HabitTypeEnum` (component)*
  ```ts
HabitTypeEnum = z.enum(['boolean', 'quantity'])
  ```

  *Exports: `NotificationPrefs` (component)*
  ```ts
NotificationPrefs = z.object({
  email: z.boolean().default(true),
  push: z.boolean().default(true),
  task_reminders: z.boolean().default(true),
  goal_updates: z.boolean().default(true),
  habit_reminders: z.boolean().default(true),
})
  ```

  *Exports: `PointTransaction` (component)*
  ```ts
PointTransaction = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  points: z.number().int(),
  reason: z.string(),
  source_type: z.string(),
  source_id: z.string().uuid().nullish(),
  created_at: z.string().datetime(),
})
  ```

  *Exports: `PointTransaction` (type)*
  ```ts
type PointTransaction = z.infer<typeof PointTransaction>;
  ```

  *Exports: `Principle` (component)*
  ```ts
Principle = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), // <<< Changed from 'name' to 'title'
  body: z.string(), // <<< Renamed from description for clarity, matching migration
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
})
  ```

  *Exports: `Principle` (type)*
  ```ts
type Principle = z.infer<typeof Principle>;
  ```

  *Exports: `Reminder` (component)*
  ```ts
Reminder = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
  reminder_time: z.string().datetime(),
  is_active: z.boolean().default(true),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
})
  ```

  *Exports: `Reminder` (type)*
  ```ts
type Reminder = z.infer<typeof Reminder>;
  ```

  *Exports: `Reward` (component)*
  ```ts
Reward = z.object({
  id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullish(),
  type: RewardTypeEnum,
  required_points: z.number().int().nonnegative().default(0),
  can_earn_multiple: z.boolean().default(false),
  image_url: z.string().url().nullish(),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
})
  ```

  *Exports: `Reward` (type)*
  ```ts
type Reward = z.infer<typeof Reward>;
  ```

  *Exports: `RewardTypeEnum` (component)*
  ```ts
RewardTypeEnum = z.enum(['badge', 'achievement', 'item', 'discount'])
  ```

  *Exports: `RouterInputs` (type)*
  ```ts
type RouterInputs = inferRouterInputs<AppRouter>;
  ```

  *Exports: `RouterOutputs` (type)*
  ```ts
type RouterOutputs = inferRouterOutputs<AppRouter>;
  ```

  *Exports: `StateEntry` (component)*
  ```ts
StateEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  definition_id: z.string().uuid(), // <<< Renamed from tracked_state_def_id for consistency? check DB
  value_numeric: z.number().optional().nullable(),
  value_text: z.string().optional().nullable(),
  entry_timestamp: z.string().datetime({ message: "Invalid datetime string. Must be UTC ISO 8601" }).optional(),
  notes: z.string().optional().nullable(), // <<< Added notes
})
  ```

  *Exports: `StateEntry` (type)*
  ```ts
type StateEntry = z.infer<typeof StateEntry>;
  ```

  *Exports: `Task` (component)*
  ```ts
Task = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  notes: z.string().nullish(),
  status: TaskStatusEnum.default('todo'),
  priority_enum: TaskPriorityEnum.nullish(), // <<< Renamed from priority
  due_date: z.string().datetime().nullish(),
  goal_id: z.string().uuid().nullish(),
  parent_task_id: z.string().uuid().nullish(),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
})
  ```

  *Exports: `Task` (type)*
  ```ts
type Task = z.infer<typeof Task>;
  ```

  *Exports: `TaskPriorityEnum` (component)*
  ```ts
TaskPriorityEnum = z.enum(['low', 'medium', 'high'])
  ```

  *Exports: `TaskStatusEnum` (component)*
  ```ts
TaskStatusEnum = z.enum(['todo', 'doing', 'done', 'blocked', 'pending'])
  ```

  *Exports: `TrackedStateDef` (component)*
  ```ts
TrackedStateDef = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  name: z.string(),
  // category: z.string(), // Category seems removed/replaced in DB schema by scale/custom_labels
  scale: z.enum(['1-5', 'low-high', 'custom']), // <<< Added scale
  custom_labels: z.array(z.string()).nullish(), // <<< Added custom_labels
  unit: z.string().nullish(), // Keep unit if still used alongside scale
  icon: z.string().nullish(), // Keep icon if still used
  target_min_value: z.number().nullish(), // <<< Added
  target_max_value: z.number().nullish(), // <<< Added
  active: z.boolean().default(true), // <<< Added active
  priority: z.number().int().default(1), // <<< Added priority
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
})
  ```

  *Exports: `TrackedStateDef` (type)*
  ```ts
type TrackedStateDef = z.infer<typeof TrackedStateDef>;
  ```

  *Exports: `UiPrefs` (component)*
  ```ts
UiPrefs = z.object({
  theme: z.enum(['system', 'light', 'dark']).default('system'),
  compact_view: z.boolean().default(false),
  show_completed_tasks: z.boolean().default(true),
  first_day_of_week: z.number().int().min(0).max(6).default(0),
})
  ```

  *Exports: `updateGoalInput` (unknown)*
  ```ts
updateGoalInput = createGoalInput.partial().extend({ id: z.string().uuid() })
  ```

  *Exports: `updateGoalProgressNoteInput` (unknown)*
  ```ts
updateGoalProgressNoteInput = createGoalProgressNoteInput.partial().extend({ id: z.string().uuid() })
  ```

  *Exports: `updateHabitEntryInput` (unknown)*
  ```ts
updateHabitEntryInput = createHabitEntryInput.partial().extend({ id: z.string().uuid() })
  ```

  *Exports: `updateHabitInput` (unknown)*
  ```ts
updateHabitInput = createHabitInput.partial().extend({ id: z.string().uuid() })
  ```

  *Exports: `updatePrincipleInput` (unknown)*
  ```ts
updatePrincipleInput = createPrincipleInput.partial().extend({ id: z.string().uuid() })
  ```

  *Exports: `updateProfileInput` (unknown)*
  ```ts
updateProfileInput = UserProfile.partial().omit({ id: true, created_at: true, updated_at: true })
  ```

  *Exports: `updateReminderInput` (unknown)*
  ```ts
updateReminderInput = createReminderInput.partial().extend({ id: z.string().uuid() })
  ```

  *Exports: `updateSettingsInput` (unknown)*
  ```ts
updateSettingsInput = z.object({
  notification_preferences: NotificationPrefs.partial().optional(),
  ui_preferences: UiPrefs.partial().optional(),
})
  ```

  *Exports: `updateStateEntryInput` (unknown)*
  ```ts
updateStateEntryInput = CreateStateEntryInput.partial().extend({ id: z.string().uuid() })
  ```

  *Exports: `updateTaskInput` (unknown)*
  ```ts
updateTaskInput = createTaskInput.partial().extend({ id: z.string().uuid() })
  ```

  *Exports: `updateTaskStatusInput` (unknown)*
  ```ts
updateTaskStatusInput = z.object({ id: z.string().uuid(), status: TaskStatusEnum })
  ```

  *Exports: `updateTrackedStateDefInput` (unknown)*
  ```ts
updateTrackedStateDefInput = createTrackedStateDefInput.partial().extend({ id: z.string().uuid() })
  ```

  *Exports: `updateValueInput` (unknown)*
  ```ts
updateValueInput = createValueInput.partial().extend({ id: z.string().uuid() })
  ```

  *Exports: `UserBadge` (component)*
  ```ts
UserBadge = z.object({
  // Note: user_badges might be merged into user_rewards with type='badge'
  user_id: z.string().uuid(),
  badge_id: z.string(), // Matches badge_definitions.id (text)
  earned_at: z.string().datetime(),
  progress: z.number().nullish(), // From DB schema
})
  ```

  *Exports: `UserBadge` (type)*
  ```ts
type UserBadge = z.infer<typeof UserBadge>;
  ```

  *Exports: `UserProfile` (component)*
  ```ts
UserProfile = z.object({
  id: z.string().uuid(),
  username: z.string().nullish(),
  avatar_url: z.string().url().nullish(),
  full_name: z.string().nullish(),
  bio: z.string().nullish(),
  points: z.number().int().nonnegative().default(0),
  time_zone: z.string().nullish(),
  onboarding_completed: z.boolean().default(false),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
})
  ```

  *Exports: `UserProfile` (type)*
  ```ts
type UserProfile = z.infer<typeof UserProfile>;
  ```

  *Exports: `UserReward` (component)*
  ```ts
UserReward = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  reward_id: z.string().uuid(),
  reward_type: z.string().nullish(), // From DB schema
  earned_at: z.string().datetime(),
  points_spent: z.number().int().nonnegative().default(0),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
})
  ```

  *Exports: `UserReward` (type)*
  ```ts
type UserReward = z.infer<typeof UserReward>;
  ```

  *Exports: `UserSettings` (component)*
  ```ts
UserSettings = z.object({
  id: z.string().uuid().optional(),
  user_id: z.string().uuid(),
  notification_preferences: NotificationPrefs,
  ui_preferences: UiPrefs,
})
  ```

  *Exports: `UserSettings` (type)*
  ```ts
type UserSettings = z.infer<typeof UserSettings>;
  ```

  *Exports: `Value` (component)*
  ```ts
Value = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), 
  description: z.string().nullish(),
  color: z.string().nullish(),
  icon: z.string().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
})
  ```

  *Exports: `Value` (type)*
  ```ts
type Value = z.infer<typeof Value>;
  ```

- **server/tsconfig.json** (0.5 KB, 19 lines)

### stores

- **stores/uiStore.ts** (0.3 KB, 12 lines)

  *Exports: `useUiStore` (hook)*
  ```ts
useUiStore = create<UiState>((set) => ({
  isDarkMode: false, // Default to light mode
  toggleTheme: () => set((state) => ({ isDarkMode: !state.isDarkMode })),
}))
  ```

### supabase

- **supabase/.gitignore** (0.1 KB, 9 lines)

- **supabase/config.toml** (10.9 KB, 309 lines)

- **supabase/migrations/20250424033333_initial_schema.sql** (16.9 KB, 329 lines)

- **supabase/migrations/20250424035232_add_missing_tables.sql** (0.0 KB, 1 lines)

- **supabase/migrations/20250424035717_add_missing_tables.sql** (11.7 KB, 210 lines)

- **supabase/migrations/20250425000000_create_user_settings_table.sql** (1.8 KB, 55 lines)

- **supabase/migrations/20250426000000_create_rewards_tables.sql** (5.6 KB, 149 lines)

- **supabase/migrations/20250428124230_standardize_field_naming.sql** (1.0 KB, 22 lines)

- **supabase/migrations/20250428130834_enhance_functional_schema.sql** (11.6 KB, 266 lines)

### types

- **types/database.types.ts** (31.8 KB, 1141 lines)

  *Exports: `CompositeTypes` (type)*
  ```ts
type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof Database },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends { schema: keyof Database }
  ? Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never
  ```

  *Exports: `Constants` (component)*
  ```ts
Constants = {
  public: {
    Enums: {
      habit_frequency_period: ["day", "week", "month"],
      habit_type: ["boolean", "quantity"],
      reward_type: ["badge", "achievement", "item", "discount"],
      task_priority: ["low", "medium", "high"],
      task_status: ["todo", "doing", "done", "blocked", "pending"],
      tracked_state_scale: ["1-5", "low-high", "custom"],
    },
  },
} as const
  ```

  *Exports: `Database` (type)*
  ```ts
type Database = {
public: {
  Tables: {
    badge_definitions: {
      Row: {
        description: string | null
        icon: string
        id: string
        title: string
      }
      Insert: {
        description?: string | null
        icon: string
        id: string
        title: string
      }
      Update: {
        description?: string | null
        icon?: string
        id?: string
        title?: string
      }
      Relationships: []
    }
    goal_progress_notes: {
      Row: {
        created_at: string
        goal_id: string
        id: string
        note: string
        user_id: string
      }
      Insert: {
        created_at?: string
        goal_id: string
        id?: string
        note: string
        user_id: string
      }
      Update: {
        created_at?: string
        goal_id?: string
        id?: string
        note?: string
        user_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "goal_progress_notes_goal_id_fkey"
          columns: ["goal_id"]
          isOneToOne: false
          referencedRelation: "goals"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "goal_progress_notes_user_id_fkey"
          columns: ["user_id"]
          isOneToOne: false
          referencedRelation: "profiles"
          referencedColumns: ["id"]
        },
      ]
    }
    goal_values: {
      Row: {
        goal_id: string
        user_id: string
        value_id: string
      }
      Insert: {
        goal_id: string
        user_id: string
        value_id: string
      }
      Update: {
        goal_id?: string
        user_id?: string
        value_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "goal_values_goal_id_fkey"
          columns: ["goal_id"]
          isOneToOne: false
          referencedRelation: "goals"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "goal_values_user_id_fkey"
          columns: ["user_id"]
          isOneToOne: false
          referencedRelation: "profiles"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "goal_values_value_id_fkey"
          columns: ["value_id"]
          isOneToOne: false
          referencedRelation: "values"
          referencedColumns: ["id"]
        },
      ]
    }
    goals: {
      Row: {
        archived_at: string | null
        created_at: string | null
        description: string | null
        id: string
        progress: number | null
        sort_order: number | null
        target_date: string | null
        title: string
        updated_at: string | null
        user_id: string
      }
      Insert: {
        archived_at?: string | null
        created_at?: string | null
        description?: string | null
        id?: string
        progress?: number | null
        sort_order?: number | null
        target_date?: string | null
        title: string
        updated_at?: string | null
        user_id: string
      }
      Update: {
        archived_at?: string | null
        created_at?: string | null
        description?: string | null
        id?: string
        progress?: number | null
        sort_order?: number | null
        target_date?: string | null
        title?: string
        updated_at?: string | null
        user_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "goals_user_id_fkey"
          columns: ["user_id"]
          isOneToOne: false
          referencedRelation: "profiles"
          referencedColumns: ["id"]
        },
      ]
    }
    habit_entries: {
      Row: {
        completed: boolean
        created_at: string
        date: string
        habit_id: string
        id: string
        notes: string | null
        quantity_value: number | null
        user_id: string
      }
      Insert: {
        completed?: boolean
        created_at?: string
        date: string
        habit_id: string
        id?: string
        notes?: string | null
        quantity_value?: number | null
        user_id: string
      }
      Update: {
        completed?: boolean
        created_at?: string
        date?: string
        habit_id?: string
        id?: string
        notes?: string | null
        quantity_value?: number | null
        user_id?: string
      }
      Relationships: [
        {
          foreignKeyName: "habit_entries_habit_id_fkey"
          columns: ["habit_id"]
          isOneToOne: false
          referencedRelation: "habits"
          referencedColumns: ["id"]
        },
        {
          foreignKeyName: "habit_entr... /* snippet truncated */
  ```

  *Exports: `Enums` (type)*
  ```ts
type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof Database },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never
  ```

  *Exports: `Json` (type)*
  ```ts
type Json =
| string
| number
| boolean
| null
| { [key: string]: Json | undefined }
| Json[]
  ```

  *Exports: `Tables` (type)*
  ```ts
type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof (Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        Database[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? (Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      Database[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never
  ```

  *Exports: `TablesInsert` (type)*
  ```ts
type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never
  ```

  *Exports: `TablesUpdate` (type)*
  ```ts
type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never
  ```

### utils

- **utils/api-types.ts** (0.6 KB, 22 lines)

  *Exports: `RouterInputs` (type)*
  ```ts
type RouterInputs = inferRouterInputs<AppRouter>;
  ```

  *Exports: `RouterOutputs` (type)*
  ```ts
type RouterOutputs = inferRouterOutputs<AppRouter>;
  ```

- **utils/auth.ts** (1.2 KB, 52 lines)

  *Exports: `getUserProfile` (function)*
  ```ts
async function getUserProfile() {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) return null;
    
    // If we have a user, get their profile from the profiles table
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', user.id)
      .single();
    
    if (error) {
      // If profile doesn't exist yet, return basic user info
      return {
        id: user.id,
        email: user.email,
        username: user.user_metadata?.username || 'User',
        created_at: user.created_at,
      };
    }
    
    return data;
  } catch (error) {
    console.error('Error getting user profile:', error);
    return null;
  }
}
  ```

  *Exports: `logout` (function)*
  ```ts
async function logout() {
  try {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
    
    // Navigate to login screen
    router.replace('/auth/login');
  } catch (error) {
    console.error('Error signing out:', error);
    // Force navigation even if there was an error
    router.replace('/auth/login');
  }
}
  ```

- **utils/colors.ts** (4.9 KB, 213 lines)

  *Exports: `palette` (unknown)*
  ```ts
palette = {
  // Main UI colors
  black: '#000000',
  white: '#FFFFFF',
  
  // Grays
  gray: {
    50: '#F9FAFB',
    100: '#F3F4F6',
    200: '#E5E7EB',
    300: '#D1D5DB',
    400: '#9CA3AF',
    500: '#6B7280',
    600: '#4B5563',
    700: '#374151',
    800: '#1F2937',
    900: '#111827',
  },
  
  // Blues
  blue: {
    50: '#EFF6FF',
    100: '#DBEAFE',
    200: '#BFDBFE',
    300: '#93C5FD',
    400: '#60A5FA',
    500: '#3B82F6',
    600: '#2563EB',
    700: '#1D4ED8',
    800: '#1E40AF',
    900: '#1E3A8A',
  },
  
  // Greens
  green: {
    50: '#ECFDF5',
    100: '#D1FAE5',
    200: '#A7F3D0',
    300: '#6EE7B7',
    400: '#34D399',
    500: '#10B981',
    600: '#059669',
    700: '#047857',
    800: '#065F46',
    900: '#064E3B',
  },
  
  // Reds
  red: {
    50: '#FEF2F2',
    100: '#FEE2E2',
    200: '#FECACA',
    300: '#FCA5A5',
    400: '#F87171',
    500: '#EF4444',
    600: '#DC2626',
    700: '#B91C1C',
    800: '#991B1B',
    900: '#7F1D1D',
  },
  
  // Yellows
  yellow: {
    50: '#FFFBEB',
    100: '#FEF3C7',
    200: '#FDE68A',
    300: '#FCD34D',
    400: '#FBBF24',
    500: '#F59E0B',
    600: '#D97706',
    700: '#B45309',
    800: '#92400E',
    900: '#78350F',
  },
  
  // Purples
  purple: {
    50: '#F5F3FF',
    100: '#EDE9FE',
    200: '#DDD6FE',
    300: '#C4B5FD',
    400: '#A78BFA',
    500: '#8B5CF6',
    600: '#7C3AED',
    700: '#6D28D9',
    800: '#5B21B6',
    900: '#4C1D95',
  },
}
  ```

  *Exports: `semanticTokens` (unknown)*
  ```ts
semanticTokens = {
  // Background colors
  background: {
    /** Main app background */
    app: '$background',
    /** Card/surface background */
    card: '$backgroundHover',
    /** Secondary surface background */
    secondary: '$backgroundPress',
    /** Tertiary surface background */
    tertiary: '$backgroundStrong',
    /** Input background */
    input: '$backgroundTransparent',
  },
  
  // Foreground/content colors
  content: {
    /** Primary text */
    primary: '$color',
    /** Secondary/dimmed text */
    secondary: '$colorTransparent',
    /** Subtle text - least emphasis */
    subtle: '$colorTransparent2',
    /** Disabled text */
    disabled: '$colorTransparent3',
  },
  
  // Border colors
  border: {
    /** Default border */
    default: '$borderColor',
    /** Focused border */
    focus: '$borderColorFocus',
    /** Border for hover state */
    hover: '$borderColorHover',
  },
  
  // Status colors
  status: {
    /** Success indicators */
    success: '$green10',
    /** Error indicators */
    error: '$red10',
    /** Warning indicators */
    warning: '$yellow10',
    /** Information indicators */
    info: '$blue10',
  },
  
  // Brand colors (adjust to match your brand)
  brand: {
    /** Primary brand color */
    primary: '$blue10',
    /** Secondary brand color */
    secondary: '$purple10',
    /** Accent brand color */
    accent: '$green10',
  }
}
  ```

  *Exports: `useColors` (function)*
  ```ts
function useColors() {
  const theme = useTheme();
  
  return {
    background: {
      app: theme?.background?.get() || '#FFFFFF',
      card: theme?.backgroundHover?.get() || '#F3F4F6',
      secondary: theme?.backgroundPress?.get() || '#E5E7EB',
      tertiary: theme?.backgroundStrong?.get() || '#D1D5DB',
      input: theme?.backgroundTransparent?.get() || '#FFFFFF',
    },
    content: {
      primary: theme?.color?.get() || '#111827',
      secondary: theme?.colorTransparent?.get() || '#4B5563',
      subtle: theme?.colorTransparent2?.get() || theme?.colorTransparent?.get() || '#6B7280',
      disabled: theme?.colorTransparent3?.get() || theme?.colorTransparent?.get() || '#9CA3AF',
    },
    border: {
      default: theme?.borderColor?.get() || '#E5E7EB',
      focus: theme?.borderColorFocus?.get() || '#93C5FD',
      hover: theme?.borderColorHover?.get() || '#BFDBFE',
    },
    status: {
      success: theme?.green10?.get() || '#10B981',
      error: theme?.red10?.get() || '#EF4444',
      warning: theme?.yellow10?.get() || '#F59E0B',
      info: theme?.blue10?.get() || '#3B82F6',
    },
    brand: {
      primary: theme?.blue10?.get() || '#3B82F6',
      secondary: theme?.purple10?.get() || '#8B5CF6',
      accent: theme?.green10?.get() || '#10B981',
    }
  };
}
  ```

  *Exports: `withOpacity` (function)*
  ```ts
function withOpacity(hex: string, alpha: number): string {
  // Extract RGB components from hex
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}
  ```

- **utils/generated-hooks.ts** (1.3 KB, 72 lines)

  *Exports: `useDashboard` (hook)*
  ```ts
useDashboard = {
  // Add strongly typed hooks here
}
  ```

  *Exports: `useGoal` (hook)*
  ```ts
useGoal = {
  // Add strongly typed hooks here
}
  ```

  *Exports: `useGoalProgressNote` (hook)*
  ```ts
useGoalProgressNote = {
  // Add strongly typed hooks here
}
  ```

  *Exports: `useHabit` (hook)*
  ```ts
useHabit = {
  // Add strongly typed hooks here
}
  ```

  *Exports: `usePrinciple` (hook)*
  ```ts
usePrinciple = {
  // Add strongly typed hooks here
}
  ```

  *Exports: `useReminder` (hook)*
  ```ts
useReminder = {
  // Add strongly typed hooks here
}
  ```

  *Exports: `useRewards` (hook)*
  ```ts
useRewards = {
  // Add strongly typed hooks here
}
  ```

  *Exports: `useState` (hook)*
  ```ts
useState = {
  // Add strongly typed hooks here
}
  ```

  *Exports: `useTask` (hook)*
  ```ts
useTask = {
  // Add strongly typed hooks here
}
  ```

  *Exports: `useUser` (hook)*
  ```ts
useUser = {
  // Add strongly typed hooks here
}
  ```

  *Exports: `useValue` (hook)*
  ```ts
useValue = {
  // Add strongly typed hooks here
}
  ```

- **utils/haptics.ts** (1.2 KB, 42 lines)

  *Exports: `haptics` (unknown)*
  ```ts
haptics = {
  /**
   * Light impact - subtle tap for small UI elements (buttons, toggles)
   */
  light: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light),
  
  /**
   * Medium impact - standard tap for medium elements (picker selections)
   */
  medium: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium),
  
  /**
   * Heavy impact - stronger bump for significant actions
   */
  heavy: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy),
  
  /**
   * Selection feedback - subtle tap for navigating through options
   */
  selection: () => Haptics.selectionAsync(),
  
  /**
   * Success notification - double-tap vibration for completed actions
   */
  success: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success),
  
  /**
   * Warning notification - attention-grabbing pattern for warnings
   */
  warning: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning),
  
  /**
   * Error notification - strong buzz pattern for errors
   */
  error: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error),
}
  ```

- **utils/mock-api.ts** (2.3 KB, 82 lines)

  *Exports: `appRouter` (unknown)*
  ```ts
appRouter = router({
  greeting: {
    hello: publicProcedure
      .input(z.object({ name: z.string().optional() }))
      .query(({ input }) => {
        return {
          greeting: `Hello ${input.name ?? 'world'}`,
        };
      }),
    goodbye: publicProcedure
      .query(() => {
        return {
          greeting: 'Goodbye!',
        };
      }),
  },
  user: {
    get: publicProcedure
      .input(z.object({ id: z.string() }))
      .query(({ input }) => {
        return {
          id: input.id,
          name: 'Mock User',
        };
      }),
    list: publicProcedure
      .query(() => {
        return [
          { id: '1', name: 'Mock User 1' },
          { id: '2', name: 'Mock User 2' },
        ];
      }),
  },
  auth: {
    refreshToken: publicProcedure
      .input(z.object({ refreshToken: z.string() }))
      .mutation(async ({ input }) => {
        console.log('Mock API: refreshToken called with', input.refreshToken);
        // Simulate checking refresh token and issuing new ones
        await new Promise(resolve => setTimeout(resolve, 300));
        if (input.refreshToken === 'valid-refresh-token') { // Example valid token
          return {
            accessToken: `mock-access-${Date.now()}`,
            refreshToken: `mock-refresh-${Date.now()}`,
          };
        } else {
          // Throw error for invalid refresh token
          throw new Error('Invalid refresh token'); 
        }
      }),
    // Add login/logout mutations here later
  },
  item: {
    add: publicProcedure
      .input(z.object({ name: z.string() }))
      .mutation(async ({ input }) => {
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 500));
        // In a real backend, save to DB
        console.log('Mock API: Adding item', input);
        return {
          id: Math.random().toString(36).substring(7), // Generate random ID
          name: input.name,
          status: 'added'
        };
      }),
  },
})
  ```

  *Exports: `AppRouter` (type)*
  ```ts
type AppRouter = typeof appRouter;
  ```

- **utils/nats-client.ts** (4.5 KB, 173 lines)

  *Exports: `addSubjectHandler` (function)*
  ```ts
function addSubjectHandler(subject: string, handler: CacheUpdateHandler): () => void {
  if (!handlers[subject]) {
    handlers[subject] = [];
  }
  
  handlers[subject].push(handler);
  
  // Return a function to remove the handler
  return () => {
    if (handlers[subject]) {
      handlers[subject] = handlers[subject].filter(h => h !== handler);
    }
  };
}
  ```

  *Exports: `closeNatsConnection` (function)*
  ```ts
async function closeNatsConnection(): Promise<void> {
  if (natsConnection) {
    await natsConnection.close();
    natsConnection = null;
  }
}
  ```

  *Exports: `getNatsConnection` (function)*
  ```ts
function getNatsConnection(): NatsConnection | null {
  return natsConnection;
}
  ```

  *Exports: `initNatsClient` (function)*
  ```ts
async function initNatsClient(
  url: string, 
  qc: QueryClient,
  options: Partial<ConnectionOptions> = {}
): Promise<NatsConnection> {
  if (natsConnection) {
    return natsConnection;
  }
  
  if (isConnecting) {
    throw new Error('NATS connection is already in progress');
  }
  
  isConnecting = true;
  
  try {
    // Set the query client for cache updates
    queryClient = qc;
    
    // Connect to NATS server
    natsConnection = await connect({
      servers: url,
      // Add required polyfills for React Native
      // These would need to be properly implemented in a real app
      ...options,
    });
    
    console.log('Connected to NATS server');
    
    // Setup ping interval to keep connection alive
    const pingInterval = setInterval(() => {
      if (natsConnection && !natsConnection.isClosed) {
        // Note: Using a custom ping mechanism instead of the built-in one
        try {
          const start = Date.now();
          // Simple ping using a request to a dummy subject
          natsConnection.request('_PING_', undefined, { timeout: 1000 })
            .then(() => {
              const latency = Date.now() - start;
              console.log(`NATS server latency: ${latency}ms`);
            })
            .catch((err: Error) => {
              console.error('NATS ping error:', err.message);
            });
        } catch (err) {
          const error = err as Error;
          console.error('NATS ping error:', error.message);
        }
      } else {
        clearInterval(pingInterval);
      }
    }, 30000);
    
    // Handle connection close
    natsConnection.closed().then(() => {
      console.log('NATS connection closed');
      natsConnection = null;
      clearInterval(pingInterval);
      // Could implement reconnection logic here
    });
    
    return natsConnection;
  } catch (error) {
    console.error('Failed to connect to NATS server:', error);
    isConnecting = false;
    throw error;
  }
}
  ```

  *Exports: `subscribeWithCache` (function)*
  ```ts
async function subscribeWithCache(
  subject: string,
  queryKey: unknown[],
  updateType: 'invalidate' | 'setData' = 'invalidate'
): Promise<() => void> {
  if (!natsConnection) {
    throw new Error('NATS client not initialized');
  }
  
  if (!queryClient) {
    throw new Error('QueryClient not set');
  }
  
  // Create subscription
  const subscription = natsConnection.subscribe(subject);
  
  // Setup message handler
  (async () => {
    for await (const msg of subscription) {
      try {
        const data = JSON.parse(sc.decode(msg.data));
        
        if (updateType === 'invalidate') {
          // Invalidate the cache for this query key
          queryClient.invalidateQueries({ queryKey });
        } else {
          // Update the cache directly
          queryClient.setQueryData(queryKey, data);
        }
        
        // Call any custom handlers
        if (handlers[subject]) {
          handlers[subject].forEach(handler => handler(data));
        }
      } catch (error) {
        const err = error as Error;
        console.error(`Error handling message for ${subject}:`, err.message);
      }
    }
  })();
  
  // Return unsubscribe function
  return () => {
    subscription.unsubscribe();
  };
}
  ```

- **utils/offline-mutations.ts** (4.1 KB, 133 lines)

  *Exports: `asyncStoragePersister` (unknown)*
  ```ts
asyncStoragePersister = createAsyncStoragePersister({
  storage: AsyncStorage,
})
  ```

  *Exports: `configureQueryClientForOffline` (function)*
  ```ts
function configureQueryClientForOffline(queryClient: QueryClient): NetInfoSubscription {
  // Listen to network status changes and update onlineManager
  const unsubscribe = NetInfo.addEventListener(state => {
    onlineManager.setOnline(state.isConnected === true);
  });
  
  // When a mutation fails due to network error, pause it instead of failing
  queryClient.getMutationCache().config.onError = (error: unknown, _variables: unknown, _context: unknown, mutation: any) => {
    // Check if the error is a network error
    if (
      error instanceof Error && 
      (
        error.message.includes('network') || 
        error.message.includes('Network Error') ||
        error.message.includes('Failed to fetch')
      )
    ) {
      console.log('Network error detected, pausing mutation for later retry');
      
      // Pause the mutation instead of failing permanently
      mutation.state.isPaused = true;
    }
  };
  
  // Set up persistence
  persistQueryClient({
    queryClient,
    ...reactQueryPersistOptions,
  });

  // Return unsubscribe function for cleanup
  return unsubscribe;
}
  ```

  *Exports: `getPendingMutations` (function)*
  ```ts
function getPendingMutations(mutationCache: MutationCache): Mutation[] {
  return mutationCache.getAll().filter((mutation: any) => 
    mutation?.state?.status === 'loading' || 
    (mutation?.state?.status === 'error' && mutation?.state?.isPaused)
  );
}
  ```

  *Exports: `markItemAsOffline` (function)*
  ```ts
function markItemAsOffline<T>(item: T): T & { isOffline: boolean } {
  return {
    ...item,
    isOffline: true,
  };
}
  ```

  *Exports: `markItemAsSynced` (function)*
  ```ts
function markItemAsSynced<T extends { isOffline?: boolean }>(item: T): T {
  const result = { ...item };
  delete result.isOffline;
  return result;
}
  ```

  *Exports: `reactQueryPersistOptions` (unknown)*
  ```ts
reactQueryPersistOptions: Omit<PersistQueryClientOptions, 'queryClient'> = {
  persister: asyncStoragePersister,
  // Add custom serialization/deserialization if needed
  // We want to persist mutations especially for offline support
  buster: 'v1',
  dehydrateOptions: {
    shouldDehydrateMutation: () => true,
  },
}
  ```

  *Exports: `useResumeNetworkMutations` (function)*
  ```ts
function useResumeNetworkMutations(queryClient: QueryClient) {
  const netInfo = useNetInfo();
  const previousNetworkState = useRef(netInfo.isConnected);
  
  // Update React Query's online status manager
  useEffect(() => {
    onlineManager.setOnline(netInfo.isConnected === true);
  }, [netInfo.isConnected]);
  
  useEffect(() => {
    const isConnectedNow = netInfo.isConnected === true;
    const wasConnected = previousNetworkState.current === true;
    
    // If we just reconnected to the network
    if (isConnectedNow && !wasConnected) {
      console.log('Internet connection restored, resuming paused mutations');
      
      // Resume any paused mutations
      queryClient.resumePausedMutations().then(() => {
        // After resuming mutations, invalidate queries to refresh data
        queryClient.invalidateQueries();
      }).catch((error: Error) => {
        console.error('Error resuming mutations:', error.message);
      });
    }
    
    // Update our ref
    previousNetworkState.current = isConnectedNow;
  }, [netInfo.isConnected, queryClient]);
}
  ```

- **utils/offline-sync.ts** (7.5 KB, 276 lines)

  *Exports: `getPendingItems` (function)*
  ```ts
async function getPendingItems(type: string): Promise<PendingItem[]> {
  try {
    const itemsStr = await AsyncStorage.getItem(PENDING_ITEMS_KEY);
    if (!itemsStr) return [];
    
    const items: PendingItem[] = JSON.parse(itemsStr);
    return items.filter(item => item.type === type);
  } catch (error) {
    console.error('Error getting pending items:', error);
    return [];
  }
}
  ```

  *Exports: `PendingItem` (interface)*
  ```ts
interface PendingItem {
  id: string;
  type: string;
  data: any;
  createdAt: number;
  isNotSynced: boolean;
}
  ```

  *Exports: `saveOfflineMutation` (function)*
  ```ts
async function saveOfflineMutation(
  type: 'create' | 'update' | 'delete',
  entity: string,
  data: any
): Promise<string> {
  try {
    // Generate a temporary ID for new items
    const id = `temp-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
    
    // Create mutation object
    const mutation: OfflineMutation = {
      id,
      type,
      entity,
      data,
      timestamp: Date.now(),
    };
    
    // Get existing mutations
    const existingMutationsStr = await AsyncStorage.getItem(OFFLINE_MUTATIONS_KEY);
    const existingMutations: OfflineMutation[] = existingMutationsStr 
      ? JSON.parse(existingMutationsStr) 
      : [];
    
    // Add new mutation
    existingMutations.push(mutation);
    
    // Save mutations back to storage
    await AsyncStorage.setItem(OFFLINE_MUTATIONS_KEY, JSON.stringify(existingMutations));
    
    // Also add to pending items for UI
    if (type === 'create' || type === 'update') {
      await addToPendingItems(id, entity, data);
    }
    
    return id;
  } catch (error) {
    console.error('Error saving offline mutation:', error);
    throw error;
  }
}
  ```

  *Exports: `setupBackgroundSync` (function)*
  ```ts
function setupBackgroundSync(): () => void {
  // Subscribe to network changes
  const unsubscribe = NetInfo.addEventListener(state => {
    // When we go from offline to online, sync mutations
    if (state.isConnected && state.isInternetReachable !== false) {
      syncOfflineMutations()
        .then(success => {
          console.log('Background sync completed:', success ? 'success' : 'with errors');
        })
        .catch(error => {
          console.error('Background sync failed:', error);
        });
    }
  });
  
  return unsubscribe;
}
  ```

  *Exports: `syncOfflineMutations` (function)*
  ```ts
async function syncOfflineMutations(): Promise<boolean> {
  try {
    // Check if we're online
    const netInfo = await NetInfo.fetch();
    if (!netInfo.isConnected || netInfo.isInternetReachable === false) {
      console.log('Not connected to the internet, skipping sync');
      return false;
    }
    
    // Get all pending mutations
    const mutationsStr = await AsyncStorage.getItem(OFFLINE_MUTATIONS_KEY);
    if (!mutationsStr) return true; // Nothing to sync
    
    const mutations: OfflineMutation[] = JSON.parse(mutationsStr);
    if (!mutations.length) return true; // Nothing to sync
    
    console.log(`Syncing ${mutations.length} offline mutations...`);
    
    // Process each mutation in order
    const results = await Promise.allSettled(
      mutations.map(async (mutation) => {
        try {
          switch (mutation.type) {
            case 'create':
              return await processMutation('create', mutation);
            case 'update':
              return await processMutation('update', mutation);
            case 'delete':
              return await processMutation('delete', mutation);
            default:
              console.error('Unknown mutation type:', mutation.type);
              return false;
          }
        } catch (error) {
          console.error('Error processing mutation:', error);
          return false;
        }
      })
    );
    
    // Check results
    const allSucceeded = results.every(
      result => result.status === 'fulfilled' && result.value === true
    );
    
    if (allSucceeded) {
      // Clear pending mutations if all succeeded
      await AsyncStorage.removeItem(OFFLINE_MUTATIONS_KEY);
      await AsyncStorage.removeItem(PENDING_ITEMS_KEY);
      
      // Invalidate queries to refresh data
      queryClient.invalidateQueries();
      
      return true;
    } else {
      // Some mutations failed, remove the successful ones
      const successfulMutationIndexes = results.map((result, index) => 
        result.status === 'fulfilled' && result.value === true ? index : -1
      ).filter(index => index !== -1);
      
      const remainingMutations = mutations.filter(
        (_, index) => !successfulMutationIndexes.includes(index)
      );
      
      // Save remaining mutations
      await AsyncStorage.setItem(
        OFFLINE_MUTATIONS_KEY, 
        JSON.stringify(remainingMutations)
      );
      
      // Refresh query data
      queryClient.invalidateQueries();
      
      return false;
    }
  } catch (error) {
    console.error('Error syncing offline mutations:', error);
    return false;
  }
}
  ```

- **utils/query-client.ts** (0.1 KB, 3 lines)

  *Exports: `queryClient` (unknown)*
  ```ts
queryClient = new QueryClient()
  ```

- **utils/settings.ts** (1.9 KB, 76 lines)

  *Exports: `APP_SETTINGS_KEY` (component)*
  ```ts
APP_SETTINGS_KEY = 'aether_app_settings'
  ```

  *Exports: `AppSettings` (type)*
  ```ts
type AppSettings = typeof DEFAULT_SETTINGS;
  ```

  *Exports: `getAppVersion` (function)*
  ```ts
function getAppVersion(): string {
  // In a real app, you would use expo-constants to get the app version
  // import Constants from 'expo-constants';
  // return Constants.expoConfig.version;
  return '1.0.0';
}
  ```

  *Exports: `getPlatformInfo` (function)*
  ```ts
function getPlatformInfo(): string {
  return `${Platform.OS} ${Platform.Version}`;
}
  ```

  *Exports: `getSettings` (function)*
  ```ts
async function getSettings(): Promise<AppSettings> {
  try {
    const storedSettings = await SecureStore.getItemAsync(APP_SETTINGS_KEY);
    if (!storedSettings) return DEFAULT_SETTINGS;
    
    return { ...DEFAULT_SETTINGS, ...JSON.parse(storedSettings) };
  } catch (error) {
    console.error('Error getting settings:', error);
    return DEFAULT_SETTINGS;
  }
}
  ```

  *Exports: `saveSettings` (function)*
  ```ts
async function saveSettings(settings: Partial<AppSettings>): Promise<void> {
  try {
    const currentSettings = await getSettings();
    const newSettings = { ...currentSettings, ...settings };
    
    await SecureStore.setItemAsync(
      APP_SETTINGS_KEY, 
      JSON.stringify(newSettings)
    );
  } catch (error) {
    console.error('Error saving settings:', error);
  }
}
  ```

  *Exports: `updateSetting` (function)*
  ```ts
async function updateSetting<K extends keyof AppSettings>(
  key: K, 
  value: AppSettings[K]
): Promise<void> {
  await saveSettings({ [key]: value } as Partial<AppSettings>);
}
  ```

- **utils/supabase.ts** (1.6 KB, 53 lines)

  *Exports: `getCurrentUser` (unknown)*
  ```ts
getCurrentUser = async () => {
  const { data, error } = await supabase.auth.getUser();
  if (error) {
    console.error('Error getting user:', error.message);
    return null;
  }
  return data.user;
}
  ```

  *Exports: `isAuthenticated` (unknown)*
  ```ts
isAuthenticated = async () => {
  const { data, error } = await supabase.auth.getSession();
  return !!data.session;
}
  ```

  *Exports: `supabase` (unknown)*
  ```ts
supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: ExpoSecureStoreAdapter,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
})
  ```

- **utils/trpc.ts** (0.7 KB, 21 lines)

  *Exports: `RouterInputs` (type)*
  ```ts
type RouterInputs = TypedRouterInputs;
  ```

  *Exports: `RouterOutputs` (type)*
  ```ts
type RouterOutputs = TypedRouterOutputs;
  ```

  *Exports: `trpc` (unknown)*
  ```ts
trpc = createTRPCReact<AppRouter>()
  ```

  ```

- **code_atlas.js** (0.0 KB, 0 lines) *(No explicit exports)*
  *(Content not read or file is binary/excluded)*

- **debug_context.txt** (35.9 KB, 1048 lines) *(No explicit exports)*

  ```txt
========================================
 AETHERIPHONE DEBUG CONTEXT DUMP     
========================================

Date: 2025-04-30T04:41:00.809Z

========================================
FILE: tamagui.config.ts
----------------------------------------

// tamagui.config.ts
import { createAnimations } from '@tamagui/animations-react-native';
import { createFont, createTamagui, createTokens } from 'tamagui';
import { Platform } from 'react-native';
import * as MotionConstants from '@/constants/motion'; // Import motion constants

// Font definitions - Zelda Theme
// Assumes 'CalamitySans' and 'HyliaSerif' are loaded via useFonts or similar
const headingFont = createFont({
  family: 'HyliaSerif', // Zelda Display Font
  size: {
    // Mapped closer to iOS Dynamic Type: https://developer.apple.com/design/human-interface-guidelines/typography
    1: 13,  // Caption 2
    2: 15,  // Subheadline
    3: 17,  // Body (true default)
    4: 20,  // Title 3
    5: 22,  // Title 2
    6: 28,  // Title 1
    7: 34,  // Large Title
    8: 40,  // Extra Large Title (custom)
    true: 17, // Default size (Body)
  },
  lineHeight: {
    // Approximate line heights based on new sizes
    1: 18, 2: 20, 3: 22, 4: 25, 5: 28, 6: 34, 7: 41, 8: 50, 
    true: 22,
  },
  weight: {
    // Prompt 2 asks for 400-700
    4: '400', // Normal
    6: '600', // Semi-bold/Bold
    7: '700', // Extra-bold/Black
    true: '400',
  },
  letterSpacing: {
    1: 0, 2: 0, 3: -0.5, 4: -0.5, 5: -1, 6: -1, 7: -1.5, 8: -1.5,
    true: 0,
  },
  // Required: Map weights to specific font faces if needed (e.g., 'HyliaSerif-Bold')
  // face: {
  //   400: { normal: 'HyliaSerif-Regular' },
  //   700: { normal: 'HyliaSerif-Bold' },
  // },
});

const bodyFont = createFont({
  family: 'CalamitySans', // Zelda Body Font
  size: {
    // Mapped closer to iOS Dynamic Type
    1: 11,  // Footnote
    2: 12,  // Caption 1
    3: 13,  // Caption 2
    4: 15,  // Subheadline
    5: 17,  // Body (true default)
    6: 20,  // Title 3 (matching headingFont.$4)
    true: 17, // Default body size
  },
  lineHeight: {
    // Approximate line heights
    1: 13, 2: 16, 3: 18, 4: 20, 5: 22, 6: 25,
    true: 22, // Default body line height
  },
  weight: {
    4: '400', // Regular
    5: '500', // Medium (if available)
    7: '700', // Bold (if needed/available)
    true: '400',
  },
  letterSpacing: {
    1: 0.1, 2: 0.1, 3: 0, 4: 0, 5: -0.1, 6: -0.1,
    true: 0,
  },
  // Required: Map weights to specific font faces if needed (e.g., 'CalamitySans-Medium')
  // face: {
  //   400: { normal: 'CalamitySans-Regular' },
  //   500: { normal: 'CalamitySans-Medium' },
  // },
});

const monoFont = createFont({
  family: Platform.select({ web: 'monospace', default: 'SpaceMono' }), // Keep SpaceMono for code
  size: {
    1: 12, 2: 14, 3: 15, 4: 16, 5: 18, 6: 20, true: 15,
  },
  lineHeight: {
    1: 18, 2: 22, 3: 24, 4: 26, 5: 28, 6: 32, true: 24,
  },
  weight: {
    4: '400', // Normal weight
    true: '400',
  },
  letterSpacing: {
    4: 0,
    true: 0,
  },
  face: {
    400: { normal: 'SpaceMono' }, // Map weight 400 to the loaded SpaceMono font
  },
});

// Animation driver using reanimated
const animations = createAnimations({
  fast: {
    type: 'timing',
    duration: MotionConstants.durations.standard,
    // easing: MotionConstants.easings.standard, // Removed as createAnimations defaults work well
  },
  medium: {
    type: 'timing',
    duration: MotionConstants.durations.modal,
  },
  slow: {
    type: 'timing',
    duration: MotionConstants.durations.long,
  },
  bouncy: {
    type: 'spring',
    damping: 9,
    mass: 0.9,
    stiffness: 150,
  },
  lazy: {
    type: 'spring',
    damping: 18,
    stiffness: 50,
  },
  quick: {
    type: 'spring',
    damping: 20,
    mass: 1.2,
    stiffness: 250,
  },
});

// Standard Radix Gray scale (light theme)
const gray = {
  gray1: '#fcfcfc', gray2: '#f8f8f8', gray3: '#f3f3f3', gray4: '#ededed', gray5: '#e8e8e8', gray6: '#e2e2e2', gray7: '#dbdbdb', gray8: '#c7c7c7', gray9: '#8f8f8f', gray10: '#858585', gray11: '#6f6f6f', gray12: '#171717',
};

// Standard Radix Gray scale (dark theme)
const grayDark = {
  gray1: '#191919', gray2: '#212121', gray3: '#282828', gray4: '#303030', gray5: '#393939', gray6: '#424242', gray7: '#4f4f4f', gray8: '#626262', gray9: '#737373', gray10: '#838383', gray11: '#ababab', gray12: '#ededed',
};

// Tokens (refined based on your existing config)
const tokens = createTokens({
  size: {
    0: 0, 1: 4, 2: 8, 3: 12, 4: 16, 5: 20, 6: 24, 7: 28, 8: 32, 9: 36, 10: 40, 11: 44, 12: 48, 13: 52, 14: 56, 15: 60, 16: 64, true: 16,
  },
  space: {
    0: 0, 1: 4, 2: 8, 3: 12, 4: 16, 5: 20, 6: 24, 7: 28, 8: 32, 9: 36, 10: 40, 11: 44, 12: 48, 13: 52, 14: 56, 15: 60, 16: 64, true: 16, '-1': -4, '-2': -8, '-3': -12, '-4': -16,
  },
  radius: {
    0: 0, 1: 3, 2: 5, 3: 8, 4: 10, 5: 14, 6: 16, 7: 20, 8: 24, 9: 28, 10: 32, true: 10, // Updated radius.5 to 14
  },
  zIndex: { 0: 0, 1: 100, 2: 200, 3: 300, 4: 400, 5: 500 },
  color: {
    // Zelda Palette (Prompt 1)
    ...gray, // Add light greys
    ...grayDark, // Add dark greys (will be overridden in dark theme definition)
    parchment: '#FDFFE0',
    sheikahCyan: '#86A5A9',
    korokGreen: '#92C582',
    darkText: '#536F50',
    guardianOrange: '#FF9F0A',
    darkTealBg: '#1A2E3A',
    darkCyanGlow: '#64FFDA',

    // Shadow Colors (Prompt 5)
    shadowColorLight: 'rgba(83, 111, 80, 1)', // dark desaturated text color
    shadowColorDark: 'rgba(0, 0, 0, 1)', // Black base
    white: '#FFFFFF',
    black: '#000000',
  },
});

// Define themes using Zelda Palette
const lightTheme = {
  // Base Colors
  background: tokens.color.parchment,      // Light bg
  backgroundStrong: tokens.color.white,     // Keep white for strong contrast areas if needed
  backgroundTransparent: 'rgba(253, 255, 224, 0)', // Fully transparent parchment
  color: tokens.color.darkText,             // Dark desaturated text
  colorSecondary: tokens.color.darkText,      // Use main text color, maybe slightly lighter if needed later
  colorTertiary: tokens.color.sheikahCyan,    // Use accent for tertiary info?
  borderColor: tokens.color.sheikahCyan,      // Use accent for borders
  borderColorHover: tokens.color.korokGreen,  // Korok green on hover?

  // Theme-specific states (can refine later)
  backgroundHover: tokens.color.parchment,    // Keep parchment, maybe slightly darker/lighter
  backgroundPress: tokens.color.parchment,    // Keep parchment
  backgroundFocus: tokens.color.parchment,    // Keep parchment
  colorHover: tokens.color.korokGreen,        // Korok green text on hover?
  colorPress: tokens.color.korokGreen,
  colorFocus: tokens.color.sheikahCyan,
  borderColorPress: tokens.color.korokGreen,
  borderColorFocus: tokens.color.sheikahCyan,

  // Semantic Tokens (Prompt 4)
  accent: tokens.color.sheikahCyan,
  surfaceSubtle: tokens.color.parchment,    // Base color, apply opacity in component (e.g., rgba(253,255,224,0.8))
  destructive: tokens.color.guardianOrange,

  // Standard Semantic Mapping (can use Zelda colors)
  primary: tokens.color.sheikahCyan,        // Map primary to accent
  secondary: tokens.color.korokGreen,       // Map secondary to korok green?
  success: tokens.color.korokGreen,
  warning: tokens.color.guardianOrange,     // Use guardian orange for warning
  error: tokens.color.guardianOrange,       // Use guardian orange for error
  info: tokens.color.sheikahCyan,

  // Semantic Aliases (Playbook 1.1)
  surface: tokens.color.parchment, // Maps to background
  onSurface: tokens.color.darkText,  // Maps to color
  outline: tokens.color.sheikahCyan, // Maps to borderColor

  // Shadows (Playbook 1.1 & Prompt 5)
  shadowColor: tokens.color.shadowColorLight, // Use darkText color base for shadow
  shadowColorHover: 'rgba(83, 111, 80, 0.15)',
  shadowSm: 'rgba(83, 111, 80, 0.10)', // 10% opacity
  shadowMd: 'rgba(83, 111, 80, 0.15)', // 15% opacity
  shadowLg: 'rgba(83, 111, 80, 0.20)', // 20% opacity

  // Toast Themes (Report Item 6)
  toast_success_background: tokens.color.korokGreen,
  toast_success_color: tokens.color.parchment,
  toast_error_background: tokens.color.guardianOrange,
  toast_error_color: tokens.color.parchment,
  toast_warning_background: tokens.color.guardianOrange, // Often same as error
  toast_warning_color: tokens.color.parchment,
  toast_info_background: tokens.color.sheikahCyan,
  toast_info_color: tokens.color.parchment,
};

const darkTheme: typeof lightTheme = {
  // Base Colors
  ...grayDark, // Override light greys with dark greys
  background: tokens.color.darkTealBg,      // Dark-mode bg
  backgroundStrong: tokens.color.black,       // Black for contrast?
  backgroundTransparent: 'rgba(26, 46, 58, 0)', // Fully transparent dark teal
  color: tokens.color.parchment,          // Use light parchment for text
  colorSecondary: tokens.color.sheikahCyan,   // Sheikah cyan for secondary text
  colorTertiary: tokens.color.korokGreen,     // Korok green for tertiary
  borderColor: tokens.color.sheikahCyan,      // Sheikah cyan borders
  borderColorHover: tokens.color.darkCyanGlow, // Glow cyan on hover?

  // Theme-specific states
  backgroundHover: tokens.color.darkTealBg,   // Keep bg, maybe slightly lighter
  backgroundPress: tokens.color.darkTealBg,
  backgroundFocus: tokens.color.darkTealBg,
  colorHover: tokens.color.darkCyanGlow,
  colorPress: tokens.color.darkCyanGlow,
  colorFocus: tokens.color.darkCyanGlow,
  borderColorPress: tokens.color.darkCyanGlow,
  borderColorFocus: tokens.color.darkCyanGlow,

  // Semantic Tokens (Prompt 4)
  accent: tokens.color.sheikahCyan,
  surfaceSubtle: tokens.color.darkTealBg, // Use dark bg, apply opacity in component
  destructive: tokens.color.guardianOrange,

  // Standard Semantic Mapping
  primary: tokens.color.darkCyanGlow,       // Use glow cyan for primary actions
  secondary: tokens.color.korokGreen,
  success: tokens.color.korokGreen,
  warning: tokens.color.guardianOrange,
  error: tokens.color.guardianOrange,
  info: tokens.color.sheikahCyan,

  // Semantic Aliases (Playbook 1.1)
  surface: tokens.color.darkTealBg,   // Maps to background
  onSurface: tokens.color.parchment,  // Maps to color
  outline: tokens.color.sheikahCyan, // Maps to borderColor

  // Shadows (Playbook 1.1 & Prompt 5)
  shadowColor: tokens.color.shadowColorDark, // Darker shadow for dark mode
  shadowColorHover: 'rgba(0, 0, 0, 0.30)',
  shadowSm: 'rgba(0, 0, 0, 0.20)', // 20% opacity
  shadowMd: 'rgba(0, 0, 0, 0.30)', // 30% opacity
  shadowLg: 'rgba(0, 0, 0, 0.40)', // 40% opacity

  // Toast Themes (Report Item 6)
  toast_success_background: tokens.color.korokGreen,
  toast_success_color: tokens.color.darkTealBg,
  toast_error_background: tokens.color.guardianOrange,
  toast_error_color: tokens.color.darkTealBg,
  toast_warning_background: tokens.color.guardianOrange, // Often same as error
  toast_warning_color: tokens.color.darkTealBg,
  toast_info_background: tokens.color.sheikahCyan,
  toast_info_color: tokens.color.darkTealBg,
};

// Create the Tamagui config
const config = createTamagui({
  animations,
  shouldAddPrefersColorThemes: true,
  themeClassNameOnRoot: true,
  shorthands: {
    // Keep your existing shorthands
    m: 'margin', mt: 'marginTop', mr: 'marginRight', mb: 'marginBottom', ml: 'marginLeft', mx: 'marginHorizontal', my: 'marginVertical',
    p: 'padding', pt: 'paddingTop', pr: 'paddingRight', pb: 'paddingBottom', pl: 'paddingLeft', px: 'paddingHorizontal', py: 'paddingVertical',
    bg: 'backgroundColor', br: 'borderRadius', bw: 'borderWidth', bc: 'borderColor',
    f: 'flex', fd: 'flexDirection', ai: 'alignItems', jc: 'justifyContent', w: 'width', h: 'height',
    ac: 'alignContent',
    als: 'alignSelf',
    btc: 'borderTopColor',
    bbc: 'borderBottomColor',
    blc: 'borderLeftColor',
    brc: 'borderRightColor',
    boc: 'borderColor',
    bs: 'borderStyle',
    dsp: 'display',
    fb: 'flexBasis',
    fg: 'flexGrow',
    fs: 'flexShrink',
    fw: 'flexWrap',
    mah: 'maxHeight',
    maw: 'maxWidth',
    mih: 'minHeight',
    miw: 'minWidth',
    op: 'opacity',
    ov: 'overflow',
    r: 'right',
    shac: 'shadowColor',
    shar: 'shadowRadius',
    shof: 'shadowOffset',
    shop: 'shadowOpacity',
    t: 'top',
    ta: 'textAlign',
    tt: 'textTransform',
    va: 'verticalAlign',
    zi: 'zIndex',
  },
  fonts: {
    // Use Zelda fonts
    heading: headingFont,
    body: bodyFont,
    mono: monoFont, // Keep mono
  },
  themes: {
    light: lightTheme,
    dark: darkTheme,
  },
  tokens,
  media: { // Keep standard media queries
    xs: { maxWidth: 660 }, sm: { maxWidth: 800 }, md: { maxWidth: 1020 }, lg: { maxWidth: 1280 }, xl: { maxWidth: 1420 }, xxl: { maxWidth: 1600 },
    gtXs: { minWidth: 661 }, gtSm: { minWidth: 801 }, gtMd: { minWidth: 1021 }, gtLg: { minWidth: 1281 },
    short: { maxHeight: 820 }, tall: { minHeight: 820 },
    hoverNone: { hover: 'none' }, pointerCoarse: { pointer: 'coarse' },
  },
  settings: {
      allowedStyleValues: 'somewhat-strict',
      autocompleteSpecificTokens: 'except-special',
  },
});

type AppConfig = typeof config;

// Augment Tamagui interface - this is crucial!
declare module '@tamagui/core' {
  // If AppConfig is defined and exported:
  interface TamaguiCustomConfig extends AppConfig {}
}

export default config;

[EOF: tamagui.config.ts]

========================================
FILE: babel.config.js
----------------------------------------

module.exports = function (api) {
  api.cache(true);
  return {
    presets: ['babel-preset-expo'],
    plugins: [
      // Inline env variables for Tamagui
      [
        'transform-inline-environment-variables',
        {
          include: ['TAMAGUI_TARGET'],
        },
      ],
      
      // Tamagui plugin for optimized compilation
      [
        '@tamagui/babel-plugin',
        {
          components: ['tamagui'],
          config: './tamagui.config.ts',
          logTimings: true,
          disableExtraction: process.env.NODE_ENV === 'development',
        },
      ],
      
      // Reanimated plugin must be last
      'react-native-reanimated/plugin',
    ],
  };
}; 

[EOF: babel.config.js]

========================================
FILE: providers/Providers.tsx
----------------------------------------

// providers/Providers.tsx
import { QueryClientProvider } from '@tanstack/react-query';
import { persistQueryClient } from '@tanstack/react-query-persist-client';
import { TamaguiProvider, type TamaguiProviderProps } from 'tamagui';
import { ToastProvider, ToastViewport } from '@tamagui/toast'; // Import from Tamagui Toast
import React, { useEffect, useState, type ReactNode } from 'react';
import { Platform } from 'react-native'; // Import Platform

import config from '../tamagui.config'; // Import your config
import { trpc } from '../utils/trpc'; // Your tRPC hook setup
import { queryClient, persister, initializeNetworkMonitoring, resumeMutationsAndInvalidate } from '@/utils/query-client';
import { useUiStore } from '@/stores/uiStore';
import { supabase } from '@/utils/supabase'; // Needed for auth link
import { createTRPCClient, httpBatchLink, TRPCLink, TRPCClientError } from '@trpc/client'; // Import TRPC Client utils
import { observable } from '@trpc/server/observable';
import type { AppRouter } from '../server/src/router'; // Adjust path if needed
import type { Session } from '@supabase/supabase-js';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

// Setup query client persistence
persistQueryClient({
  queryClient,
  persister,
  maxAge: 1000 * 60 * 60 * 24, // 24 hours
  dehydrateOptions: {
    shouldDehydrateMutation: () => false, // Usually don't dehydrate mutations
  },
});

// New component for the viewport using safe area
const CurrentToastViewport = () => {
  const { top, bottom, left, right } = useSafeAreaInsets();
  return (
    <>
      {/* Adjust positioning based on your desired toast location */}
      <ToastViewport
        name="global_top"
        flexDirection="column" // Stack new toasts below older ones
        top={top + 10} // Add padding below status bar
        left={left + 10} // Add padding from sides
        right={right + 10}
      />
      <ToastViewport
        name="global_bottom"
        flexDirection="column-reverse"
        bottom={bottom + 10}
        left={left + 10}
        right={right + 10}
      />
    </>
  );
};

// Extract tRPC links setup
function getTRPCLinks(getSession: () => Promise<Session | null>): TRPCLink<AppRouter>[] {
  const apiBaseUrl = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api/trpc'; // Default to localhost
  console.log('Using tRPC API URL:', apiBaseUrl);

  return [
    // Link to handle auth token injection and refresh
    (runtime) => {
      return ({ op, next }) => {
        return observable((observer) => {
          getSession().then(session => {
            const headers = (op.context?.headers || {}) as Record<string, string>;
            if (session?.access_token) {
              headers['Authorization'] = `Bearer ${session.access_token}`;
            }

            // Proceed with the request, ensuring context is passed correctly
            next({ ...op, context: { ...op.context, headers } })
              .subscribe({
                next: (value) => observer.next(value),
                error: async (err) => {
                  if (err instanceof TRPCClientError && err.data?.httpStatus === 401) {
                    console.log('tRPC: Token expired or invalid, attempting refresh...');
                    try {
                      // Supabase handles refresh internally if needed when getSession is called
                      const { data, error: refreshError } = await supabase.auth.refreshSession();
                      if (refreshError) throw refreshError;

                      if (data.session) {
                        console.log('tRPC: Session refreshed successfully, retrying request.');
                        const refreshedHeaders = { ...headers, Authorization: `Bearer ${data.session.access_token}` };
                        // Retry with new headers in context
                        next({ ...op, context: { ...op.context, headers: refreshedHeaders } }).subscribe(observer);
                      } else {
                        console.error('tRPC: Session refresh failed, no session returned.');
                        observer.error(err); // Propagate original error if no new session
                        // Optionally trigger logout here
                        supabase.auth.signOut();
                      }
                    } catch (refreshCatchError) {
                      console.error('tRPC: Session refresh catch error:', refreshCatchError);
                      observer.error(err); // Propagate original error
                      supabase.auth.signOut();
                    }
                  } else {
                    observer.error(err); // Propagate non-auth errors
                  }
                },
                complete: () => observer.complete(),
              });
          }).catch(err => {
             console.error('tRPC: Error getting session for headers:', err);
             observer.error(new TRPCClientError('Failed to get session')); // Use TRPCClientError
          });

          // Return cleanup function if needed
          return () => {};
        });
      };
    },
    // The terminating HTTP link
    httpBatchLink({
      url: apiBaseUrl,
       headers() {
         // Headers are injected by the middleware link above
         return {};
       },
      // Add superjson transformer here if you use one
      // transformer: superjson,
    }),
  ];
}

export function Providers({ children }: { children: ReactNode }) {
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';

  // Initialize network monitoring and query client persistence
  useEffect(() => {
    const unsubscribeNetworkMonitoring = initializeNetworkMonitoring();
    resumeMutationsAndInvalidate(); // Try resuming mutations on app load
    return () => {
      unsubscribeNetworkMonitoring();
    };
  }, []);

  // Memoize tRPC client creation
  const [trpcClient] = useState(() =>
    trpc.createClient({
      links: getTRPCLinks(async () => { // Pass session getter to links setup
        const { data } = await supabase.auth.getSession();
        return data.session;
      }),
    })
  );

  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <TamaguiProvider
            config={config}
            defaultTheme={currentTheme}
            // disableInjectCSS // May not be needed depending on setup
        >
          {/* Use Tamagui's ToastProvider */}
          <ToastProvider
            // burntOptions={{ from: 'top' }} // Disabled until native module 'Burnt' is installed
            swipeDirection="horizontal"
            duration={4000}
            native={[]}
          >
            {children}
            {/* Add the safe-area aware ToastViewport */}
            <CurrentToastViewport />
          </ToastProvider>
        </TamaguiProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
}

[EOF: providers/Providers.tsx]

========================================
FILE: app/_layout.tsx
----------------------------------------

// app/_layout.tsx
import React, { useCallback, useEffect, useState, ReactNode, createContext, useContext } from 'react';
import { Slot, SplashScreen, useRouter, useSegments } from 'expo-router';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { StatusBar } from 'expo-status-bar';
import { View, ActivityIndicator, Platform } from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { useFonts } from 'expo-font';
import { useColorScheme } from 'react-native';
import { TamaguiProvider, Theme } from 'tamagui'; // Consolidate Tamagui imports
import tamaguiConfig from '../tamagui.config'; // Use default import
import type { ThemeName } from '@tamagui/core'; // Ensure ThemeName is imported from @tamagui/core
import * as SecureStore from 'expo-secure-store'; // Import SecureStore

import { supabase } from '@/utils/supabase';

import type { Session } from '@supabase/supabase-js';

// Prevent the splash screen from auto-hiding
SplashScreen.preventAutoHideAsync();

/* ------------------------------------------------------------------ */
/*  1. Simple Auth-aware context                                       */
/* ------------------------------------------------------------------ */
interface AuthCtx {
  session: Session | null;
  isLoading: boolean;
}
export const AuthContext = React.createContext<AuthCtx>({
  session: null,
  isLoading: true,
});
export const useAuth = () => React.useContext(AuthContext);

/* ------------------------------------------------------------------ */
/*  2. The actual Provider                                             */
/* ------------------------------------------------------------------ */
function AuthProvider({ children }: { children: ReactNode }) {
  const [session, setSession] = useState<Session | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Initial session check
  useEffect(() => {
    supabase.auth.getSession().then(({ data }) => {
      setSession(data.session ?? null);
      setIsLoading(false);
      console.log('Initial session check:', data.session ? 'Session found' : 'No session');
    }).catch(error => {
        console.error("Error getting initial session:", error);
        setIsLoading(false);
    });

    // Subscribe to auth changes (login / logout / token refresh)
    const { data: authListener } = supabase.auth.onAuthStateChange(
      (_event, newSession) => {
        console.log('Auth state changed:', _event, newSession ? 'New session' : 'No session');
        setSession(newSession ?? null);
        // If the event is SIGNED_IN or TOKEN_REFRESHED, loading might briefly be true again
        // depending on how you handle redirects, but usually setting session is enough.
        // If SIGNED_OUT, ensure loading is false.
        if (_event === 'SIGNED_OUT') {
          setIsLoading(false);
        }
      },
    );

    return () => {
      authListener?.subscription.unsubscribe();
    };
  }, []);

  return (
    <AuthContext.Provider value={{ session, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
}

/* ------------------------------------------------------------------ */
/*  3. Enforce splash-screen logic & route guarding                    */
/* ------------------------------------------------------------------ */
function Root() {
  const { session, isLoading } = useAuth();
  const router = useRouter();
  const segments = useSegments(); // e.g., ["(tabs)", "home"] or ["(auth)", "login"]

  /* Load Fonts ----------------------------------------------------- */
  const [fontsLoaded, fontError] = useFonts({
    // Ensure font names match those used in tamagui.config.ts
    Inter: require('@tamagui/font-inter/otf/Inter-Medium.otf'),
    InterBold: require('@tamagui/font-inter/otf/Inter-Bold.otf'),
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
  });

  /* Handle Font Loading & Errors ----------------------------------- */
  useEffect(() => {
    if (fontError) {
      console.error("Font loading error:", fontError);
      // Decide how to handle font errors - maybe show an error message?
      // For now, we still need to hide splash eventually.
      SplashScreen.hideAsync();
    }
  }, [fontError]);

  /* Redirect Logic ------------------------------------------------- */
  useEffect(() => {
    // Wait until auth state is confirmed AND fonts are potentially loaded
    if (isLoading || !fontsLoaded && !fontError) return;

    const inAuthGroup = segments[0] === '(auth)';

    console.log(`Auth State: isLoading=${isLoading}, session=${!!session}, inAuthGroup=${inAuthGroup}, segments=${segments.join('/')}`);

    if (!session && !inAuthGroup) {
      console.log('Redirecting to login...');
      router.replace('/(auth)/login');
    } else if (session && inAuthGroup) {
      console.log('Redirecting to home...');
      router.replace('/(tabs)/home');
    } else {
        console.log('No redirect needed.');
    }
  }, [isLoading, session, segments, router, fontsLoaded, fontError]);

  /* Hide splash only when fonts loaded/error AND auth check done ---- */
  useEffect(() => {
    if ((fontsLoaded || fontError) && !isLoading) {
        console.log('Hiding SplashScreen...');
      SplashScreen.hideAsync();
    }
  }, [fontsLoaded, fontError, isLoading]);

  /* Show loading indicator until ready ----------------------------- */
  if (!fontsLoaded && !fontError || isLoading) {
    // Optionally, return the Splash Screen component itself or a custom loading view
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#1C1C1E' /* Approx dark bg */ }}>
        <ActivityIndicator size="large" color="#FFFFFF" />
      </View>
    );
  }

  // Once loaded and auth checked, render the content based on route
  return (
    <>
      <StatusBar style={Platform.OS === 'ios' ? 'light' : 'auto'} />
      <Slot />
    </>
  );
}

/* ------------------------------------------------------------------ */
/*  4. Wrap everything with SafeArea, Providers, etc.                  */
/* ------------------------------------------------------------------ */
import { ToastProvider, Toast, useToastState, ToastViewport } from '@tamagui/toast';
import { CheckCircle, AlertCircle, AlertTriangle, Info } from '@tamagui/lucide-icons';
import { YStack, XStack } from 'tamagui';
import { ThemeProvider, DarkTheme, DefaultTheme } from '@react-navigation/native';

const ACCENT_COLOR_KEY = 'userAccentColor';
const DEFAULT_ACCENT = 'blue'; // Set your default accent color theme name here

// Context to provide accent update function down the tree
const AccentContext = createContext({
  setAccent: (color: string) => {},
});
export const useAccent = () => useContext(AccentContext);

function RootLayoutNav() {
  const colorScheme = useColorScheme();
  const themeMode = colorScheme === 'dark' ? 'dark' : 'light';

  return (
    <ToastProvider swipeDirection="horizontal" duration={6000}>
      <Slot />
      <CurrentToast />
      <ToastViewport name="DefaultViewport" top={40} left={0} right={0} /> 
    </ToastProvider>
  );
}

function CurrentToast() {
  const currentToast = useToastState();

  if (!currentToast || currentToast.isHandledNatively) {
    return null;
  }

  const toastType = currentToast.customData?.type || 'info'; // Default to 'info'
  let themeName = 'toast_info'; // Default theme
  let IconComponent = Info;

  switch (toastType) {
    case 'success':
      themeName = 'toast_success';
      IconComponent = CheckCircle;
      break;
    case 'error':
      themeName = 'toast_error';
      IconComponent = AlertCircle;
      break;
    case 'warning':
      themeName = 'toast_warning';
      IconComponent = AlertTriangle;
      break;
  }

  return (
    <Theme name={themeName as ThemeName}> {/* Cast themeName to ThemeName */}
      <Toast
        key={currentToast.id}
        duration={currentToast.duration}
        enterStyle={{ opacity: 0, scale: 0.5, y: -25 }}
        exitStyle={{ opacity: 0, scale: 0.95, y: -10 }} // Adjusted exit style slightly
        y={0}
        opacity={1}
        scale={1}
        animation="bouncy" // Apply bouncy animation
        viewportName={currentToast.viewportName ?? 'DefaultViewport'}
        backgroundColor="$background" // Use background from the wrapped theme
        padding="$3"
        borderRadius="$4"
        marginHorizontal="$4"
        elevate
        shadowColor="$shadowColor"
      >
        <YStack space="$1">
          <XStack space="$2" alignItems="center">
            <IconComponent size={18} color="$color" /> {/* Use color from the wrapped theme */}
            <Toast.Title color="$color">{currentToast.title}</Toast.Title> {/* Use color from the wrapped theme */}
          </XStack>
          {!!currentToast.message && (
            <Toast.Description color="$color"> {/* Use color from the wrapped theme */}
              {currentToast.message}
            </Toast.Description>
          )}
        </YStack>
      </Toast>
    </Theme>
  );
}

function Providers({ children }: { children: React.ReactNode }) {
  const colorScheme = useColorScheme();
  const [accentColor, setAccentColor] = useState(DEFAULT_ACCENT);

  // Load accent color on mount
  useEffect(() => {
    const loadAccent = async () => {
      try {
        const savedAccent = await SecureStore.getItemAsync(ACCENT_COLOR_KEY);
        if (savedAccent) {
          setAccentColor(savedAccent);
        }
      } catch (error) {
        console.error('Failed to load accent color:', error);
      }
    };
    loadAccent();
  }, []);

  // Function to update and save accent color
  const handleSetAccent = useCallback(async (newColor: string) => {
    try {
      await SecureStore.setItemAsync(ACCENT_COLOR_KEY, newColor);
      setAccentColor(newColor);
    } catch (error) {
      console.error('Failed to save accent color:', error);
    }
  }, []);

  return (
    <AccentContext.Provider value={{ setAccent: handleSetAccent }}>
      <Theme name={accentColor as ThemeName}> {/* Cast accentColor to ThemeName */}
        {children}
      </Theme>
    </AccentContext.Provider>
  );
}

export default function RootLayout() {
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        {/* Core Providers (Tamagui, QueryClient, tRPC) */}
        <Providers>
          {/* Auth Provider manages session state */}
          <AuthProvider>
            {/* Root handles splash, font loading, and redirects */}
            <RootLayoutNav />
          </AuthProvider>
        </Providers>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}


[EOF: app/_layout.tsx]

========================================
FILE: package.json
----------------------------------------

{
  "name": "aetheriphone",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "test": "yarn test:ui && yarn test:server",
    "test:ui": "./node_modules/.bin/jest --config jest.config.ui.js",
    "test:server": "jest --config jest.config.server.js",
    "test:ui:watch": "./node_modules/.bin/jest --config jest.config.ui.js --watchAll",
    "test:server:watch": "jest --config jest.config.server.js --watchAll",
    "test:ci": "yarn test:ui --ci --silent && yarn test:server --ci --silent",
    "test:coverage": "jest --config jest.config.ui.js --coverage",
    "test:update": "jest --config jest.config.ui.js --updateSnapshot",
    "lint": "expo lint",
    "generate-types": "node ./scripts/generate-trpc-types.js",
    "generate-hooks": "node ./scripts/generate-trpc-client.js",
    "generate": "node ./scripts/generate-all.js",
    "dev": "npm run generate && expo start"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.2",
    "@hookform/resolvers": "^5.0.1",
    "@react-native-async-storage/async-storage": "1.23.1",
    "@react-native-community/netinfo": "^11.4.1",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "@shopify/flash-list": "^1.8.0",
    "@supabase/supabase-js": "^2.49.4",
    "@tamagui/animations-react-native": "1.126.1", 
    "@tamagui/config": "1.126.1", 
    "@tamagui/core": "1.126.1", 
    "@tamagui/font-inter": "1.126.1", 
    "@tamagui/lucide-icons": "1.126.1", 
    "@tamagui/react-native-media-driver": "1.126.1", 
    "@tamagui/shorthands": "1.126.1",
    "@tamagui/stacks": "1.126.1",
    "@tamagui/themes": "1.126.1",
    "@tamagui/toast": "1.126.1",
    "@tanstack/query-async-storage-persister": "^5.74.4",
    "@tanstack/react-query": "^5.74.4",
    "@tanstack/react-query-persist-client": "^5.74.4",
    "@testing-library/react-native": "^13.2.0",
    "@trpc/client": "^11.1.0",
    "@trpc/react-query": "^11.1.0",
    "@trpc/server": "^11.1.0",
    "burnt": "^0.13.0",
    "date-fns": "^4.1.0",
    "expo": "~52.0.46",
    "expo-blur": "~14.0.3",
    "expo-constants": "~17.0.8",
    "expo-dev-client": "~5.0.20",
    "expo-font": "~13.0.4",
    "expo-haptics": "~14.0.1",
    "expo-linking": "~7.0.5",
    "expo-router": "~4.0.20",
    "expo-secure-store": "^14.0.1",
    "expo-splash-screen": "~0.29.24",
    "expo-status-bar": "~2.0.1",
    "expo-symbols": "~0.2.2",
    "expo-system-ui": "~4.0.9",
    "expo-web-browser": "~14.0.2",
    "lottie-react-native": "7.1.0",
    "nativewind": "^4.1.19",
    "nats.ws": "^1.30.3",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-hook-form": "^7.56.1",
    "react-native": "0.76.9",
    "react-native-gesture-handler": "~2.20.2",
    "react-native-reanimated": "^3.17.4",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-svg": "15.8.0",
    "react-native-url-polyfill": "^2.0.0",
    "react-native-web": "~0.19.13",
    "react-native-webview": "13.12.5",
    "tamagui": "1.126.1",
    "text-encoding": "^0.7.0",
    "zod": "^3.24.3",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@tamagui/babel-plugin": "1.126.1", 
    "@testing-library/jest-native": "^5.4.3",
    "@types/jest": "^29.5.12",
    "@types/react": "~18.3.12",
    "@types/react-test-renderer": "^18.3.0",
    "autoprefixer": "^10.4.21",
    "babel-plugin-transform-inline-environment-variables": "^0.4.4",
    "eslint": "^8.57.0",
    "eslint-config-expo": "~8.0.1",
    "jest": "^29.2.1",
    "jest-expo": "~52.0.6",
    "jest-mock-extended": "^4.0.0-beta1",
    "msw": "^2.1.5",
    "postcss": "^8.5.3",
    "react-test-renderer": "18.3.1",
    "supabase": "^2.22.4",
    "tailwindcss": "^3.4.17",
    "ts-jest": "^29.3.2",
    "typescript": "^5.3.3"
  },
  "private": true
}

[EOF: package.json]

========================================
FILE: tsconfig.json
----------------------------------------

{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "baseUrl": ".",
    "jsx": "react-native",
    "paths": {
      "@/*": [
        "./*"
      ],
      "server/*": [
        "./server/*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts",
    "server/**/*.ts"
  ]
}


[EOF: tsconfig.json]


  ```

- **eas.json** (0.3 KB, 22 lines) *(No explicit exports)*

  ```json
{
  "cli": {
    "version": ">= 16.3.2",
    "appVersionSource": "remote"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "distribution": "internal"
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}

  ```

- **file_hierarchy.txt** (5.3 KB, 211 lines) *(No explicit exports)*

  ```txt
.
./.expo
./.expo/types
./.expo/types/router.d.ts
./.expo/settings.json
./.expo/README.md
./.expo/devices.json
./types
./types/trpc-types.ts
./types/index.ts
./tailwind.config.js
./ts_errors.log
./app
./app/compose.tsx
./app/index.tsx
./app/toast-test.tsx
./app/auth
./app/auth/login.tsx
./app/auth/update-password.tsx
./app/auth/register.tsx
./app/auth/_layout.tsx
./app/auth/forgot-password.tsx
./app/auth/verify-email.tsx
./app/(tabs)
./app/(tabs)/settings
./app/(tabs)/settings/index.tsx
./app/(tabs)/home
./app/(tabs)/home/index.tsx
./app/(tabs)/home/details.tsx
./app/(tabs)/home/_layout.tsx
./app/(tabs)/planner
./app/(tabs)/planner/index.tsx
./app/(tabs)/rewards
./app/(tabs)/rewards/index.tsx
./app/(tabs)/_layout.tsx
./app/(tabs)/compass
./app/(tabs)/compass/index.tsx
./app/(tabs)/explore.tsx
./app/utils
./app/utils/api-types.ts
./app/+not-found.tsx
./app/_layout.tsx
./app.d.ts
./app.json
./.expo 2
./constants
./constants/Colors.ts
./constants/motion.ts
./providers
./providers/ToastProvider.tsx
./providers/AppProvider.tsx
./providers/ConfettiProvider.tsx
./providers/Providers.tsx
./AETHER_TODO.md
./expo-env.d.ts
./output
./output/app_code_overview.txt
./stores
./stores/uiStore.ts
./modals
./server
./server/package-lock.json
./server/package.json
./server/.env
./server/tsconfig.json
./server/src
./server/src/routers
./server/src/routers/dashboardRouter.ts
./server/src/routers/habitRouter.ts
./server/src/routers/rewardsRouter.ts
./server/src/routers/taskRouter.ts
./server/src/routers/valueRouter.ts
./server/src/routers/goalRouter.ts
./server/src/routers/trackedStateRouter.ts
./server/src/routers/userRouter.ts
./server/src/router.ts
./server/src/context.ts
./server/src/index.ts
./utils
./utils/colors.ts
./utils/query-client.ts
./utils/offline-sync.ts
./utils/trpc.ts
./utils/settings.ts
./utils/nats-client.ts
./utils/haptics.ts
./utils/generated-hooks.ts
./utils/supabase.ts
./utils/auth.ts
./utils/offline-mutations.ts
./utils/mock-api.ts
./eas.json
./.tamagui
./.tamagui/tamagui.config.json
./supabase
./supabase/migrations
./supabase/migrations/20250424035717_add_missing_tables.sql
./supabase/migrations/20250424035232_add_missing_tables.sql
./supabase/migrations/20250424033333_initial_schema.sql
./supabase/migrations/20250425000000_create_user_settings_table.sql
./supabase/migrations/20250426000000_create_rewards_tables.sql
./supabase/.branches
./supabase/.branches/_current_branch
./supabase/.temp
./supabase/.temp/postgres-version
./supabase/.temp/project-ref
./supabase/.temp/rest-version
./supabase/.temp/storage-version
./supabase/.temp/gotrue-version
./supabase/.temp/pooler-url
./supabase/.temp/cli-latest
./supabase/.gitignore
./supabase/config.toml
./README.md
./assets 2
./components
./components/ui
./components/ui/ConfettiButton.tsx
./components/ui/FrostedCard.tsx
./components/ui/TabBarBackground.tsx
./components/ui/IconSymbol.ios.tsx
./components/ui/AnimatedCountingText.tsx
./components/ui/iOS
./components/ui/iOS/NativeWindButton.tsx
./components/ui/iOS/Button.tsx
./components/ui/TabBarBackground.ios.tsx
./components/ui/FloatingActionButton.tsx
./components/ui/Button.tsx
./components/ui/ErrorBanner.tsx
./components/ui/HabitToggleRow.tsx
./components/ui/IconSymbol.tsx
./components/ui/Skeleton.tsx
./components/ui/nativewind-setup.tsx
./components/settings
./components/settings/ThemePreview.tsx
./components/settings/NotificationRow.tsx
./components/ExternalLink.tsx
./components/ThemedText.tsx
./components/auth
./components/auth/FloatingInput.tsx
./components/planner
./components/planner/HabitsList.tsx
./components/planner/HabitTracker.tsx
./components/planner/StreakCalendar.tsx
./components/planner/GoalsList.tsx
./components/ThemedView.tsx
./components/EmptyOrSkeleton.tsx
./components/rewards
./components/rewards/ConfettiBurst.tsx
./components/HelloWave.tsx
./components/aether
./components/aether/GoalCard.tsx
./components/aether/ProgressRing.tsx
./components/aether/ValueBadge.tsx
./components/aether/AetherCard.tsx
./components/aether/HabitCard.tsx
./components/dashboard
./components/dashboard/DashboardSection.tsx
./components/dashboard/GoalSummaryCard.tsx
./components/dashboard/StateIndicator.tsx
./components/dashboard/HabitCheckItem.tsx
./components/dashboard/TaskItem.tsx
./components/__tests__
./components/__tests__/ThemedText-test.tsx
./components/__tests__/__snapshots__
./components/__tests__/__snapshots__/ThemedText-test.tsx.snap
./components/ParallaxScrollView.tsx
./components/HapticTab.tsx
./components/OfflineIndicator.tsx
./components/Collapsible.tsx
./yarn.lock
./file_hierarchy.txt
./babel.config.js
./.gitignore
./package.json
./.env
./hooks
./hooks/useSkeleton.ts
./hooks/useColorScheme.web.ts
./hooks/useThemeColor.ts
./hooks/useColorScheme.ts
./hooks/useOfflineSync.ts
./scripts
./scripts/generate-all.js
./scripts/generate-trpc-types.js
./scripts/reset-project.js
./scripts/generate-trpc-client.js
./scripts/generate_app_code_overview.sh
./.github
./.github/workflows
./.github/workflows/ci.yml
./.eslintrc.js
./global.d.ts
./tsconfig.json
./.env.example
./postcss.config.js
./assets
./assets/images
./assets/images/icon.png
./assets/images/partial-react-logo.png
./assets/images/react-logo@2x.png
./assets/images/react-logo@3x.png
./assets/images/favicon.png
./assets/images/adaptive-icon.png
./assets/images/react-logo.png
./assets/images/splash-icon.png
./assets/fonts
./assets/fonts/SpaceMono-Regular.ttf
./tamagui.config.ts
./SUPABASE_INTEGRATION.md

  ```

- **gather_complete_context.sh** (14.0 KB, 349 lines) *(No explicit exports)*

  ```sh
#!/bin/bash

# Create output file
OUTPUT_FILE="aether_migration_context.md"
echo "# Aether iPhone: Complete Migration Context" > "$OUTPUT_FILE"
echo "Generated on $(date)" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# ====================================================================================
# UTILITY FUNCTIONS
# ====================================================================================

# Add a section header
add_section() {
  echo "\n\n# $1" >> "$OUTPUT_FILE"
  echo "$2" >> "$OUTPUT_FILE"
}

# Add a subsection header
add_subsection() {
  echo "\n\n## $1" >> "$OUTPUT_FILE"
  if [ ! -z "$2" ]; then
    echo "$2" >> "$OUTPUT_FILE"
  fi
}

# Add file content with header
add_file() {
  local file_path=$1
  local description=$2
  
  if [ -f "$file_path" ]; then
    echo "\n### $(basename "$file_path")" >> "$OUTPUT_FILE"
    echo "**Path:** `$file_path`" >> "$OUTPUT_FILE"
    if [ ! -z "$description" ]; then
      echo "**Description:** $description" >> "$OUTPUT_FILE"
    fi
    echo "\n\`\`\`$(get_file_extension "$file_path")" >> "$OUTPUT_FILE"
    cat "$file_path" >> "$OUTPUT_FILE"
    echo "\`\`\`" >> "$OUTPUT_FILE"
    echo "Added $file_path to $OUTPUT_FILE"
  else
    echo "\n### $(basename "$file_path") (planned)" >> "$OUTPUT_FILE"
    echo "**Path:** `$file_path`" >> "$OUTPUT_FILE"
    echo "**Status:** File planned but not yet created" >> "$OUTPUT_FILE"
    if [ ! -z "$description" ]; then
      echo "**Description:** $description" >> "$OUTPUT_FILE"
    fi
  fi
}

# Add compact file listing (not full content)
add_file_list() {
  local pattern=$1
  local header=$2
  local limit=$3
  
  # Use default limit if not specified
  if [ -z "$limit" ]; then
    limit=100
  fi

  echo "\n### $header" >> "$OUTPUT_FILE"
  echo "\`\`\`" >> "$OUTPUT_FILE"
  find . -path "$pattern" -type f | grep -v "node_modules\|.git" | sort | head -n "$limit" >> "$OUTPUT_FILE"
  echo "\`\`\`" >> "$OUTPUT_FILE"
}

# Get file extension for code formatting
get_file_extension() {
  local filename=$1
  local ext=${filename##*.}
  
  case "$ext" in
    ts|tsx) echo "typescript" ;;
    js|jsx) echo "javascript" ;;
    json) echo "json" ;;
    sh) echo "bash" ;;
    md) echo "markdown" ;;
    css) echo "css" ;;
    *) echo "" ;;
  esac
}

# Extract code patterns and add them
extract_patterns() {
  local pattern=$1
  local description=$2
  local file_pattern=$3
  local limit=$4
  
  # Use default limit if not specified
  if [ -z "$limit" ]; then
    limit=5
  fi
  
  if [ -z "$file_pattern" ]; then
    file_pattern="."
  fi

  echo "\n### Code with pattern: '$pattern'" >> "$OUTPUT_FILE"
  echo "**Description:** $description" >> "$OUTPUT_FILE"
  
  # Find files matching pattern
  find . -path "$file_pattern" -type f -name "*.ts" -o -name "*.tsx" | \
    grep -v "node_modules\|.git\|dist\|build" | \
    xargs grep -l "$pattern" 2>/dev/null | \
    head -n "$limit" | while read file; do
      echo "\n#### From $(basename "$file")" >> "$OUTPUT_FILE"
      echo "\`\`\`$(get_file_extension "$file")" >> "$OUTPUT_FILE"
      grep -A 5 -B 5 "$pattern" "$file" | head -n 15 >> "$OUTPUT_FILE"
      echo "\`\`\`" >> "$OUTPUT_FILE"
    done
}

# ====================================================================================
# 1. PROJECT OVERVIEW AND MIGRATION PLAN
# ====================================================================================

add_section "1️⃣ Project Overview & Migration Plan" "Top-level overview and plan for Tamagui → Gluestack/NativeWind migration."

# Add the refactoring plan
cat << 'EOF' >> "$OUTPUT_FILE"

## Refactoring Plan

File-by-file work-order for the frontend refactor.
* Top-level paths follow an Expo Router layout (app/…)
* 🔮 marks assumptions to be confirmed

### 1️⃣ Core Design System (/design-system)

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| tokens.ts | keep → export Tailwind-ready object instead of Tamagui createTokens | n/a | single source for color / spacing across Gluestack and NativeWind |
| theme.glue.ts | new – export const gluestackTheme = {tokens, components} | tokens.ts, Gluestack | wires Zelda palette + fonts into Gluestack provider |
| tailwind.config.js | rewrite with content: ["app/**/*.{tsx,ts}"] + colors from tokens | tokens.ts, NativeWind | unlocks className="bg-parchment" etc. in JSX |
| Primitives.tsx | new – <Stack> <Text> <Button> wrappers ⮕ Gluestack equivalents | gluestackTheme | lets old code migrate screen-by-screen w/out mass edits |
| Animations.ts | new – reusable Moti presets (fadeInUp, runePulse) | moti, react-native-reanimated | consistent motion language |

### 2️⃣ Global Providers

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| app/_layout.tsx | rewrite – wrap with <GluestackProvider theme={gluestackTheme}>, <TRPCProvider>, <SupabaseProvider> | theme.glue.ts, 🔮 TRPCProvider, 🔮 SupabaseProvider | guarantees every screen sees styled components + auth + queries |
| providers/TRPCProvider.tsx | new – instantiates trpc.createClient() + React Query | @trpc/client, @tanstack/react-query | centralises tRPC; screens just useTRPCQuery() |

### 3️⃣ Navigation Shells

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| app/(tabs)/_layout.tsx | keep – Expo Router structure (tho migrate Tamagui instances) | n/a | tab layout doesn't need much refactoring |
| app/(auth)/_layout.tsx | keep – Expo Router structure (tho migrate Tamagui instances) | n/a | auth layout doesn't need much refactoring |

### 4️⃣ Reusable UI Components

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| SwipeableRow.tsx | implement – left swipe to Complete, right swipe to Delete | react-native-gesture-handler, react-native-reanimated | enables task status changes with haptic confirmation |
| TaskRow.tsx | implement – task row formatting for to-do lists | SwipeableRow | consistent per-task presentation (name, due date, etc) |
| SectionCard.tsx | implement – glazed Sheikah-glass card section | tokens, useColorScheme | consistent dashboard UI module |

### 5️⃣ Feature Screens Migration
Migrate each one with an index.gluestack.tsx, leave old versions until each can be tested.

| Screen | New Path | Action |
| --- | --- | --- |
| Dashboard | app/(tabs)/home/index.gluestack.tsx | Implement "Task Swipe → Done" with SectionCard + Gluestack |
| Planner | app/(tabs)/planner/index.gluestack.tsx | Migrate later | 
| Compass | app/(tabs)/compass/index.gluestack.tsx | Migrate later |
| Rewards | app/(tabs)/rewards/index.gluestack.tsx | Migrate later |
| Settings | app/(tabs)/settings/index.gluestack.tsx | Migrate later |

### 6️⃣ Utility Hooks

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| useDashboardQuery.ts | implement – fetches active tasks, habits, goals via tRPC | TRPCProvider, React Query | clean abstraction to get status summary |
| useToggleTaskStatus.ts | implement – mutates task status w/ optimistic update | TRPCProvider, React Query | toggle task (complete/not) with onSuccess/onError hooks |
EOF

# Add key package.json for dependencies
add_file "package.json" "Current dependencies and scripts"

# ====================================================================================
# 2. CONFIGURATION FILES
# ====================================================================================

add_section "2️⃣ Key Configuration Files" "Configuration files critical to the Tamagui → Gluestack/NativeWind migration."

# Add current Tamagui config (to be migrated from)
add_file "tamagui.config.ts" "Current Tamagui configuration (migration source)"

# Add current babel config
add_file "babel.config.js" "Babel configuration - needs updates for NativeWind"

# Add current tsconfig
add_file "tsconfig.json" "TypeScript configuration"

# Add current tailwind config (to be updated)
add_file "tailwind.config.js" "Tailwind CSS configuration - needs updates for NativeWind"

# Add metro config if it exists
add_file "metro.config.js" "Metro bundler configuration"

# Add app.json for Expo configuration
add_file "app.json" "Expo app configuration"

# ====================================================================================
# 3. DESIGN SYSTEM MIGRATION
# ====================================================================================

add_section "3️⃣ Design System Migration" "Moving from Tamagui tokens to Gluestack UI theme & NativeWind classes."

# Core design system directories
add_file_list "./design-system/*" "Existing design system files"

# Current theme tokens from Tamagui
add_file "design-system/tokens.ts" "Current or new design tokens" "Single source for color/spacing across Gluestack and NativeWind"

# Add the new Gluestack theme file (if it exists)
add_file "design-system/theme.glue.ts" "New Gluestack theme configuration" "Wires Zelda palette + fonts into Gluestack provider"

# Add the Primitives wrapper (if it exists)
add_file "design-system/Primitives.tsx" "UI primitives wrapper" "Wrappers for Gluestack equivalents to ease migration"

# Add the Animations file (if it exists)
add_file "design-system/Animations.ts" "Animation presets" "Reusable Moti animation presets"

# Identify existing theme/token imports for future reference
extract_patterns "from ['\"](.*tamagui.*|\.\./tokens)['\"]"\
"Theme/token imports to convert" "*.tsx" 10

# ====================================================================================
# 4. PROVIDER ARCHITECTURE
# ====================================================================================

add_section "4️⃣ Provider Architecture" "Overview of providers wrapper architecture."

# Current app layout (root provider setup)
add_file "app/_layout.tsx" "Root layout with providers" "Configures global providers and theme"

# Current providers directory
add_file_list "./providers/*" "Current provider files"

# Add GluestackProvider if it exists
add_file "providers/GluestackProvider.tsx" "New Gluestack provider" "Provides Gluestack theme to app"

# Other key providers
add_file "providers/Providers.tsx" "Current providers wrapper (to be refactored)" 
add_file "providers/TRPCProvider.tsx" "tRPC client provider" "Centralizes tRPC + React Query setup"
add_file "providers/SupabaseProvider.tsx" "Supabase client provider" "Centralizes Supabase client + auth state"

# ====================================================================================
# 5. DASHBOARD IMPLEMENTATION
# ====================================================================================

add_section "5️⃣ Dashboard Implementation" "Focus on the critical 'Task Swipe → Done' feature for migration."

# Current home screen (to be migrated)
add_file "app/(tabs)/home/index.tsx" "Current dashboard implementation (to be migrated)"

# New Gluestack implementation (if exists)
add_file "app/(tabs)/home/index.gluestack.tsx" "New Gluestack dashboard implementation"

# SwipeableRow component (if exists)
add_file "app/components/SwipeableRow.tsx" "Swipeable row component for task actions"

# TaskRow component (if exists)
add_file "app/components/TaskRow.tsx" "Task row formatting for to-do lists"

# SectionCard component (if exists)
add_file "app/components/SectionCard.tsx" "Glazed Sheikah-glass card section"

# Dashboard query hook (if exists)
add_file "app/lib/useDashboardQuery.ts" "Hook for fetching dashboard data"

# Task toggle hook (if exists)
add_file "app/lib/useToggleTaskStatus.ts" "Hook for toggling task status"

# ====================================================================================
# 6. TASK/SWIPE IMPLEMENTATION DETAILS
# ====================================================================================

add_section "6️⃣ Task Swipe Implementation Details" "Technical details of the swipe-to-complete feature."

# Find swipe implementations in the codebase
extract_patterns "SwipeableRow|onSwipe|onSwipeLeft|onSwipeRight" "Swipeable row implementation details"

# Find task completion logic in the codebase
extract_patterns "completeTask|markTaskComplete|toggleTaskStatus" "Task completion logic"

# ====================================================================================
# 7. TRPC INTEGRATION
# ====================================================================================

add_section "7️⃣ tRPC Integration" "How tRPC is integrated with the frontend."

# Look for tRPC router and task-related procedures
find server/src/routers -name "*.ts" -type f 2>/dev/null | while read file; do
  if grep -q "task\|Task" "$file"; then
    add_file "$file" "tRPC router with task-related procedures"
  fi
done

# Look for tRPC utility files
add_file "utils/trpc.ts" "tRPC client utility"

# Find tRPC query/mutation usage
extract_patterns "trpc\..*\.useQuery|trpc\..*\.useMutation" "tRPC query and mutation usage"

# ====================================================================================
# 8. SUPABASE INTEGRATION
# ====================================================================================

add_section "8️⃣ Supabase Integration" "How Supabase is integrated with the frontend."

# Look for Supabase client setup
add_file "utils/supabase.ts" "Supabase client utility"

# Find Supabase usage patterns
extract_patterns "supabase\.|from\(.*\)\." "Supabase client usage patterns"

# ====================================================================================
# 9. ASSETS & STYLES
# ====================================================================================

add_section "9️⃣ Assets & Styles" "Fonts, images, and other assets."

# Add font asset listing
echo "\n### Font Assets" >> "$OUTPUT_FILE"
echo "\`\`\`" >> "$OUTPUT_FILE"
find assets -name "*.ttf" -o -name "*.otf" 2>/dev/null | sort >> "$OUTPUT_FILE"
echo "\`\`\`" >> "$OUTPUT_FILE"

# Add image asset listing
echo "\n### Image Assets" >> "$OUTPUT_FILE"
echo "\`\`\`" >> "$OUTPUT_FILE"
find assets -name "*.png" -o -name "*.jpg" -o -name "*.svg" 2>/dev/null | sort >> "$OUTPUT_FILE"
echo "\`\`\`" >> "$OUTPUT_FILE"

# Add animation asset listing
echo "\n### Animation Assets (Lottie)" >> "$OUTPUT_FILE"
echo "\`\`\`" >> "$OUTPUT_FILE"
find assets -name "*.json" 2>/dev/null | sort >> "$OUTPUT_FILE"
echo "\`\`\`" >> "$OUTPUT_FILE"

echo "Complete migration context has been generated in $OUTPUT_FILE"

  ```

- **gather_complete_context_fixed.sh** (14.1 KB, 349 lines) *(No explicit exports)*

  ```sh
#!/bin/bash

# Create output file
OUTPUT_FILE="aether_migration_context.md"
echo "# Aether iPhone: Complete Migration Context" > "$OUTPUT_FILE"
echo "Generated on $(date)" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# ====================================================================================
# UTILITY FUNCTIONS
# ====================================================================================

# Add a section header
add_section() {
  echo "\n\n# $1" >> "$OUTPUT_FILE"
  echo "$2" >> "$OUTPUT_FILE"
}

# Add a subsection header
add_subsection() {
  echo "\n\n## $1" >> "$OUTPUT_FILE"
  if [ ! -z "$2" ]; then
    echo "$2" >> "$OUTPUT_FILE"
  fi
}

# Add file content with header
add_file() {
  local file_path=$1
  local description=$2
  
  if [ -f "$file_path" ]; then
    echo "\n### $(basename "$file_path")" >> "$OUTPUT_FILE"
    echo "**Path:** $file_path" >> "$OUTPUT_FILE"
    if [ ! -z "$description" ]; then
      echo "**Description:** $description" >> "$OUTPUT_FILE"
    fi
    echo "\n\`\`\`$(get_file_extension "$file_path")" >> "$OUTPUT_FILE"
    cat "$file_path" >> "$OUTPUT_FILE"
    echo "\`\`\`" >> "$OUTPUT_FILE"
    echo "Added $file_path to $OUTPUT_FILE"
  else
    echo "\n### $(basename "$file_path") (planned)" >> "$OUTPUT_FILE"
    echo "**Path:** $file_path" >> "$OUTPUT_FILE"
    echo "**Status:** File planned but not yet created" >> "$OUTPUT_FILE"
    if [ ! -z "$description" ]; then
      echo "**Description:** $description" >> "$OUTPUT_FILE"
    fi
  fi
}

# Add compact file listing (not full content)
add_file_list() {
  local pattern=$1
  local header=$2
  local limit=$3
  
  # Use default limit if not specified
  if [ -z "$limit" ]; then
    limit=100
  fi

  echo "\n### $header" >> "$OUTPUT_FILE"
  echo "\`\`\`" >> "$OUTPUT_FILE"
  find . -path "$pattern" -type f | grep -v "node_modules\|.git" | sort | head -n "$limit" >> "$OUTPUT_FILE"
  echo "\`\`\`" >> "$OUTPUT_FILE"
}

# Get file extension for code formatting
get_file_extension() {
  local filename=$1
  local ext=${filename##*.}
  
  case "$ext" in
    ts|tsx) echo "typescript" ;;
    js|jsx) echo "javascript" ;;
    json) echo "json" ;;
    sh) echo "bash" ;;
    md) echo "markdown" ;;
    css) echo "css" ;;
    *) echo "" ;;
  esac
}

# Extract code patterns and add them
extract_patterns() {
  local pattern=$1
  local description=$2
  local file_pattern=$3
  local limit=$4
  
  # Use default limit if not specified
  if [ -z "$limit" ]; then
    limit=5
  fi
  
  if [ -z "$file_pattern" ]; then
    file_pattern="."
  fi

  echo "\n### Code with pattern: '$pattern'" >> "$OUTPUT_FILE"
  echo "**Description:** $description" >> "$OUTPUT_FILE"
  
  # Find files matching pattern
  find . -path "$file_pattern" -type f -name "*.ts" -o -name "*.tsx" | \
    grep -v "node_modules\|.git\|dist\|build" | \
    xargs grep -l "$pattern" 2>/dev/null | \
    head -n "$limit" | while read file; do
      echo "\n#### From $(basename "$file")" >> "$OUTPUT_FILE"
      echo "\`\`\`$(get_file_extension "$file")" >> "$OUTPUT_FILE"
      grep -A 5 -B 5 "$pattern" "$file" | head -n 15 >> "$OUTPUT_FILE"
      echo "\`\`\`" >> "$OUTPUT_FILE"
    done
}

# ====================================================================================
# 1. PROJECT OVERVIEW AND MIGRATION PLAN
# ====================================================================================

add_section "1ufe0fu20e3 Project Overview & Migration Plan" "Top-level overview and plan for Tamagui u2192 Gluestack/NativeWind migration."

# Add the refactoring plan
cat << 'EOF' >> "$OUTPUT_FILE"

## Refactoring Plan

File-by-file work-order for the frontend refactor.
* Top-level paths follow an Expo Router layout (app/u2026)
* ud83dudd2e marks assumptions to be confirmed

### 1ufe0fu20e3 Core Design System (/design-system)

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| tokens.ts | keep u2192 export Tailwind-ready object instead of Tamagui createTokens | n/a | single source for color / spacing across Gluestack and NativeWind |
| theme.glue.ts | new u2013 export const gluestackTheme = {tokens, components} | tokens.ts, Gluestack | wires Zelda palette + fonts into Gluestack provider |
| tailwind.config.js | rewrite with content: ["app/**/*.{tsx,ts}"] + colors from tokens | tokens.ts, NativeWind | unlocks className="bg-parchment" etc. in JSX |
| Primitives.tsx | new u2013 <Stack> <Text> <Button> wrappers u2b95 Gluestack equivalents | gluestackTheme | lets old code migrate screen-by-screen w/out mass edits |
| Animations.ts | new u2013 reusable Moti presets (fadeInUp, runePulse) | moti, react-native-reanimated | consistent motion language |

### 2ufe0fu20e3 Global Providers

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| app/_layout.tsx | rewrite u2013 wrap with <GluestackProvider theme={gluestackTheme}>, <TRPCProvider>, <SupabaseProvider> | theme.glue.ts, ud83dudd2e TRPCProvider, ud83dudd2e SupabaseProvider | guarantees every screen sees styled components + auth + queries |
| providers/TRPCProvider.tsx | new u2013 instantiates trpc.createClient() + React Query | @trpc/client, @tanstack/react-query | centralises tRPC; screens just useTRPCQuery() |

### 3ufe0fu20e3 Navigation Shells

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| app/(tabs)/_layout.tsx | keep u2013 Expo Router structure (tho migrate Tamagui instances) | n/a | tab layout doesn't need much refactoring |
| app/(auth)/_layout.tsx | keep u2013 Expo Router structure (tho migrate Tamagui instances) | n/a | auth layout doesn't need much refactoring |

### 4ufe0fu20e3 Reusable UI Components

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| SwipeableRow.tsx | implement u2013 left swipe to Complete, right swipe to Delete | react-native-gesture-handler, react-native-reanimated | enables task status changes with haptic confirmation |
| TaskRow.tsx | implement u2013 task row formatting for to-do lists | SwipeableRow | consistent per-task presentation (name, due date, etc) |
| SectionCard.tsx | implement u2013 glazed Sheikah-glass card section | tokens, useColorScheme | consistent dashboard UI module |

### 5ufe0fu20e3 Feature Screens Migration
Migrate each one with an index.gluestack.tsx, leave old versions until each can be tested.

| Screen | New Path | Action |
| --- | --- | --- |
| Dashboard | app/(tabs)/home/index.gluestack.tsx | Implement "Task Swipe u2192 Done" with SectionCard + Gluestack |
| Planner | app/(tabs)/planner/index.gluestack.tsx | Migrate later | 
| Compass | app/(tabs)/compass/index.gluestack.tsx | Migrate later |
| Rewards | app/(tabs)/rewards/index.gluestack.tsx | Migrate later |
| Settings | app/(tabs)/settings/index.gluestack.tsx | Migrate later |

### 6ufe0fu20e3 Utility Hooks

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| useDashboardQuery.ts | implement u2013 fetches active tasks, habits, goals via tRPC | TRPCProvider, React Query | clean abstraction to get status summary |
| useToggleTaskStatus.ts | implement u2013 mutates task status w/ optimistic update | TRPCProvider, React Query | toggle task (complete/not) with onSuccess/onError hooks |
EOF

# Add key package.json for dependencies
add_file "package.json" "Current dependencies and scripts"

# ====================================================================================
# 2. CONFIGURATION FILES
# ====================================================================================

add_section "2ufe0fu20e3 Key Configuration Files" "Configuration files critical to the Tamagui u2192 Gluestack/NativeWind migration."

# Add current Tamagui config (to be migrated from)
add_file "tamagui.config.ts" "Current Tamagui configuration (migration source)"

# Add current babel config
add_file "babel.config.js" "Babel configuration - needs updates for NativeWind"

# Add current tsconfig
add_file "tsconfig.json" "TypeScript configuration"

# Add current tailwind config (to be updated)
add_file "tailwind.config.js" "Tailwind CSS configuration - needs updates for NativeWind"

# Add metro config if it exists
add_file "metro.config.js" "Metro bundler configuration"

# Add app.json for Expo configuration
add_file "app.json" "Expo app configuration"

# ====================================================================================
# 3. DESIGN SYSTEM MIGRATION
# ====================================================================================

add_section "3ufe0fu20e3 Design System Migration" "Moving from Tamagui tokens to Gluestack UI theme & NativeWind classes."

# Core design system directories
add_file_list "./design-system/*" "Existing design system files"

# Current theme tokens from Tamagui
add_file "design-system/tokens.ts" "Current or new design tokens" "Single source for color/spacing across Gluestack and NativeWind"

# Add the new Gluestack theme file (if it exists)
add_file "design-system/theme.glue.ts" "New Gluestack theme configuration" "Wires Zelda palette + fonts into Gluestack provider"

# Add the Primitives wrapper (if it exists)
add_file "design-system/Primitives.tsx" "UI primitives wrapper" "Wrappers for Gluestack equivalents to ease migration"

# Add the Animations file (if it exists)
add_file "design-system/Animations.ts" "Animation presets" "Reusable Moti animation presets"

# Identify existing theme/token imports for future reference
extract_patterns "from ['\"](.*tamagui.*|\.\./tokens)['\"]"\
"Theme/token imports to convert" "*.tsx" 10

# ====================================================================================
# 4. PROVIDER ARCHITECTURE
# ====================================================================================

add_section "4ufe0fu20e3 Provider Architecture" "Overview of providers wrapper architecture."

# Current app layout (root provider setup)
add_file "app/_layout.tsx" "Root layout with providers" "Configures global providers and theme"

# Current providers directory
add_file_list "./providers/*" "Current provider files"

# Add GluestackProvider if it exists
add_file "providers/GluestackProvider.tsx" "New Gluestack provider" "Provides Gluestack theme to app"

# Other key providers
add_file "providers/Providers.tsx" "Current providers wrapper (to be refactored)" 
add_file "providers/TRPCProvider.tsx" "tRPC client provider" "Centralizes tRPC + React Query setup"
add_file "providers/SupabaseProvider.tsx" "Supabase client provider" "Centralizes Supabase client + auth state"

# ====================================================================================
# 5. DASHBOARD IMPLEMENTATION
# ====================================================================================

add_section "5ufe0fu20e3 Dashboard Implementation" "Focus on the critical 'Task Swipe u2192 Done' feature for migration."

# Current home screen (to be migrated)
add_file "app/(tabs)/home/index.tsx" "Current dashboard implementation (to be migrated)"

# New Gluestack implementation (if exists)
add_file "app/(tabs)/home/index.gluestack.tsx" "New Gluestack dashboard implementation"

# SwipeableRow component (if exists)
add_file "app/components/SwipeableRow.tsx" "Swipeable row component for task actions"

# TaskRow component (if exists)
add_file "app/components/TaskRow.tsx" "Task row formatting for to-do lists"

# SectionCard component (if exists)
add_file "app/components/SectionCard.tsx" "Glazed Sheikah-glass card section"

# Dashboard query hook (if exists)
add_file "app/lib/useDashboardQuery.ts" "Hook for fetching dashboard data"

# Task toggle hook (if exists)
add_file "app/lib/useToggleTaskStatus.ts" "Hook for toggling task status"

# ====================================================================================
# 6. TASK/SWIPE IMPLEMENTATION DETAILS
# ====================================================================================

add_section "6ufe0fu20e3 Task Swipe Implementation Details" "Technical details of the swipe-to-complete feature."

# Find swipe implementations in the codebase
extract_patterns "SwipeableRow|onSwipe|onSwipeLeft|onSwipeRight" "Swipeable row implementation details"

# Find task completion logic in the codebase
extract_patterns "completeTask|markTaskComplete|toggleTaskStatus" "Task completion logic"

# ====================================================================================
# 7. TRPC INTEGRATION
# ====================================================================================

add_section "7ufe0fu20e3 tRPC Integration" "How tRPC is integrated with the frontend."

# Look for tRPC router and task-related procedures
find server/src/routers -name "*.ts" -type f 2>/dev/null | while read file; do
  if grep -q "task\|Task" "$file"; then
    add_file "$file" "tRPC router with task-related procedures"
  fi
done

# Look for tRPC utility files
add_file "utils/trpc.ts" "tRPC client utility"

# Find tRPC query/mutation usage
extract_patterns "trpc\..*\.useQuery|trpc\..*\.useMutation" "tRPC query and mutation usage"

# ====================================================================================
# 8. SUPABASE INTEGRATION
# ====================================================================================

add_section "8ufe0fu20e3 Supabase Integration" "How Supabase is integrated with the frontend."

# Look for Supabase client setup
add_file "utils/supabase.ts" "Supabase client utility"

# Find Supabase usage patterns
extract_patterns "supabase\.|from\(.*\)\." "Supabase client usage patterns"

# ====================================================================================
# 9. ASSETS & STYLES
# ====================================================================================

add_section "9ufe0fu20e3 Assets & Styles" "Fonts, images, and other assets."

# Add font asset listing
echo "\n### Font Assets" >> "$OUTPUT_FILE"
echo "\`\`\`" >> "$OUTPUT_FILE"
find assets -name "*.ttf" -o -name "*.otf" 2>/dev/null | sort >> "$OUTPUT_FILE"
echo "\`\`\`" >> "$OUTPUT_FILE"

# Add image asset listing
echo "\n### Image Assets" >> "$OUTPUT_FILE"
echo "\`\`\`" >> "$OUTPUT_FILE"
find assets -name "*.png" -o -name "*.jpg" -o -name "*.svg" 2>/dev/null | sort >> "$OUTPUT_FILE"
echo "\`\`\`" >> "$OUTPUT_FILE"

# Add animation asset listing
echo "\n### Animation Assets (Lottie)" >> "$OUTPUT_FILE"
echo "\`\`\`" >> "$OUTPUT_FILE"
find assets -name "*.json" 2>/dev/null | sort >> "$OUTPUT_FILE"
echo "\`\`\`" >> "$OUTPUT_FILE"

echo "Complete migration context has been generated in $OUTPUT_FILE"

  ```

- **gather_complete_context_full.sh** (20.0 KB, 511 lines) *(No explicit exports)*

  ```sh
#!/bin/bash

# Create output file with proper unicode encoding
OUTPUT_FILE="aether_migration_context_full.md"
echo -e "# Aether iPhone: Complete Migration Context" > "$OUTPUT_FILE"
echo -e "Generated on $(date)" >> "$OUTPUT_FILE"
echo -e "" >> "$OUTPUT_FILE"

# ====================================================================================
# UTILITY FUNCTIONS
# ====================================================================================

# Add a section header
add_section() {
  echo -e "\n\n# $1" >> "$OUTPUT_FILE"
  echo -e "$2" >> "$OUTPUT_FILE"
}

# Add a subsection header
add_subsection() {
  echo -e "\n\n## $1" >> "$OUTPUT_FILE"
  if [ ! -z "$2" ]; then
    echo -e "$2" >> "$OUTPUT_FILE"
  fi
}

# Add file content with header
add_file() {
  local file_path=$1
  local description=$2
  
  if [ -f "$file_path" ]; then
    echo -e "\n### $(basename "$file_path")" >> "$OUTPUT_FILE"
    echo -e "**Path:** $file_path" >> "$OUTPUT_FILE"
    if [ ! -z "$description" ]; then
      echo -e "**Description:** $description" >> "$OUTPUT_FILE"
    fi
    echo -e "\n\`\`\`$(get_file_extension "$file_path")" >> "$OUTPUT_FILE"
    cat "$file_path" >> "$OUTPUT_FILE"
    echo -e "\`\`\`" >> "$OUTPUT_FILE"
    echo "Added $file_path to $OUTPUT_FILE"
  else
    echo -e "\n### $(basename "$file_path") (planned)" >> "$OUTPUT_FILE"
    echo -e "**Path:** $file_path" >> "$OUTPUT_FILE"
    echo -e "**Status:** File planned but not yet created" >> "$OUTPUT_FILE"
    if [ ! -z "$description" ]; then
      echo -e "**Description:** $description" >> "$OUTPUT_FILE"
    fi
  fi
}

# Add compact file listing (not full content)
add_file_list() {
  local pattern=$1
  local header=$2
  local limit=$3
  
  # Use default limit if not specified
  if [ -z "$limit" ]; then
    limit=500
  fi

  echo -e "\n### $header" >> "$OUTPUT_FILE"
  echo -e "\`\`\`" >> "$OUTPUT_FILE"
  find . -path "$pattern" -type f | grep -v "node_modules\|.git" | sort | head -n "$limit" >> "$OUTPUT_FILE"
  echo -e "\`\`\`" >> "$OUTPUT_FILE"
}

# Add all files in a directory recursively
add_directory_files() {
  local dir_path=$1
  local file_pattern=$2
  local description=$3
  
  # Default to all files if pattern not specified
  if [ -z "$file_pattern" ]; then
    file_pattern="*"
  fi
  
  # Get list of files
  files=$(find "$dir_path" -type f -name "$file_pattern" | grep -v "node_modules\|.git" | sort)
  
  # Process each file
  for file in $files; do
    add_file "$file" "$description"
  done
}

# Get file extension for code formatting
get_file_extension() {
  local filename=$1
  local ext=${filename##*.}
  
  case "$ext" in
    ts|tsx) echo "typescript" ;;
    js|jsx) echo "javascript" ;;
    json) echo "json" ;;
    sh) echo "bash" ;;
    md) echo "markdown" ;;
    css) echo "css" ;;
    toml) echo "toml" ;;
    sql) echo "sql" ;;
    *) echo "" ;;
  esac
}

# Extract code patterns and add them
extract_patterns() {
  local pattern=$1
  local description=$2
  local file_pattern=$3
  local limit=$4
  
  # Use default limit if not specified
  if [ -z "$limit" ]; then
    limit=5
  fi
  
  if [ -z "$file_pattern" ]; then
    file_pattern="."
  fi

  echo -e "\n### Code with pattern: '$pattern'" >> "$OUTPUT_FILE"
  echo -e "**Description:** $description" >> "$OUTPUT_FILE"
  
  # Find files matching pattern
  find . -path "$file_pattern" -type f -name "*.ts" -o -name "*.tsx" | \
    grep -v "node_modules\|.git\|dist\|build" | \
    xargs grep -l "$pattern" 2>/dev/null | \
    head -n "$limit" | while read file; do
      echo -e "\n#### From $(basename "$file")" >> "$OUTPUT_FILE"
      echo -e "\`\`\`$(get_file_extension "$file")" >> "$OUTPUT_FILE"
      grep -A 5 -B 5 "$pattern" "$file" | head -n 15 >> "$OUTPUT_FILE"
      echo -e "\`\`\`" >> "$OUTPUT_FILE"
    done
}

# ====================================================================================
# TABLE OF CONTENTS
# ====================================================================================

add_section "📋 Table of Contents" "Navigation for this comprehensive document."

cat << 'EOF' >> "$OUTPUT_FILE"

1. [Project Overview & Migration Plan](#1️⃣-project-overview--migration-plan)
2. [Configuration Files](#2️⃣-configuration-files)
3. [Design System Migration](#3️⃣-design-system-migration)
4. [Provider Architecture](#4️⃣-provider-architecture)
5. [UI Components](#5️⃣-ui-components)
6. [App Screens](#6️⃣-app-screens)
7. [Backend & Data Layer](#7️⃣-backend--data-layer)
8. [Utilities & Hooks](#8️⃣-utilities--hooks)
9. [Zelda Styling Guide](#9️⃣-zelda-styling-guide)
10. [Assets & Files](#🎨-assets--files)
11. [Testing](#📊-testing)
12. [Supabase Integration](#💾-supabase-integration)

EOF

# ====================================================================================
# 1. PROJECT OVERVIEW AND MIGRATION PLAN
# ====================================================================================

add_section "1️⃣ Project Overview & Migration Plan" "Top-level overview and plan for Tamagui → Gluestack/NativeWind migration."

# Add the refactoring plan
cat << 'EOF' >> "$OUTPUT_FILE"

## Refactoring Plan

File-by-file work-order for the frontend refactor.
* Top-level paths follow an Expo Router layout (app/…)
* 🔮 marks assumptions to be confirmed

### 1️⃣ Core Design System (/design-system)

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| tokens.ts | keep → export Tailwind-ready object instead of Tamagui createTokens | n/a | single source for color / spacing across Gluestack and NativeWind |
| theme.glue.ts | new – export const gluestackTheme = {tokens, components} | tokens.ts, Gluestack | wires Zelda palette + fonts into Gluestack provider |
| tailwind.config.js | rewrite with content: ["app/**/*.{tsx,ts}"] + colors from tokens | tokens.ts, NativeWind | unlocks className="bg-parchment" etc. in JSX |
| Primitives.tsx | new – <Stack> <Text> <Button> wrappers ⮕ Gluestack equivalents | gluestackTheme | lets old code migrate screen-by-screen w/out mass edits |
| Animations.ts | new – reusable Moti presets (fadeInUp, runePulse) | moti, react-native-reanimated | consistent motion language |

### 2️⃣ Global Providers

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| app/_layout.tsx | rewrite – wrap with <GluestackProvider theme={gluestackTheme}>, <TRPCProvider>, <SupabaseProvider> | theme.glue.ts, 🔮 TRPCProvider, 🔮 SupabaseProvider | guarantees every screen sees styled components + auth + queries |
| providers/TRPCProvider.tsx | new – instantiates trpc.createClient() + React Query | @trpc/client, @tanstack/react-query | centralises tRPC; screens just useTRPCQuery() |

### 3️⃣ Navigation Shells

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| app/(tabs)/_layout.tsx | keep – Expo Router structure (tho migrate Tamagui instances) | n/a | tab layout doesn't need much refactoring |
| app/(auth)/_layout.tsx | keep – Expo Router structure (tho migrate Tamagui instances) | n/a | auth layout doesn't need much refactoring |

### 4️⃣ Reusable UI Components

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| SwipeableRow.tsx | implement – left swipe to Complete, right swipe to Delete | react-native-gesture-handler, react-native-reanimated | enables task status changes with haptic confirmation |
| TaskRow.tsx | implement – task row formatting for to-do lists | SwipeableRow | consistent per-task presentation (name, due date, etc) |
| SectionCard.tsx | implement – glazed Sheikah-glass card section | tokens, useColorScheme | consistent dashboard UI module |

### 5️⃣ Feature Screens Migration
Migrate each one with an index.gluestack.tsx, leave old versions until each can be tested.

| Screen | New Path | Action |
| --- | --- | --- |
| Dashboard | app/(tabs)/home/index.gluestack.tsx | Implement "Task Swipe → Done" with SectionCard + Gluestack |
| Planner | app/(tabs)/planner/index.gluestack.tsx | Migrate later | 
| Compass | app/(tabs)/compass/index.gluestack.tsx | Migrate later |
| Rewards | app/(tabs)/rewards/index.gluestack.tsx | Migrate later |
| Settings | app/(tabs)/settings/index.gluestack.tsx | Migrate later |

### 6️⃣ Utility Hooks

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| useDashboardQuery.ts | implement – fetches active tasks, habits, goals via tRPC | TRPCProvider, React Query | clean abstraction to get status summary |
| useToggleTaskStatus.ts | implement – mutates task status w/ optimistic update | TRPCProvider, React Query | toggle task (complete/not) with onSuccess/onError hooks |
EOF

# Add key package.json for dependencies
add_file "package.json" "Current dependencies and scripts"

# Add basic readme
add_file "README.md" "Project documentation"

# Add any refactoring plans
add_file "refactoring_plan.md" "Migration plan details"
add_file "REFACTORING_PLAN_V2.yaml" "Updated migration plan"

# ====================================================================================
# 2. CONFIGURATION FILES
# ====================================================================================

add_section "2️⃣ Configuration Files" "Configuration files critical to the Tamagui → Gluestack/NativeWind migration."

# Add current Tamagui config (to be migrated from)
add_file "tamagui.config.ts" "Current Tamagui configuration (migration source)"

# Add current babel config
add_file "babel.config.js" "Babel configuration - needs updates for NativeWind"

# Add current tsconfig
add_file "tsconfig.json" "TypeScript configuration"

# Add current tailwind config (to be updated)
add_file "tailwind.config.js" "Tailwind CSS configuration - needs updates for NativeWind"

# Add metro config if it exists
add_file "metro.config.js" "Metro bundler configuration"

# Add app.json for Expo configuration
add_file "app.json" "Expo app configuration"

# Add postcss config
add_file "postcss.config.js" "PostCSS configuration for Tailwind"

# Add eslint config
add_file ".eslintrc.js" "ESLint configuration"

# Add global types
add_file "global.d.ts" "Global TypeScript declarations"
add_file "expo-env.d.ts" "Expo environment type declarations"

# Add env example
add_file ".env.example" "Environment variables template"

# ====================================================================================
# 3. DESIGN SYSTEM MIGRATION
# ====================================================================================

add_section "3️⃣ Design System Migration" "Moving from Tamagui tokens to Gluestack UI theme & NativeWind classes."

# Add all design system files
add_directory_files "./design-system" "*" "Design system components, tokens, and utilities"

# Add color constant files
add_directory_files "./constants" "*" "Application constants including colors and animations"

# Identify existing theme/token imports for future reference
extract_patterns "from ['\"](.*tamagui.*|\.\./tokens)['\"]"\
"Theme/token imports to convert" "*.tsx" 10

# ====================================================================================
# 4. PROVIDER ARCHITECTURE
# ====================================================================================

add_section "4️⃣ Provider Architecture" "Overview of providers wrapper architecture."

# Current app layout (root provider setup)
add_file "app/_layout.tsx" "Root layout with providers" "Configures global providers and theme"

# Add all provider files
add_directory_files "./providers" "*.tsx" "Provider components for app-wide state and context"

# ====================================================================================
# 5. UI COMPONENTS
# ====================================================================================

add_section "5️⃣ UI Components" "UI component library including new Gluestack implementations."

# Add all component files grouped by category

# Dashboard components
add_subsection "Dashboard Components" "Components used in the dashboard interface"
add_directory_files "./components/dashboard" "*.tsx" "Dashboard UI components"

# UI primitives
add_subsection "UI Primitives" "Basic UI building blocks"
add_directory_files "./components/ui/primitives" "*.tsx" "Primitive UI components"

# General UI components
add_subsection "General UI Components" "Reusable UI components"
add_directory_files "./components/ui" "*.tsx" "General UI components"

# Lists components
add_subsection "List Components" "Components for displaying lists"
add_directory_files "./components/lists" "*.tsx" "List UI components"

# Planner components
add_subsection "Planner Components" "Components for planning features"
add_directory_files "./components/planner" "*.tsx" "Planner UI components"

# Auth components
add_subsection "Auth Components" "Authentication-related components"
add_directory_files "./components/auth" "*.tsx" "Authentication UI components"

# Other component directories
add_directory_files "./components/compass" "*.tsx" "Compass feature components"
add_directory_files "./components/rewards" "*.tsx" "Rewards feature components"
add_directory_files "./components/settings" "*.tsx" "Settings UI components"
add_directory_files "./components/aether" "*.tsx" "Aether-specific components"

# New Gluestack components (app/components)
add_subsection "New Gluestack Components" "New components using Gluestack UI"
add_directory_files "./app/components" "*.tsx" "New Gluestack UI components"

# ====================================================================================
# 6. APP SCREENS
# ====================================================================================

add_section "6️⃣ App Screens" "Application screens and routing structure."

# Add auth screens
add_subsection "Auth Screens" "Authentication screens"
add_file "app/(auth)/_layout.tsx" "Auth layout"
add_directory_files "./app/(auth)" "*.tsx" "Authentication screens"

# Add tabs layout
add_subsection "Tab Navigation" "Tab-based navigation structure"
add_file "app/(tabs)/_layout.tsx" "Tabs layout"

# Add home screens (original and Gluestack version)
add_subsection "Home/Dashboard Screens" "Dashboard main screens"
add_file "app/(tabs)/home/index.tsx" "Original home screen"
add_file "app/(tabs)/home/index.gluestack.tsx" "Gluestack version of home screen"

# Add planner screens
add_subsection "Planner Screens" "Task/habit/goal planning screens"
add_file "app/(tabs)/planner/_layout.tsx" "Planner layout"
add_directory_files "./app/(tabs)/planner" "*.tsx" "Planning screens"

# Add other tab screens
add_subsection "Other Main Screens" "Other main tab screens"
add_file "app/(tabs)/compass/index.tsx" "Compass screen"
add_file "app/(tabs)/rewards/index.tsx" "Rewards screen"

# Add settings screens
add_subsection "Settings Screens" "Settings and configuration screens"
add_file "app/(tabs)/settings/_layout.tsx" "Settings layout"
add_directory_files "./app/(tabs)/settings" "*.tsx" "Settings screens"

# Add other root-level screens
add_subsection "Other Screens" "Miscellaneous screens"
add_file "app/index.tsx" "Root index (if exists)"
add_file "app/compose.tsx" "Compose screen (if exists)"

# Add utility query hooks
add_subsection "Screen Query Hooks" "Hooks for screen data fetching"
add_directory_files "./app/lib" "*.ts" "Screen-specific utility hooks"

# ====================================================================================
# 7. BACKEND & DATA LAYER
# ====================================================================================

add_section "7️⃣ Backend & Data Layer" "Server-side code, routers, API integration."

# Add server entry points
add_subsection "Server Core" "Server entry points and context"
add_file "server/src/index.ts" "Server entry point"
add_file "server/src/context.ts" "tRPC context setup"
add_file "server/src/router.ts" "Main router configuration"

# Add server routers
add_subsection "tRPC Routers" "Backend tRPC routers"
add_directory_files "./server/src/routers" "*.ts" "tRPC router implementation"

# Add server types
add_subsection "Server Types" "Backend type definitions"
add_directory_files "./server/src/types" "*.ts" "Server-side type definitions"

# ====================================================================================
# 8. UTILITIES & HOOKS
# ====================================================================================

add_section "8️⃣ Utilities & Hooks" "Reusable utilities and React hooks."

# Add hooks
add_subsection "Hooks" "Custom React hooks"
add_directory_files "./hooks" "*.ts" "Custom React hooks"

# Add utilities
add_subsection "Utilities" "Helper utilities and functions"
add_directory_files "./utils" "*.ts" "Utility functions and helpers"

# Add stores
add_subsection "State Stores" "Global state management"
add_directory_files "./stores" "*.ts" "State stores (Zustand/Redux)"

# ====================================================================================
# 9. ZELDA STYLING GUIDE
# ====================================================================================

add_section "9️⃣ Zelda Styling Guide" "Zelda: Breath of the Wild / Sheikah Slate aesthetic guidelines."

# Add styling context if available
if [ -f "aether_styling_context.txt" ]; then
  echo -e "\n### Zelda Theme Styling Guide" >> "$OUTPUT_FILE"
  echo -e "**Source:** aether_styling_context.txt" >> "$OUTPUT_FILE"
  echo -e "\n\`\`\`" >> "$OUTPUT_FILE"
  grep -A 20 -B 2 "hex codes\|fonts\|Sheikah\|Korok\|parchment" aether_styling_context.txt | head -30 >> "$OUTPUT_FILE"
  echo -e "\n\`\`\`" >> "$OUTPUT_FILE"
fi

# ====================================================================================
# 10. TESTING SETUP
# ====================================================================================

add_section "📊 Testing" "Testing configuration and test files."

# Add Jest config files
add_subsection "Jest Configuration" "Jest testing setup"
add_file "jest.config.ui.js" "UI component testing config"
add_file "jest.config.server.js" "Server testing config"
add_file "jest.setup.js" "Jest setup file"
add_file "jest.server.setup.js" "Jest server setup file"

# Add component tests
add_subsection "Component Tests" "UI component tests"
add_directory_files "./__tests__/components" "*.test.tsx" "Component test files"

# Add server tests
add_subsection "Server Tests" "Backend server tests"
add_directory_files "./__tests__/server" "*.test.ts" "Server test files"

# Add test utilities
add_subsection "Test Utilities" "Testing utilities and helpers"
add_file "./__tests__/test-utils.tsx" "Test utilities"
add_file "./__tests__/server/test-helpers.ts" "Server test helpers"

# ====================================================================================
# 11. SUPABASE INTEGRATION
# ====================================================================================

add_section "💾 Supabase Integration" "Supabase database integration."

# Add Supabase migration files
add_subsection "Supabase Migrations" "Database schema migrations"
add_directory_files "./supabase/migrations" "*.sql" "Supabase SQL migrations"

# Add Supabase config
add_subsection "Supabase Configuration" "Supabase connection setup"
add_file "supabase/config.toml" "Supabase configuration"
add_file "SUPABASE_INTEGRATION.md" "Supabase integration documentation"

# Add database types
add_subsection "Database Types" "Database type definitions"
add_file "types/database.types.ts" "Supabase database types"

# ====================================================================================
# 12. ASSETS & FILES
# ====================================================================================

add_section "🎨 Assets & Files" "Fonts, images, and other assets."

# Add font asset listing
echo -e "\n### Font Assets" >> "$OUTPUT_FILE"
echo -e "\`\`\`" >> "$OUTPUT_FILE"
find assets -name "*.ttf" -o -name "*.otf" 2>/dev/null | sort >> "$OUTPUT_FILE"
echo -e "\`\`\`" >> "$OUTPUT_FILE"

# Add image asset listing
echo -e "\n### Image Assets" >> "$OUTPUT_FILE"
echo -e "\`\`\`" >> "$OUTPUT_FILE"
find assets -name "*.png" -o -name "*.jpg" -o -name "*.svg" 2>/dev/null | sort >> "$OUTPUT_FILE"
echo -e "\`\`\`" >> "$OUTPUT_FILE"

# Add animation asset listing
echo -e "\n### Animation Assets (Lottie)" >> "$OUTPUT_FILE"
echo -e "\`\`\`" >> "$OUTPUT_FILE"
find assets -name "*.json" 2>/dev/null | sort >> "$OUTPUT_FILE"
echo -e "\`\`\`" >> "$OUTPUT_FILE"

echo "Complete comprehensive migration context has been generated in $OUTPUT_FILE"

  ```

- **gather_complete_context_improved.sh** (15.3 KB, 375 lines) *(No explicit exports)*

  ```sh
#!/bin/bash

# Create output file with proper unicode encoding
OUTPUT_FILE="aether_migration_context.md"
echo -e "# Aether iPhone: Complete Migration Context" > "$OUTPUT_FILE"
echo -e "Generated on $(date)" >> "$OUTPUT_FILE"
echo -e "" >> "$OUTPUT_FILE"

# ====================================================================================
# UTILITY FUNCTIONS
# ====================================================================================

# Add a section header
add_section() {
  echo -e "\n\n# $1" >> "$OUTPUT_FILE"
  echo -e "$2" >> "$OUTPUT_FILE"
}

# Add a subsection header
add_subsection() {
  echo -e "\n\n## $1" >> "$OUTPUT_FILE"
  if [ ! -z "$2" ]; then
    echo -e "$2" >> "$OUTPUT_FILE"
  fi
}

# Add file content with header
add_file() {
  local file_path=$1
  local description=$2
  
  if [ -f "$file_path" ]; then
    echo -e "\n### $(basename "$file_path")" >> "$OUTPUT_FILE"
    echo -e "**Path:** $file_path" >> "$OUTPUT_FILE"
    if [ ! -z "$description" ]; then
      echo -e "**Description:** $description" >> "$OUTPUT_FILE"
    fi
    echo -e "\n\`\`\`$(get_file_extension "$file_path")" >> "$OUTPUT_FILE"
    cat "$file_path" >> "$OUTPUT_FILE"
    echo -e "\`\`\`" >> "$OUTPUT_FILE"
    echo "Added $file_path to $OUTPUT_FILE"
  else
    echo -e "\n### $(basename "$file_path") (planned)" >> "$OUTPUT_FILE"
    echo -e "**Path:** $file_path" >> "$OUTPUT_FILE"
    echo -e "**Status:** File planned but not yet created" >> "$OUTPUT_FILE"
    if [ ! -z "$description" ]; then
      echo -e "**Description:** $description" >> "$OUTPUT_FILE"
    fi
  fi
}

# Add compact file listing (not full content)
add_file_list() {
  local pattern=$1
  local header=$2
  local limit=$3
  
  # Use default limit if not specified
  if [ -z "$limit" ]; then
    limit=100
  fi

  echo -e "\n### $header" >> "$OUTPUT_FILE"
  echo -e "\`\`\`" >> "$OUTPUT_FILE"
  find . -path "$pattern" -type f | grep -v "node_modules\|.git" | sort | head -n "$limit" >> "$OUTPUT_FILE"
  echo -e "\`\`\`" >> "$OUTPUT_FILE"
}

# Get file extension for code formatting
get_file_extension() {
  local filename=$1
  local ext=${filename##*.}
  
  case "$ext" in
    ts|tsx) echo "typescript" ;;
    js|jsx) echo "javascript" ;;
    json) echo "json" ;;
    sh) echo "bash" ;;
    md) echo "markdown" ;;
    css) echo "css" ;;
    *) echo "" ;;
  esac
}

# Extract code patterns and add them
extract_patterns() {
  local pattern=$1
  local description=$2
  local file_pattern=$3
  local limit=$4
  
  # Use default limit if not specified
  if [ -z "$limit" ]; then
    limit=5
  fi
  
  if [ -z "$file_pattern" ]; then
    file_pattern="."
  fi

  echo -e "\n### Code with pattern: '$pattern'" >> "$OUTPUT_FILE"
  echo -e "**Description:** $description" >> "$OUTPUT_FILE"
  
  # Find files matching pattern
  find . -path "$file_pattern" -type f -name "*.ts" -o -name "*.tsx" | \
    grep -v "node_modules\|.git\|dist\|build" | \
    xargs grep -l "$pattern" 2>/dev/null | \
    head -n "$limit" | while read file; do
      echo -e "\n#### From $(basename "$file")" >> "$OUTPUT_FILE"
      echo -e "\`\`\`$(get_file_extension "$file")" >> "$OUTPUT_FILE"
      grep -A 5 -B 5 "$pattern" "$file" | head -n 15 >> "$OUTPUT_FILE"
      echo -e "\`\`\`" >> "$OUTPUT_FILE"
    done
}

# ====================================================================================
# 1. PROJECT OVERVIEW AND MIGRATION PLAN
# ====================================================================================

add_section "1️⃣ Project Overview & Migration Plan" "Top-level overview and plan for Tamagui → Gluestack/NativeWind migration."

# Add the refactoring plan
cat << 'EOF' >> "$OUTPUT_FILE"

## Refactoring Plan

File-by-file work-order for the frontend refactor.
* Top-level paths follow an Expo Router layout (app/…)
* 🔮 marks assumptions to be confirmed

### 1️⃣ Core Design System (/design-system)

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| tokens.ts | keep → export Tailwind-ready object instead of Tamagui createTokens | n/a | single source for color / spacing across Gluestack and NativeWind |
| theme.glue.ts | new – export const gluestackTheme = {tokens, components} | tokens.ts, Gluestack | wires Zelda palette + fonts into Gluestack provider |
| tailwind.config.js | rewrite with content: ["app/**/*.{tsx,ts}"] + colors from tokens | tokens.ts, NativeWind | unlocks className="bg-parchment" etc. in JSX |
| Primitives.tsx | new – <Stack> <Text> <Button> wrappers ⮕ Gluestack equivalents | gluestackTheme | lets old code migrate screen-by-screen w/out mass edits |
| Animations.ts | new – reusable Moti presets (fadeInUp, runePulse) | moti, react-native-reanimated | consistent motion language |

### 2️⃣ Global Providers

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| app/_layout.tsx | rewrite – wrap with <GluestackProvider theme={gluestackTheme}>, <TRPCProvider>, <SupabaseProvider> | theme.glue.ts, 🔮 TRPCProvider, 🔮 SupabaseProvider | guarantees every screen sees styled components + auth + queries |
| providers/TRPCProvider.tsx | new – instantiates trpc.createClient() + React Query | @trpc/client, @tanstack/react-query | centralises tRPC; screens just useTRPCQuery() |

### 3️⃣ Navigation Shells

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| app/(tabs)/_layout.tsx | keep – Expo Router structure (tho migrate Tamagui instances) | n/a | tab layout doesn't need much refactoring |
| app/(auth)/_layout.tsx | keep – Expo Router structure (tho migrate Tamagui instances) | n/a | auth layout doesn't need much refactoring |

### 4️⃣ Reusable UI Components

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| SwipeableRow.tsx | implement – left swipe to Complete, right swipe to Delete | react-native-gesture-handler, react-native-reanimated | enables task status changes with haptic confirmation |
| TaskRow.tsx | implement – task row formatting for to-do lists | SwipeableRow | consistent per-task presentation (name, due date, etc) |
| SectionCard.tsx | implement – glazed Sheikah-glass card section | tokens, useColorScheme | consistent dashboard UI module |

### 5️⃣ Feature Screens Migration
Migrate each one with an index.gluestack.tsx, leave old versions until each can be tested.

| Screen | New Path | Action |
| --- | --- | --- |
| Dashboard | app/(tabs)/home/index.gluestack.tsx | Implement "Task Swipe → Done" with SectionCard + Gluestack |
| Planner | app/(tabs)/planner/index.gluestack.tsx | Migrate later | 
| Compass | app/(tabs)/compass/index.gluestack.tsx | Migrate later |
| Rewards | app/(tabs)/rewards/index.gluestack.tsx | Migrate later |
| Settings | app/(tabs)/settings/index.gluestack.tsx | Migrate later |

### 6️⃣ Utility Hooks

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| useDashboardQuery.ts | implement – fetches active tasks, habits, goals via tRPC | TRPCProvider, React Query | clean abstraction to get status summary |
| useToggleTaskStatus.ts | implement – mutates task status w/ optimistic update | TRPCProvider, React Query | toggle task (complete/not) with onSuccess/onError hooks |
EOF

# Add key package.json for dependencies
add_file "package.json" "Current dependencies and scripts"

# ====================================================================================
# 2. CONFIGURATION FILES
# ====================================================================================

add_section "2️⃣ Key Configuration Files" "Configuration files critical to the Tamagui → Gluestack/NativeWind migration."

# Add current Tamagui config (to be migrated from)
add_file "tamagui.config.ts" "Current Tamagui configuration (migration source)"

# Add current babel config
add_file "babel.config.js" "Babel configuration - needs updates for NativeWind"

# Add current tsconfig
add_file "tsconfig.json" "TypeScript configuration"

# Add current tailwind config (to be updated)
add_file "tailwind.config.js" "Tailwind CSS configuration - needs updates for NativeWind"

# Add metro config if it exists
add_file "metro.config.js" "Metro bundler configuration"

# Add app.json for Expo configuration
add_file "app.json" "Expo app configuration"

# ====================================================================================
# 3. DESIGN SYSTEM MIGRATION
# ====================================================================================

add_section "3️⃣ Design System Migration" "Moving from Tamagui tokens to Gluestack UI theme & NativeWind classes."

# Core design system directories
add_file_list "./design-system/*" "Existing design system files"

# Current theme tokens from Tamagui
add_file "design-system/tokens.ts" "Current or new design tokens" "Single source for color/spacing across Gluestack and NativeWind"

# Add the new Gluestack theme file (if it exists)
add_file "design-system/theme.glue.ts" "New Gluestack theme configuration" "Wires Zelda palette + fonts into Gluestack provider"

# Add the Primitives wrapper (if it exists)
add_file "design-system/Primitives.tsx" "UI primitives wrapper" "Wrappers for Gluestack equivalents to ease migration"

# Add the Animations file (if it exists)
add_file "design-system/Animations.ts" "Animation presets" "Reusable Moti animation presets"

# Identify existing theme/token imports for future reference
extract_patterns "from ['\"](.*tamagui.*|\.\./tokens)['\"]"\
"Theme/token imports to convert" "*.tsx" 10

# ====================================================================================
# 4. PROVIDER ARCHITECTURE
# ====================================================================================

add_section "4️⃣ Provider Architecture" "Overview of providers wrapper architecture."

# Current app layout (root provider setup)
add_file "app/_layout.tsx" "Root layout with providers" "Configures global providers and theme"

# Current providers directory
add_file_list "./providers/*" "Current provider files"

# Add GluestackProvider if it exists
add_file "providers/GluestackProvider.tsx" "New Gluestack provider" "Provides Gluestack theme to app"

# Other key providers
add_file "providers/Providers.tsx" "Current providers wrapper (to be refactored)" 
add_file "providers/TRPCProvider.tsx" "tRPC client provider" "Centralizes tRPC + React Query setup"
add_file "providers/SupabaseProvider.tsx" "Supabase client provider" "Centralizes Supabase client + auth state"

# ====================================================================================
# 5. DASHBOARD IMPLEMENTATION
# ====================================================================================

add_section "5️⃣ Dashboard Implementation" "Focus on the critical 'Task Swipe → Done' feature for migration."

# Current home screen (to be migrated)
add_file "app/(tabs)/home/index.tsx" "Current dashboard implementation (to be migrated)"

# New Gluestack implementation (if exists)
add_file "app/(tabs)/home/index.gluestack.tsx" "New Gluestack dashboard implementation"

# SwipeableRow component (if exists)
add_file "app/components/SwipeableRow.tsx" "Swipeable row component for task actions"

# TaskRow component (if exists)
add_file "app/components/TaskRow.tsx" "Task row formatting for to-do lists"

# SectionCard component (if exists)
add_file "app/components/SectionCard.tsx" "Glazed Sheikah-glass card section"

# Dashboard query hook (if exists)
add_file "app/lib/useDashboardQuery.ts" "Hook for fetching dashboard data"

# Task toggle hook (if exists)
add_file "app/lib/useToggleTaskStatus.ts" "Hook for toggling task status"

# ====================================================================================
# 6. TASK/SWIPE IMPLEMENTATION DETAILS
# ====================================================================================

add_section "6️⃣ Task Swipe Implementation Details" "Technical details of the swipe-to-complete feature."

# Find swipe implementations in the codebase
extract_patterns "SwipeableRow|onSwipe|onSwipeLeft|onSwipeRight" "Swipeable row implementation details"

# Find task completion logic in the codebase
extract_patterns "completeTask|markTaskComplete|toggleTaskStatus" "Task completion logic"

# ====================================================================================
# 7. TRPC INTEGRATION
# ====================================================================================

add_section "7️⃣ tRPC Integration" "How tRPC is integrated with the frontend."

# Look for tRPC router and task-related procedures
find server/src/routers -name "*.ts" -type f 2>/dev/null | while read file; do
  if grep -q "task\|Task" "$file"; then
    add_file "$file" "tRPC router with task-related procedures"
  fi
done

# Look for tRPC utility files
add_file "utils/trpc.ts" "tRPC client utility"

# Find tRPC query/mutation usage
extract_patterns "trpc\..*\.useQuery|trpc\..*\.useMutation" "tRPC query and mutation usage"

# ====================================================================================
# 8. SUPABASE INTEGRATION
# ====================================================================================

add_section "8️⃣ Supabase Integration" "How Supabase is integrated with the frontend."

# Look for Supabase client setup
add_file "utils/supabase.ts" "Supabase client utility"

# Find Supabase usage patterns
extract_patterns "supabase\.|from\(.*\)\." "Supabase client usage patterns"

# ====================================================================================
# 9. ZELDA STYLING GUIDE
# ====================================================================================

add_section "9️⃣ Zelda Styling Guide" "Zelda: Breath of the Wild / Sheikah Slate aesthetic guidelines."

# Add styling context if available
if [ -f "aether_styling_context.txt" ]; then
  echo -e "\n### Zelda Theme Styling Guide" >> "$OUTPUT_FILE"
  echo -e "**Source:** aether_styling_context.txt" >> "$OUTPUT_FILE"
  echo -e "\n\`\`\`" >> "$OUTPUT_FILE"
  grep -A 20 -B 2 "hex codes\|fonts\|Sheikah\|Korok\|parchment" aether_styling_context.txt | head -30 >> "$OUTPUT_FILE"
  echo -e "\n\`\`\`" >> "$OUTPUT_FILE"
fi

# Find existing UI primitives to migrate
echo -e "\n### UI Primitives to Migrate" >> "$OUTPUT_FILE"
find components/ui/primitives -name "*.tsx" -type f 2>/dev/null | while read file; do
  component_name=$(basename "$file" .tsx)
  echo -e "\n#### $component_name" >> "$OUTPUT_FILE"
  echo -e "**File:** $file" >> "$OUTPUT_FILE"
  echo -e "\n\`\`\`typescript" >> "$OUTPUT_FILE"
  head -30 "$file" >> "$OUTPUT_FILE"
  echo -e "\n...\n\`\`\`" >> "$OUTPUT_FILE"
done

# ====================================================================================
# 10. ASSETS & STYLES
# ====================================================================================

add_section "🎨 Assets & Styles" "Fonts, images, and other assets."

# Add font asset listing
echo -e "\n### Font Assets" >> "$OUTPUT_FILE"
echo -e "\`\`\`" >> "$OUTPUT_FILE"
find assets -name "*.ttf" -o -name "*.otf" 2>/dev/null | sort >> "$OUTPUT_FILE"
echo -e "\`\`\`" >> "$OUTPUT_FILE"

# Add image asset listing
echo -e "\n### Image Assets" >> "$OUTPUT_FILE"
echo -e "\`\`\`" >> "$OUTPUT_FILE"
find assets -name "*.png" -o -name "*.jpg" -o -name "*.svg" 2>/dev/null | sort >> "$OUTPUT_FILE"
echo -e "\`\`\`" >> "$OUTPUT_FILE"

# Add animation asset listing
echo -e "\n### Animation Assets (Lottie)" >> "$OUTPUT_FILE"
echo -e "\`\`\`" >> "$OUTPUT_FILE"
find assets -name "*.json" 2>/dev/null | sort >> "$OUTPUT_FILE"
echo -e "\`\`\`" >> "$OUTPUT_FILE"

echo "Complete migration context has been generated in $OUTPUT_FILE"

  ```

- **gather_complete_context_v3.sh** (1.0 KB, 34 lines) *(No explicit exports)*

  ```sh
#!/bin/bash
# … keep header …

usage(){ cat <<EOF
Usage: $0 [-q] [-s MAX_KB]
  -q   Quick mode (diff since merge-base of HEAD vs origin/main)
  -s   Max inline size in KiB (default: 512)
EOF
exit 1; }

MAX_INLINE_SIZE=$((512*1024))
while getopts ":qs:h" flag; do
  case $flag in
    q) QUICK_MODE=true ;;
    s) MAX_INLINE_SIZE=$(($OPTARG*1024)) ;;
    h) usage ;;
  esac
done
shift $((OPTIND-1))

# 1️⃣  File list -------------------------------------------------------------
if git rev-parse --is-inside-work-tree &>/dev/null; then
  if $QUICK_MODE; then
    base=$(git merge-base HEAD origin/main 2>/dev/null || git rev-parse --short HEAD~1)
    mapfile -t tracked < <(git diff --name-only "$base"..HEAD)  # Ensure variables are quoted
  else
    mapfile -t tracked < <(git ls-files)
  fi
  mapfile -t untracked < <(git ls-files --others --exclude-standard)
  FILES=( "${tracked[@]}" "${untracked[@]}" )
else
  mapfile -t FILES < <(find . -type f ! -path "./node_modules/*")
fi

  ```

- **gather_debug_info.js** (1.6 KB, 47 lines) *(No explicit exports)*

  ```js
// gather_debug_info.js
// Reads and exports the content of key configuration and source files for debugging purposes.

const fs = require('fs');
const path = require('path');

const projectRoot = path.resolve(__dirname); // Assumes this script is run from the project root
const outputFileName = 'debug_context.txt';

const filesToRead = [
  'tamagui.config.ts',
  'babel.config.js',
  'providers/Providers.tsx',
  'app/_layout.tsx',
  'package.json',
  'tsconfig.json'
];

let combinedContent = `========================================\n`;
combinedContent += ` AETHERIPHONE DEBUG CONTEXT DUMP     \n`;
combinedContent += `========================================\n\n`;
combinedContent += `Date: ${new Date().toISOString()}\n\n`;


filesToRead.forEach(filePath => {
  const fullPath = path.join(projectRoot, filePath);
  combinedContent += `========================================\n`;
  combinedContent += `FILE: ${filePath}\n`;
  combinedContent += `----------------------------------------\n\n`;
  try {
    const content = fs.readFileSync(fullPath, 'utf-8');
    combinedContent += content;
    console.log(`Successfully read: ${filePath}`);
  } catch (error) {
    const errorMessage = `Error reading file ${filePath}: ${error.message}`;
    combinedContent += errorMessage;
    console.error(`Error reading file ${filePath}:`, error);
  }
  combinedContent += `\n\n[EOF: ${filePath}]\n\n`;
});

try {
  fs.writeFileSync(path.join(projectRoot, outputFileName), combinedContent);
  console.log(`\nSuccessfully wrote combined content to ${outputFileName}`);
} catch (error) {
  console.error(`\nError writing to output file ${outputFileName}:`, error);
}
  ```

- **gather_implementation_details.sh** (4.9 KB, 133 lines) *(No explicit exports)*

  ```sh
#!/bin/bash

# Create or truncate the implementation_details.txt file
echo "# Aether iPhone: Implementation Details for Migration Questions" > implementation_details.txt
echo "Generated on $(date)" >> implementation_details.txt
echo "" >> implementation_details.txt

# Function to add a file to the output with header
add_file_with_header() {
  local filename=$1
  local header=$2
  
  echo "\n\n## $header" >> implementation_details.txt
  
  if [ -f "$filename" ]; then
    echo "**File:** $filename" >> implementation_details.txt
    echo "\n\`\`\`" >> implementation_details.txt
    cat "$filename" >> implementation_details.txt
    echo "\`\`\`" >> implementation_details.txt
    echo "Added $filename to implementation_details.txt"
  else
    echo "**File not found:** $filename" >> implementation_details.txt
  fi
}

# Function to add just a section header
add_section_header() {
  local header=$1
  echo "\n\n# $header" >> implementation_details.txt
}

# 1. tRPC Routers and Procedures
add_section_header "1️⃣ tRPC Router Names & Procedure Signatures"

# First, find all router files
echo "\n## Router Definitions" >> implementation_details.txt
find server/src/routers -name "*.ts" -type f 2>/dev/null | while read file; do
  router_name=$(basename "$file" .ts)
  add_file_with_header "$file" "Router: $router_name"
done

# Look for router imports/exports to find the main app router
echo "\n## Router Import/Export Structure" >> implementation_details.txt
add_file_with_header "server/src/routers/index.ts" "Main App Router"

# Check if there's a dashboard-specific router
add_file_with_header "server/src/routers/dashboardRouter.ts" "Dashboard Router"

# Core entity routers (based on user's mention)
ROUTERS=(
  "server/src/routers/goalRouter.ts"
  "server/src/routers/taskRouter.ts"
  "server/src/routers/habitRouter.ts"
  "server/src/routers/profileRouter.ts"
  "server/src/routers/principleRouter.ts"
  "server/src/routers/rewardRouter.ts"
)

for file in "${ROUTERS[@]}"; do
  router_name=$(basename "$file" .ts | sed 's/Router//')
  add_file_with_header "$file" "$router_name Router"
done

# 2. Points Economy Endpoint
add_section_header "2️⃣ Points Economy Endpoint"

# Look for reward or points related files
echo "\n## Reward System Implementation" >> implementation_details.txt

# Check for reward/points routers
add_file_with_header "server/src/routers/rewardRouter.ts" "Reward Router"

# Check for points mutation handlers
find server/src -name "*.ts" -type f -exec grep -l "points\|rupees\|reward" {} \; 2>/dev/null | while read file; do
  if [[ $file != *test* ]]; then
    add_file_with_header "$file" "Points/Rewards Handler: $(basename "$file")"
  fi
done

# Frontend reward/points components
find components -name "*.tsx" -type f -exec grep -l "points\|rupees\|reward" {} \; 2>/dev/null | while read file; do
  if [[ $file != *test* ]]; then
    component_name=$(basename "$file" .tsx)
    add_file_with_header "$file" "Points/Rewards Component: $component_name"
  fi
done

# 3. Realtime Strategy
add_section_header "3️⃣ Realtime Strategy"

# Check for Supabase realtime implementation
echo "\n## Supabase Realtime Implementation" >> implementation_details.txt

# Look for channel subscriptions
find . -name "*.ts" -o -name "*.tsx" | grep -v "node_modules\|.git" | xargs grep -l "supabase.*channel\|on(\|channel" 2>/dev/null | while read file; do
  add_file_with_header "$file" "Realtime Channel: $(basename "$file")"
done

# Check for polling mechanisms
echo "\n## Polling Implementation" >> implementation_details.txt
find . -name "*.ts" -o -name "*.tsx" | grep -v "node_modules\|.git" | xargs grep -l "refetchInterval\|polling\|setInterval" 2>/dev/null | while read file; do
  add_file_with_header "$file" "Polling: $(basename "$file")"
done

# 4. Core Query Hooks
add_section_header "4️⃣ Core Query Hooks"

# Extract query hooks from the codebase
find hooks -name "*.ts" -type f 2>/dev/null | while read file; do
  hook_name=$(basename "$file" .ts)
  add_file_with_header "$file" "Hook: $hook_name"
done

# Look for any usage of tRPC queries
echo "\n## tRPC Query Usage Examples" >> implementation_details.txt
find app -name "*.tsx" -type f | xargs grep -l "useQuery\|useMutation\|trpc" 2>/dev/null | head -5 | while read file; do
  add_file_with_header "$file" "tRPC Query Example: $(basename "$file")"
done

# 5. Swipe-to-Complete Implementation
add_section_header "5️⃣ Dashboard "Task Swipe → Done" Flow"

# Look for swipe implementations
add_file_with_header "components/ui/SwipeableRow.tsx" "SwipeableRow Component"
add_file_with_header "components/dashboard/TaskItem.tsx" "TaskItem Component"

# Check task completion handlers
find . -name "*.ts" -o -name "*.tsx" | grep -v "node_modules\|.git" | xargs grep -l "completeTask\|onComplete\|markTaskComplete" 2>/dev/null | while read file; do
  add_file_with_header "$file" "Task Completion Handler: $(basename "$file")"
done

echo "\nAll implementation details for your open questions have been collected in implementation_details.txt"

  ```

- **gather_integrated_context.sh** (5.6 KB, 180 lines) *(No explicit exports)*

  ```sh
#!/bin/bash

# Create or truncate the project.txt file
echo "# Aether iPhone: Tamagui to Gluestack/NativeWind Migration" > project.txt
echo "Generated on $(date)" >> project.txt
echo "" >> project.txt

# Function to add a file to the project.txt with header
add_file_with_header() {
  local filename=$1
  local header=$2
  
  echo "\n\n## $header" >> project.txt
  
  if [ -f "$filename" ]; then
    echo "**Current implementation:** $filename" >> project.txt
    echo "\n\`\`\`" >> project.txt
    cat "$filename" >> project.txt
    echo "\`\`\`" >> project.txt
    echo "Added $filename to project.txt"
  else
    echo "**File planned but not yet created:** $filename" >> project.txt
  fi
}

# Function to add just the section header
add_section_header() {
  local header=$1
  echo "\n\n# $header" >> project.txt
}


# --- 1. Core Design System ---
add_section_header "1️⃣ Core Design System"
echo "\nMigration path: Tamagui tokens → Gluestack UI + NativeWind" >> project.txt

# Add current tamagui.config.ts
add_file_with_header "tamagui.config.ts" "Current tokens (tamagui.config.ts)"

# Add current tailwind.config.js
add_file_with_header "tailwind.config.js" "tailwind.config.js (to be rewritten)"

# Add constants/motion.ts for animation reference
add_file_with_header "constants/motion.ts" "Motion constants"

# Note planned files that don't exist yet
echo "\n\n## Planned new files" >> project.txt
echo "* tokens.ts - Export Tailwind-ready object instead of Tamagui createTokens" >> project.txt
echo "* theme.glue.ts - Wire Zelda palette & fonts into Gluestack provider" >> project.txt 
echo "* Primitives.tsx - Create wrappers for Gluestack equivalents" >> project.txt
echo "* Animations.ts - Create reusable Moti presets" >> project.txt


# --- 2. Global Providers ---
add_section_header "2️⃣ Global Providers"

# Current app/_layout.tsx implementation
add_file_with_header "app/_layout.tsx" "Current app/_layout.tsx (to be rewritten)"

# Show existing provider implementations
find providers -name "*.tsx" -type f 2>/dev/null | while read file; do
  filename=$(basename "$file")
  add_file_with_header "$file" "Current $filename (to be refactored)"
done

# Note planned providers
echo "\n\n## Planned new providers" >> project.txt
echo "* providers/TRPCProvider.tsx - Instantiate trpc.createClient() + React Query" >> project.txt
echo "* providers/SupabaseProvider.tsx - Context for supabase-js instance + session" >> project.txt


# --- 3. Navigation Shells ---
add_section_header "3️⃣ Navigation Shells (Expo Router)"

# Current tab layout implementation
add_file_with_header "app/(tabs)/_layout.tsx" "Current tab layout (to be rewritten)"

# Current auth layout implementation
add_file_with_header "app/(auth)/_layout.tsx" "Current auth layout"


# --- 4. Reusable Components ---
add_section_header "4️⃣ Reusable Components"

# Show current primitive components
echo "\n\n## Current UI primitives" >> project.txt
find components/ui/primitives -name "*.tsx" -type f 2>/dev/null | while read file; do
  component_name=$(basename "$file" .tsx)
  add_file_with_header "$file" "$component_name"
done

# Show some key components that will need conversion
echo "\n\n## Key components to migrate" >> project.txt
KEY_COMPONENTS=(
  "components/ui/Container.tsx"
  "components/ui/EmptyOrSkeleton.tsx"
  "components/dashboard/DashboardSection.tsx"
  "components/dashboard/GoalSummaryCard.tsx"
)

for file in "${KEY_COMPONENTS[@]}"; do
  if [ -f "$file" ]; then
    component_name=$(basename "$file" .tsx)
    add_file_with_header "$file" "$component_name"
  fi
done

# Note planned components
echo "\n\n## Planned new components" >> project.txt
echo "* SectionCard.tsx - Glazed parchment card with header, children slot" >> project.txt
echo "* StatBadge.tsx - Heart/rupee style KPI badge" >> project.txt
echo "* SkeletonCard.tsx - NativeWind animated placeholder" >> project.txt
echo "* EmptyState.tsx - Triforce-in-cloud illustration + call-to-action" >> project.txt


# --- 5. Feature Screens ---
add_section_header "5️⃣ Feature Screens"

# Show current implementations of main feature screens
echo "\n\n## Current implementations" >> project.txt
FEATURE_SCREENS=(
  "app/(tabs)/home/index.tsx"
  "app/(tabs)/planner/index.tsx"
  "app/(tabs)/compass/index.tsx"
  "app/(tabs)/rewards/index.tsx"
  "app/(tabs)/settings/index.tsx"
)

for file in "${FEATURE_SCREENS[@]}"; do
  if [ -f "$file" ]; then
    screen_name=$(echo "$file" | sed 's/.*\/(.*)\/\(.*\)\/index.tsx/\1-\2/')
    add_file_with_header "$file" "Current $screen_name screen"
  fi
done


# --- 6. Utilities & Hooks ---
add_section_header "6️⃣ Utils & Hooks"

# Show current client implementations
UTIL_FILES=(
  "utils/supabase.ts"
  "utils/trpc.ts"
)

for file in "${UTIL_FILES[@]}"; do
  if [ -f "$file" ]; then
    util_name=$(basename "$file" .ts)
    add_file_with_header "$file" "$util_name"
  fi
done

# --- 7. Type Definitions (for reference) ---
add_section_header "Type Definitions (for reference)"

TYPE_FILES=(
  "utils/api-types.ts"
  "server/src/types/trpc-types.ts"
)

for file in "${TYPE_FILES[@]}"; do
  if [ -f "$file" ]; then
    type_file=$(basename "$file" .ts)
    add_file_with_header "$file" "$type_file"
  fi
done


# --- 8. Assets ---
add_section_header "7️⃣ Assets"

# Just list asset directories
echo "\n\n## Font Files in assets/fonts:" >> project.txt
ls -la assets/fonts 2>/dev/null >> project.txt || echo "No font directory found" >> project.txt

echo "\n\n## Lottie Files in assets:" >> project.txt
find assets -name "*.json" 2>/dev/null | sort >> project.txt || echo "No Lottie files found" >> project.txt

echo "\n\nAll migration context has been collected in project.txt with integrated file contexts"

  ```

- **gather_project_context.sh** (11.6 KB, 285 lines) *(No explicit exports)*

  ```sh
#!/bin/bash

# Create or truncate the project.txt file
echo "# Aether iPhone Project Context for Tamagui to Gluestack/NativeWind Migration" > project.txt
echo "Generated on $(date)" >> project.txt

# Add refactoring plan to the beginning
cat << 'EOF' >> project.txt

## Refactoring Plan

File-by-file work-order for the frontend refactor.
* Top-level paths follow an Expo Router layout (app/…)
* 🔮 marks assumptions to be confirmed

### 1️⃣ Core Design System (/design-system)

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| tokens.ts | keep → export Tailwind-ready object instead of Tamagui createTokens | n/a | single source for color / spacing across Gluestack and NativeWind |
| theme.glue.ts | new – export const gluestackTheme = {tokens, components} | tokens.ts, Gluestack | wires Zelda palette + fonts into Gluestack provider |
| tailwind.config.js | rewrite with content: ["app/**/*.{tsx,ts}"] + colors from tokens | tokens.ts, NativeWind | unlocks className="bg-parchment" etc. in JSX |
| Primitives.tsx | new – <Stack> <Text> <Button> wrappers ⮕ Gluestack equivalents | gluestackTheme | lets old code migrate screen-by-screen w/out mass edits |
| Animations.ts | new – reusable Moti presets (fadeInUp, runePulse) | moti, react-native-reanimated | consistent motion language |

### 2️⃣ Global Providers

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| app/_layout.tsx | rewrite – wrap with <GluestackProvider theme={gluestackTheme}>, <TRPCProvider>, <SupabaseProvider> | theme.glue.ts, 🔮 TRPCProvider, 🔮 SupabaseProvider | guarantees every screen sees styled components + auth + queries |
| providers/TRPCProvider.tsx | new – instantiates trpc.createClient() + React Query | @trpc/client, @tanstack/react-query | centralises tRPC; screens just useTRPCQuery() |
| providers/SupabaseProvider.tsx | new – context for supabase-js instance + session | @supabase/auth-helpers-react | avoids prop-drilling, keeps auth refresh logic isolated |

### 3️⃣ Navigation Shells (Expo Router)

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| app/(tabs)/_layout.tsx | rewrite – BottomTabs with icons (Shield, Scroll, Compass, Ruby, Cog) | gluestack/svg icons | Zelda-flavoured nav & group-wide background parchment |
| app/(tabs)/index.tsx | rewrite – Home list (see SectionCard) | 📄 SectionCard.tsx, 🔮 trpc.dashboard.getDashboardData | one entry to test new DS without touching others |
| app/(auth)/ | unchanged aside from Tailwind classes | existing screens | auth flow continues to work |

### 4️⃣ Reusable Components (app/components)

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| SectionCard.tsx | new – glazed parchment card with header, children slot | Primitives, Animations | reusable for Dashboard sections, Planner lists, etc. |
| StatBadge.tsx | new – heart/rupee style KPI badge | Primitives | quick "level / points" readouts |
| SkeletonCard.tsx | port from Tamagui variant → NativeWind animated placeholder | react-native-linear-gradient | keeps perceived performance |
| EmptyState.tsx | new – Triforce-in-cloud illustration + call-to-action | svg-asset | encourages first-time engagement |

### 5️⃣ Feature Folders

#### 🛡 Home app/dashboard

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| index.tsx | new (move logic from old screen) – <FlatList> of section data | SectionCard, StatBadge, 🔮 useDashboardQuery | declarative; pull-to-refresh Lottie spinner |
| hooks/useDashboardQuery.ts | new – typed wrapper around trpc.dashboard.getDashboardData | RouterOutputs | co-locates data logic with UI |

#### 📜 Planner app/planner

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| _layout.tsx | new – SegmentedControl (Goals / Tasks / Habits) | Gluestack SegmentedControl | local navigation |
| Goals.tsx / Tasks.tsx / Habits.tsx | rewrite each list-view with RecyclerListView + swipe actions | 🔮 useGoalsQuery, etc. | performant infinite scrolling |
| hooks/useGoalsQuery.ts etc. | new wrappers | RouterOutputs | enforce Zod types end-to-end |
| components/GoalRow.tsx | new card with progress bar | Primitives, Animations | consistent visual language |

#### 🧭 Compass app/compass

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| index.tsx | rewrite – master/detail responsive layout | react-native-responsive-layout | quick principle lookup & edit |
| components/PrinciplePreview.tsx | new | Primitives | mini-card list |
| hooks/usePrinciplesQuery.ts | new | RouterOutputs | typed |

#### 🎁 Rewards app/rewards

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| index.tsx | rewrite – Grid/List toggle with derived animation | Moti | engaging loot boutique |
| components/RewardTile.tsx | new | Primitives | highlights image + cost |
| hooks/useRewardsQuery.ts | new | RouterOutputs | realtime claim updates |

#### ⚙️ Settings app/settings

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| index.tsx | rewrite – grouped list with divide-y classes | NativeWind | cleaner iOS look |
| hooks/useProfileMutation.ts | new | RouterInputs | patch profile + toast |

### 6️⃣ Utils & Hooks (app/lib)

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| supabaseClient.ts | keep | @supabase/supabase-js | single import site |
| trpcClient.ts | keep (point to new URL if needed) | @trpc/client | no API change |
| useOfflineCache.ts | new – queryClient.persist() to SQLite | expo-sqlite | offline UX on flights |
| useAuthGuard.tsx | new – redirect unauth users to (auth) stack | Supabase session | consistent gating |

### 7️⃣ Assets

| Item | Action | Why |
| --- | --- | --- |
| assets/fonts/HyliaSerif.ttf CalamitySans.ttf | keep | brand typefaces |
| assets/lottie/sheikah_spinner.json | keep | loading flair |
| assets/svg/triforce_cloud.svg | new | EmptyState illustration |

### 8️⃣ Testing & CI

| File | Action | Depends on | Why |
| --- | --- | --- | --- |
| e2e/Home.spec.ts | new – Playwright test clicks through sections | expo-playwright | prevents regressions |
| jest/setup.ts | update mocks for Gluestack primitives | jest | green unit tests |
| .eas.json | update channel preview-green | Expo EAS | staged rollout |

### 🔮 Assumptions / Unknowns
* TRPC routers exist for dashboard, goal, task, habit, principle, reward, profile. If any are missing we'll stub until backend delivers.
* Auth context – I assumed you expose useSession() from Supabase; if not we'll craft it.
* SVG icon set – I'm planning to import Heroicons + custom Zelda glyphs; confirm license.
EOF

echo "\n## Migration Overview" >> project.txt
echo "Current: Tamagui-based design system" >> project.txt
echo "Target: Gluestack UI + NativeWind" >> project.txt
echo "" >> project.txt

# Function to add a file to the project.txt
add_file() {
  local filename=$1
  
  if [ -f "$filename" ]; then
    echo "\n\n===========================================================" >> project.txt
    echo "# FILE: $filename" >> project.txt
    echo "===========================================================\n" >> project.txt
    cat "$filename" >> project.txt
    echo "Added $filename to project.txt"
  else
    echo "Warning: File $filename not found"
  fi
}

# 1) Core Configuration Files
echo "\n\n===========================================================" >> project.txt
echo "# 1️⃣ CORE DESIGN SYSTEM" >> project.txt
echo "===========================================================\n" >> project.txt

# Main config files
CORE_CONFIG_FILES=(
  "tamagui.config.ts"
  "tailwind.config.js"
  "constants/motion.ts"
  "constants/theme.ts"
  "package.json"
)

for file in "${CORE_CONFIG_FILES[@]}"; do
  add_file "$file"
done

# 2) Type Definitions (important for migrating to new system)
echo "\n\n===========================================================" >> project.txt
echo "# TYPE DEFINITIONS" >> project.txt
echo "===========================================================\n" >> project.txt

TYPE_FILES=(
  "types/database.types.ts"
  "utils/api-types.ts"
  "server/src/types/trpc-types.ts"
  "utils/generated-hooks.ts"
)

for file in "${TYPE_FILES[@]}"; do
  add_file "$file"
done

# 3) Global Providers
echo "\n\n===========================================================" >> project.txt
echo "# 2️⃣ GLOBAL PROVIDERS" >> project.txt
echo "===========================================================\n" >> project.txt

add_file "app/_layout.tsx"

# Find all provider files
find providers -name "*.tsx" -type f 2>/dev/null | while read file; do
  add_file "$file"
done

# Find utils with client setup (for trpc and supabase)
echo "\n\n===========================================================" >> project.txt
echo "# 6️⃣ CLIENT UTILITIES" >> project.txt
echo "===========================================================\n" >> project.txt

UTIL_FILES=(
  "utils/supabase.ts"
  "utils/trpc.ts"
  "utils/api.ts"
)

for file in "${UTIL_FILES[@]}"; do
  add_file "$file"
done

# 4) Navigation Layout Files
echo "\n\n===========================================================" >> project.txt
echo "# 3️⃣ NAVIGATION SHELLS" >> project.txt
echo "===========================================================\n" >> project.txt

NAV_FILES=(
  "app/(tabs)/_layout.tsx"
  "app/(tabs)/index.tsx"
  "app/(auth)/_layout.tsx"
)

for file in "${NAV_FILES[@]}"; do
  add_file "$file"
done

# 5) Key UI Components for Migration
echo "\n\n===========================================================" >> project.txt
echo "# 4️⃣ REUSABLE COMPONENTS" >> project.txt
echo "===========================================================\n" >> project.txt

# UI primitives first
find components/ui/primitives -name "*.tsx" -type f 2>/dev/null | while read file; do
  add_file "$file"
done

# Core shared components that will need migration
KEY_COMPONENTS=(
  "components/ui/Container.tsx"
  "components/ui/EmptyOrSkeleton.tsx"
  "components/ui/SwipeableRow.tsx"
  "components/dashboard/DashboardSection.tsx"
  "components/dashboard/GoalSummaryCard.tsx"
  "components/dashboard/DailyProgressBanner.tsx"
  "components/dashboard/TaskItem.tsx"
  "components/dashboard/HabitCheckItem.tsx"
  "components/lists/GoalList.tsx"
  "components/lists/TaskList.tsx"
  "components/lists/HabitList.tsx"
  "components/settings/ThemePreview.tsx"
  "components/compass/PrincipleCard.tsx"
  "components/rewards/ConfettiBurst.tsx"
)

for file in "${KEY_COMPONENTS[@]}"; do
  add_file "$file"
done

# 6) Feature Screens
echo "\n\n===========================================================" >> project.txt
echo "# 5️⃣ FEATURE SCREENS" >> project.txt
echo "===========================================================\n" >> project.txt

# Core feature screens
FEATURE_SCREENS=(
  "app/(tabs)/home/index.tsx"
  "app/(tabs)/planner/index.tsx"
  "app/(tabs)/compass/index.tsx"
  "app/(tabs)/rewards/index.tsx"
  "app/(tabs)/settings/index.tsx"
)

for file in "${FEATURE_SCREENS[@]}"; do
  add_file "$file"
done

# 7) Assets
echo "\n\n===========================================================" >> project.txt
echo "# 7️⃣ ASSETS" >> project.txt
echo "===========================================================\n" >> project.txt

# Just list asset directories
echo "Font Files in assets/fonts:" >> project.txt
ls -la assets/fonts 2>/dev/null >> project.txt || echo "No font directory found" >> project.txt

echo "\nLottie Files in assets:" >> project.txt
find assets -name "*.json" 2>/dev/null | sort >> project.txt || echo "No Lottie files found" >> project.txt

echo "\nSVG Files in assets:" >> project.txt
find assets -name "*.svg" 2>/dev/null | sort >> project.txt || echo "No SVG files found" >> project.txt

echo "\nAll project context has been collected in project.txt"

  ```

- **gather_tamagui_styles.sh** (2.2 KB, 68 lines) *(No explicit exports)*

  ```sh
#!/bin/bash

# Create or truncate the project.txt file
echo "# Aether iPhone Project Context for Tamagui to Gluestack/NativeWind Migration" > project.txt
echo "Generated on $(date)" >> project.txt
echo "\n## Migration Overview" >> project.txt
echo "Current: Tamagui-based design system" >> project.txt
echo "Target: Gluestack UI + NativeWind" >> project.txt
echo "" >> project.txt

# Function to add a file to the project.txt
add_file() {
  local filename=$1
  
  if [ -f "$filename" ]; then
    echo "\n\n===========================================================" >> project.txt
    echo "# FILE: $filename" >> project.txt
    echo "===========================================================\n" >> project.txt
    cat "$filename" >> project.txt
    echo "Added $filename to project.txt"
  else
    echo "Warning: File $filename not found"
  fi
}

# Add main Tamagui configuration files
add_file "tamagui.config.ts"
add_file ".tamagui/tamagui.config.json"
add_file "app/_layout.tsx"

# Process all component directories
echo "\n\n===========================================================" >> project.txt
echo "# ALL COMPONENTS" >> project.txt
echo "===========================================================\n" >> project.txt

# Find all component files
find components -name "*.tsx" -type f | while read file; do
  add_file "$file"
done

# Process all app screens
echo "\n\n===========================================================" >> project.txt
echo "# APP SCREENS" >> project.txt
echo "===========================================================\n" >> project.txt

# Find all app screen files
find app -name "*.tsx" -type f | grep -v "_layout.tsx" | while read file; do
  add_file "$file"
done

# Add constants and utils
echo "\n\n===========================================================" >> project.txt
echo "# CONSTANTS AND UTILS" >> project.txt
echo "===========================================================\n" >> project.txt

# List of styling utility files
STYLING_FILES=(
  "constants/motion.ts"
  "constants/theme.ts"
  "utils/themes.ts"
  "utils/styleUtils.ts"
)

for file in "${STYLING_FILES[@]}"; do
  add_file "$file"
done

echo "\nAll styling-related files have been collected in project.txt"
  ```

- **global.css** (0.1 KB, 4 lines) *(No explicit exports)*

  ```css
@tailwind base;
@tailwind components;
@tailwind utilities;

  ```

- **implementation_details.txt** (634.7 KB, 18588 lines) *(No explicit exports)*

  ```txt
# Aether iPhone: Implementation Details for Migration Questions
Generated on Wed Apr 30 00:55:52 CDT 2025

\n\n# 1️⃣ tRPC Router Names & Procedure Signatures
\n## Router Definitions
\n\n## Router: dashboardRouter
**File:** server/src/routers/dashboardRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';

// Define fields for consistent selection - align with Zod schemas & table structure
const HABIT_FIELDS = 'id, user_id, name, description, habit_type, goal_quantity, goal_units, frequency_type, frequency_details, reminder_id, streak, best_streak, sort_order, created_at, updated_at'; // Added reminder_id
const GOAL_FIELDS = 'id, user_id, name, description, priority, status, target_date, sort_order, created_at, updated_at'; // Use target_date
const TASK_FIELDS = 'id, user_id, name, notes, status, priority, due_date, reminder_id, goal_id, sort_order, created_at, updated_at'; // Use due_date, reminder_id
const HABIT_ENTRY_FIELDS = 'id, habit_id, user_id, date, quantity_value, notes, created_at';
const TRACKED_STATE_DEF_FIELDS = 'id, user_id, name, description, data_type, unit, sort_order, active, notes, created_at, updated_at'; // Adjusted based on potential schema changes

export const dashboardRouter = router({
  getDashboardData: protectedProcedure
    .input(
      z.object({
        habitLimit: z.number().min(1).default(5),
        goalLimit: z.number().min(1).default(5),
        taskLimit: z.number().min(1).default(10)
      }).optional()
    )
    .query(async ({ ctx, input }) => {
      try {
        // Get limits from input or use defaults
        const habitLimit = input?.habitLimit || 5;
        const goalLimit = input?.goalLimit || 5;
        const taskLimit = input?.taskLimit || 10;

        // --- Fetch Habits ---
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
          .limit(habitLimit);
        if (habitsError) throw habitsError;

        // --- Fetch Goals ---
        const { data: goals, error: goalsError } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
          .limit(goalLimit);
        if (goalsError) throw goalsError;

        // --- Fetch Upcoming Tasks (focus on upcoming tasks and prioritize those due soon) ---
        const today = new Date();
        const twoWeeksFromNow = new Date();
        twoWeeksFromNow.setDate(today.getDate() + 14);
        
        // We want to fetch tasks that are:
        // 1. Not completed
        // 2. Due within the next two weeks, or overdue
        // 3. Either unassigned or associated with the dashboard goals
        const { data: tasks, error: tasksError } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .neq('status', 'completed') // Use correct enum value
          .or(`due_date.lte.${twoWeeksFromNow.toISOString()},due_date.is.null`)
          .order('due_date', { ascending: true, nullsFirst: false }) // Use 'due_date'
          .limit(taskLimit);
        if (tasksError) throw tasksError;

        // --- Fetch Active Tracked State Definitions ---
        const { data: trackedStateDefinitions, error: statesError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .eq('active', true)
          .order('sort_order', { ascending: true, nullsFirst: false }); // Correct: nullsFirst: false for nulls last
        if (statesError) throw statesError;
        
        // --- Fetch Latest State Entries for Active Definitions ---
        let latestEntriesMap: Record<string, { value: any; created_at: string }> = {};
        const stateDefIds = (trackedStateDefinitions || []).map(s => s.id);

        if (stateDefIds.length > 0) {
          // Use a CTE and ROW_NUMBER() to get the latest entry per state_id
          const { data: latestEntries, error: entriesError } = await ctx.supabaseAdmin.rpc(
            'get_latest_state_entries_for_user', 
            { p_user_id: ctx.userId, p_state_ids: stateDefIds }
          );

          if (entriesError) {
            console.error('Error fetching latest state entries:', entriesError);
            // Decide how to handle this - throw, or continue with empty/default values?
            // For now, log and continue, states will show default value
          } else {
            // Define expected type for entries from RPC
            type LatestEntry = { state_id: string; value: any; created_at: string };
            
            latestEntriesMap = (latestEntries as LatestEntry[] || []).reduce(
              (acc: Record<string, { value: any; created_at: string }>, entry: LatestEntry) => {
              acc[entry.state_id] = { value: entry.value, created_at: entry.created_at };
              return acc;
            }, {} as typeof latestEntriesMap);
          }
        }

        // --- Process Habits for 'completed' flag ---
        const todayStr = new Date().toISOString().split('T')[0];
        const habitIds = (habits || []).map(h => h.id);
        const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id') // Only need habit_id to check existence
          .eq('user_id', ctx.userId)
          .eq('date', todayStr) // Filter by date
          .in('habit_id', habitIds);
        if (todayEntriesError) throw todayEntriesError;

        const completedHabitIds = new Set((habitEntriesToday || []).map(e => e.habit_id));

        const formattedHabits = (habits || []).map(h => ({
          id: h.id,
          name: h.name, // Use name
          description: h.description, // Pass other potentially useful fields
          habit_type: h.habit_type,
          streak: h.streak,
          // Consider a habit completed if *any* entry exists for today
          completed: completedHabitIds.has(h.id)
        }));

        // --- Process Goals for 'progress' ---
        const goalIds = (goals || []).map(g => g.id);
        let tasksMap: Record<string, { total: number; completed: number }> = {};
        if (goalIds.length > 0) {
          const { data: allTasksForGoals, error: tasksError2 } = await ctx.supabaseAdmin
            .from('tasks')
            .select('goal_id, status')
            .eq('user_id', ctx.userId)
            .in('goal_id', goalIds);
          if (tasksError2) throw tasksError2;

          tasksMap = (allTasksForGoals || []).reduce<Record<string, { total: number; completed: number }>>((acc, task) => {
            if (task.goal_id) { // Ensure goal_id is not null
              const gid = task.goal_id;
              if (!acc[gid]) acc[gid] = { total: 0, completed: 0 };
              acc[gid].total++;
              if (task.status === 'completed') acc[gid].completed++;
            }
            return acc;
          }, {});
        }

        const formattedGoals = (goals || []).map((g) => {
          const { total = 0, completed: comp = 0 } = tasksMap[g.id] || {};
          // Calculate progress based on tasks, ignore goal.progress field for now
          const progress = total > 0 ? comp / total : 0;
          return {
            id: g.id,
            title: g.name, // Changed name to title to match frontend expectations
            status: g.status, // Pass status directly
            priority: g.priority, // Pass priority
            progress: Math.round(progress * 100) / 100, // Keep calculated progress
            tasks: { // Add tasks information expected by GoalSummaryCard
              total: total,
              completed: comp
            }
          };
        });

        // --- Format Tasks (Minimal formatting needed if TASK_FIELDS is correct) ---
        const formattedTasks = (tasks || []).map((t) => ({
          id: t.id,
          name: t.name,
          status: t.status,
          priority: t.priority,
          due_date: t.due_date, // Use due_date
          // Add other fields as needed by the dashboard UI
        }));

        // --- Format Tracked States with Latest Values ---
        const formattedTrackedStates = (trackedStateDefinitions || []).map((def) => {
          const latestEntry = latestEntriesMap[def.id];
          return {
            id: def.id,
            name: def.name,
            unit: def.unit, // Use 'unit' field
            currentValue: latestEntry ? latestEntry.value : null, // Default to null
            lastUpdated: latestEntry ? latestEntry.created_at : null,
          };
        });

        // Return formatted data including trackedStates
        return {
          habits: formattedHabits,
          goals: formattedGoals,
          tasks: tasks || [], // Ensure tasks is always an array
          trackedStates: formattedTrackedStates, // Use the newly formatted array
        };
      } catch (error: any) {
        console.error('Dashboard data fetch error:', error);
        
        // Handle specific error types with appropriate error codes
        if (error.code === '42P01') { // Table doesn't exist
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Database schema error',
          });
        }
        
        if (error.code === '23505') { // Unique violation
          throw new TRPCError({
            code: 'CONFLICT',
            message: 'Resource already exists',
          });
        }
        
        // Default error handling
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch dashboard data',
        });
      }
    }),
  
  getWeeklyProgress: protectedProcedure
    .input(z.object({
      daysToInclude: z.number().min(1).optional().default(7),
      includeRawData: z.boolean().optional().default(false),
    }).optional())
    .query(async ({ ctx, input }) => {
      try {
        // Calculate date range based on input or default to past week
        const daysToInclude = input?.daysToInclude || 7;
        const includeRawData = input?.includeRawData || false;
        
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(endDate.getDate() - (daysToInclude - 1));
        
        const todayStr = endDate.toISOString().split('T')[0];
        const startDateStr = startDate.toISOString().split('T')[0];
        
        // Generate array of all dates in the range for daily aggregation
        const dateRange: string[] = [];
        const tempDate = new Date(startDate);
        while (tempDate <= endDate) {
          dateRange.push(tempDate.toISOString().split('T')[0]);
          tempDate.setDate(tempDate.getDate() + 1);
        }
        
        // Fetch habits relevant to the date range (active during any part of the range)
        // Need to consider habits created *before* the end date and not archived *before* the start date
        const HABIT_FIELDS_FOR_PROGRESS = 'id, name, habit_type, frequency_type, frequency_details, created_at, streak, best_streak'; // Add streak fields
        const { data: relevantHabits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS_FOR_PROGRESS)
          .eq('user_id', ctx.userId)
          // Add logic here if needed to filter habits active within the date range
          // e.g., .lt('created_at', endDate.toISOString())
          //       .or(`archived_at.gte.${startDate.toISOString()},archived_at.is.null`)
          ;
        if (habitsError) throw habitsError;

        const relevantHabitIds = (relevantHabits || []).map(h => h.id);

        // Fetch habit entries within the date range for relevant habits
        const { data: habitEntries, error: entriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('id, habit_id, date, completed, quantity_value, notes')
          .eq('user_id', ctx.userId)
          .in('habit_id', relevantHabitIds.length > 0 ? relevantHabitIds : ['dummy-uuid']) // Filter by relevant habits
          .gte('date', startDate.toISOString().split('T')[0])
          .lte('date', endDate.toISOString().split('T')[0])
          .order('date', { ascending: true });
 
        if (entriesError) throw entriesError;

        // Get all tasks completed or due within the date range
        const { data: relevantTasks, error: tasksError } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .or(`due_date.gte.${startDateStr}.and.due_date.lte.${todayStr},status.eq.completed.and.updated_at.gte.${startDateStr}.and.updated_at.lte.${todayStr}`);

        if (tasksError) throw tasksError;
        
        // Get total tasks count for completion rate
        const { count: totalTasks, error: countError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', ctx.userId);
          
        if (countError) throw countError;
        
        // Get goal progress snapshots for the period
        const { data: goalSnapshots, error: goalSnapshotsError } = await ctx.supabaseAdmin
          .from('goal_progress_snapshots') // Assuming we have this table
          .select('goal_id, progress, created_at')
          .eq('user_id', ctx.userId)
          .gte('created_at', startDate.toISOString())
          .lte('created_at', endDate.toISOString())
          .order('created_at', { ascending: true });
          
        if (goalSnapshotsError) throw goalSnapshotsError;

        // -- AGGREGATE DATA BY DAY --
        
        // Create daily habit completion structure
        const habitsByDay: Record<string, { completed: number; total: number; entries: any[]; expected: number }> = {};
        dateRange.forEach(date => {
          habitsByDay[date] = { completed: 0, total: 0, entries: [], expected: 0 };
        });
        
        // Populate completed habits from entries (count existence, not completed flag)
        habitEntries?.forEach((entry: any) => {
          const dateStr = (entry.date as string).split('T')[0];
          if (habitsByDay[dateStr]) {
            // Only count one completion per habit per day
            if (!habitsByDay[dateStr].entries.some((e: any) => e.habit_id === entry.habit_id)) {
              habitsByDay[dateStr].completed++;
            }
            habitsByDay[dateStr].entries.push(entry);
          }
        });
        
        // Create daily task completion structure
        const tasksByDay: Record<string, { completed: number; entries: any[] }> = {};
        dateRange.forEach(date => {
          tasksByDay[date] = { completed: 0, entries: [] };
        });
        
        // Process completed tasks into daily stats
        relevantTasks?.forEach(task => {
          const completedDate = (task.updated_at as string).split('T')[0];
          if (tasksByDay[completedDate]) {
            tasksByDay[completedDate].completed++;
            tasksByDay[completedDate].entries.push(task);
          }
        });
        
        // Calculate expected habits per day based on frequency
        const isHabitExpected = (habit: any, date: string): boolean => {
          const dateObj = new Date(date + 'T00:00:00Z'); // Ensure UTC
          const dayOfWeek = dateObj.getUTCDay(); // 0 = Sunday, 6 = Saturday
          const dayOfMonth = dateObj.getUTCDate();
          const month = dateObj.getUTCMonth(); // 0 = January, 11 = December

          const habitCreatedDate = new Date(habit.created_at);
          if (dateObj < habitCreatedDate) {
            return false; // Cannot be expected before it was created
          }

          switch (habit.frequency_type) {
            case 'daily':
              return true;
            case 'specific_days':
              return Array.isArray(habit.frequency_details?.days) && habit.frequency_details.days.includes(dayOfWeek);
            // TODO: Add logic for 'weekly', 'monthly' etc. as needed
            default:
              return false;
          }
        };
        relevantHabits?.forEach(habit => {
          dateRange.forEach(date => {
            if (isHabitExpected(habit, date)) {
              habitsByDay[date].expected++;
            }
          });
        });
        
        // Format into daily progress reports
        const dailyProgress = dateRange.map(date => {
          const habitStats = habitsByDay[date];
          const taskStats = tasksByDay[date];
          
          const habitCompletionRate = habitStats.expected > 0 
            ? habitStats.completed / habitStats.expected 
            : 0;
            
          return {
            date,
            habits: {
              total: habitStats.total,
              completed: habitStats.completed,
              completionRate: habitCompletionRate,
              expected: habitStats.expected
            },
            tasks: {
              completed: taskStats.completed
            },
            // Optionally include raw entries if requested
            ...(includeRawData ? {
              habitEntries: habitStats.entries,
              completedTasks: taskStats.entries
            } : {})
          };
        });
        
        // Calculate overall metrics
        const totalHabitEntries = Object.values(habitsByDay).reduce(
          (sum, day) => sum + day.total, 0);
        const completedHabitEntries = Object.values(habitsByDay).reduce(
          (sum, day) => sum + day.completed, 0);
        const totalCompletedTasks = Object.values(tasksByDay).reduce(
          (sum, day) => sum + day.completed, 0);
          
        const taskCompletionRate = totalTasks ? totalCompletedTasks / totalTasks : 0;
        const habitConsistency = totalHabitEntries > 0 
          ? completedHabitEntries / totalHabitEntries 
          : 0;
          
        // Calculate habit streaks (could be moved to a separate helper function)
        const habitStreaks = (relevantHabits || []).map(habit => ({
          id: habit.id,
          name: habit.name,
          currentStreak: habit.streak || 0,
          bestStreak: habit.best_streak || 0
        }));
        
        // Prepare goal progress data
        const goalProgress: Record<string, { snapshots: any[]; startProgress?: number; endProgress?: number }> = {};
        
        (goalSnapshots || []).forEach(snapshot => {
          if (!goalProgress[snapshot.goal_id]) {
            goalProgress[snapshot.goal_id] = { snapshots: [] };
          }
          goalProgress[snapshot.goal_id].snapshots.push({
            progress: snapshot.progress,
            date: (snapshot.created_at as string).split('T')[0]
          });
        });
        
        // Calculate start and end progress for each goal
        Object.keys(goalProgress).forEach(goalId => {
          const snapshots = goalProgress[goalId].snapshots;
          if (snapshots.length > 0) {
            // Sort by date
            snapshots.sort((a, b) => a.date.localeCompare(b.date));
            goalProgress[goalId].startProgress = snapshots[0].progress;
            goalProgress[goalId].endProgress = snapshots[snapshots.length - 1].progress;
          }
        });
        
        return {
          dailyProgress,
          overallMetrics: {
            totalHabitEntries,
            completedHabitEntries,
            habitCompletionRate: habitConsistency,
            completedTasksCount: totalCompletedTasks,
            taskCompletionRate,
            // Trend indicators (compared to previous period)
            trends: {
              habitsImproving: true, // Placeholder - would compare to previous period
              tasksImproving: false // Placeholder - would compare to previous period
            }
          },
          habitStreaks,
          goalProgress: Object.entries(goalProgress).map(([goalId, data]) => ({
            goalId,
            progressChange: (data.endProgress || 0) - (data.startProgress || 0),
            currentProgress: data.endProgress || 0
          })),
          dateRange: {
            start: startDateStr,
            end: todayStr,
            days: dateRange
          }
        };
      } catch (error: any) {
        console.error('Weekly progress fetch error:', error);
        
        // Handle specific error types with appropriate error codes
        if (error.code === '42P01') { // Table doesn't exist
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Database schema error',
          });
        }
        
        if (error.code === '22P02') { // Invalid text representation
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Invalid input format',
          });
        }
        
        // Default error handling
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch weekly progress',
        });
      }
    }),
}); ```
\n\n## Router: habitRouter
**File:** server/src/routers/habitRouter.ts
\n```
import { z } from "zod";
import { router, protectedProcedure } from "../router";
import { TRPCError } from "@trpc/server";
import {
  createHabitInput,
  updateHabitInput,
  createHabitEntryInput,
  updateHabitEntryInput,
} from '../types/trpc-types';
import {
  differenceInCalendarDays,
  parseISO,
  format
} from 'date-fns'; // Need date-fns

const HABIT_FIELDS =
  'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, sort_order, streak, best_streak, created_at, updated_at';

const HABIT_ENTRY_FIELDS =
  'id, user_id, habit_id, date, completed, quantity_value, notes, created_at';

async function calculateAndUpdateStreak(habitId: string, userId: string, supabase: any): Promise<{ currentStreak: number, bestStreak: number }> {
  try {
    // Fetch all entries for the habit, ordered by date descending
    const { data: entries, error: entriesError } = await supabase
      .from('habit_entries')
      .select('date, completed') // Only need date and completed status
      .eq('habit_id', habitId)
      .eq('user_id', userId)
      .order('date', { ascending: false });

    if (entriesError) {
      console.error(`Streak Calc Error: Failed to fetch entries for habit ${habitId}:`, entriesError);
      return { currentStreak: 0, bestStreak: 0 }; // Return 0 if entries can't be fetched
    }

    if (!entries || entries.length === 0) {
      // No entries, reset streak
      const { error: updateErr } = await supabase
        .from('habits')
        .update({ streak: 0 })
        .eq('id', habitId);
      if (updateErr) console.error(`Streak Calc Error: Failed to reset streak for habit ${habitId}`, updateErr);
      // Fetch best streak to return it accurately even if current is 0
      const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
      return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 };
    }

    let currentStreak = 0;
    const today = new Date();
    let expectedDate = today; // Start checking from today
    const todayStr = format(today, 'yyyy-MM-dd');
    const todayEntry = entries.find((e: any) => e.date === todayStr);

    // Determine starting point for streak check
    if (todayEntry?.completed) {
      currentStreak = 1;
      expectedDate = new Date(today.setDate(today.getDate() - 1)); // Start checking from yesterday
    } else {
      const yesterday = new Date(); // Need a fresh date object
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayStr = format(yesterday, 'yyyy-MM-dd');
      const yesterdayEntry = entries.find((e: any) => e.date === yesterdayStr);
      if (yesterdayEntry?.completed) {
        currentStreak = 1;
        expectedDate = new Date(yesterday.setDate(yesterday.getDate() - 1)); // Start checking from day before yesterday
      } else {
        currentStreak = 0;
        // No need to loop if streak is already 0 based on today/yesterday
      }
    }

    // Only loop if there's a potential streak > 0
    if (currentStreak > 0) {
      // Find index of the entry *before* the expectedDate (since we check backwards)
      let startIndex = entries.findIndex((e: any) => e.date === format(expectedDate, 'yyyy-MM-dd'));
      // If expected date wasn't found (e.g., yesterday was the start), adjust index
      if (startIndex === -1) {
        // Start from the entry after the one that established the initial streak (today or yesterday)
        const initialStreakDateStr = todayEntry?.completed ? todayStr : (format(new Date(new Date().setDate(new Date().getDate() - 1)), 'yyyy-MM-dd'));
        const initialEntryIndex = entries.findIndex((e: any) => e.date === initialStreakDateStr);
        startIndex = initialEntryIndex !== -1 ? initialEntryIndex + 1 : 0;
      }

      for (let i = startIndex; i < entries.length; i++) {
        const entry = entries[i];
        const entryDate = parseISO(entry.date);
        const expectedDateStr = format(expectedDate, 'yyyy-MM-dd');

        if (entry.date === expectedDateStr) {
          if (entry.completed) {
            currentStreak++;
            expectedDate.setDate(expectedDate.getDate() - 1); // Move to check previous day
          } else {
            break; // Streak broken by uncompleted entry
          }
        } else {
          // Check if the date difference breaks the streak (allowing for gaps)
          const previousDate = i > 0 ? parseISO(entries[i - 1].date) : parseISO(entries[0].date);
          const dateDiff = differenceInCalendarDays(previousDate, entryDate);

          if (dateDiff > 1) {
            break; // Gap too large, streak broken
          }

          // If gap is 1 day, but this entry wasn't completed, streak is broken
          if (!entry.completed) {
            break;
          }

          // If gap is 1 day and completed, it doesn't continue the *current* consecutive sequence
          // but doesn't necessarily break it either (e.g., completed Mon, Wed - streak is 1 from Wed).
          // For simplicity, we break the loop here, assuming the *consecutive* streak from today/yesterday is what matters.
          // A more complex implementation could find the *longest* streak ending recently.
          break;
        }
      }
    }

    // Fetch current best_streak
    const { data: habitData, error: habitFetchError } = await supabase
      .from('habits')
      .select('best_streak')
      .eq('id', habitId)
      .single();

    if (habitFetchError) {
      console.error(`Streak Calc Error: Failed to fetch habit ${habitId} for best_streak:`, habitFetchError);
      // Fallback best streak if fetch fails
      const bestStreakFallback = Math.max(currentStreak, 0); 
      const { error: updateError } = await supabase
        .from('habits')
        .update({ streak: currentStreak, best_streak: bestStreakFallback })
        .eq('id', habitId);
      if (updateError) console.error(`Streak Calc Error: Failed to update streak (fallback) for habit ${habitId}:`, updateError);
      console.log(`Streak Updated (Fallback Best) for habit ${habitId}: Current=${currentStreak}, Best=${bestStreakFallback}`);
      return { currentStreak, bestStreak: bestStreakFallback };
    }

    const bestStreak = Math.max(currentStreak, habitData?.best_streak || 0);

    // Update the habit record
    const { error: updateError } = await supabase
      .from('habits')
      .update({ streak: currentStreak, best_streak: bestStreak })
      .eq('id', habitId);

    if (updateError) {
      console.error(`Streak Calc Error: Failed to update streak for habit ${habitId}:`, updateError);
    }

    console.log(`Streak Updated for habit ${habitId}: Current=${currentStreak}, Best=${bestStreak}`);
    return { currentStreak, bestStreak };

  } catch (error) {
    console.error(`Unexpected error calculating streak for habit ${habitId}:`, error);
    // Attempt to fetch best streak even on error
    const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
    return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 }; // Return 0 current streak on error
  }
}

export const habitRouter = router({
  getHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (habitsError) throw habitsError;
        if (!habits) return [];

        const todayStr = new Date().toISOString().split('T')[0];

        const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id')
          .eq('user_id', ctx.userId)
          .eq('date', todayStr)
          .in('habit_id', habits.map(h => h.id));

        if (todayEntriesError) throw todayEntriesError;

        const completedMap = (habitEntriesToday || []).reduce<Record<string, boolean>>((acc, entry) => {
          acc[entry.habit_id] = true;
          return acc;
        }, {});

        const formattedHabits = habits.map(h => ({
          ...h,
          completedToday: !!completedMap[h.id]
        }));

        return formattedHabits;
      } catch (error: any) {
        throw new TRPCError({ 
          code: 'INTERNAL_SERVER_ERROR', 
          message: error.message || 'Failed to fetch habits'
        });
      }
    }),

  getHabitById: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .select(HABIT_FIELDS)
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (error) throw new TRPCError({ 
        code: error.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: error.message 
      });
      return data;
    }),

  createHabit: protectedProcedure
    .input(createHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .insert({
          ...input,
          user_id: ctx.userId,
          streak: 0,
          best_streak: 0
        })
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  updateHabit: protectedProcedure
    .input(updateHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { id, ...updateData } = input;

      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .update(updateData)
        .eq("id", id)
        .eq('user_id', ctx.userId)
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  deleteHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { error } = await ctx.supabaseAdmin
        .from("habits")
        .delete()
        .eq("id", input.id);

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return { id: input.id };
    }),

  listArchivedHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        return habits || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived habits',
        });
      }
    }),

  archiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to archive habit' });
      }
    }),

  unarchiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to unarchive habit' });
      }
    }),

  getHabitEntries: protectedProcedure
    .input(z.object({
      habitId: z.string().uuid(),
      startDate: z.string().optional(), 
      endDate: z.string().optional(),   
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { error: habitError } = await ctx.supabaseAdmin
          .from("habits")
          .select("id")
          .eq("id", input.habitId)
          .eq("user_id", ctx.userId)
          .single();

        if (habitError) {
          if (habitError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: habitError.message });
        }

        let query = ctx.supabaseAdmin
          .from('habit_entries')
          .select(HABIT_ENTRY_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('habit_id', input.habitId);

        if (input.startDate) query = query.gte('date', input.startDate);
        if (input.endDate) query = query.lte('date', input.endDate);

        const { data, error: entriesError } = await query.order('date', { ascending: false });

        if (entriesError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: entriesError.message });
        return data || [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to fetch habit entries' });
      }
    }),

  getHabitEntriesForHabit: protectedProcedure
    .input(z.object({ habitId: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      // TODO: Implement logic to fetch habit entries for a specific habit
      console.log(`Fetching entries for habit: ${input.habitId}, user: ${ctx.userId}`);
      // Example fetch:
      // const { data, error } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select(HABIT_ENTRY_FIELDS)
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .order('date', { ascending: false });
      // if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      // return data || [];
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),

  createHabitEntry: protectedProcedure
    .input(createHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .insert({ ...input, user_id: ctx.userId })
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });

        // Update streak after successful insert
        if (data) {
          await calculateAndUpdateStreak(input.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create habit entry',
        });
      }
    }),

  updateHabitEntry: protectedProcedure
    .input(updateHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: habitEntry, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) throw new TRPCError({ 
          code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
          message: "Habit entry not found or access denied" 
        });

        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId) // Ensure ownership
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });

        // Update streak after successful update
        if (data) {
          await calculateAndUpdateStreak(data.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update habit entry',
        });
      }
    }),

  deleteHabitEntry: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Fetch habitId *before* deleting the entry
        const { data: entryToDelete, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id') // Fetch habit_id
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !entryToDelete) {
          throw new TRPCError({ 
            code: fetchError?.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Habit entry not found or access denied.' 
          });
        }

        const { habit_id: habitIdForStreak } = entryToDelete; // Store before delete

        // Perform delete
        const { error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId); // Ensure user owns the entry being deleted

        if (error) throw error; // Throw if delete fails

        // Update streak *after* successful delete
        if (habitIdForStreak) { // Check if we got the habitId
          await calculateAndUpdateStreak(habitIdForStreak, ctx.userId, ctx.supabaseAdmin);
        }

        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete habit entry',
        });
      }
    }),

  toggleHabitEntry: protectedProcedure
    .input(z.object({ habitId: z.string().uuid(), date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/) }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Implement logic to find if entry exists for habitId/date/userId.
      // If exists, delete it.
      // If not exists, create it (need default values for boolean/quantity type).
      // Call calculateAndUpdateStreak after create/delete.
      console.log(`Toggling habit entry for habit: ${input.habitId}, date: ${input.date}`);
      // Example logic:
      // const { data: existingEntry, error: findError } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select('id')
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .eq('date', input.date)
      //   .maybeSingle();
      // if (findError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: findError.message });

      // if (existingEntry) {
      //   // Delete existing
      //   const { error: deleteError } = await ctx.supabaseAdmin.from('habit_entries').delete().eq('id', existingEntry.id);
      //   if (deleteError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: deleteError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'deleted', habitId: input.habitId, date: input.date };
      // } else {
      //   // Create new
      //   // Need to know habit type to set default 'completed' or 'quantity_value'
      //   const { data: newEntry, error: createError } = await ctx.supabaseAdmin
      //     .from('habit_entries')
      //     .insert({ habit_id: input.habitId, user_id: ctx.userId, date: input.date, completed: true /* or quantity_value: default */ })
      //     .select(HABIT_ENTRY_FIELDS)
      //     .single();
      //   if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'created', entry: newEntry };
      // }
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),
});```
\n\n## Router: reminderRouter
**File:** server/src/routers/reminderRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createReminderInput,
  updateReminderInput,
  GetRemindersForEntityInput,
  DeleteReminderInput,
} from '../types/trpc-types';

// Define fields for consistent selection
const REMINDER_FIELDS = 'id, user_id, related_entity_type, related_entity_id, reminder_time, message, is_active, created_at, updated_at';

export const reminderRouter = router({
  // Get all active reminders for the user (might need refinement later)
  getActiveReminders: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('is_active', true)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch active reminders',
        });
      }
    }),

  // Get reminders linked to a specific entity
  getRemindersForEntity: protectedProcedure
    .input(GetRemindersForEntityInput)
    .query(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('related_entity_type', input.related_entity_type)
          .eq('related_entity_id', input.related_entity_id)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch reminders for entity',
        });
      }
    }),

  createReminder: protectedProcedure
    .input(createReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // TODO: Potentially validate that related_entity_id exists and belongs to user?
        // This requires knowing the related_entity_type and querying the correct table.
        // For now, assume valid input.
        const { data: reminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return reminder;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create reminder',
        });
      }
    }),

  updateReminder: protectedProcedure
    .input(updateReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { data: updatedReminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return updatedReminder;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update reminder',
        });
      }
    }),

  deleteReminder: protectedProcedure
    .input(DeleteReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('reminders')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete reminder',
        });
      }
    }),
});
```
\n\n## Router: principleRouter
**File:** server/src/routers/principleRouter.ts
\n```
// server/src/routers/principleRouter.ts
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createPrincipleInput, updatePrincipleInput } from '../types/trpc-types'; // These now expect 'title' and 'body'

// Define fields for consistent selection, using 'title' and 'body'
const PRINCIPLE_FIELDS = 'id, user_id, title, body, sort_order, created_at, updated_at';

export const principleRouter = router({
  getPrinciples: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: principles, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principles || []; // Return empty array if null
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principles',
        });
      }
    }),

  getPrincipleById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) {
           if (error.code === 'PGRST116') { // Handle not found specifically
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found' });
           }
           throw error; // Rethrow other errors
        }
        // No need for !principle check if .single() is used and error isn't PGRST116

        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principle',
        });
      }
    }),

  createPrinciple: protectedProcedure
    .input(createPrincipleInput) // This Zod schema now expects 'title' and 'body'
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .insert({
            ...input, // Spread validated input, already contains 'title' and 'body'
            user_id: ctx.userId,
          })
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create principle',
        });
      }
    }),

  updatePrinciple: protectedProcedure
    .input(updatePrincipleInput) // This Zod schema now expects 'title' and 'body' (optional)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
           if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to update it' });
           }
           throw fetchError;
        }

        // Update
        const { data: updatedPrinciple, error } = await ctx.supabaseAdmin
          .from('principles')
          .update(updateData) // updateData contains validated 'title'/'body' if provided
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return updatedPrinciple;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update principle',
        });
      }
    }),

  deletePrinciple: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
            if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to delete it' });
           }
           throw fetchError;
        }

        // Delete
        const { error } = await ctx.supabaseAdmin
          .from('principles')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete principle',
        });
      }
    }),
});```
\n\n## Router: rewardsRouter
**File:** server/src/routers/rewardsRouter.ts
\n```
import { TRPCError } from '@trpc/server';
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { supabaseAdmin } from '../context';

// Corrected relative path
import { claimLootInput, awardBadgeInput } from '../types/trpc-types';

export const rewardsRouter = router({
  // Get all rewards for current user
  getUserRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Select specific fields aligned with our Zod types
        const { data: rewards, error } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('id, user_id, reward_id, earned_at, rewards(id, name, description, emoji, image_url, required_points, type)')
          .eq('user_id', ctx.userId)
          .order('earned_at', { ascending: false });

        if (error) throw error;
        return rewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user rewards',
        });
      }
    }),

  // Get available rewards that can be earned
  getAvailableRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Get all rewards with specific fields
        const { data: allRewards, error: rewardsError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('id, name, description, emoji, image_url, required_points, type, can_earn_multiple')
          .order('required_points', { ascending: true });

        if (rewardsError) throw rewardsError;

        // Get already earned rewards
        const { data: earnedRewards, error: earnedError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('reward_id')
          .eq('user_id', ctx.userId);

        if (earnedError) throw earnedError;

        // Filter out already earned one-time rewards
        const earnedIds = new Set((earnedRewards || []).map(er => er.reward_id));
        const availableRewards = allRewards?.filter(reward => 
          !earnedIds.has(reward.id) || reward.can_earn_multiple);

        return availableRewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch available rewards',
        });
      }
    }),

  // Get user points
  getUserPoints: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: userProfile, error } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (error) throw error;
        return {
          points: userProfile?.points || 0,
          lifetimePoints: userProfile?.lifetime_points || 0,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user points',
        });
      }
    }),

  // Earn a reward if eligible
  earnReward: protectedProcedure
    .input(claimLootInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get the reward details
        const { data: reward, error: rewardError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.rewardId)
          .single();

        if (rewardError || !reward) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Reward not found',
          });
        }

        // Check if user has enough points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        if (userProfile.points < reward.required_points) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Not enough points to earn this reward',
          });
        }

        // If the reward is one-time, check if already earned
        if (!reward.can_earn_multiple) {
          const { data: existingReward, error: existingError } = await ctx.supabaseAdmin
            .from('user_rewards')
            .select('id')
            .eq('user_id', ctx.userId)
            .eq('reward_id', input.rewardId)
            .single();

          if (existingReward) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'You have already earned this one-time reward',
            });
          }
        }

        // Begin transaction
        // 1. Deduct points from user
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: userProfile.points - reward.required_points,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // 2. Add reward to user's earned rewards
        const { data: userReward, error: insertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.rewardId,
            earned_at: new Date().toISOString(),
            points_spent: reward.required_points,
          })
          .select()
          .single();

        if (insertError) {
          // Rollback points if adding reward failed
          await ctx.supabaseAdmin
            .from('profiles')
            .update({
              points: userProfile.points,
            })
            .eq('id', ctx.userId);

          throw insertError;
        }

        return {
          success: true,
          reward: userReward,
          remainingPoints: userProfile.points - reward.required_points,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to earn reward',
        });
      }
    }),

  // Award points to user (e.g., for completing habits, tasks)
  awardPoints: protectedProcedure
    .input(awardBadgeInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get current user points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        // Get badge details
        const { data: badge, error: badgeError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.badgeId)
          .eq('type', 'badge')
          .single();

        if (badgeError || !badge) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Badge not found',
          });
        }

        // Default points to award
        const pointsToAward = 10;
        const currentPoints = userProfile.points || 0;
        const lifetimePoints = userProfile.lifetime_points || 0;
        const newPoints = currentPoints + pointsToAward;
        const newLifetimePoints = lifetimePoints + pointsToAward;

        // Update user points
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: newPoints,
            lifetime_points: newLifetimePoints,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // Record the point transaction
        const { data: pointTransaction, error: transactionError } = await ctx.supabaseAdmin
          .from('point_transactions')
          .insert({
            user_id: ctx.userId,
            points: pointsToAward,
            reason: `Earned badge: ${badge.name}`,
            source_type: 'badge',
            source_id: input.badgeId,
          })
          .select()
          .single();

        if (transactionError) throw transactionError;

        // Add badge to user's earned rewards
        const { data: userBadge, error: badgeInsertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.badgeId,
            reward_type: 'badge',
            earned_at: new Date().toISOString(),
            points_spent: 0, // Badges don't cost points
          })
          .select()
          .single();

        if (badgeInsertError) throw badgeInsertError;

        return {
          success: true,
          previousPoints: currentPoints,
          newPoints,
          pointsAdded: pointsToAward,
          transaction: pointTransaction,
          badge: userBadge,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to award badge',
        });
      }
    }),

  // Get point transaction history
  getPointHistory: protectedProcedure
    .input(z.object({
      limit: z.number().optional().default(20),
      cursor: z.string().optional(), // for pagination
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('point_transactions')
          .select('*')
          .eq('user_id', ctx.userId)
          .order('created_at', { ascending: false })
          .limit(input.limit);
          
        // Handle cursor-based pagination
        if (input.cursor) {
          query = query.lt('created_at', input.cursor);
        }
        
        const { data: transactions, error } = await query;

        if (error) throw error;
        
        // Determine if there are more results
        const lastItem = transactions && transactions.length > 0 
          ? transactions[transactions.length - 1] 
          : null;
          
        return {
          items: transactions || [],
          nextCursor: lastItem?.created_at,
          hasMore: (transactions?.length || 0) === input.limit,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch point history',
        });
      }
    }),
}); ```
\n\n## Router: taskRouter
**File:** server/src/routers/taskRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createTaskInput,
  updateTaskInput,
  updateTaskStatusInput,
  TaskStatusEnum, // Import the enum
  TaskPriorityEnum,
} from '../types/trpc-types';

// Define fields for selection consistency
const TASK_FIELDS =
  'id, user_id, title, notes, status, priority, due_date, goal_id, parent_task_id, recurrence_rule, recurrence_end_date, archived_at, sort_order, created_at, updated_at'; // Corrected: 'priority' instead of 'priority_enum' if that's the actual column name after migration
const GOAL_FIELDS = 'id, user_id, title, description, progress, target_date, archived_at, sort_order, created_at, updated_at';


// --- Helper function to update goal progress ---
async function updateGoalProgress(goalId: string, userId: string, supabase: any) {
  try {
    // 1. Fetch all non-archived tasks for the goal
    const { data: tasks, error: tasksError } = await supabase
      .from('tasks')
      .select('id, status') // Only need id and status
      .eq('goal_id', goalId)
      .eq('user_id', userId)
      .is('archived_at', null); // Exclude archived tasks

    if (tasksError) {
      console.error(`Error fetching tasks for goal ${goalId} during progress update:`, tasksError);
      // Decide how to handle this - maybe just log and skip update?
      return; // Exit if tasks can't be fetched
    }

    const totalTasks = tasks?.length || 0;
    const completedTasks = tasks?.filter((t: { status: string }) => t.status === TaskStatusEnum.enum.done).length || 0;

    // 2. Calculate progress (avoid division by zero)
    const newProgress = totalTasks > 0 ? completedTasks / totalTasks : 0;
    // Ensure progress is between 0 and 1, rounded to avoid floating point issues
    const clampedProgress = Math.round(Math.min(1, Math.max(0, newProgress)) * 100) / 100;

    // 3. Update the goal record
    const { error: updateError } = await supabase
      .from('goals')
      .update({ progress: clampedProgress })
      .eq('id', goalId)
      .eq('user_id', userId); // Ensure user owns the goal

    if (updateError) {
      console.error(`Error updating progress for goal ${goalId}:`, updateError);
      // Log error but don't necessarily throw, task toggle was successful
    } else {
        console.log(`Updated progress for goal ${goalId} to ${clampedProgress}`);
    }

  } catch (err) {
    console.error(`Unexpected error during goal progress update for goal ${goalId}:`, err);
    // Log unexpected errors
  }
}

export const taskRouter = router({
  getTasks: protectedProcedure // Gets non-archived tasks
    .input(z.object({
      goalId: z.string().uuid().optional(),
      // TODO: Add filters for status, priority, dates etc.?
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null); // Filter out archived

        if (input.goalId) {
          query = query.eq('goal_id', input.goalId);
        }

        // TODO: Add complex priority enum sorting? (e.g. high > medium > low)
        const { data: tasks, error } = await query
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('due_date', { ascending: true, nullsFirst: false }) // Order by due date (nulls last)
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tasks',
        });
      }
    }),

  getTaskById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(), // Use uuid validation
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!task) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found',
          });
        }

        // TODO: Parse with Task schema?
        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch task',
        });
      }
    }),

  createTask: protectedProcedure
    .input(createTaskInput) // Use imported input type
    .mutation(async ({ ctx, input }) => {
      try {
        // Verify goal_id if provided
        if (input.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', input.goal_id)
            .eq('user_id', ctx.userId) // Ensure goal belongs to user
            .is('archived_at', null) // Ensure goal is not archived
            .single();

          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived goal ID',
            });
          }
        }

        // Verify parent_task_id if provided
        if (input.parent_task_id) {
          const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
            .from('tasks')
            .select('id')
            .eq('id', input.parent_task_id)
            .eq('user_id', ctx.userId) // Ensure parent belongs to user
            .is('archived_at', null) // Ensure parent is not archived
            .single();

          if (parentError || !parentTask) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived parent task ID',
            });
          }
        }

        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .insert({
            ...input, // Spread validated input (includes new fields like parent_task_id, recurrence etc)
            user_id: ctx.userId,
            // Ensure due_date is used if present in input
            due_date: input.due_date ?? null, // Use correct field name
          })
          .select(TASK_FIELDS)
          .single();

        if (error) {
           // Handle specific errors like FK violations?
           console.error("Create task error:", error);
           throw error;
        }
        // TODO: Parse with Task schema?
        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create task',
        });
      }
    }),

  updateTask: protectedProcedure
    .input(updateTaskInput) // Use imported input type
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input; // Separate id from update payload

        // Check ownership
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id, parent_task_id') // Select parent_task_id for cycle check
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to update it',
          });
        }

        // Verify goal_id if being updated
        if (updateData.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', updateData.goal_id)
            .eq('user_id', ctx.userId)
            .is('archived_at', null)
            .single();

          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived goal ID',
            });
          }
        }
        // Handle setting goal_id to null
        if (updateData.goal_id === null) {
          updateData.goal_id = null;
        }

        // Verify parent_task_id if being updated
        if (updateData.parent_task_id) {
           // Basic cycle check
           if (updateData.parent_task_id === id) {
             throw new TRPCError({
               code: 'BAD_REQUEST',
               message: 'Task cannot be its own parent',
             });
           }
          const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
            .from('tasks')
            .select('id')
            .eq('id', updateData.parent_task_id)
            .eq('user_id', ctx.userId)
            .is('archived_at', null)
            .single();

          if (parentError || !parentTask) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived parent task ID',
            });
          }
          // TODO: Add deeper cycle detection if needed (check if new parent is a descendant)
        }
         // Handle setting parent_task_id to null
        if (updateData.parent_task_id === null) {
          updateData.parent_task_id = null;
        }

        // Ensure correct field name for due date if provided
        const payload: Record<string, any> = { ...updateData };
        if ('due_date' in payload) {
          payload.due_date = payload.due_date ?? null;
        }

        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update(payload) // Pass validated update data
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
             // Handle specific errors like FK violations?
           console.error("Update task error:", error);
           throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update task',
        });
      }
    }),

  deleteTask: protectedProcedure
    .input(z.object({
      id: z.string().uuid(), // Use uuid validation
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to delete it',
          });
        }

        // Delete the task (consider implications for subtasks - maybe archive instead?)
        // For now, direct delete.
        const { error } = await ctx.supabaseAdmin
          .from('tasks')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete task',
        });
      }
    }),

  // ---- Archive/Unarchive ----
  listArchivedTasks: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: tasks, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null) // Filter for archived tasks
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived tasks',
        });
      }
    }),

  archiveTask: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Consider archiving subtasks recursively?
      try {
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Task not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive task',
        });
      }
    }),

  unarchiveTask: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
       // TODO: Consider check if parent is archived?
      try {
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Task not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive task',
        });
      }
    }),

  // ---- Status Update ----
  updateTaskStatus: protectedProcedure
    .input(updateTaskStatusInput) // Uses { id: string().uuid(), status: TaskStatusEnum }
    .mutation(async ({ ctx, input }) => {
       try {
         // Check ownership first
         const { data: existing, error: fetchErr } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

         if (fetchErr || !existing) {
           throw new TRPCError({ code: 'NOT_FOUND', message: 'Task not found or permission denied.' });
         }

         // Perform update
         const { data: updatedTask, error: updateErr } = await ctx.supabaseAdmin
           .from('tasks')
           .update({ status: input.status })
           .eq('id', input.id)
           .select(TASK_FIELDS)
           .single();

         if (updateErr) throw updateErr;
         // TODO: Parse with Task schema?
         return updatedTask;
       } catch (error: any) {
         if (error instanceof TRPCError) throw error;
         throw new TRPCError({
           code: 'INTERNAL_SERVER_ERROR',
           message: error.message || 'Failed to update task status',
         });
       }
    }),

  // ---- Refactored Stubs ----
  listToday: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const todayStart = new Date();
        todayStart.setHours(0, 0, 0, 0);
        const todayEnd = new Date();
        todayEnd.setHours(23, 59, 59, 999);

        const { data: tasks, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .gte('due_date', todayStart.toISOString())
          .lte('due_date', todayEnd.toISOString())
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('due_date', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list tasks for today' });
      }
    }),

  listUpcoming: protectedProcedure
    .query(async ({ ctx }) => {
       try {
         const tomorrowStart = new Date();
         tomorrowStart.setDate(tomorrowStart.getDate() + 1);
         tomorrowStart.setHours(0, 0, 0, 0);

         const { data: tasks, error } = await ctx.supabaseAdmin
           .from('tasks')
           .select(TASK_FIELDS)
           .eq('user_id', ctx.userId)
           .is('archived_at', null)
           .gte('due_date', tomorrowStart.toISOString()) // Due date is tomorrow or later
           .order('due_date', { ascending: true, nullsFirst: false })
           .order('sort_order', { ascending: true, nullsFirst: false })
           .order('created_at', { ascending: false });

         if (error) throw error;
         // TODO: Parse with Task schema?
         return tasks || [];
       } catch (error: any) {
         throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list upcoming tasks' });
       }
    }),

 listOverdue: protectedProcedure
    .query(async ({ ctx }) => {
       try {
         const todayStart = new Date();
         todayStart.setHours(0, 0, 0, 0);

         const { data: tasks, error } = await ctx.supabaseAdmin
           .from('tasks')
           .select(TASK_FIELDS)
           .eq('user_id', ctx.userId)
           .is('archived_at', null)
           .lt('due_date', todayStart.toISOString()) // Due date is before today
           .not('status', 'in', `('${TaskStatusEnum.enum.done}')`) // Exclude completed tasks
           .order('due_date', { ascending: true, nullsFirst: false })
           .order('sort_order', { ascending: true, nullsFirst: false })
           .order('created_at', { ascending: false });

         if (error) throw error;
         // TODO: Parse with Task schema?
         return tasks || [];
       } catch (error: any) {
         throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list overdue tasks' });
       }
    }),

  toggleTask: protectedProcedure // Toggles between 'todo' and 'done'
    .input(z.object({
      taskId: z.string().uuid(),
      completed: z.boolean().optional() // Optional for backward compatibility
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // 1. Fetch the current task, including goal_id
        const { data: currentTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id, status, goal_id, title') // <-- Include goal_id and title
          .eq('id', input.taskId)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !currentTask) {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Task not found or permission denied.' });
        }

        // 2. Determine the new status
        let newStatus;
        if (input.completed !== undefined) {
          // If completed was explicitly provided, use it
          newStatus = input.completed ? TaskStatusEnum.enum.done : TaskStatusEnum.enum.todo;
        } else {
          // Otherwise toggle the current status
          newStatus = currentTask.status === TaskStatusEnum.enum.done
            ? TaskStatusEnum.enum.todo
            : TaskStatusEnum.enum.done;
        }

        // 3. Update the task status
        const { data: updatedTask, error: updateError } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ status: newStatus })
          .eq('id', input.taskId)
          .select(TASK_FIELDS) // Return the full updated task
          .single();

        if (updateError) throw updateError;

        // 4. *** NEW: Update goal progress if applicable ***
        if (currentTask.goal_id) {
           // Call the helper function asynchronously - no need to await here
           // unless the UI needs the updated goal immediately (unlikely for a toggle)
          updateGoalProgress(currentTask.goal_id, ctx.userId, ctx.supabaseAdmin);
        }

        // 5. Return the updated task
        return updatedTask;

      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        console.error("Error in toggleTask:", error); // Log unexpected errors
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to toggle task status',
        });
      }
    }),

  // --- Obsolete Stubs (keep or remove based on client usage) ---
  /*
  getTasksByGoal: protectedProcedure ... // Covered by getTasks with goalId filter
  getTodaysTasks: protectedProcedure ... // Replaced by listToday
  getUpcomingTasks: protectedProcedure ... // Replaced by listUpcoming
  updateTaskStatus_OLD: protectedProcedure ... // Replaced by updateTaskStatus and toggleTask
  */

});```
\n\n## Router: valueRouter
**File:** server/src/routers/valueRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createValueInput, updateValueInput } from '../types/trpc-types';

export const valueRouter = router({
  getValues: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: values, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return values;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch values',
        });
      }
    }),

  getValueById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!value) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found',
          });
        }

        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch value',
        });
      }
    }),

  createValue: protectedProcedure
    .input(createValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create value',
        });
      }
    }),

  updateValue: protectedProcedure
    .input(updateValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // First check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to update it',
          });
        }

        // Update the value
        const { data: updatedValue, error } = await ctx.supabaseAdmin
          .from('values')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return updatedValue;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update value',
        });
      }
    }),

  deleteValue: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to delete it',
          });
        }

        // Delete the value
        const { error } = await ctx.supabaseAdmin
          .from('values')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete value',
        });
      }
    }),
});```
\n\n## Router: goalRouter
**File:** server/src/routers/goalRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createGoalInput, updateGoalInput } from '../types/trpc-types';

const GOAL_FIELDS = 'id, user_id, title, description, progress, target_date, archived_at, sort_order, created_at, updated_at';

export const goalRouter = router({
  getGoals: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;

        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals',
        });
      }
    }),

  getGoalById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!goal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found',
          });
        }

        return goal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal',
        });
      }
    }),

  createGoal: protectedProcedure
    .input(createGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return goal;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal',
        });
      }
    }),

  updateGoal: protectedProcedure
    .input(updateGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to update it',
          });
        }

        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal',
        });
      }
    }),

  deleteGoal: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to delete it',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goals')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal',
        });
      }
    }),

  listActive: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals (in listActive stub)',
        });
      }
    }),

  listArchived: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived goals',
        });
      }
    }),

  archiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') { 
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive goal',
        });
      }
    }),

  unarchiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive goal',
        });
      }
    }),
});```
\n\n## Router: goalProgressNoteRouter
**File:** server/src/routers/goalProgressNoteRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createGoalProgressNoteInput,
  updateGoalProgressNoteInput,
  GetGoalProgressNotesInput,
  DeleteGoalProgressNoteInput,
} from '../types/trpc-types';

// Define fields for consistent selection
const GOAL_PROGRESS_NOTE_FIELDS = 'id, goal_id, user_id, note, created_at';

export const goalProgressNoteRouter = router({
  // Get all notes for a specific goal
  getNotesForGoal: protectedProcedure
    .input(GetGoalProgressNotesInput)
    .query(async ({ ctx, input }) => {
      try {
        // First, ensure the goal exists and belongs to the user
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        // Fetch the notes for that goal
        const { data, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .eq('user_id', ctx.userId) // Redundant check, but good practice
          .eq('goal_id', input.goal_id)
          .order('created_at', { ascending: false }); // Newest first

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal progress notes',
        });
      }
    }),

  createNote: protectedProcedure
    .input(createGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Ensure the goal exists and belongs to the user before adding a note
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        const { data: note, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return note;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal progress note',
        });
      }
    }),

  updateNote: protectedProcedure
    .input(updateGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership of the note
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { data: updatedNote, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return updatedNote;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal progress note',
        });
      }
    }),

  deleteNote: protectedProcedure
    .input(DeleteGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal progress note',
        });
      }
    }),
});
```
\n\n## Router: trackedStateRouter
**File:** server/src/routers/trackedStateRouter.ts
\n```
// File: server/src/routers/trackedStateRouter.ts

import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  // Ensure all necessary input types from trpc-types are imported
  createTrackedStateDefInput,
  updateTrackedStateDefInput,
  GetTrackedStateDefByIdInput,
  DeleteTrackedStateDefInput,
  CreateStateEntryInput,      // <--- Import for createEntry
  updateStateEntryInput,      // <--- Import for updateEntry
  GetStateEntriesInput,       // <--- Import for getEntries
  DeleteStateEntryInput       // <--- Import for deleteEntry
} from '../types/trpc-types';

// Use correct field names from database.types.ts & trpc-types.ts
const TRACKED_STATE_DEF_FIELDS = 'id, user_id, name, description, scale, custom_labels, unit, icon, target_min_value, target_max_value, created_at, updated_at, active, priority';
const STATE_ENTRY_FIELDS = 'id, user_id, definition_id, value_numeric, value_text, entry_timestamp, notes';

export const trackedStateRouter = router({
  getDefinitions: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('active', true)
          .order('priority', { ascending: true, nullsFirst: false }) // Corrected: nullsFirst
          .order('created_at', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tracked state definitions',
        });
      }
    }),

  getDefinitionById: protectedProcedure
    .input(GetTrackedStateDefByIdInput) // Use correct Zod schema
    .query(async ({ ctx, input }) => {
       try {
        const { data: definition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS)
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Tracked state definition not found.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return definition;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tracked state definition',
        });
      }
    }),

  createDefinition: protectedProcedure
    .input(createTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { data: definition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .insert({
            ...input, // input is now correctly typed
            user_id: ctx.userId,
          })
          .select(TRACKED_STATE_DEF_FIELDS)
          .single();

        if (error) throw error;
        return definition;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create tracked state definition',
        });
      }
    }),

  updateDefinition: protectedProcedure
    .input(updateTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { id, ...updateData } = input; // input is now correctly typed

        const { error: fetchError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Definition not found or access denied.',
          });
        }

        const { data: updatedDefinition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(TRACKED_STATE_DEF_FIELDS)
          .single();

        if (error) throw error;
        return updatedDefinition;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update tracked state definition',
        });
      }
    }),

  deleteDefinition: protectedProcedure
    .input(DeleteTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Definition not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .delete()
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id }; // input.id is now correctly typed
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete tracked state definition',
        });
      }
    }),

  // --- State Entry Procedures ---

  getEntries: protectedProcedure
    .input(GetStateEntriesInput) // <<<--- ADDED .input() BINDING
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('state_entries')
          .select(STATE_ENTRY_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('definition_id', input.tracked_state_def_id); // input is now typed

        if (input.startDate) { // input is now typed
          query = query.gte('entry_timestamp', input.startDate);
        }
        if (input.endDate) { // input is now typed
          query = query.lte('entry_timestamp', input.endDate);
        }

        query = query.order('entry_timestamp', { ascending: false });

        if (input.limit) { // input is now typed
          query = query.limit(input.limit);
        }

        const { data: entries, error } = await query;

        if (error) throw error;
        return entries ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch state entries',
        });
      }
    }),

  createEntry: protectedProcedure
    .input(CreateStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
      try {
        // Check definition ownership (already implemented correctly)
        const { error: defError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', input.tracked_state_def_id) // input is now typed
          .eq('user_id', ctx.userId)
          .single();

        if (defError) {
          throw new TRPCError({
            code: defError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Tracked state definition not found or invalid.',
          });
        }

        // Insert typed data
        const { data: entry, error } = await ctx.supabaseAdmin
          .from('state_entries')
          .insert({
            user_id: ctx.userId,
            definition_id: input.tracked_state_def_id, // input is now typed
            value_numeric: input.value_numeric,     // input is now typed
            value_text: input.value_text,         // input is now typed
            entry_timestamp: input.entry_timestamp || new Date().toISOString(), // input is now typed
            notes: input.notes,                 // input is now typed
          })
          .select(STATE_ENTRY_FIELDS)
          .single();

        if (error) throw error;
        return entry;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create state entry',
        });
      }
    }),

  updateEntry: protectedProcedure
    .input(updateStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input; // input is now typed

        // Check ownership (already implemented correctly)
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('state_entries')
          .select('id')
          .eq('id', id) // Use id from destructured input
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Entry not found or access denied.',
          });
        }

        // updateData is now correctly typed from the input schema
        const { data: updatedEntry, error } = await ctx.supabaseAdmin
          .from('state_entries')
          .update(updateData)
          .eq('id', id) // Use id from destructured input
          .eq('user_id', ctx.userId)
          .select(STATE_ENTRY_FIELDS)
          .single();

        if (error) throw error;
        return updatedEntry;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update state entry',
        });
      }
    }),

  deleteEntry: protectedProcedure
    .input(DeleteStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
       try {
        // Check ownership (already implemented correctly)
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('state_entries')
          .select('id')
          .eq('id', input.id) // input is now typed
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Entry not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('state_entries')
          .delete()
          .eq('id', input.id) // input is now typed
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id }; // input is now typed
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete state entry',
        });
      }
    }),
});```
\n\n## Router: userRouter
**File:** server/src/routers/userRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure, publicProcedure } from '../router';
import { TRPCError } from '@trpc/server';

export const userRouter = router({
  getProfile: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('id, username, avatar_url, full_name, bio, time_zone, onboarding_completed, created_at, updated_at')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  updateProfile: protectedProcedure
    .input(z.object({
      full_name: z.string().optional(),
      avatar_url: z.string().optional(),
      theme: z.string().optional(),
      time_zone: z.string().optional(),
      display_name: z.string().optional(),
      bio: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update(input)
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getUserSettings: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('id, user_id, notification_preferences, ui_preferences')
        .eq('user_id', ctx.userId)
        .single();
        
      if (error) {
        // If settings don't exist, create default settings
        if (error.code === 'PGRST116') {
          const { data: newSettings, error: createError } = await ctx.supabaseAdmin
            .from('user_settings')
            .insert({
              user_id: ctx.userId,
              notification_preferences: {
                email: true,
                push: true,
                task_reminders: true,
                goal_updates: true,
                habit_reminders: true
              },
              ui_preferences: {
                theme: 'system',
                compact_view: false,
                show_completed_tasks: true
              }
            })
            .select()
            .single();
            
          if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
          return newSettings;
        }
        
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      }
      
      return data;
    }),
    
  updateUserSettings: protectedProcedure
    .input(z.object({
      notification_preferences: z.object({
        email: z.boolean().optional(),
        push: z.boolean().optional(),
        task_reminders: z.boolean().optional(),
        goal_updates: z.boolean().optional(),
        habit_reminders: z.boolean().optional()
      }).optional(),
      ui_preferences: z.object({
        theme: z.string().optional(),
        compact_view: z.boolean().optional(),
        show_completed_tasks: z.boolean().optional()
      }).optional()
    }))
    .mutation(async ({ ctx, input }) => {
      // First check if settings exist
      const { data: existingSettings, error: fetchError } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('id')
        .eq('user_id', ctx.userId)
        .single();
        
      if (fetchError && fetchError.code === 'PGRST116') {
        // Create settings if they don't exist
        const defaultSettings = {
          user_id: ctx.userId,
          notification_preferences: {
            email: true,
            push: true,
            task_reminders: true,
            goal_updates: true,
            habit_reminders: true,
            ...input.notification_preferences
          },
          ui_preferences: {
            theme: 'system',
            compact_view: false,
            show_completed_tasks: true,
            ...input.ui_preferences
          }
        };
        
        const { data, error } = await ctx.supabaseAdmin
          .from('user_settings')
          .insert(defaultSettings)
          .select()
          .single();
          
        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        return data;
      } else if (fetchError) {
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: fetchError.message });
      }
      
      // Update existing settings
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .update(input)
        .eq('user_id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getOnboardingStatus: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('id, onboarding_completed')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { onboardingCompleted: data?.onboarding_completed || false };
    }),
    
  completeOnboarding: protectedProcedure
    .mutation(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update({ onboarding_completed: true })
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { success: true };
    }),
}); ```
\n## Router Import/Export Structure
\n\n## Main App Router
**File not found:** server/src/routers/index.ts
\n\n## Dashboard Router
**File:** server/src/routers/dashboardRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';

// Define fields for consistent selection - align with Zod schemas & table structure
const HABIT_FIELDS = 'id, user_id, name, description, habit_type, goal_quantity, goal_units, frequency_type, frequency_details, reminder_id, streak, best_streak, sort_order, created_at, updated_at'; // Added reminder_id
const GOAL_FIELDS = 'id, user_id, name, description, priority, status, target_date, sort_order, created_at, updated_at'; // Use target_date
const TASK_FIELDS = 'id, user_id, name, notes, status, priority, due_date, reminder_id, goal_id, sort_order, created_at, updated_at'; // Use due_date, reminder_id
const HABIT_ENTRY_FIELDS = 'id, habit_id, user_id, date, quantity_value, notes, created_at';
const TRACKED_STATE_DEF_FIELDS = 'id, user_id, name, description, data_type, unit, sort_order, active, notes, created_at, updated_at'; // Adjusted based on potential schema changes

export const dashboardRouter = router({
  getDashboardData: protectedProcedure
    .input(
      z.object({
        habitLimit: z.number().min(1).default(5),
        goalLimit: z.number().min(1).default(5),
        taskLimit: z.number().min(1).default(10)
      }).optional()
    )
    .query(async ({ ctx, input }) => {
      try {
        // Get limits from input or use defaults
        const habitLimit = input?.habitLimit || 5;
        const goalLimit = input?.goalLimit || 5;
        const taskLimit = input?.taskLimit || 10;

        // --- Fetch Habits ---
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
          .limit(habitLimit);
        if (habitsError) throw habitsError;

        // --- Fetch Goals ---
        const { data: goals, error: goalsError } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
          .limit(goalLimit);
        if (goalsError) throw goalsError;

        // --- Fetch Upcoming Tasks (focus on upcoming tasks and prioritize those due soon) ---
        const today = new Date();
        const twoWeeksFromNow = new Date();
        twoWeeksFromNow.setDate(today.getDate() + 14);
        
        // We want to fetch tasks that are:
        // 1. Not completed
        // 2. Due within the next two weeks, or overdue
        // 3. Either unassigned or associated with the dashboard goals
        const { data: tasks, error: tasksError } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .neq('status', 'completed') // Use correct enum value
          .or(`due_date.lte.${twoWeeksFromNow.toISOString()},due_date.is.null`)
          .order('due_date', { ascending: true, nullsFirst: false }) // Use 'due_date'
          .limit(taskLimit);
        if (tasksError) throw tasksError;

        // --- Fetch Active Tracked State Definitions ---
        const { data: trackedStateDefinitions, error: statesError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .eq('active', true)
          .order('sort_order', { ascending: true, nullsFirst: false }); // Correct: nullsFirst: false for nulls last
        if (statesError) throw statesError;
        
        // --- Fetch Latest State Entries for Active Definitions ---
        let latestEntriesMap: Record<string, { value: any; created_at: string }> = {};
        const stateDefIds = (trackedStateDefinitions || []).map(s => s.id);

        if (stateDefIds.length > 0) {
          // Use a CTE and ROW_NUMBER() to get the latest entry per state_id
          const { data: latestEntries, error: entriesError } = await ctx.supabaseAdmin.rpc(
            'get_latest_state_entries_for_user', 
            { p_user_id: ctx.userId, p_state_ids: stateDefIds }
          );

          if (entriesError) {
            console.error('Error fetching latest state entries:', entriesError);
            // Decide how to handle this - throw, or continue with empty/default values?
            // For now, log and continue, states will show default value
          } else {
            // Define expected type for entries from RPC
            type LatestEntry = { state_id: string; value: any; created_at: string };
            
            latestEntriesMap = (latestEntries as LatestEntry[] || []).reduce(
              (acc: Record<string, { value: any; created_at: string }>, entry: LatestEntry) => {
              acc[entry.state_id] = { value: entry.value, created_at: entry.created_at };
              return acc;
            }, {} as typeof latestEntriesMap);
          }
        }

        // --- Process Habits for 'completed' flag ---
        const todayStr = new Date().toISOString().split('T')[0];
        const habitIds = (habits || []).map(h => h.id);
        const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id') // Only need habit_id to check existence
          .eq('user_id', ctx.userId)
          .eq('date', todayStr) // Filter by date
          .in('habit_id', habitIds);
        if (todayEntriesError) throw todayEntriesError;

        const completedHabitIds = new Set((habitEntriesToday || []).map(e => e.habit_id));

        const formattedHabits = (habits || []).map(h => ({
          id: h.id,
          name: h.name, // Use name
          description: h.description, // Pass other potentially useful fields
          habit_type: h.habit_type,
          streak: h.streak,
          // Consider a habit completed if *any* entry exists for today
          completed: completedHabitIds.has(h.id)
        }));

        // --- Process Goals for 'progress' ---
        const goalIds = (goals || []).map(g => g.id);
        let tasksMap: Record<string, { total: number; completed: number }> = {};
        if (goalIds.length > 0) {
          const { data: allTasksForGoals, error: tasksError2 } = await ctx.supabaseAdmin
            .from('tasks')
            .select('goal_id, status')
            .eq('user_id', ctx.userId)
            .in('goal_id', goalIds);
          if (tasksError2) throw tasksError2;

          tasksMap = (allTasksForGoals || []).reduce<Record<string, { total: number; completed: number }>>((acc, task) => {
            if (task.goal_id) { // Ensure goal_id is not null
              const gid = task.goal_id;
              if (!acc[gid]) acc[gid] = { total: 0, completed: 0 };
              acc[gid].total++;
              if (task.status === 'completed') acc[gid].completed++;
            }
            return acc;
          }, {});
        }

        const formattedGoals = (goals || []).map((g) => {
          const { total = 0, completed: comp = 0 } = tasksMap[g.id] || {};
          // Calculate progress based on tasks, ignore goal.progress field for now
          const progress = total > 0 ? comp / total : 0;
          return {
            id: g.id,
            title: g.name, // Changed name to title to match frontend expectations
            status: g.status, // Pass status directly
            priority: g.priority, // Pass priority
            progress: Math.round(progress * 100) / 100, // Keep calculated progress
            tasks: { // Add tasks information expected by GoalSummaryCard
              total: total,
              completed: comp
            }
          };
        });

        // --- Format Tasks (Minimal formatting needed if TASK_FIELDS is correct) ---
        const formattedTasks = (tasks || []).map((t) => ({
          id: t.id,
          name: t.name,
          status: t.status,
          priority: t.priority,
          due_date: t.due_date, // Use due_date
          // Add other fields as needed by the dashboard UI
        }));

        // --- Format Tracked States with Latest Values ---
        const formattedTrackedStates = (trackedStateDefinitions || []).map((def) => {
          const latestEntry = latestEntriesMap[def.id];
          return {
            id: def.id,
            name: def.name,
            unit: def.unit, // Use 'unit' field
            currentValue: latestEntry ? latestEntry.value : null, // Default to null
            lastUpdated: latestEntry ? latestEntry.created_at : null,
          };
        });

        // Return formatted data including trackedStates
        return {
          habits: formattedHabits,
          goals: formattedGoals,
          tasks: tasks || [], // Ensure tasks is always an array
          trackedStates: formattedTrackedStates, // Use the newly formatted array
        };
      } catch (error: any) {
        console.error('Dashboard data fetch error:', error);
        
        // Handle specific error types with appropriate error codes
        if (error.code === '42P01') { // Table doesn't exist
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Database schema error',
          });
        }
        
        if (error.code === '23505') { // Unique violation
          throw new TRPCError({
            code: 'CONFLICT',
            message: 'Resource already exists',
          });
        }
        
        // Default error handling
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch dashboard data',
        });
      }
    }),
  
  getWeeklyProgress: protectedProcedure
    .input(z.object({
      daysToInclude: z.number().min(1).optional().default(7),
      includeRawData: z.boolean().optional().default(false),
    }).optional())
    .query(async ({ ctx, input }) => {
      try {
        // Calculate date range based on input or default to past week
        const daysToInclude = input?.daysToInclude || 7;
        const includeRawData = input?.includeRawData || false;
        
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(endDate.getDate() - (daysToInclude - 1));
        
        const todayStr = endDate.toISOString().split('T')[0];
        const startDateStr = startDate.toISOString().split('T')[0];
        
        // Generate array of all dates in the range for daily aggregation
        const dateRange: string[] = [];
        const tempDate = new Date(startDate);
        while (tempDate <= endDate) {
          dateRange.push(tempDate.toISOString().split('T')[0]);
          tempDate.setDate(tempDate.getDate() + 1);
        }
        
        // Fetch habits relevant to the date range (active during any part of the range)
        // Need to consider habits created *before* the end date and not archived *before* the start date
        const HABIT_FIELDS_FOR_PROGRESS = 'id, name, habit_type, frequency_type, frequency_details, created_at, streak, best_streak'; // Add streak fields
        const { data: relevantHabits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS_FOR_PROGRESS)
          .eq('user_id', ctx.userId)
          // Add logic here if needed to filter habits active within the date range
          // e.g., .lt('created_at', endDate.toISOString())
          //       .or(`archived_at.gte.${startDate.toISOString()},archived_at.is.null`)
          ;
        if (habitsError) throw habitsError;

        const relevantHabitIds = (relevantHabits || []).map(h => h.id);

        // Fetch habit entries within the date range for relevant habits
        const { data: habitEntries, error: entriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('id, habit_id, date, completed, quantity_value, notes')
          .eq('user_id', ctx.userId)
          .in('habit_id', relevantHabitIds.length > 0 ? relevantHabitIds : ['dummy-uuid']) // Filter by relevant habits
          .gte('date', startDate.toISOString().split('T')[0])
          .lte('date', endDate.toISOString().split('T')[0])
          .order('date', { ascending: true });
 
        if (entriesError) throw entriesError;

        // Get all tasks completed or due within the date range
        const { data: relevantTasks, error: tasksError } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .or(`due_date.gte.${startDateStr}.and.due_date.lte.${todayStr},status.eq.completed.and.updated_at.gte.${startDateStr}.and.updated_at.lte.${todayStr}`);

        if (tasksError) throw tasksError;
        
        // Get total tasks count for completion rate
        const { count: totalTasks, error: countError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', ctx.userId);
          
        if (countError) throw countError;
        
        // Get goal progress snapshots for the period
        const { data: goalSnapshots, error: goalSnapshotsError } = await ctx.supabaseAdmin
          .from('goal_progress_snapshots') // Assuming we have this table
          .select('goal_id, progress, created_at')
          .eq('user_id', ctx.userId)
          .gte('created_at', startDate.toISOString())
          .lte('created_at', endDate.toISOString())
          .order('created_at', { ascending: true });
          
        if (goalSnapshotsError) throw goalSnapshotsError;

        // -- AGGREGATE DATA BY DAY --
        
        // Create daily habit completion structure
        const habitsByDay: Record<string, { completed: number; total: number; entries: any[]; expected: number }> = {};
        dateRange.forEach(date => {
          habitsByDay[date] = { completed: 0, total: 0, entries: [], expected: 0 };
        });
        
        // Populate completed habits from entries (count existence, not completed flag)
        habitEntries?.forEach((entry: any) => {
          const dateStr = (entry.date as string).split('T')[0];
          if (habitsByDay[dateStr]) {
            // Only count one completion per habit per day
            if (!habitsByDay[dateStr].entries.some((e: any) => e.habit_id === entry.habit_id)) {
              habitsByDay[dateStr].completed++;
            }
            habitsByDay[dateStr].entries.push(entry);
          }
        });
        
        // Create daily task completion structure
        const tasksByDay: Record<string, { completed: number; entries: any[] }> = {};
        dateRange.forEach(date => {
          tasksByDay[date] = { completed: 0, entries: [] };
        });
        
        // Process completed tasks into daily stats
        relevantTasks?.forEach(task => {
          const completedDate = (task.updated_at as string).split('T')[0];
          if (tasksByDay[completedDate]) {
            tasksByDay[completedDate].completed++;
            tasksByDay[completedDate].entries.push(task);
          }
        });
        
        // Calculate expected habits per day based on frequency
        const isHabitExpected = (habit: any, date: string): boolean => {
          const dateObj = new Date(date + 'T00:00:00Z'); // Ensure UTC
          const dayOfWeek = dateObj.getUTCDay(); // 0 = Sunday, 6 = Saturday
          const dayOfMonth = dateObj.getUTCDate();
          const month = dateObj.getUTCMonth(); // 0 = January, 11 = December

          const habitCreatedDate = new Date(habit.created_at);
          if (dateObj < habitCreatedDate) {
            return false; // Cannot be expected before it was created
          }

          switch (habit.frequency_type) {
            case 'daily':
              return true;
            case 'specific_days':
              return Array.isArray(habit.frequency_details?.days) && habit.frequency_details.days.includes(dayOfWeek);
            // TODO: Add logic for 'weekly', 'monthly' etc. as needed
            default:
              return false;
          }
        };
        relevantHabits?.forEach(habit => {
          dateRange.forEach(date => {
            if (isHabitExpected(habit, date)) {
              habitsByDay[date].expected++;
            }
          });
        });
        
        // Format into daily progress reports
        const dailyProgress = dateRange.map(date => {
          const habitStats = habitsByDay[date];
          const taskStats = tasksByDay[date];
          
          const habitCompletionRate = habitStats.expected > 0 
            ? habitStats.completed / habitStats.expected 
            : 0;
            
          return {
            date,
            habits: {
              total: habitStats.total,
              completed: habitStats.completed,
              completionRate: habitCompletionRate,
              expected: habitStats.expected
            },
            tasks: {
              completed: taskStats.completed
            },
            // Optionally include raw entries if requested
            ...(includeRawData ? {
              habitEntries: habitStats.entries,
              completedTasks: taskStats.entries
            } : {})
          };
        });
        
        // Calculate overall metrics
        const totalHabitEntries = Object.values(habitsByDay).reduce(
          (sum, day) => sum + day.total, 0);
        const completedHabitEntries = Object.values(habitsByDay).reduce(
          (sum, day) => sum + day.completed, 0);
        const totalCompletedTasks = Object.values(tasksByDay).reduce(
          (sum, day) => sum + day.completed, 0);
          
        const taskCompletionRate = totalTasks ? totalCompletedTasks / totalTasks : 0;
        const habitConsistency = totalHabitEntries > 0 
          ? completedHabitEntries / totalHabitEntries 
          : 0;
          
        // Calculate habit streaks (could be moved to a separate helper function)
        const habitStreaks = (relevantHabits || []).map(habit => ({
          id: habit.id,
          name: habit.name,
          currentStreak: habit.streak || 0,
          bestStreak: habit.best_streak || 0
        }));
        
        // Prepare goal progress data
        const goalProgress: Record<string, { snapshots: any[]; startProgress?: number; endProgress?: number }> = {};
        
        (goalSnapshots || []).forEach(snapshot => {
          if (!goalProgress[snapshot.goal_id]) {
            goalProgress[snapshot.goal_id] = { snapshots: [] };
          }
          goalProgress[snapshot.goal_id].snapshots.push({
            progress: snapshot.progress,
            date: (snapshot.created_at as string).split('T')[0]
          });
        });
        
        // Calculate start and end progress for each goal
        Object.keys(goalProgress).forEach(goalId => {
          const snapshots = goalProgress[goalId].snapshots;
          if (snapshots.length > 0) {
            // Sort by date
            snapshots.sort((a, b) => a.date.localeCompare(b.date));
            goalProgress[goalId].startProgress = snapshots[0].progress;
            goalProgress[goalId].endProgress = snapshots[snapshots.length - 1].progress;
          }
        });
        
        return {
          dailyProgress,
          overallMetrics: {
            totalHabitEntries,
            completedHabitEntries,
            habitCompletionRate: habitConsistency,
            completedTasksCount: totalCompletedTasks,
            taskCompletionRate,
            // Trend indicators (compared to previous period)
            trends: {
              habitsImproving: true, // Placeholder - would compare to previous period
              tasksImproving: false // Placeholder - would compare to previous period
            }
          },
          habitStreaks,
          goalProgress: Object.entries(goalProgress).map(([goalId, data]) => ({
            goalId,
            progressChange: (data.endProgress || 0) - (data.startProgress || 0),
            currentProgress: data.endProgress || 0
          })),
          dateRange: {
            start: startDateStr,
            end: todayStr,
            days: dateRange
          }
        };
      } catch (error: any) {
        console.error('Weekly progress fetch error:', error);
        
        // Handle specific error types with appropriate error codes
        if (error.code === '42P01') { // Table doesn't exist
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Database schema error',
          });
        }
        
        if (error.code === '22P02') { // Invalid text representation
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Invalid input format',
          });
        }
        
        // Default error handling
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch weekly progress',
        });
      }
    }),
}); ```
\n\n## goal Router
**File:** server/src/routers/goalRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createGoalInput, updateGoalInput } from '../types/trpc-types';

const GOAL_FIELDS = 'id, user_id, title, description, progress, target_date, archived_at, sort_order, created_at, updated_at';

export const goalRouter = router({
  getGoals: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;

        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals',
        });
      }
    }),

  getGoalById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!goal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found',
          });
        }

        return goal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal',
        });
      }
    }),

  createGoal: protectedProcedure
    .input(createGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return goal;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal',
        });
      }
    }),

  updateGoal: protectedProcedure
    .input(updateGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to update it',
          });
        }

        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal',
        });
      }
    }),

  deleteGoal: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to delete it',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goals')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal',
        });
      }
    }),

  listActive: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals (in listActive stub)',
        });
      }
    }),

  listArchived: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived goals',
        });
      }
    }),

  archiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') { 
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive goal',
        });
      }
    }),

  unarchiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive goal',
        });
      }
    }),
});```
\n\n## task Router
**File:** server/src/routers/taskRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createTaskInput,
  updateTaskInput,
  updateTaskStatusInput,
  TaskStatusEnum, // Import the enum
  TaskPriorityEnum,
} from '../types/trpc-types';

// Define fields for selection consistency
const TASK_FIELDS =
  'id, user_id, title, notes, status, priority, due_date, goal_id, parent_task_id, recurrence_rule, recurrence_end_date, archived_at, sort_order, created_at, updated_at'; // Corrected: 'priority' instead of 'priority_enum' if that's the actual column name after migration
const GOAL_FIELDS = 'id, user_id, title, description, progress, target_date, archived_at, sort_order, created_at, updated_at';


// --- Helper function to update goal progress ---
async function updateGoalProgress(goalId: string, userId: string, supabase: any) {
  try {
    // 1. Fetch all non-archived tasks for the goal
    const { data: tasks, error: tasksError } = await supabase
      .from('tasks')
      .select('id, status') // Only need id and status
      .eq('goal_id', goalId)
      .eq('user_id', userId)
      .is('archived_at', null); // Exclude archived tasks

    if (tasksError) {
      console.error(`Error fetching tasks for goal ${goalId} during progress update:`, tasksError);
      // Decide how to handle this - maybe just log and skip update?
      return; // Exit if tasks can't be fetched
    }

    const totalTasks = tasks?.length || 0;
    const completedTasks = tasks?.filter((t: { status: string }) => t.status === TaskStatusEnum.enum.done).length || 0;

    // 2. Calculate progress (avoid division by zero)
    const newProgress = totalTasks > 0 ? completedTasks / totalTasks : 0;
    // Ensure progress is between 0 and 1, rounded to avoid floating point issues
    const clampedProgress = Math.round(Math.min(1, Math.max(0, newProgress)) * 100) / 100;

    // 3. Update the goal record
    const { error: updateError } = await supabase
      .from('goals')
      .update({ progress: clampedProgress })
      .eq('id', goalId)
      .eq('user_id', userId); // Ensure user owns the goal

    if (updateError) {
      console.error(`Error updating progress for goal ${goalId}:`, updateError);
      // Log error but don't necessarily throw, task toggle was successful
    } else {
        console.log(`Updated progress for goal ${goalId} to ${clampedProgress}`);
    }

  } catch (err) {
    console.error(`Unexpected error during goal progress update for goal ${goalId}:`, err);
    // Log unexpected errors
  }
}

export const taskRouter = router({
  getTasks: protectedProcedure // Gets non-archived tasks
    .input(z.object({
      goalId: z.string().uuid().optional(),
      // TODO: Add filters for status, priority, dates etc.?
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null); // Filter out archived

        if (input.goalId) {
          query = query.eq('goal_id', input.goalId);
        }

        // TODO: Add complex priority enum sorting? (e.g. high > medium > low)
        const { data: tasks, error } = await query
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('due_date', { ascending: true, nullsFirst: false }) // Order by due date (nulls last)
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tasks',
        });
      }
    }),

  getTaskById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(), // Use uuid validation
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!task) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found',
          });
        }

        // TODO: Parse with Task schema?
        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch task',
        });
      }
    }),

  createTask: protectedProcedure
    .input(createTaskInput) // Use imported input type
    .mutation(async ({ ctx, input }) => {
      try {
        // Verify goal_id if provided
        if (input.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', input.goal_id)
            .eq('user_id', ctx.userId) // Ensure goal belongs to user
            .is('archived_at', null) // Ensure goal is not archived
            .single();

          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived goal ID',
            });
          }
        }

        // Verify parent_task_id if provided
        if (input.parent_task_id) {
          const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
            .from('tasks')
            .select('id')
            .eq('id', input.parent_task_id)
            .eq('user_id', ctx.userId) // Ensure parent belongs to user
            .is('archived_at', null) // Ensure parent is not archived
            .single();

          if (parentError || !parentTask) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived parent task ID',
            });
          }
        }

        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .insert({
            ...input, // Spread validated input (includes new fields like parent_task_id, recurrence etc)
            user_id: ctx.userId,
            // Ensure due_date is used if present in input
            due_date: input.due_date ?? null, // Use correct field name
          })
          .select(TASK_FIELDS)
          .single();

        if (error) {
           // Handle specific errors like FK violations?
           console.error("Create task error:", error);
           throw error;
        }
        // TODO: Parse with Task schema?
        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create task',
        });
      }
    }),

  updateTask: protectedProcedure
    .input(updateTaskInput) // Use imported input type
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input; // Separate id from update payload

        // Check ownership
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id, parent_task_id') // Select parent_task_id for cycle check
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to update it',
          });
        }

        // Verify goal_id if being updated
        if (updateData.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', updateData.goal_id)
            .eq('user_id', ctx.userId)
            .is('archived_at', null)
            .single();

          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived goal ID',
            });
          }
        }
        // Handle setting goal_id to null
        if (updateData.goal_id === null) {
          updateData.goal_id = null;
        }

        // Verify parent_task_id if being updated
        if (updateData.parent_task_id) {
           // Basic cycle check
           if (updateData.parent_task_id === id) {
             throw new TRPCError({
               code: 'BAD_REQUEST',
               message: 'Task cannot be its own parent',
             });
           }
          const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
            .from('tasks')
            .select('id')
            .eq('id', updateData.parent_task_id)
            .eq('user_id', ctx.userId)
            .is('archived_at', null)
            .single();

          if (parentError || !parentTask) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived parent task ID',
            });
          }
          // TODO: Add deeper cycle detection if needed (check if new parent is a descendant)
        }
         // Handle setting parent_task_id to null
        if (updateData.parent_task_id === null) {
          updateData.parent_task_id = null;
        }

        // Ensure correct field name for due date if provided
        const payload: Record<string, any> = { ...updateData };
        if ('due_date' in payload) {
          payload.due_date = payload.due_date ?? null;
        }

        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update(payload) // Pass validated update data
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
             // Handle specific errors like FK violations?
           console.error("Update task error:", error);
           throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update task',
        });
      }
    }),

  deleteTask: protectedProcedure
    .input(z.object({
      id: z.string().uuid(), // Use uuid validation
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to delete it',
          });
        }

        // Delete the task (consider implications for subtasks - maybe archive instead?)
        // For now, direct delete.
        const { error } = await ctx.supabaseAdmin
          .from('tasks')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete task',
        });
      }
    }),

  // ---- Archive/Unarchive ----
  listArchivedTasks: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: tasks, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null) // Filter for archived tasks
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived tasks',
        });
      }
    }),

  archiveTask: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Consider archiving subtasks recursively?
      try {
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Task not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive task',
        });
      }
    }),

  unarchiveTask: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
       // TODO: Consider check if parent is archived?
      try {
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Task not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive task',
        });
      }
    }),

  // ---- Status Update ----
  updateTaskStatus: protectedProcedure
    .input(updateTaskStatusInput) // Uses { id: string().uuid(), status: TaskStatusEnum }
    .mutation(async ({ ctx, input }) => {
       try {
         // Check ownership first
         const { data: existing, error: fetchErr } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

         if (fetchErr || !existing) {
           throw new TRPCError({ code: 'NOT_FOUND', message: 'Task not found or permission denied.' });
         }

         // Perform update
         const { data: updatedTask, error: updateErr } = await ctx.supabaseAdmin
           .from('tasks')
           .update({ status: input.status })
           .eq('id', input.id)
           .select(TASK_FIELDS)
           .single();

         if (updateErr) throw updateErr;
         // TODO: Parse with Task schema?
         return updatedTask;
       } catch (error: any) {
         if (error instanceof TRPCError) throw error;
         throw new TRPCError({
           code: 'INTERNAL_SERVER_ERROR',
           message: error.message || 'Failed to update task status',
         });
       }
    }),

  // ---- Refactored Stubs ----
  listToday: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const todayStart = new Date();
        todayStart.setHours(0, 0, 0, 0);
        const todayEnd = new Date();
        todayEnd.setHours(23, 59, 59, 999);

        const { data: tasks, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .gte('due_date', todayStart.toISOString())
          .lte('due_date', todayEnd.toISOString())
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('due_date', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list tasks for today' });
      }
    }),

  listUpcoming: protectedProcedure
    .query(async ({ ctx }) => {
       try {
         const tomorrowStart = new Date();
         tomorrowStart.setDate(tomorrowStart.getDate() + 1);
         tomorrowStart.setHours(0, 0, 0, 0);

         const { data: tasks, error } = await ctx.supabaseAdmin
           .from('tasks')
           .select(TASK_FIELDS)
           .eq('user_id', ctx.userId)
           .is('archived_at', null)
           .gte('due_date', tomorrowStart.toISOString()) // Due date is tomorrow or later
           .order('due_date', { ascending: true, nullsFirst: false })
           .order('sort_order', { ascending: true, nullsFirst: false })
           .order('created_at', { ascending: false });

         if (error) throw error;
         // TODO: Parse with Task schema?
         return tasks || [];
       } catch (error: any) {
         throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list upcoming tasks' });
       }
    }),

 listOverdue: protectedProcedure
    .query(async ({ ctx }) => {
       try {
         const todayStart = new Date();
         todayStart.setHours(0, 0, 0, 0);

         const { data: tasks, error } = await ctx.supabaseAdmin
           .from('tasks')
           .select(TASK_FIELDS)
           .eq('user_id', ctx.userId)
           .is('archived_at', null)
           .lt('due_date', todayStart.toISOString()) // Due date is before today
           .not('status', 'in', `('${TaskStatusEnum.enum.done}')`) // Exclude completed tasks
           .order('due_date', { ascending: true, nullsFirst: false })
           .order('sort_order', { ascending: true, nullsFirst: false })
           .order('created_at', { ascending: false });

         if (error) throw error;
         // TODO: Parse with Task schema?
         return tasks || [];
       } catch (error: any) {
         throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list overdue tasks' });
       }
    }),

  toggleTask: protectedProcedure // Toggles between 'todo' and 'done'
    .input(z.object({
      taskId: z.string().uuid(),
      completed: z.boolean().optional() // Optional for backward compatibility
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // 1. Fetch the current task, including goal_id
        const { data: currentTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id, status, goal_id, title') // <-- Include goal_id and title
          .eq('id', input.taskId)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !currentTask) {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Task not found or permission denied.' });
        }

        // 2. Determine the new status
        let newStatus;
        if (input.completed !== undefined) {
          // If completed was explicitly provided, use it
          newStatus = input.completed ? TaskStatusEnum.enum.done : TaskStatusEnum.enum.todo;
        } else {
          // Otherwise toggle the current status
          newStatus = currentTask.status === TaskStatusEnum.enum.done
            ? TaskStatusEnum.enum.todo
            : TaskStatusEnum.enum.done;
        }

        // 3. Update the task status
        const { data: updatedTask, error: updateError } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ status: newStatus })
          .eq('id', input.taskId)
          .select(TASK_FIELDS) // Return the full updated task
          .single();

        if (updateError) throw updateError;

        // 4. *** NEW: Update goal progress if applicable ***
        if (currentTask.goal_id) {
           // Call the helper function asynchronously - no need to await here
           // unless the UI needs the updated goal immediately (unlikely for a toggle)
          updateGoalProgress(currentTask.goal_id, ctx.userId, ctx.supabaseAdmin);
        }

        // 5. Return the updated task
        return updatedTask;

      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        console.error("Error in toggleTask:", error); // Log unexpected errors
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to toggle task status',
        });
      }
    }),

  // --- Obsolete Stubs (keep or remove based on client usage) ---
  /*
  getTasksByGoal: protectedProcedure ... // Covered by getTasks with goalId filter
  getTodaysTasks: protectedProcedure ... // Replaced by listToday
  getUpcomingTasks: protectedProcedure ... // Replaced by listUpcoming
  updateTaskStatus_OLD: protectedProcedure ... // Replaced by updateTaskStatus and toggleTask
  */

});```
\n\n## habit Router
**File:** server/src/routers/habitRouter.ts
\n```
import { z } from "zod";
import { router, protectedProcedure } from "../router";
import { TRPCError } from "@trpc/server";
import {
  createHabitInput,
  updateHabitInput,
  createHabitEntryInput,
  updateHabitEntryInput,
} from '../types/trpc-types';
import {
  differenceInCalendarDays,
  parseISO,
  format
} from 'date-fns'; // Need date-fns

const HABIT_FIELDS =
  'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, sort_order, streak, best_streak, created_at, updated_at';

const HABIT_ENTRY_FIELDS =
  'id, user_id, habit_id, date, completed, quantity_value, notes, created_at';

async function calculateAndUpdateStreak(habitId: string, userId: string, supabase: any): Promise<{ currentStreak: number, bestStreak: number }> {
  try {
    // Fetch all entries for the habit, ordered by date descending
    const { data: entries, error: entriesError } = await supabase
      .from('habit_entries')
      .select('date, completed') // Only need date and completed status
      .eq('habit_id', habitId)
      .eq('user_id', userId)
      .order('date', { ascending: false });

    if (entriesError) {
      console.error(`Streak Calc Error: Failed to fetch entries for habit ${habitId}:`, entriesError);
      return { currentStreak: 0, bestStreak: 0 }; // Return 0 if entries can't be fetched
    }

    if (!entries || entries.length === 0) {
      // No entries, reset streak
      const { error: updateErr } = await supabase
        .from('habits')
        .update({ streak: 0 })
        .eq('id', habitId);
      if (updateErr) console.error(`Streak Calc Error: Failed to reset streak for habit ${habitId}`, updateErr);
      // Fetch best streak to return it accurately even if current is 0
      const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
      return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 };
    }

    let currentStreak = 0;
    const today = new Date();
    let expectedDate = today; // Start checking from today
    const todayStr = format(today, 'yyyy-MM-dd');
    const todayEntry = entries.find((e: any) => e.date === todayStr);

    // Determine starting point for streak check
    if (todayEntry?.completed) {
      currentStreak = 1;
      expectedDate = new Date(today.setDate(today.getDate() - 1)); // Start checking from yesterday
    } else {
      const yesterday = new Date(); // Need a fresh date object
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayStr = format(yesterday, 'yyyy-MM-dd');
      const yesterdayEntry = entries.find((e: any) => e.date === yesterdayStr);
      if (yesterdayEntry?.completed) {
        currentStreak = 1;
        expectedDate = new Date(yesterday.setDate(yesterday.getDate() - 1)); // Start checking from day before yesterday
      } else {
        currentStreak = 0;
        // No need to loop if streak is already 0 based on today/yesterday
      }
    }

    // Only loop if there's a potential streak > 0
    if (currentStreak > 0) {
      // Find index of the entry *before* the expectedDate (since we check backwards)
      let startIndex = entries.findIndex((e: any) => e.date === format(expectedDate, 'yyyy-MM-dd'));
      // If expected date wasn't found (e.g., yesterday was the start), adjust index
      if (startIndex === -1) {
        // Start from the entry after the one that established the initial streak (today or yesterday)
        const initialStreakDateStr = todayEntry?.completed ? todayStr : (format(new Date(new Date().setDate(new Date().getDate() - 1)), 'yyyy-MM-dd'));
        const initialEntryIndex = entries.findIndex((e: any) => e.date === initialStreakDateStr);
        startIndex = initialEntryIndex !== -1 ? initialEntryIndex + 1 : 0;
      }

      for (let i = startIndex; i < entries.length; i++) {
        const entry = entries[i];
        const entryDate = parseISO(entry.date);
        const expectedDateStr = format(expectedDate, 'yyyy-MM-dd');

        if (entry.date === expectedDateStr) {
          if (entry.completed) {
            currentStreak++;
            expectedDate.setDate(expectedDate.getDate() - 1); // Move to check previous day
          } else {
            break; // Streak broken by uncompleted entry
          }
        } else {
          // Check if the date difference breaks the streak (allowing for gaps)
          const previousDate = i > 0 ? parseISO(entries[i - 1].date) : parseISO(entries[0].date);
          const dateDiff = differenceInCalendarDays(previousDate, entryDate);

          if (dateDiff > 1) {
            break; // Gap too large, streak broken
          }

          // If gap is 1 day, but this entry wasn't completed, streak is broken
          if (!entry.completed) {
            break;
          }

          // If gap is 1 day and completed, it doesn't continue the *current* consecutive sequence
          // but doesn't necessarily break it either (e.g., completed Mon, Wed - streak is 1 from Wed).
          // For simplicity, we break the loop here, assuming the *consecutive* streak from today/yesterday is what matters.
          // A more complex implementation could find the *longest* streak ending recently.
          break;
        }
      }
    }

    // Fetch current best_streak
    const { data: habitData, error: habitFetchError } = await supabase
      .from('habits')
      .select('best_streak')
      .eq('id', habitId)
      .single();

    if (habitFetchError) {
      console.error(`Streak Calc Error: Failed to fetch habit ${habitId} for best_streak:`, habitFetchError);
      // Fallback best streak if fetch fails
      const bestStreakFallback = Math.max(currentStreak, 0); 
      const { error: updateError } = await supabase
        .from('habits')
        .update({ streak: currentStreak, best_streak: bestStreakFallback })
        .eq('id', habitId);
      if (updateError) console.error(`Streak Calc Error: Failed to update streak (fallback) for habit ${habitId}:`, updateError);
      console.log(`Streak Updated (Fallback Best) for habit ${habitId}: Current=${currentStreak}, Best=${bestStreakFallback}`);
      return { currentStreak, bestStreak: bestStreakFallback };
    }

    const bestStreak = Math.max(currentStreak, habitData?.best_streak || 0);

    // Update the habit record
    const { error: updateError } = await supabase
      .from('habits')
      .update({ streak: currentStreak, best_streak: bestStreak })
      .eq('id', habitId);

    if (updateError) {
      console.error(`Streak Calc Error: Failed to update streak for habit ${habitId}:`, updateError);
    }

    console.log(`Streak Updated for habit ${habitId}: Current=${currentStreak}, Best=${bestStreak}`);
    return { currentStreak, bestStreak };

  } catch (error) {
    console.error(`Unexpected error calculating streak for habit ${habitId}:`, error);
    // Attempt to fetch best streak even on error
    const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
    return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 }; // Return 0 current streak on error
  }
}

export const habitRouter = router({
  getHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (habitsError) throw habitsError;
        if (!habits) return [];

        const todayStr = new Date().toISOString().split('T')[0];

        const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id')
          .eq('user_id', ctx.userId)
          .eq('date', todayStr)
          .in('habit_id', habits.map(h => h.id));

        if (todayEntriesError) throw todayEntriesError;

        const completedMap = (habitEntriesToday || []).reduce<Record<string, boolean>>((acc, entry) => {
          acc[entry.habit_id] = true;
          return acc;
        }, {});

        const formattedHabits = habits.map(h => ({
          ...h,
          completedToday: !!completedMap[h.id]
        }));

        return formattedHabits;
      } catch (error: any) {
        throw new TRPCError({ 
          code: 'INTERNAL_SERVER_ERROR', 
          message: error.message || 'Failed to fetch habits'
        });
      }
    }),

  getHabitById: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .select(HABIT_FIELDS)
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (error) throw new TRPCError({ 
        code: error.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: error.message 
      });
      return data;
    }),

  createHabit: protectedProcedure
    .input(createHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .insert({
          ...input,
          user_id: ctx.userId,
          streak: 0,
          best_streak: 0
        })
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  updateHabit: protectedProcedure
    .input(updateHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { id, ...updateData } = input;

      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .update(updateData)
        .eq("id", id)
        .eq('user_id', ctx.userId)
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  deleteHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { error } = await ctx.supabaseAdmin
        .from("habits")
        .delete()
        .eq("id", input.id);

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return { id: input.id };
    }),

  listArchivedHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        return habits || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived habits',
        });
      }
    }),

  archiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to archive habit' });
      }
    }),

  unarchiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to unarchive habit' });
      }
    }),

  getHabitEntries: protectedProcedure
    .input(z.object({
      habitId: z.string().uuid(),
      startDate: z.string().optional(), 
      endDate: z.string().optional(),   
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { error: habitError } = await ctx.supabaseAdmin
          .from("habits")
          .select("id")
          .eq("id", input.habitId)
          .eq("user_id", ctx.userId)
          .single();

        if (habitError) {
          if (habitError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: habitError.message });
        }

        let query = ctx.supabaseAdmin
          .from('habit_entries')
          .select(HABIT_ENTRY_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('habit_id', input.habitId);

        if (input.startDate) query = query.gte('date', input.startDate);
        if (input.endDate) query = query.lte('date', input.endDate);

        const { data, error: entriesError } = await query.order('date', { ascending: false });

        if (entriesError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: entriesError.message });
        return data || [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to fetch habit entries' });
      }
    }),

  getHabitEntriesForHabit: protectedProcedure
    .input(z.object({ habitId: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      // TODO: Implement logic to fetch habit entries for a specific habit
      console.log(`Fetching entries for habit: ${input.habitId}, user: ${ctx.userId}`);
      // Example fetch:
      // const { data, error } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select(HABIT_ENTRY_FIELDS)
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .order('date', { ascending: false });
      // if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      // return data || [];
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),

  createHabitEntry: protectedProcedure
    .input(createHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .insert({ ...input, user_id: ctx.userId })
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });

        // Update streak after successful insert
        if (data) {
          await calculateAndUpdateStreak(input.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create habit entry',
        });
      }
    }),

  updateHabitEntry: protectedProcedure
    .input(updateHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: habitEntry, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) throw new TRPCError({ 
          code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
          message: "Habit entry not found or access denied" 
        });

        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId) // Ensure ownership
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });

        // Update streak after successful update
        if (data) {
          await calculateAndUpdateStreak(data.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update habit entry',
        });
      }
    }),

  deleteHabitEntry: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Fetch habitId *before* deleting the entry
        const { data: entryToDelete, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id') // Fetch habit_id
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !entryToDelete) {
          throw new TRPCError({ 
            code: fetchError?.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Habit entry not found or access denied.' 
          });
        }

        const { habit_id: habitIdForStreak } = entryToDelete; // Store before delete

        // Perform delete
        const { error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId); // Ensure user owns the entry being deleted

        if (error) throw error; // Throw if delete fails

        // Update streak *after* successful delete
        if (habitIdForStreak) { // Check if we got the habitId
          await calculateAndUpdateStreak(habitIdForStreak, ctx.userId, ctx.supabaseAdmin);
        }

        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete habit entry',
        });
      }
    }),

  toggleHabitEntry: protectedProcedure
    .input(z.object({ habitId: z.string().uuid(), date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/) }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Implement logic to find if entry exists for habitId/date/userId.
      // If exists, delete it.
      // If not exists, create it (need default values for boolean/quantity type).
      // Call calculateAndUpdateStreak after create/delete.
      console.log(`Toggling habit entry for habit: ${input.habitId}, date: ${input.date}`);
      // Example logic:
      // const { data: existingEntry, error: findError } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select('id')
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .eq('date', input.date)
      //   .maybeSingle();
      // if (findError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: findError.message });

      // if (existingEntry) {
      //   // Delete existing
      //   const { error: deleteError } = await ctx.supabaseAdmin.from('habit_entries').delete().eq('id', existingEntry.id);
      //   if (deleteError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: deleteError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'deleted', habitId: input.habitId, date: input.date };
      // } else {
      //   // Create new
      //   // Need to know habit type to set default 'completed' or 'quantity_value'
      //   const { data: newEntry, error: createError } = await ctx.supabaseAdmin
      //     .from('habit_entries')
      //     .insert({ habit_id: input.habitId, user_id: ctx.userId, date: input.date, completed: true /* or quantity_value: default */ })
      //     .select(HABIT_ENTRY_FIELDS)
      //     .single();
      //   if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'created', entry: newEntry };
      // }
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),
});```
\n\n## profile Router
**File not found:** server/src/routers/profileRouter.ts
\n\n## principle Router
**File:** server/src/routers/principleRouter.ts
\n```
// server/src/routers/principleRouter.ts
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createPrincipleInput, updatePrincipleInput } from '../types/trpc-types'; // These now expect 'title' and 'body'

// Define fields for consistent selection, using 'title' and 'body'
const PRINCIPLE_FIELDS = 'id, user_id, title, body, sort_order, created_at, updated_at';

export const principleRouter = router({
  getPrinciples: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: principles, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principles || []; // Return empty array if null
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principles',
        });
      }
    }),

  getPrincipleById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) {
           if (error.code === 'PGRST116') { // Handle not found specifically
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found' });
           }
           throw error; // Rethrow other errors
        }
        // No need for !principle check if .single() is used and error isn't PGRST116

        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principle',
        });
      }
    }),

  createPrinciple: protectedProcedure
    .input(createPrincipleInput) // This Zod schema now expects 'title' and 'body'
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .insert({
            ...input, // Spread validated input, already contains 'title' and 'body'
            user_id: ctx.userId,
          })
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create principle',
        });
      }
    }),

  updatePrinciple: protectedProcedure
    .input(updatePrincipleInput) // This Zod schema now expects 'title' and 'body' (optional)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
           if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to update it' });
           }
           throw fetchError;
        }

        // Update
        const { data: updatedPrinciple, error } = await ctx.supabaseAdmin
          .from('principles')
          .update(updateData) // updateData contains validated 'title'/'body' if provided
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return updatedPrinciple;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update principle',
        });
      }
    }),

  deletePrinciple: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
            if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to delete it' });
           }
           throw fetchError;
        }

        // Delete
        const { error } = await ctx.supabaseAdmin
          .from('principles')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete principle',
        });
      }
    }),
});```
\n\n## reward Router
**File not found:** server/src/routers/rewardRouter.ts
\n\n# 2️⃣ Points Economy Endpoint
\n## Reward System Implementation
\n\n## Reward Router
**File not found:** server/src/routers/rewardRouter.ts
\n\n## Points/Rewards Handler: habitRouter.ts
**File:** server/src/routers/habitRouter.ts
\n```
import { z } from "zod";
import { router, protectedProcedure } from "../router";
import { TRPCError } from "@trpc/server";
import {
  createHabitInput,
  updateHabitInput,
  createHabitEntryInput,
  updateHabitEntryInput,
} from '../types/trpc-types';
import {
  differenceInCalendarDays,
  parseISO,
  format
} from 'date-fns'; // Need date-fns

const HABIT_FIELDS =
  'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, sort_order, streak, best_streak, created_at, updated_at';

const HABIT_ENTRY_FIELDS =
  'id, user_id, habit_id, date, completed, quantity_value, notes, created_at';

async function calculateAndUpdateStreak(habitId: string, userId: string, supabase: any): Promise<{ currentStreak: number, bestStreak: number }> {
  try {
    // Fetch all entries for the habit, ordered by date descending
    const { data: entries, error: entriesError } = await supabase
      .from('habit_entries')
      .select('date, completed') // Only need date and completed status
      .eq('habit_id', habitId)
      .eq('user_id', userId)
      .order('date', { ascending: false });

    if (entriesError) {
      console.error(`Streak Calc Error: Failed to fetch entries for habit ${habitId}:`, entriesError);
      return { currentStreak: 0, bestStreak: 0 }; // Return 0 if entries can't be fetched
    }

    if (!entries || entries.length === 0) {
      // No entries, reset streak
      const { error: updateErr } = await supabase
        .from('habits')
        .update({ streak: 0 })
        .eq('id', habitId);
      if (updateErr) console.error(`Streak Calc Error: Failed to reset streak for habit ${habitId}`, updateErr);
      // Fetch best streak to return it accurately even if current is 0
      const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
      return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 };
    }

    let currentStreak = 0;
    const today = new Date();
    let expectedDate = today; // Start checking from today
    const todayStr = format(today, 'yyyy-MM-dd');
    const todayEntry = entries.find((e: any) => e.date === todayStr);

    // Determine starting point for streak check
    if (todayEntry?.completed) {
      currentStreak = 1;
      expectedDate = new Date(today.setDate(today.getDate() - 1)); // Start checking from yesterday
    } else {
      const yesterday = new Date(); // Need a fresh date object
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayStr = format(yesterday, 'yyyy-MM-dd');
      const yesterdayEntry = entries.find((e: any) => e.date === yesterdayStr);
      if (yesterdayEntry?.completed) {
        currentStreak = 1;
        expectedDate = new Date(yesterday.setDate(yesterday.getDate() - 1)); // Start checking from day before yesterday
      } else {
        currentStreak = 0;
        // No need to loop if streak is already 0 based on today/yesterday
      }
    }

    // Only loop if there's a potential streak > 0
    if (currentStreak > 0) {
      // Find index of the entry *before* the expectedDate (since we check backwards)
      let startIndex = entries.findIndex((e: any) => e.date === format(expectedDate, 'yyyy-MM-dd'));
      // If expected date wasn't found (e.g., yesterday was the start), adjust index
      if (startIndex === -1) {
        // Start from the entry after the one that established the initial streak (today or yesterday)
        const initialStreakDateStr = todayEntry?.completed ? todayStr : (format(new Date(new Date().setDate(new Date().getDate() - 1)), 'yyyy-MM-dd'));
        const initialEntryIndex = entries.findIndex((e: any) => e.date === initialStreakDateStr);
        startIndex = initialEntryIndex !== -1 ? initialEntryIndex + 1 : 0;
      }

      for (let i = startIndex; i < entries.length; i++) {
        const entry = entries[i];
        const entryDate = parseISO(entry.date);
        const expectedDateStr = format(expectedDate, 'yyyy-MM-dd');

        if (entry.date === expectedDateStr) {
          if (entry.completed) {
            currentStreak++;
            expectedDate.setDate(expectedDate.getDate() - 1); // Move to check previous day
          } else {
            break; // Streak broken by uncompleted entry
          }
        } else {
          // Check if the date difference breaks the streak (allowing for gaps)
          const previousDate = i > 0 ? parseISO(entries[i - 1].date) : parseISO(entries[0].date);
          const dateDiff = differenceInCalendarDays(previousDate, entryDate);

          if (dateDiff > 1) {
            break; // Gap too large, streak broken
          }

          // If gap is 1 day, but this entry wasn't completed, streak is broken
          if (!entry.completed) {
            break;
          }

          // If gap is 1 day and completed, it doesn't continue the *current* consecutive sequence
          // but doesn't necessarily break it either (e.g., completed Mon, Wed - streak is 1 from Wed).
          // For simplicity, we break the loop here, assuming the *consecutive* streak from today/yesterday is what matters.
          // A more complex implementation could find the *longest* streak ending recently.
          break;
        }
      }
    }

    // Fetch current best_streak
    const { data: habitData, error: habitFetchError } = await supabase
      .from('habits')
      .select('best_streak')
      .eq('id', habitId)
      .single();

    if (habitFetchError) {
      console.error(`Streak Calc Error: Failed to fetch habit ${habitId} for best_streak:`, habitFetchError);
      // Fallback best streak if fetch fails
      const bestStreakFallback = Math.max(currentStreak, 0); 
      const { error: updateError } = await supabase
        .from('habits')
        .update({ streak: currentStreak, best_streak: bestStreakFallback })
        .eq('id', habitId);
      if (updateError) console.error(`Streak Calc Error: Failed to update streak (fallback) for habit ${habitId}:`, updateError);
      console.log(`Streak Updated (Fallback Best) for habit ${habitId}: Current=${currentStreak}, Best=${bestStreakFallback}`);
      return { currentStreak, bestStreak: bestStreakFallback };
    }

    const bestStreak = Math.max(currentStreak, habitData?.best_streak || 0);

    // Update the habit record
    const { error: updateError } = await supabase
      .from('habits')
      .update({ streak: currentStreak, best_streak: bestStreak })
      .eq('id', habitId);

    if (updateError) {
      console.error(`Streak Calc Error: Failed to update streak for habit ${habitId}:`, updateError);
    }

    console.log(`Streak Updated for habit ${habitId}: Current=${currentStreak}, Best=${bestStreak}`);
    return { currentStreak, bestStreak };

  } catch (error) {
    console.error(`Unexpected error calculating streak for habit ${habitId}:`, error);
    // Attempt to fetch best streak even on error
    const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
    return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 }; // Return 0 current streak on error
  }
}

export const habitRouter = router({
  getHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (habitsError) throw habitsError;
        if (!habits) return [];

        const todayStr = new Date().toISOString().split('T')[0];

        const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id')
          .eq('user_id', ctx.userId)
          .eq('date', todayStr)
          .in('habit_id', habits.map(h => h.id));

        if (todayEntriesError) throw todayEntriesError;

        const completedMap = (habitEntriesToday || []).reduce<Record<string, boolean>>((acc, entry) => {
          acc[entry.habit_id] = true;
          return acc;
        }, {});

        const formattedHabits = habits.map(h => ({
          ...h,
          completedToday: !!completedMap[h.id]
        }));

        return formattedHabits;
      } catch (error: any) {
        throw new TRPCError({ 
          code: 'INTERNAL_SERVER_ERROR', 
          message: error.message || 'Failed to fetch habits'
        });
      }
    }),

  getHabitById: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .select(HABIT_FIELDS)
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (error) throw new TRPCError({ 
        code: error.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: error.message 
      });
      return data;
    }),

  createHabit: protectedProcedure
    .input(createHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .insert({
          ...input,
          user_id: ctx.userId,
          streak: 0,
          best_streak: 0
        })
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  updateHabit: protectedProcedure
    .input(updateHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { id, ...updateData } = input;

      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .update(updateData)
        .eq("id", id)
        .eq('user_id', ctx.userId)
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  deleteHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { error } = await ctx.supabaseAdmin
        .from("habits")
        .delete()
        .eq("id", input.id);

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return { id: input.id };
    }),

  listArchivedHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        return habits || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived habits',
        });
      }
    }),

  archiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to archive habit' });
      }
    }),

  unarchiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to unarchive habit' });
      }
    }),

  getHabitEntries: protectedProcedure
    .input(z.object({
      habitId: z.string().uuid(),
      startDate: z.string().optional(), 
      endDate: z.string().optional(),   
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { error: habitError } = await ctx.supabaseAdmin
          .from("habits")
          .select("id")
          .eq("id", input.habitId)
          .eq("user_id", ctx.userId)
          .single();

        if (habitError) {
          if (habitError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: habitError.message });
        }

        let query = ctx.supabaseAdmin
          .from('habit_entries')
          .select(HABIT_ENTRY_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('habit_id', input.habitId);

        if (input.startDate) query = query.gte('date', input.startDate);
        if (input.endDate) query = query.lte('date', input.endDate);

        const { data, error: entriesError } = await query.order('date', { ascending: false });

        if (entriesError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: entriesError.message });
        return data || [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to fetch habit entries' });
      }
    }),

  getHabitEntriesForHabit: protectedProcedure
    .input(z.object({ habitId: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      // TODO: Implement logic to fetch habit entries for a specific habit
      console.log(`Fetching entries for habit: ${input.habitId}, user: ${ctx.userId}`);
      // Example fetch:
      // const { data, error } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select(HABIT_ENTRY_FIELDS)
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .order('date', { ascending: false });
      // if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      // return data || [];
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),

  createHabitEntry: protectedProcedure
    .input(createHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .insert({ ...input, user_id: ctx.userId })
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });

        // Update streak after successful insert
        if (data) {
          await calculateAndUpdateStreak(input.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create habit entry',
        });
      }
    }),

  updateHabitEntry: protectedProcedure
    .input(updateHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: habitEntry, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) throw new TRPCError({ 
          code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
          message: "Habit entry not found or access denied" 
        });

        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId) // Ensure ownership
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });

        // Update streak after successful update
        if (data) {
          await calculateAndUpdateStreak(data.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update habit entry',
        });
      }
    }),

  deleteHabitEntry: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Fetch habitId *before* deleting the entry
        const { data: entryToDelete, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id') // Fetch habit_id
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !entryToDelete) {
          throw new TRPCError({ 
            code: fetchError?.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Habit entry not found or access denied.' 
          });
        }

        const { habit_id: habitIdForStreak } = entryToDelete; // Store before delete

        // Perform delete
        const { error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId); // Ensure user owns the entry being deleted

        if (error) throw error; // Throw if delete fails

        // Update streak *after* successful delete
        if (habitIdForStreak) { // Check if we got the habitId
          await calculateAndUpdateStreak(habitIdForStreak, ctx.userId, ctx.supabaseAdmin);
        }

        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete habit entry',
        });
      }
    }),

  toggleHabitEntry: protectedProcedure
    .input(z.object({ habitId: z.string().uuid(), date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/) }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Implement logic to find if entry exists for habitId/date/userId.
      // If exists, delete it.
      // If not exists, create it (need default values for boolean/quantity type).
      // Call calculateAndUpdateStreak after create/delete.
      console.log(`Toggling habit entry for habit: ${input.habitId}, date: ${input.date}`);
      // Example logic:
      // const { data: existingEntry, error: findError } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select('id')
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .eq('date', input.date)
      //   .maybeSingle();
      // if (findError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: findError.message });

      // if (existingEntry) {
      //   // Delete existing
      //   const { error: deleteError } = await ctx.supabaseAdmin.from('habit_entries').delete().eq('id', existingEntry.id);
      //   if (deleteError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: deleteError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'deleted', habitId: input.habitId, date: input.date };
      // } else {
      //   // Create new
      //   // Need to know habit type to set default 'completed' or 'quantity_value'
      //   const { data: newEntry, error: createError } = await ctx.supabaseAdmin
      //     .from('habit_entries')
      //     .insert({ habit_id: input.habitId, user_id: ctx.userId, date: input.date, completed: true /* or quantity_value: default */ })
      //     .select(HABIT_ENTRY_FIELDS)
      //     .single();
      //   if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'created', entry: newEntry };
      // }
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),
});```
\n\n## Points/Rewards Handler: rewardsRouter.ts
**File:** server/src/routers/rewardsRouter.ts
\n```
import { TRPCError } from '@trpc/server';
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { supabaseAdmin } from '../context';

// Corrected relative path
import { claimLootInput, awardBadgeInput } from '../types/trpc-types';

export const rewardsRouter = router({
  // Get all rewards for current user
  getUserRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Select specific fields aligned with our Zod types
        const { data: rewards, error } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('id, user_id, reward_id, earned_at, rewards(id, name, description, emoji, image_url, required_points, type)')
          .eq('user_id', ctx.userId)
          .order('earned_at', { ascending: false });

        if (error) throw error;
        return rewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user rewards',
        });
      }
    }),

  // Get available rewards that can be earned
  getAvailableRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Get all rewards with specific fields
        const { data: allRewards, error: rewardsError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('id, name, description, emoji, image_url, required_points, type, can_earn_multiple')
          .order('required_points', { ascending: true });

        if (rewardsError) throw rewardsError;

        // Get already earned rewards
        const { data: earnedRewards, error: earnedError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('reward_id')
          .eq('user_id', ctx.userId);

        if (earnedError) throw earnedError;

        // Filter out already earned one-time rewards
        const earnedIds = new Set((earnedRewards || []).map(er => er.reward_id));
        const availableRewards = allRewards?.filter(reward => 
          !earnedIds.has(reward.id) || reward.can_earn_multiple);

        return availableRewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch available rewards',
        });
      }
    }),

  // Get user points
  getUserPoints: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: userProfile, error } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (error) throw error;
        return {
          points: userProfile?.points || 0,
          lifetimePoints: userProfile?.lifetime_points || 0,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user points',
        });
      }
    }),

  // Earn a reward if eligible
  earnReward: protectedProcedure
    .input(claimLootInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get the reward details
        const { data: reward, error: rewardError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.rewardId)
          .single();

        if (rewardError || !reward) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Reward not found',
          });
        }

        // Check if user has enough points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        if (userProfile.points < reward.required_points) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Not enough points to earn this reward',
          });
        }

        // If the reward is one-time, check if already earned
        if (!reward.can_earn_multiple) {
          const { data: existingReward, error: existingError } = await ctx.supabaseAdmin
            .from('user_rewards')
            .select('id')
            .eq('user_id', ctx.userId)
            .eq('reward_id', input.rewardId)
            .single();

          if (existingReward) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'You have already earned this one-time reward',
            });
          }
        }

        // Begin transaction
        // 1. Deduct points from user
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: userProfile.points - reward.required_points,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // 2. Add reward to user's earned rewards
        const { data: userReward, error: insertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.rewardId,
            earned_at: new Date().toISOString(),
            points_spent: reward.required_points,
          })
          .select()
          .single();

        if (insertError) {
          // Rollback points if adding reward failed
          await ctx.supabaseAdmin
            .from('profiles')
            .update({
              points: userProfile.points,
            })
            .eq('id', ctx.userId);

          throw insertError;
        }

        return {
          success: true,
          reward: userReward,
          remainingPoints: userProfile.points - reward.required_points,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to earn reward',
        });
      }
    }),

  // Award points to user (e.g., for completing habits, tasks)
  awardPoints: protectedProcedure
    .input(awardBadgeInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get current user points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        // Get badge details
        const { data: badge, error: badgeError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.badgeId)
          .eq('type', 'badge')
          .single();

        if (badgeError || !badge) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Badge not found',
          });
        }

        // Default points to award
        const pointsToAward = 10;
        const currentPoints = userProfile.points || 0;
        const lifetimePoints = userProfile.lifetime_points || 0;
        const newPoints = currentPoints + pointsToAward;
        const newLifetimePoints = lifetimePoints + pointsToAward;

        // Update user points
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: newPoints,
            lifetime_points: newLifetimePoints,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // Record the point transaction
        const { data: pointTransaction, error: transactionError } = await ctx.supabaseAdmin
          .from('point_transactions')
          .insert({
            user_id: ctx.userId,
            points: pointsToAward,
            reason: `Earned badge: ${badge.name}`,
            source_type: 'badge',
            source_id: input.badgeId,
          })
          .select()
          .single();

        if (transactionError) throw transactionError;

        // Add badge to user's earned rewards
        const { data: userBadge, error: badgeInsertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.badgeId,
            reward_type: 'badge',
            earned_at: new Date().toISOString(),
            points_spent: 0, // Badges don't cost points
          })
          .select()
          .single();

        if (badgeInsertError) throw badgeInsertError;

        return {
          success: true,
          previousPoints: currentPoints,
          newPoints,
          pointsAdded: pointsToAward,
          transaction: pointTransaction,
          badge: userBadge,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to award badge',
        });
      }
    }),

  // Get point transaction history
  getPointHistory: protectedProcedure
    .input(z.object({
      limit: z.number().optional().default(20),
      cursor: z.string().optional(), // for pagination
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('point_transactions')
          .select('*')
          .eq('user_id', ctx.userId)
          .order('created_at', { ascending: false })
          .limit(input.limit);
          
        // Handle cursor-based pagination
        if (input.cursor) {
          query = query.lt('created_at', input.cursor);
        }
        
        const { data: transactions, error } = await query;

        if (error) throw error;
        
        // Determine if there are more results
        const lastItem = transactions && transactions.length > 0 
          ? transactions[transactions.length - 1] 
          : null;
          
        return {
          items: transactions || [],
          nextCursor: lastItem?.created_at,
          hasMore: (transactions?.length || 0) === input.limit,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch point history',
        });
      }
    }),
}); ```
\n\n## Points/Rewards Handler: trpc-types.ts
**File:** server/src/types/trpc-types.ts
\n```
// server/src/types/trpc-types.ts
/*
  Aether – Shared tRPC Types
  ------------------------------------------------------------------
  Every Zod schema that powers a router lives here so both the server
  (routers) and the client (React Query hooks) reference a **single**
  source‑of‑truth.  Import these types everywhere else – **never** hand‑roll
  shapes again.
*/

import { z } from 'zod';
import { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from '../router';

/* ------------------------------------------------------------------
 * Enums (keep in sync with DB enums)
 * ----------------------------------------------------------------*/
export const TaskStatusEnum = z.enum(['todo', 'doing', 'done', 'blocked', 'pending']);
export const TaskPriorityEnum = z.enum(['low', 'medium', 'high']);
export const RewardTypeEnum = z.enum(['badge', 'achievement', 'item', 'discount']);
export const HabitTypeEnum = z.enum(['boolean', 'quantity']);
export const HabitFrequencyPeriodEnum = z.enum(['day', 'week', 'month']);

/* ------------------------------------------------------------------
 * Domain Models (DB row shapes) – keep in sync with Supabase tables
 * ----------------------------------------------------------------*/
export const UserProfile = z.object({
  id: z.string().uuid(),
  username: z.string().nullish(),
  avatar_url: z.string().url().nullish(),
  full_name: z.string().nullish(),
  bio: z.string().nullish(),
  points: z.number().int().nonnegative().default(0),
  time_zone: z.string().nullish(),
  onboarding_completed: z.boolean().default(false),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type UserProfile = z.infer<typeof UserProfile>;

export const NotificationPrefs = z.object({
  email: z.boolean().default(true),
  push: z.boolean().default(true),
  task_reminders: z.boolean().default(true),
  goal_updates: z.boolean().default(true),
  habit_reminders: z.boolean().default(true),
});

export const UiPrefs = z.object({
  theme: z.enum(['system', 'light', 'dark']).default('system'),
  compact_view: z.boolean().default(false),
  show_completed_tasks: z.boolean().default(true),
  first_day_of_week: z.number().int().min(0).max(6).default(0),
});

export const UserSettings = z.object({
  id: z.string().uuid().optional(),
  user_id: z.string().uuid(),
  notification_preferences: NotificationPrefs,
  ui_preferences: UiPrefs,
});
export type UserSettings = z.infer<typeof UserSettings>;

export const Value = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), 
  description: z.string().nullish(),
  color: z.string().nullish(),
  icon: z.string().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type Value = z.infer<typeof Value>;

export const Principle = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), // <<< Changed from 'name' to 'title'
  body: z.string(), // <<< Renamed from description for clarity, matching migration
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type Principle = z.infer<typeof Principle>;

export const Goal = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  description: z.string().nullish(),
  progress: z.number().nullish(),
  target_date: z.string().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime().nullish(),
  updated_at: z.string().datetime().nullish(),
});
export type Goal = z.infer<typeof Goal>;

export const Task = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  notes: z.string().nullish(),
  status: TaskStatusEnum.default('todo'),
  priority_enum: TaskPriorityEnum.nullish(), // <<< Renamed from priority
  due_date: z.string().datetime().nullish(),
  goal_id: z.string().uuid().nullish(),
  parent_task_id: z.string().uuid().nullish(),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Task = z.infer<typeof Task>;

export const Habit = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  cue: z.string().nullish(),
  routine: z.string().nullish(),
  reward: z.string().nullish(),
  streak: z.number().nonnegative().default(0),
  best_streak: z.number().nonnegative().default(0),
  habit_type: HabitTypeEnum.default('boolean'),
  goal_quantity: z.number().int().nullish(),
  goal_unit: z.string().nullish(),
  frequency_period: HabitFrequencyPeriodEnum.default('day'),
  goal_frequency: z.number().int().positive().default(1),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(), // <<< Added sort_order
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Habit = z.infer<typeof Habit>;

export const HabitEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  habit_id: z.string().uuid(),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be in YYYY-MM-DD format"),
  completed: z.boolean().default(false),
  quantity_value: z.number().int().nullish(),
  notes: z.string().nullish(),
  created_at: z.string().datetime(),
});
export type HabitEntry = z.infer<typeof HabitEntry>;

export const TrackedStateDef = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  name: z.string(),
  // category: z.string(), // Category seems removed/replaced in DB schema by scale/custom_labels
  scale: z.enum(['1-5', 'low-high', 'custom']), // <<< Added scale
  custom_labels: z.array(z.string()).nullish(), // <<< Added custom_labels
  unit: z.string().nullish(), // Keep unit if still used alongside scale
  icon: z.string().nullish(), // Keep icon if still used
  target_min_value: z.number().nullish(), // <<< Added
  target_max_value: z.number().nullish(), // <<< Added
  active: z.boolean().default(true), // <<< Added active
  priority: z.number().int().default(1), // <<< Added priority
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type TrackedStateDef = z.infer<typeof TrackedStateDef>;

export const StateEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  definition_id: z.string().uuid(), // <<< Renamed from tracked_state_def_id for consistency? check DB
  value_numeric: z.number().optional().nullable(),
  value_text: z.string().optional().nullable(),
  entry_timestamp: z.string().datetime({ message: "Invalid datetime string. Must be UTC ISO 8601" }).optional(),
  notes: z.string().optional().nullable(), // <<< Added notes
});
export type StateEntry = z.infer<typeof StateEntry>;

export const Reward = z.object({
  id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullish(),
  type: RewardTypeEnum,
  required_points: z.number().int().nonnegative().default(0),
  can_earn_multiple: z.boolean().default(false),
  image_url: z.string().url().nullish(),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Reward = z.infer<typeof Reward>;

export const UserReward = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  reward_id: z.string().uuid(),
  reward_type: z.string().nullish(), // From DB schema
  earned_at: z.string().datetime(),
  points_spent: z.number().int().nonnegative().default(0),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type UserReward = z.infer<typeof UserReward>;

export const PointTransaction = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  points: z.number().int(),
  reason: z.string(),
  source_type: z.string(),
  source_id: z.string().uuid().nullish(),
  created_at: z.string().datetime(),
});
export type PointTransaction = z.infer<typeof PointTransaction>;

export const BadgeDefinition = z.object({
  id: z.string(), // From DB: text primary key
  title: z.string(),
  description: z.string().nullish(),
  icon: z.string(),
});
export type BadgeDefinition = z.infer<typeof BadgeDefinition>;

export const UserBadge = z.object({
  // Note: user_badges might be merged into user_rewards with type='badge'
  user_id: z.string().uuid(),
  badge_id: z.string(), // Matches badge_definitions.id (text)
  earned_at: z.string().datetime(),
  progress: z.number().nullish(), // From DB schema
});
export type UserBadge = z.infer<typeof UserBadge>;

export const Reminder = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
  reminder_time: z.string().datetime(),
  is_active: z.boolean().default(true),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Reminder = z.infer<typeof Reminder>;

export const GoalProgressNote = z.object({
  id: z.string().uuid(),
  goal_id: z.string().uuid(),
  user_id: z.string().uuid(),
  note: z.string(),
  created_at: z.string().datetime(),
});
export type GoalProgressNote = z.infer<typeof GoalProgressNote>;

/* ------------------------------------------------------------------
 * Router‑level Schemas – inputs & outputs for every procedure
 * ----------------------------------------------------------------*/
export const greetingInput = z.object({ name: z.string().optional() });
export const greetingOutput = z.object({ greeting: z.string() });

// User
export const updateProfileInput = UserProfile.partial().omit({ id: true, created_at: true, updated_at: true });
export const updateSettingsInput = z.object({
  notification_preferences: NotificationPrefs.partial().optional(),
  ui_preferences: UiPrefs.partial().optional(),
});

// Values
export const createValueInput = Value.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateValueInput = createValueInput.partial().extend({ id: z.string().uuid() });

// Principles
// Uses 'title' and 'body' from the updated Principle schema
export const createPrincipleInput = Principle.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updatePrincipleInput = createPrincipleInput.partial().extend({ id: z.string().uuid() });

// Goals
export const createGoalInput = Goal.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateGoalInput = createGoalInput.partial().extend({ id: z.string().uuid() });

// Tasks
export const createTaskInput = Task.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateTaskInput = createTaskInput.partial().extend({ id: z.string().uuid() });
export const updateTaskStatusInput = z.object({ id: z.string().uuid(), status: TaskStatusEnum });

// Habits
export const createHabitInput = Habit.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateHabitInput = createHabitInput.partial().extend({ id: z.string().uuid() });

// Habit Entries
export const createHabitEntryInput = HabitEntry.omit({ id: true, user_id: true, created_at: true });
export const updateHabitEntryInput = createHabitEntryInput.partial().extend({ id: z.string().uuid() });

// Tracked State Definitions
export const createTrackedStateDefInput = TrackedStateDef.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateTrackedStateDefInput = createTrackedStateDefInput.partial().extend({ id: z.string().uuid() });
export const GetTrackedStateDefByIdInput = z.object({ id: z.string().uuid() });
export const DeleteTrackedStateDefInput = z.object({ id: z.string().uuid() });

// State Entries
export const CreateStateEntryInput = StateEntry.omit({ id: true, user_id: true })
.extend({
  tracked_state_def_id: z.string().uuid(), // Ensure this is required
  // Values are optional in base schema
});
export const updateStateEntryInput = CreateStateEntryInput.partial().extend({ id: z.string().uuid() });
export const GetStateEntriesInput = z.object({
  tracked_state_def_id: z.string().uuid(), // Renamed from definition_id to match DB? Check usage.
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  limit: z.number().int().positive().optional(),
});
export const DeleteStateEntryInput = z.object({ id: z.string().uuid() });

// Rewards (Assuming rewards definitions are managed elsewhere)
// No create/update for Reward definitions needed via API?
export const claimLootInput = z.object({
  rewardId: z.string().uuid(), // Use rewardId to match router
});

// Badges
export const awardBadgeInput = z.object({
  badgeId: z.string(), // Matches text ID in badge_definitions
  description: z.string().optional(), // Example custom field if needed
});

// Reminders
export const createReminderInput = Reminder.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateReminderInput = createReminderInput.partial().extend({ id: z.string().uuid() });
export const GetRemindersForEntityInput = z.object({
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
});
export const DeleteReminderInput = z.object({ id: z.string().uuid() });

// Goal Progress Notes
export const createGoalProgressNoteInput = GoalProgressNote.omit({ id: true, user_id: true, created_at: true });
export const updateGoalProgressNoteInput = createGoalProgressNoteInput.partial().extend({ id: z.string().uuid() });
export const GetGoalProgressNotesInput = z.object({ goal_id: z.string().uuid() });
export const DeleteGoalProgressNoteInput = z.object({ id: z.string().uuid() });

/* ------------------------------------------------------------------
 * Aggregate Router Types – automatically inferred
 * ----------------------------------------------------------------*/
export type RouterInputs = inferRouterInputs<AppRouter>;
export type RouterOutputs = inferRouterOutputs<AppRouter>;

/*
  Usage (client‑side):

  const utils = trpc.useUtils();
  type TasksOutput = RouterOutputs['task']['getTasks'];
  type CreateTaskInput = RouterInputs['task']['createTask'];
*/```
\n\n## Points/Rewards Handler: index.ts
**File:** server/src/types/index.ts
\n```
export type ValueId = string;
export type GoalId = string;
export type TaskId = string;
export type HabitId = string;
export type BadgeId = string;

export interface Value {
  id: ValueId;
  name: string;
  description?: string;
  color: string; // tailwind color token (e.g. 'indigo-500')
  domainId?: string; // optional grouping
}

export interface Goal {
  id: GoalId;
  title: string;
  description?: string;
  valueIds: ValueId[];
  progress: number; // 0‒1
  keyResults: KeyResult[];
  targetDate?: string; // ISO
}

export interface KeyResult {
  id: string;
  title: string;
  progress: number; // 0‒1
}

export interface Task {
  id: TaskId;
  title: string;
  notes?: string;
  status: 'todo' | 'doing' | 'done' | 'blocked';
  due?: string; // ISO date
  priority?: 1 | 2 | 3;
  goalId?: GoalId;
  valueIds?: ValueId[];
}

export interface Habit {
  id: HabitId;
  title: string;
  cue?: string;
  routine?: string;
  reward?: string;
  valueIds: ValueId[];
  streak: number; // current consecutive days
  bestStreak: number;
  history: Record<string, boolean>; // ISO day → done?
}

export interface Principle {
  id: string;
  title: string;
  body: string;
  valueIds: ValueId[];
}

export interface TrackedStateDef {
  id: string;
  name: string;
  scale: '1-5' | 'low-high' | 'custom';
  customLabels?: string[];
  valueIds: ValueId[];
}

export interface Badge {
  id: BadgeId;
  title: string;
  icon: string; // Hero‑icons name or emoji
  earnedAt?: string; // ISO
  progress?: number; // 0‒1 for not‑yet
} ```
\n\n## Points/Rewards Handler: router.ts
**File:** server/src/router.ts
\n```
import { initTRPC } from '@trpc/server';
import { z } from 'zod';
import { TRPCError } from '@trpc/server';
import { supabaseAdmin, Context } from './context';

// Initialize tRPC with Supabase context
const t = initTRPC.context<Context>().create();

// Public procedure (no auth required)
export const router = t.router;
export const publicProcedure = t.procedure;

// Protected procedures ensure user is authenticated
export const protectedProcedure = t.procedure.use(({ ctx, next }) => {
  if (!ctx.userId) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }
  return next({ ctx: { supabaseAdmin: ctx.supabaseAdmin, userId: ctx.userId } });
});

// Import individual routers
import { dashboardRouter } from './routers/dashboardRouter';
import { valueRouter } from './routers/valueRouter';
import { principleRouter } from './routers/principleRouter';
import { goalRouter } from './routers/goalRouter';
import { taskRouter } from './routers/taskRouter';
import { habitRouter } from './routers/habitRouter';
import { trackedStateRouter } from './routers/trackedStateRouter';
import { userRouter } from './routers/userRouter';
import { rewardsRouter } from './routers/rewardsRouter';
import { reminderRouter } from './routers/reminderRouter';
import { goalProgressNoteRouter } from './routers/goalProgressNoteRouter';

// Create the router with Supabase-backed procedures
export const appRouter = router({
  greeting: {
    hello: publicProcedure
      .input(z.object({ name: z.string().optional() }))
      .query(async ({ input }) => {
        return { greeting: `Hello ${input.name ?? 'world'}` };
      }),
    goodbye: publicProcedure
      .query(() => {
        return { greeting: 'Goodbye!' };
      }),
  },
  user: userRouter,
  dashboard: dashboardRouter,
  value: valueRouter,
  principle: principleRouter,
  goal: goalRouter,
  task: taskRouter,
  habit: habitRouter,
  state: trackedStateRouter,
  rewards: rewardsRouter,
  reminder: reminderRouter,
  goalProgressNote: goalProgressNoteRouter,
});

// Export type router type
export type AppRouter = typeof appRouter; ```
\n\n# 3️⃣ Realtime Strategy
\n## Supabase Realtime Implementation
\n\n## Realtime Channel: compose.tsx
**File:** ./app/compose.tsx
\n```
// app/compose.tsx
import React from 'react';
import { ScrollView } from 'react-native'; // Using RN ScrollView directly
import { Stack, useRouter, useLocalSearchParams } from 'expo-router';
import { YStack, XStack, Form, Input, Label, TextArea, Button, Switch, Paragraph, Spinner } from 'tamagui';
import { useForm, Controller, ControllerRenderProps, FieldValues } from 'react-hook-form'; // Import ControllerRenderProps
import { zodResolver } from '@hookform/resolvers/zod';
import { useToastController } from '@tamagui/toast'; // Assuming ToastProvider is set up

import { trpc, type RouterInputs } from '@/utils/trpc'; // Assuming inputs are exported like this
import { haptics } from '@/utils/haptics'; // Assuming haptics helper exists

// Assuming your Zod schemas are exported like this. Adjust if necessary.
type CreateValueInput = RouterInputs['value']['createValue'];
type CreateStateInput = RouterInputs['state']['createDefinition'];

// 1️⃣ Define tagged types for discriminated union
type CreateValueInputTagged = CreateValueInput & { __type: 'value' };
type CreateStateInputTagged = CreateStateInput & { __type: 'state' };
type FormValues = CreateValueInputTagged | CreateStateInputTagged;

export default function ComposeModal() {
  const router = useRouter();
  const params = useLocalSearchParams<{ type: string }>();
  const type = params.type === 'value' || params.type === 'state' ? params.type : undefined;
  const toast = useToastController();
  const utils = trpc.useUtils();

  const isValue = type === 'value';

  // 2️⃣ Define stricter default values using tagged types
  const defaultValueValues: CreateValueInputTagged = {
    __type: 'value',
    title: '', // Use 'title' instead of 'name' - Patch #4
    description: ''
  };
  const defaultStateValues: CreateStateInputTagged = {
    __type: 'state',
    name: '',
    scale: '1-5',
    description: '',
    active: true,
    priority: 50
  };

  // --- Separate useMutation hooks ---
  const createValueMutation = trpc.value.createValue.useMutation({
    onSuccess: (data) => handleSuccess(data),
    onError: (error) => handleError(error),
  });
  const createStateDefMutation = trpc.state.createDefinition.useMutation({
    onSuccess: (data) => handleSuccess(data),
    onError: (error) => handleError(error),
  });

  // --- Form setup ---
  const { control, handleSubmit, formState: { errors }, reset } = useForm<FormValues>({
    // Note: ZodResolver might need specific configuration if schemas differ vastly
    // or consider not using it if relying solely on backend validation for this dynamic form.
    // Use the new stricter default value constants
    defaultValues: isValue ? defaultValueValues : defaultStateValues,
  });

  // Reset form if the type changes dynamically
  React.useEffect(() => {
    // Use the new stricter default value constants for reset
    reset(isValue ? defaultValueValues : defaultStateValues);
  }, [isValue, reset]);

  // --- Shared success/error handlers ---
  const handleSuccess = (data: any) => {
      toast.show('Created successfully!', { native: true });
      haptics.success();
      if (isValue) {
        utils.value.getValues.invalidate();
      } else {
        utils.state.getDefinitions.invalidate();
      }
      if (router.canGoBack()) {
        router.dismiss(); // Apply patch #5 - Use dismiss for modals
      } else {
        router.replace('/(tabs)/compass');
      }
  }

  const handleError = (error: any) => {
       toast.show(`Error: ${error.message}`, { type: 'error', native: true });
       haptics.error();
  }

  // --- Corrected onSubmit ---
  const onSubmit = (formData: FormValues) => {
    // 3️⃣ Use discriminant (__type) for type safety, remove casts
    if (formData.__type === 'value') {
      createValueMutation.mutate(formData);
    } else { // formData.__type === 'state'
      createStateDefMutation.mutate(formData);
    }
  };

  // Handle invalid type parameter gracefully
  if (!type) {
    return (
        <YStack flex={1} justifyContent="center" alignItems="center" padding="$4">
            <Paragraph color="$error">Invalid type specified.</Paragraph> {/* Use $error */}
            <Button onPress={() => router.back()} marginTop="$4">Go Back</Button>
        </YStack>
    );
  }

  // Determine current mutation state for button
  const isPending = isValue ? createValueMutation.isPending : createStateDefMutation.isPending;

  return (
    <ScrollView contentContainerStyle={{ flexGrow: 1 }}>
      <Form onSubmit={handleSubmit(onSubmit)} flex={1} padding="$4" space="$4" backgroundColor="$background">
        <Stack.Screen options={{ title: isValue ? 'Add Principle' : 'Define State' }} />

        {/* Conditionally render form fields */}
        {isValue ? (
          <>
            {/* --- Fields for Principle/Value --- */}
            <YStack space="$2">
              <Label htmlFor="title">Title</Label> {/* Patch #4: name -> title */}
              <Controller
                name="title" /* Patch #4: name -> title */
                control={control}
                rules={{ required: 'Title is required' }} /* Patch #4 */
                render={({ field }) => ( /* Use inferred types from FormValues */
                  <Input
                    id="title"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value}
                    placeholder="Principle Title"
                  />
                )}
              />
              {/* Use $error token */}
              {errors.title && <Paragraph color="$error">{errors.title?.message}</Paragraph>}
            </YStack>

            <YStack space="$2">
              <Label htmlFor="description">Description (Optional)</Label>
              <Controller
                name="description"
                control={control}
                render={({ field }) => ( // Use inferred types
                  <TextArea
                    id="description"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value ?? ''}
                    placeholder="Describe the principle..."
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && <Paragraph color="$error">{errors.description?.message}</Paragraph>}
            </YStack>
          </>
        ) : (
          <>
            {/* --- Fields for State Definition --- */}
            <YStack space="$2">
              <Label htmlFor="name">State Name</Label>
              <Controller
                name="name"
                control={control}
                rules={{ required: 'Name is required' }}
                render={({ field }) => ( // Use inferred types // Explicit type
                  <Input
                    id="name"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value}
                    placeholder="e.g., Energy Level, Mood" />
                )}
              />
              {errors.name && <Paragraph color="$error">{errors.name?.message}</Paragraph>}
            </YStack>

             <YStack space="$2">
               <Label htmlFor="scale">Scale</Label>
               <Controller
                 name="scale"
                 control={control}
                 rules={{ required: 'Scale is required' }}
                 render={({ field }) => ( // Use inferred types
                   <>
                    <Paragraph>Scale Selector Placeholder (Selected: {field.value})</Paragraph>
                    <XStack space="$2">
                      {/* Removed invalid theme prop */}
                      <Button size="$2" onPress={() => field.onChange('1-5')} theme={field.value === '1-5' ? 'active' : undefined}>1-5</Button>
                      <Button size="$2" onPress={() => field.onChange('1-10')} theme={field.value === '1-10' ? 'active' : undefined}>1-10</Button>
                    </XStack>
                   </>
                 )}
               />
                {errors.scale && <Paragraph color="$error">{errors.scale?.message}</Paragraph>}
             </YStack>

             <YStack space="$2">
              <Label htmlFor="description">Description (Optional)</Label>
              <Controller
                name="description"
                control={control}
                render={({ field }) => ( // Use inferred types
                  <TextArea
                    id="description"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value ?? ''}
                    placeholder="Describe when/how to track this state..."
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && <Paragraph color="$error">{errors.description?.message}</Paragraph>}
            </YStack>

            <XStack space="$4" alignItems="center">
               <Label htmlFor="active" flex={1}>Active</Label>
               <Controller
                 name="active"
                 control={control}
                 render={({ field }: { field: ControllerRenderProps<FieldValues, 'active'> }) => ( // Explicit type
                    <Switch
                      id="active"
                      checked={!!field.value} // Use checked
                      onCheckedChange={field.onChange} // Use onCheckedChange
                      size="$3"
                    >
                        <Switch.Thumb animation="quick" />
                    </Switch>
                 )}
               />
            </XStack>
          </>
        )}

        {/* Removed invalid theme prop */}
        <Form.Trigger asChild disabled={isPending}>
          <Button icon={isPending ? <Spinner /> : undefined}>
            {isPending ? 'Saving...' : 'Save'}
          </Button>
        </Form.Trigger>
      </Form>
    </ScrollView>
  );
}```
\n\n## Realtime Channel: index.tsx
**File:** ./app/(tabs)/home/index.tsx
\n```
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/home/index.tsx
import React, { useCallback, useMemo } from 'react';
import { YStack, H1, Text, XStack, Button, ScrollView, Spinner } from 'tamagui';
import { SafeAreaView, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc, RouterOutputs } from '@/utils/trpc';
import DashboardSection from '@/components/dashboard/DashboardSection';
import GoalSummaryCard from '@/components/dashboard/GoalSummaryCard';
import HabitCheckItem from '@/components/dashboard/HabitCheckItem';
import TaskItem from '@/components/dashboard/TaskItem';
import StateIndicator from '@/components/dashboard/StateIndicator';
import DailyProgressBanner from '@/components/dashboard/DailyProgressBanner'; // Import Banner
import EmptyOrSkeleton from '@/components/ui/EmptyOrSkeleton';
import { SkeletonCard, SkeletonRow } from '@/components/ui/Skeleton';
import { useSkeleton } from '@/hooks/useSkeleton';
import { useColorScheme } from '@/hooks/useColorScheme';
import { useToastController } from '@tamagui/toast';
import { BlurView } from 'expo-blur';
import { Plus } from '@tamagui/lucide-icons';
import LottieView from 'lottie-react-native';
import SwipeableRow from '@/components/ui/SwipeableRow'; // Import SwipeableRow

// Types inferred from tRPC Router
type RouterOutput = RouterOutputs['dashboard']['getDashboardData'];
// --- Define types for the STRUCTURE AFTER mapping in useMemo ---
export type DashboardGoal = {
  id: string;
  title: string;
  progress: number;
  tasks: { completed: number; total: number };
  // Include other relevant fields if needed by GoalSummaryCard
  status?: string | null; 
  priority?: number | null;
};
export type DashboardHabit = {
  id: string;
  name: string;
  description?: string | null;
  completed: boolean; // Mapped from completedToday
  streak: number;
  last_entry_id?: string; // Mapped from habit.last_entry_id (null -> undefined)
  habit_type?: string | null;
};
export type DashboardTask = {
  id: string;
  name: string;
  status: string | null; // Allow null
  due_date?: Date | string | null;
  // Include other relevant fields if needed by TaskItem
};
export type DashboardState = {
  id: string;
  name: string | null;
  unit: string | null;
  currentValue: number | string | null;
  lastUpdated: string | null;
  lastEntry: { value: number | null; created_at: Date | string } | null; // Explicitly include lastEntry
};
// --- End mapped type definitions ---

export default function HomeScreen() {
  const colorScheme = useColorScheme();
  const toast = useToastController();
  const utils = trpc.useUtils(); // Get tRPC utils for mutations
  
  // Define types using RouterOutputs for clarity and safety
  // type DashboardGoal = RouterOutputs['dashboard']['getDashboardData']['goals'][number];
  // type DashboardHabit = RouterOutputs['dashboard']['getDashboardData']['habits'][number];
  // type DashboardTask = RouterOutputs['dashboard']['getDashboardData']['tasks'][number];

  // Use tRPC hooks to fetch data - Types are inferred but can be explicitly used
  const { 
    data: dashboardData, 
    isLoading, 
    error, 
    refetch,
    isRefetching 
  } = trpc.dashboard.getDashboardData.useQuery();

  // Define the habit entry mutation hook
  const createHabitEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: () => {
      refetch(); // Refresh data after successful mutation
      // Optional: Add success toast
      // toast.show('Habit updated!', { type: 'success' });
    },
    onError: (error) => {
      // Handle tRPC client error
      toast.show(error.message || 'Failed to update habit', { type: 'error' });
    }
  });

  // Handle errors
  React.useEffect(() => {
    if (error) {
      toast.show(error.message || 'Failed to load dashboard data', { type: 'error' });
    }
  }, [error, toast]);

  // Set up pull-to-refresh
  const onRefresh = useCallback(() => {
    refetch();
  }, [refetch]);

  // Custom skeleton states from your hooks
  const { isLoading: skeletonsLoading, count: skeletonCount = 3 } = {
    isLoading,
    count: 3 // Number of skeleton items to show
  };
  
  // Generate skeleton UI based on loading state
  const renderSkeletons = () => {
    return Array.from({ length: skeletonCount }).map((_, index) => (
      <SkeletonCard key={`skeleton-${index}`} />
    ));
  };

  // Get current date and greeting
  const greeting = getGreeting();
  const currentDate = new Date().toLocaleDateString('en-US', { 
    weekday: 'long', 
    month: 'long', 
    day: 'numeric' 
  });

  const dashboardDataMemo = useMemo(() => {
    // Fix: Add check to ensure dashboardData exists before accessing properties
    if (!dashboardData) {
      return null; // Or return default structure: { goals: [], habits: [], tasks: [], trackedStates: [] }
    }

    // Map and filter data, ensuring structure matches exported types
    return {
      // Filter goals to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      goals: (dashboardData.goals ?? [])
        .filter((goal): goal is typeof goal & { id: string } => !!goal?.id)
        .map((goal) => ({
        // Map to DashboardGoal structure
        id: goal.id, 
        title: goal.title ?? 'Untitled Goal', // Provide default for title
        progress: goal.progress ?? 0, 
        tasks: goal.tasks ?? { completed: 0, total: 0 }, 
        status: goal.status,
        priority: goal.priority,
      })),
      // Filter habits to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      habits: (dashboardData.habits ?? [])
        .filter((habit): habit is typeof habit & { id: string } => !!habit?.id)
        .map((habit) => ({
        // Map to DashboardHabit structure
        id: habit.id, 
        name: habit.name ?? 'Unnamed Habit', // Provide default for name
        description: habit.description,
        completed: habit.completedToday ?? false, // Map completedToday to completed
        streak: habit.streak ?? 0, 
        last_entry_id: habit.last_entry_id ?? undefined, // Map null to undefined
        habit_type: habit.habit_type,
      })),
      // Filter tasks to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      tasks: (dashboardData.tasks ?? [])
        .filter((task): task is typeof task & { id: string } => !!task?.id)
        .map((task) => ({
        // Map to DashboardTask structure
        id: task.id,
        name: task.name ?? 'Untitled Task', // Provide default name
        status: task.status,
        due_date: task.due_date,
      })),
      // Map trackedStates, ensuring lastEntry is preserved
      // Fix: Use nullish coalescing and optional chaining
      trackedStates: (dashboardData.trackedStates ?? [])
        .filter((state): state is typeof state & { id: string } => !!state?.id)
        .map((trackedState) => ({
        // Map to DashboardState structure
        id: trackedState.id,
        name: trackedState.name,
        unit: trackedState.unit,
        currentValue: trackedState.currentValue,
        lastUpdated: trackedState.lastUpdated,
        // Ensure lastEntry structure matches definition or is null
        lastEntry: trackedState.lastEntry ?? null, 
      })),
    };
  }, [dashboardData]);

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <ScrollView 
        showsVerticalScrollIndicator={false}
        contentContainerStyle={{ paddingBottom: 100 }}
        refreshControl={
          <RefreshControl
            refreshing={isRefetching}
            onRefresh={onRefresh}
            tintColor="transparent" // Hide default spinner
            colors={['transparent']} // Hide default spinner (Android)
            progressBackgroundColor="transparent" // Hide default bg (Android)
            refreshingComponent={
              <LottieView
                source={require('@/assets/refresh-sheikah.json')} // ASSUMES this file exists
                autoPlay
                loop
                style={{ width: 48, height: 48, alignSelf: 'center' }} // Center the animation
              />
            }
          />
        }
      >
        <YStack space="$4" paddingHorizontal="$4">
          {/* Header */}
          <YStack space="$1">
            <H1>{greeting}</H1>
            <Text color="$gray10">{currentDate}</Text>
          </YStack>

          {/* Daily Progress Banner */}
          <DailyProgressBanner 
            // tasksCompleted={...} 
            // totalTasks={...} 
            // habitsChecked={...} 
            // totalHabits={...} 
          />

          {/* Goals Section */}
          <DashboardSection 
            title="Goals"
            onSeeAll={() => router.push('/planner')}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load goals"
              />
            ) : !dashboardDataMemo?.goals || dashboardDataMemo.goals.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No goals yet"
                actionText="Create a goal"
                onAction={() => router.push('/planner/add-goal')}
              />
            ) : (
              <YStack space="$3">
                {dashboardDataMemo.goals.slice(0, 3).map((goal) => (
                  <SwipeableRow
                    key={goal.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.goal.delete.mutate({ id: goal.id })
                      console.log('Attempting to delete goal:', goal.id); // Placeholder
                      // utils.goal.delete.mutate({ id: goal.id });
                    }}
                  >
                    <GoalSummaryCard
                      goal={goal}
                      onPress={() => router.push(`/planner/goal/${goal.id}`)}
                    />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>

          {/* Today's Habits */}
          <DashboardSection 
            title="Today's Habits"
            onSeeAll={() => router.push('/planner?tab=habits')}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load habits"
              />
            ) : !dashboardDataMemo?.habits || dashboardDataMemo.habits.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No habits for today"
                actionText="Create a habit"
                onAction={() => router.push('/planner/add-habit')}
              />
            ) : (
              <YStack space="$2">
                {dashboardDataMemo.habits.slice(0, 4).map((habit) => (
                  <SwipeableRow
                    key={habit.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.habit.delete.mutate({ id: habit.id })
                      console.log('Attempting to delete habit:', habit.id); // Placeholder
                      // utils.habit.delete.mutate({ id: habit.id });
                    }}
                  >
                    <HabitCheckItem habit={habit} />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>

          {/* Today's State */}
          <DashboardSection
            title="Today's State"
            // TODO: Add navigation to a dedicated state tracking screen
            onSeeAll={() => console.log('Navigate to State Tracking screen')}
          >
            {isLoading ? (
              renderSkeletons() // Use generic skeletons or specific state skeletons
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load state"
              />
            ) : !dashboardDataMemo?.trackedStates || dashboardDataMemo.trackedStates.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No states being tracked"
                actionText="Track a state"
                // TODO: Navigate to state definition creation screen
                onAction={() => console.log('Navigate to Add State screen')}
              />
            ) : (
              <XStack space="$3" flexWrap="wrap"> 
                {dashboardDataMemo.trackedStates.map((stateData) => (
                  <StateIndicator
                    key={stateData.id}
                    state={stateData} // Pass the whole state object which includes lastEntry
                    lastEntry={stateData.lastEntry} // Pass lastEntry explicitly
                    // TODO: Handle interaction - e.g., navigate to state detail/entry screen
                    onPress={() => console.log('State pressed:', stateData.id)}
                  />
                ))}
              </XStack>
            )}
          </DashboardSection>

          {/* Upcoming Tasks */}
          <DashboardSection 
            title="Upcoming Tasks"
            onSeeAll={() => {/* Navigate to tasks list */}}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load tasks"
              />
            ) : !dashboardDataMemo?.tasks || dashboardDataMemo.tasks.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No upcoming tasks"
                actionText="Create a task"
                onAction={() => {/* Navigate to create task */}}
              />
            ) : (
              <YStack space="$2">
                {dashboardDataMemo.tasks.slice(0, 5).map((task) => (
                  <SwipeableRow
                    key={task.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.task.delete.mutate({ id: task.id })
                      console.log('Attempting to delete task:', task.id); // Placeholder
                      // utils.task.delete.mutate({ id: task.id });
                    }}
                  >
                    <TaskItem
                      task={{
                        // Explicitly pass props matching DashboardTask type
                        id: task.id, // Ensure id is passed
                        name: task.name, // Already defaulted in map
                        status: task.status, // Pass status
                        due_date: task.due_date, // Pass due_date
                      }}
                      isLast={false} // Adjust if needed for styling
                      onPress={() => console.log('Task Item Pressed:', task.id)}
                    />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>
        </YStack>
      </ScrollView>
      <QuickAddFAB />
    </SafeAreaView>
  );
}

// Helper function for greeting
function getGreeting() {
  const hour = new Date().getHours();
  if (hour < 12) return 'Good Morning';
  if (hour < 18) return 'Good Afternoon';
  return 'Good evening';
}

// Quick Add FAB Component
function QuickAddFAB() {
  return (
    <BlurView intensity={40} tint="default" style={{ position:'absolute', bottom:24, right:24, borderRadius:32, overflow: 'hidden' }}>
      <Button
        circular
        size="$5"
        backgroundColor="$accent"
        icon={Plus}
        elevate
        shadowColor="$shadowColor"
        shadowRadius={5}
        shadowOffset={{ width: 0, height: 2 }}
        pressStyle={{ scale: 0.95, opacity: 0.9 }}
        onPress={() => {
          router.push('/planner/add-task');
        }}
      />
    </BlurView>
  );
}
```
\n\n## Realtime Channel: index.tsx
**File:** ./app/(tabs)/planner/index.tsx
\n```
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/planner/index.tsx
import React, { useState, Suspense } from 'react';
import { YStack, XStack, Text, Tabs, Button, Spinner, Card, ScrollView } from 'tamagui';
import { SafeAreaView, FlatList, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { RouterOutputs } from '@/utils/api-types';
import { SectionError } from '@/components/ui/ErrorBanner';


interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'goals',
    title: 'Goals',
    icon: <Ionicons name="trophy-outline" size={18} color="currentColor" />
  },
  {
    key: 'habits',
    title: 'Habits',
    icon: <Ionicons name="repeat-outline" size={18} color="currentColor" />
  },
  {
    key: 'calendar',
    title: 'Calendar',
    icon: <Ionicons name="calendar-outline" size={18} color="currentColor" />
  }
];

export default function PlannerScreen() {
  const [activeTab, setActiveTab] = useState<string>('goals');
  const colorScheme = useColorScheme();
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Planner</Text>
          <Button
            size="$3"
            circular
            onPress={() => {/* Handle new item */}}
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>
        
        {/* Tabs */}
        <Tabs
          defaultValue="goals"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List 
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {tab.icon}
                  <Text>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>
          
          {/* Tab Content */}
          <Tabs.Content value="goals" flex={1}>
            <ScrollView>
              <GoalsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="habits" flex={1}>
            <ScrollView>
              <HabitsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="calendar" flex={1}>
            <ScrollView>
              <CalendarTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Goals Tab
function GoalsTab() {
  // Fetch goals using tRPC
  const { data: goals, isLoading, error, refetch } = trpc.goal.getGoals.useQuery();
  
  // Define the inferred type for a single goal
  type PlannerGoal = RouterOutputs['goal']['getGoals'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load goals" 
      />
    );
  }
  
  if (!goals || goals.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No goals yet" 
        actionText="Create a goal" 
        onAction={() => router.push('/planner/add-goal')} 
      />
    );
  }
  
  return (
    <YStack space="$4">
      {goals.map((goal: PlannerGoal) => (
        <Button 
          key={goal.id} 
          height="$12" 
          justifyContent="flex-start" 
          paddingHorizontal="$3"
          onPress={() => router.push({ pathname: '/planner/goal/[id]', params: { id: goal.id } })}
        >
          <YStack>
            <Text fontWeight="bold">{goal.title}</Text>
            <Text fontSize="$2" color="$gray10">
              {goal.dueDate ? new Date(goal.dueDate).toLocaleDateString() : 'No due date'}
            </Text>
          </YStack>
        </Button>
      ))}
    </YStack>
  );
}

// Habits Tab
function HabitsTab() {
  // Fetch habits using tRPC
  const { data: habits, isLoading, error, refetch } = trpc.habit.getHabits.useQuery();
  
  // Define the inferred type for a single habit
  type PlannerHabit = RouterOutputs['habit']['getHabits'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={isLoading} count={3} type="row" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load habits" 
      />
    );
  }
  
  if (!habits || habits.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No habits yet" 
        actionText="Create a habit" 
        onAction={() => router.push('/planner/add-habit')} 
      />
    );
  }
  
  return (
    <YStack space="$3">
      {habits.map((habit: PlannerHabit) => (
        <XStack 
          key={habit.id} 
          justifyContent="space-between" 
          alignItems="center" 
          paddingVertical="$3" 
          paddingHorizontal="$3" 
          borderBottomWidth={1} 
          borderColor="$gray5"
          pressStyle={{ opacity: 0.7 }}
          tag="pressable"
          onPress={() => router.push({ pathname: '/planner/habit/[id]', params: { id: habit.id } })}
        >
          <Text>{habit.title}</Text>
          <Button
            size="$2"
            circular
            backgroundColor={habit.completed ? '$green9' : '$gray9'}
            onPress={() => {
              // Use today's date for the habit entry
              const today = new Date().toISOString().split('T')[0];
              
              // Create a mutation to toggle habit completion
              const toggleHabit = trpc.habit.createHabitEntry.useMutation({
                onSuccess: () => {
                  refetch(); // Refresh data after toggling
                },
                onError: (error) => {
                  // Show error message
                  console.error('Failed to toggle habit:', error.message);
                }
              });
              
              // Toggle the habit completion status
              toggleHabit.mutate({
                habitId: habit.id,
                completed: !habit.completed,
                date: today
              });
            }}
            icon={<Ionicons name="checkmark" size={18} color="white" />}
          />
        </XStack>
      ))}
    </YStack>
  );
}

// Calendar Tab
function CalendarTab() {
  return (
    <YStack alignItems="center" justifyContent="center" padding="$8">
      <Text fontSize="$5" textAlign="center">
        Calendar integration coming soon
      </Text>
      <Text marginTop="$2" color="$gray10" textAlign="center">
        This tab will display task and habit schedules in a calendar view
      </Text>
    </YStack>
  );
}
```
\n\n## Realtime Channel: index.tsx
**File:** ./app/(tabs)/rewards/index.tsx
\n```
// Rewards screen with grid/list toggle and claim functionality
import React, { useState, useCallback } from 'react';
import { YStack, XStack, Text, Button, ScrollView, Card, Checkbox, useTheme, H1 } from 'tamagui';
import { SafeAreaView, View, FlatList, ImageBackground, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { RouterOutputs } from '@/utils/trpc'; // Import RouterOutputs
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton'; // Import helper component

// Define inferred type for rewards
type RewardItem = RouterOutputs['rewards']['getAvailableRewards'][number];

enum ViewMode {
  Grid = 'grid',
  List = 'list'
}

export default function RewardsScreen() {
  const [viewMode, setViewMode] = useState<ViewMode>(ViewMode.Grid);
  const colorScheme = useColorScheme();
  const theme = useTheme();

  // Define fallback colors
  const blue2 = theme?.blue2?.val ?? '#eff6ff';
  const blue5 = theme?.blue5?.val ?? '#60a5fa';
  const blue10 = theme?.blue10?.val ?? '#1e40af';
  const blue11 = theme?.blue11?.val ?? '#1e3a8a';
  const green9 = theme?.green9?.val ?? '#16a34a';

  // Fetch available rewards from tRPC
  const { 
    data: rewards, 
    isLoading, 
    error, 
    refetch 
  } = trpc.rewards.getAvailableRewards.useQuery();

  // Mutation for claiming rewards
  const claimMutation = trpc.rewards.earnReward.useMutation({
    onSuccess: (data) => {
      console.log('Reward claimed successfully:', data);
      // Maybe show confetti?
      Alert.alert('Reward Claimed!', `You spent ${data.reward.points_spent} points. Remaining: ${data.remainingPoints}`);
      refetch(); // Refetch the list of available rewards
    },
    onError: (err) => {
      console.error('Failed to claim reward:', err);
      Alert.alert('Claim Failed', err.message || 'Could not claim reward.');
    }
  });
  
  const handleClaimReward = useCallback((rewardId: string) => {
    if (claimMutation.isPending) return; // Prevent double-clicks
    
    Alert.alert(
      'Confirm Claim',
      'Are you sure you want to spend points on this reward?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Claim', 
          onPress: () => {
            claimMutation.mutate({ rewardId });
          },
          style: 'default'
        }
      ]
    );
  }, [claimMutation]);
  
  const renderItem = ({ item }: { item: RewardItem }) => { // Use inferred type
    // Assuming backend field is image_url, map to imagePath
    const imagePath = item.image_url; 
    // All items from getAvailableRewards are considered claimable (not yet claimed)
    const claimed = false; 
    // Map required_points to pointCost
    const pointCost = item.required_points;

    if (viewMode === ViewMode.Grid) {
      return (
        <Card
          size="$4"
          bordered
          width={160}
          height={200}
          margin="$2"
          overflow="hidden"
          elevation="$2"
          opacity={claimed ? 0.7 : 1}
        >
          <ImageBackground
            source={{ uri: imagePath }}
            style={{ width: '100%', height: 100 }}
          >
            <View style={{ 
              position: 'absolute', 
              top: 5, 
              right: 5, 
              backgroundColor: blue5,
              borderRadius: 10,
              padding: 4
            }}>
              <Text color="white" fontSize="$2" fontWeight="bold">
                {pointCost} pts
              </Text>
            </View>
          </ImageBackground>
          
          <YStack padding="$2" flex={1} justifyContent="space-between">
            <Text fontSize="$4" fontWeight="bold" numberOfLines={1}>
              {item.name}
            </Text>
            
            <Button
              size="$2"
              themeInverse={claimed}
              backgroundColor={claimed ? undefined : blue10}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </YStack>
        </Card>
      );
    } else {
      return (
        <Card
          bordered
          margin="$2"
          padding="$3"
          opacity={claimed ? 0.7 : 1}
        >
          <XStack space="$3" alignItems="center">
            {imagePath && (
              <View style={{ 
                width: 60, 
                height: 60, 
                borderRadius: 8, 
                overflow: 'hidden',
                backgroundColor: theme.gray3.val
              }}>
                <ImageBackground
                  source={{ uri: imagePath }}
                  style={{ width: '100%', height: '100%' }}
                />
              </View>
            )}
            
            <YStack flex={1} space="$1">
              <Text fontSize="$5" fontWeight="bold">{item.name}</Text>
              <Text fontSize="$3" color="$gray11" numberOfLines={2}>{item.description}</Text>
              <Text fontSize="$3" color={blue10} fontWeight="500">{pointCost} points</Text>
            </YStack>
            
            <Button
              size="$3"
              backgroundColor={claimed ? undefined : blue10}
              themeInverse={claimed}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </XStack>
        </Card>
      );
    }
  };
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        <YStack space="$4">
          {/* Header */}
          <XStack justifyContent="space-between" alignItems="center">
            <H1>Rewards</H1>
            
            <XStack space="$2">
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.Grid ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.Grid)}
              >
                <Ionicons 
                  name="grid-outline" 
                  size={22} 
                  color={viewMode === ViewMode.Grid ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
              
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.List ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.List)}
              >
                <Ionicons 
                  name="list-outline" 
                  size={22} 
                  color={viewMode === ViewMode.List ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
            </XStack>
          </XStack>
          
          {/* Stats */}
          <Card padding="$3" backgroundColor={blue2}>
            <XStack justifyContent="space-between" alignItems="center">
              <Text fontSize="$5" fontWeight="bold" color={blue11}>Your Points</Text>
              <Text fontSize="$6" fontWeight="bold" color={blue10}>275</Text>
            </XStack>
          </Card>
        </YStack>
        
        {/* Content Area */} 
        <EmptyOrSkeleton 
          isLoading={isLoading}
          isEmpty={!isLoading && !error && (!rewards || rewards.length === 0)}
          isError={!!error}
          text={error ? error.message : 'No rewards available yet.'} // Use text for error OR empty msg
          onRetry={refetch}
          type={viewMode === ViewMode.Grid ? 'card' : 'row'}
          count={viewMode === ViewMode.Grid ? 6 : 3}
        >
          <FlatList
            key={viewMode} // Change key based on viewMode to force re-render
            data={rewards}
            renderItem={renderItem}
            keyExtractor={(item, index) =>
              `${item?.id ?? `tmp-${index}`}-${viewMode}`   // fall back to index if ID is missing
            }
            
            // Optional: Log corrupt data in development
            onLayout={() => {
              if (__DEV__) {
                const missing = (rewards ?? []).filter(r => !r?.id);
                if (missing.length) console.warn('Rewards missing id:', missing);
              }
            }}
            numColumns={viewMode === ViewMode.Grid ? 2 : 1}
            contentContainerStyle={{ paddingBottom: 50 }} // Add padding at the bottom
            // Optional Optimizations (Patch #6)
            initialNumToRender={8}
            removeClippedSubviews={true} // Note: Can have visual glitches on iOS sometimes
          />
        </EmptyOrSkeleton>

      </YStack>
    </SafeAreaView>
  );
}
```
\n\n## Realtime Channel: _layout.tsx
**File:** ./app/_layout.tsx
\n```
// app/_layout.tsx
import '../tamagui.config'; // Import config first!

import React, { useCallback, useEffect, useState, ReactNode, createContext, useContext } from 'react';
import { Slot, SplashScreen, useRouter, useSegments } from 'expo-router';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { StatusBar } from 'expo-status-bar';
import { View, ActivityIndicator, Platform } from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { useFonts } from 'expo-font';
import { useColorScheme } from 'react-native';
import { TamaguiProvider, Theme } from 'tamagui'; // Consolidate Tamagui imports
// tamagui config is already imported at the top of the file
import type { ThemeName } from '@tamagui/core'; // Ensure ThemeName is imported from @tamagui/core
import * as SecureStore from 'expo-secure-store'; // Import SecureStore

import { supabase } from '@/utils/supabase';

import type { Session } from '@supabase/supabase-js';

// Prevent the splash screen from auto-hiding
SplashScreen.preventAutoHideAsync();

/* ------------------------------------------------------------------ */
/*  1. Simple Auth-aware context                                       */
/* ------------------------------------------------------------------ */
interface AuthCtx {
  session: Session | null;
  isLoading: boolean;
}
export const AuthContext = React.createContext<AuthCtx>({
  session: null,
  isLoading: true,
});
export const useAuth = () => React.useContext(AuthContext);

/* ------------------------------------------------------------------ */
/*  2. The actual Provider                                             */
/* ------------------------------------------------------------------ */
function AuthProvider({ children }: { children: ReactNode }) {
  const [session, setSession] = useState<Session | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Initial session check
  useEffect(() => {
    supabase.auth.getSession().then(({ data }) => {
      setSession(data.session ?? null);
      setIsLoading(false);
      console.log('Initial session check:', data.session ? 'Session found' : 'No session');
    }).catch(error => {
        console.error("Error getting initial session:", error);
        setIsLoading(false);
    });

    // Subscribe to auth changes (login / logout / token refresh)
    const { data: authListener } = supabase.auth.onAuthStateChange(
      (_event, newSession) => {
        console.log('Auth state changed:', _event, newSession ? 'New session' : 'No session');
        setSession(newSession ?? null);
        // If the event is SIGNED_IN or TOKEN_REFRESHED, loading might briefly be true again
        // depending on how you handle redirects, but usually setting session is enough.
        // If SIGNED_OUT, ensure loading is false.
        if (_event === 'SIGNED_OUT') {
          setIsLoading(false);
        }
      },
    );

    return () => {
      authListener?.subscription.unsubscribe();
    };
  }, []);

  return (
    <AuthContext.Provider value={{ session, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
}

/* ------------------------------------------------------------------ */
/*  3. Enforce splash-screen logic & route guarding                    */
/* ------------------------------------------------------------------ */
function Root() {
  const { session, isLoading } = useAuth();
  const router = useRouter();
  const segments = useSegments(); // e.g., ["(tabs)", "home"] or ["(auth)", "login"]

  /* Load Fonts ----------------------------------------------------- */
  const [fontsLoaded, fontError] = useFonts({
    // Ensure font names match those used in tamagui.config.ts
    Inter: require('@tamagui/font-inter/otf/Inter-Medium.otf'),
    InterBold: require('@tamagui/font-inter/otf/Inter-Bold.otf'),
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
  });

  /* Handle Font Loading & Errors ----------------------------------- */
  useEffect(() => {
    if (fontError) {
      console.error("Font loading error:", fontError);
      // Decide how to handle font errors - maybe show an error message?
      // For now, we still need to hide splash eventually.
      SplashScreen.hideAsync();
    }
  }, [fontError]);

  /* Redirect Logic ------------------------------------------------- */
  useEffect(() => {
    // Wait until auth state is confirmed AND fonts are potentially loaded
    if (isLoading || !fontsLoaded && !fontError) return;

    const inAuthGroup = segments[0] === '(auth)';

    console.log(`Auth State: isLoading=${isLoading}, session=${!!session}, inAuthGroup=${inAuthGroup}, segments=${segments.join('/')}`);

    if (!session && !inAuthGroup) {
      console.log('Redirecting to login...');
      router.replace('/(auth)/login');
    } else if (session && inAuthGroup) {
      console.log('Redirecting to home...');
      router.replace('/(tabs)/home');
    } else {
        console.log('No redirect needed.');
    }
  }, [isLoading, session, segments, router, fontsLoaded, fontError]);

  /* Hide splash only when fonts loaded/error AND auth check done ---- */
  useEffect(() => {
    if ((fontsLoaded || fontError) && !isLoading) {
        console.log('Hiding SplashScreen...');
      SplashScreen.hideAsync();
    }
  }, [fontsLoaded, fontError, isLoading]);

  /* Show loading indicator until ready ----------------------------- */
  if (!fontsLoaded && !fontError || isLoading) {
    // Optionally, return the Splash Screen component itself or a custom loading view
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#1C1C1E' /* Approx dark bg */ }}>
        <ActivityIndicator size="large" color="#FFFFFF" />
      </View>
    );
  }

  // Once loaded and auth checked, render the content based on route
  return (
    <>
      <StatusBar style={Platform.OS === 'ios' ? 'light' : 'auto'} />
      <Slot />
    </>
  );
}

/* ------------------------------------------------------------------ */
/*  4. Wrap everything with SafeArea, Providers, etc.                  */
/* ------------------------------------------------------------------ */
import { ToastProvider, Toast, useToastState, ToastViewport } from '@tamagui/toast';
import { CheckCircle, AlertCircle, AlertTriangle, Info } from '@tamagui/lucide-icons';
import { YStack, XStack } from 'tamagui';
import { ThemeProvider, DarkTheme, DefaultTheme } from '@react-navigation/native';

const ACCENT_COLOR_KEY = 'userAccentColor';
const DEFAULT_ACCENT = 'blue'; // Set your default accent color theme name here

// Context to provide accent update function down the tree
const AccentContext = createContext({
  setAccent: (color: string) => {},
});
export const useAccent = () => useContext(AccentContext);

function RootLayoutNav() {
  const colorScheme = useColorScheme();
  const themeMode = colorScheme === 'dark' ? 'dark' : 'light';

  return (
    <ToastProvider swipeDirection="horizontal" duration={6000}>
      <Slot />
      <CurrentToast />
      <ToastViewport name="DefaultViewport" top={40} left={0} right={0} /> 
    </ToastProvider>
  );
}

function CurrentToast() {
  const currentToast = useToastState();

  if (!currentToast || currentToast.isHandledNatively) {
    return null;
  }

  const toastType = currentToast.customData?.type || 'info'; // Default to 'info'
  let themeName = 'toast_info'; // Default theme
  let IconComponent = Info;

  switch (toastType) {
    case 'success':
      themeName = 'toast_success';
      IconComponent = CheckCircle;
      break;
    case 'error':
      themeName = 'toast_error';
      IconComponent = AlertCircle;
      break;
    case 'warning':
      themeName = 'toast_warning';
      IconComponent = AlertTriangle;
      break;
  }

  return (
    <Theme name={themeName as ThemeName}> {/* Cast themeName to ThemeName */}
      <Toast
        key={currentToast.id}
        duration={currentToast.duration}
        enterStyle={{ opacity: 0, scale: 0.5, y: -25 }}
        exitStyle={{ opacity: 0, scale: 0.95, y: -10 }} // Adjusted exit style slightly
        y={0}
        opacity={1}
        scale={1}
        animation="bouncy" // Apply bouncy animation
        viewportName={currentToast.viewportName ?? 'DefaultViewport'}
        backgroundColor="$background" // Use background from the wrapped theme
        padding="$3"
        borderRadius="$4"
        marginHorizontal="$4"
        elevate
        shadowColor="$shadowColor"
      >
        <YStack space="$1">
          <XStack space="$2" alignItems="center">
            <IconComponent size={18} color="$color" /> {/* Use color from the wrapped theme */}
            <Toast.Title color="$color">{currentToast.title}</Toast.Title> {/* Use color from the wrapped theme */}
          </XStack>
          {!!currentToast.message && (
            <Toast.Description color="$color"> {/* Use color from the wrapped theme */}
              {currentToast.message}
            </Toast.Description>
          )}
        </YStack>
      </Toast>
    </Theme>
  );
}

function Providers({ children }: { children: React.ReactNode }) {
  const colorScheme = useColorScheme();
  const [accentColor, setAccentColor] = useState(DEFAULT_ACCENT);

  // Load accent color on mount
  useEffect(() => {
    const loadAccent = async () => {
      try {
        const savedAccent = await SecureStore.getItemAsync(ACCENT_COLOR_KEY);
        if (savedAccent) {
          setAccentColor(savedAccent);
        }
      } catch (error) {
        console.error('Failed to load accent color:', error);
      }
    };
    loadAccent();
  }, []);

  // Function to update and save accent color
  const handleSetAccent = useCallback(async (newColor: string) => {
    try {
      await SecureStore.setItemAsync(ACCENT_COLOR_KEY, newColor);
      setAccentColor(newColor);
    } catch (error) {
      console.error('Failed to save accent color:', error);
    }
  }, []);

  return (
    <AccentContext.Provider value={{ setAccent: handleSetAccent }}>
      <Theme name={accentColor as ThemeName}> {/* Cast accentColor to ThemeName */}
        {children}
      </Theme>
    </AccentContext.Provider>
  );
}

export default function RootLayout() {
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        {/* Core Providers (Tamagui, QueryClient, tRPC) */}
        <Providers>
          {/* Auth Provider manages session state */}
          <AuthProvider>
            {/* Root handles splash, font loading, and redirects */}
            <RootLayoutNav />
          </AuthProvider>
        </Providers>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}
```
\n\n## Realtime Channel: AppProvider.tsx
**File:** ./providers/AppProvider.tsx
\n```
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { httpBatchLink } from '@trpc/client';
import { useEffect, useState, type ReactNode } from 'react';
import { Platform } from 'react-native';
import { TamaguiProvider } from 'tamagui';

import { NativeWindProvider } from '@/components/ui/nativewind-setup';
import config from '../tamagui.config';
import { trpc } from '@/utils/trpc';
import { useUiStore } from '@/stores/uiStore'; // Import store to get theme

/**
 * Complete app provider that integrates:
 * - tRPC
 * - React Query
 * - Tamagui
 * - NativeWind
 * - Additional providers can be added here
 */
export function AppProvider({ children }: { children: ReactNode }) {
  // Create Query Client
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 1000, // 5 seconds
        retry: Platform.OS === 'web' ? 3 : 1, // Less retries on mobile to save battery
      },
    },
  }));
  
  // Create tRPC client
  const [trpcClient] = useState(() => 
    trpc.createClient({
      links: [
        httpBatchLink({
          url: 'http://localhost:3000/api/trpc',
          fetch: (input, init) => {
            return fetch(input, {
              ...init,
              credentials: 'include',
            });
          },
        }),
      ],
    })
  );
  
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';
  
  // You could add NATS initialization here
  useEffect(() => {
    // Example: Initialize NATS for real-time updates
    // Note: This is commented out since we don't have a real NATS server to connect to
    /*
    try {
      const url = 'ws://localhost:4222';
      initNatsClient(url, queryClient)
        .then(conn => {
          console.log('NATS client initialized successfully');
          // Set up subscriptions to relevant topics
          subscribeWithCache('users.updates', ['users']);
          subscribeWithCache('messages.updates', ['messages']);
        })
        .catch(err => {
          console.error('Failed to initialize NATS client:', err);
        });
    } catch (error) {
      console.error('Error in NATS setup:', error);
    }
    
    // Cleanup on unmount
    return () => {
      closeNatsConnection().catch(err => {
        console.error('Error closing NATS connection:', err);
      });
    };
    */
  }, [queryClient]);
  
  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <NativeWindProvider theme={currentTheme}>
          <TamaguiProvider config={config}>
            {children}
          </TamaguiProvider>
        </NativeWindProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
} ```
\n\n## Realtime Channel: Providers.tsx
**File:** ./providers/Providers.tsx
\n```
// providers/Providers.tsx
import '../tamagui.config'; // Ensure Tamagui config is loaded first!
import { getConfig } from '@tamagui/core';
console.log('Effective Tamagui config keys:', Object.keys(getConfig() ?? {}));
import { QueryClientProvider } from '@tanstack/react-query';
import { persistQueryClient } from '@tanstack/react-query-persist-client';
import { TamaguiProvider, type TamaguiProviderProps } from 'tamagui';
import { ToastProvider, ToastViewport } from '@tamagui/toast'; // Import from Tamagui Toast
import React, { useEffect, useState, type ReactNode } from 'react';
import { Platform } from 'react-native'; // Import Platform

import config from '../tamagui.config'; // Import your config
import { trpc } from '../utils/trpc'; // Your tRPC hook setup
import { queryClient, persister, initializeNetworkMonitoring, resumeMutationsAndInvalidate } from '@/utils/query-client';
import { useUiStore } from '@/stores/uiStore';
import { supabase } from '@/utils/supabase'; // Needed for auth link
import { createTRPCClient, httpBatchLink, TRPCLink, TRPCClientError } from '@trpc/client'; // Import TRPC Client utils
import { observable } from '@trpc/server/observable';
import type { AppRouter } from '../server/src/router'; // Adjust path if needed
import type { Session } from '@supabase/supabase-js';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

// Setup query client persistence
persistQueryClient({
  queryClient,
  persister,
  maxAge: 1000 * 60 * 60 * 24, // 24 hours
  dehydrateOptions: {
    shouldDehydrateMutation: () => false, // Usually don't dehydrate mutations
  },
});

// New component for the viewport using safe area
const CurrentToastViewport = () => {
  const { top, bottom, left, right } = useSafeAreaInsets();
  return (
    <>
      {/* Adjust positioning based on your desired toast location */}
      <ToastViewport
        name="global_top"
        flexDirection="column" // Stack new toasts below older ones
        top={top + 10} // Add padding below status bar
        left={left + 10} // Add padding from sides
        right={right + 10}
      />
      <ToastViewport
        name="global_bottom"
        flexDirection="column-reverse"
        bottom={bottom + 10}
        left={left + 10}
        right={right + 10}
      />
    </>
  );
};

// Extract tRPC links setup
function getTRPCLinks(getSession: () => Promise<Session | null>): TRPCLink<AppRouter>[] {
  const apiBaseUrl = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api/trpc'; // Default to localhost
  console.log('Using tRPC API URL:', apiBaseUrl);

  return [
    // Link to handle auth token injection and refresh
    (runtime) => {
      return ({ op, next }) => {
        return observable((observer) => {
          getSession().then(session => {
            const headers = (op.context?.headers || {}) as Record<string, string>;
            if (session?.access_token) {
              headers['Authorization'] = `Bearer ${session.access_token}`;
            }

            // Proceed with the request, ensuring context is passed correctly
            next({ ...op, context: { ...op.context, headers } })
              .subscribe({
                next: (value) => observer.next(value),
                error: async (err) => {
                  if (err instanceof TRPCClientError && err.data?.httpStatus === 401) {
                    console.log('tRPC: Token expired or invalid, attempting refresh...');
                    try {
                      // Supabase handles refresh internally if needed when getSession is called
                      const { data, error: refreshError } = await supabase.auth.refreshSession();
                      if (refreshError) throw refreshError;

                      if (data.session) {
                        console.log('tRPC: Session refreshed successfully, retrying request.');
                        const refreshedHeaders = { ...headers, Authorization: `Bearer ${data.session.access_token}` };
                        // Retry with new headers in context
                        next({ ...op, context: { ...op.context, headers: refreshedHeaders } }).subscribe(observer);
                      } else {
                        console.error('tRPC: Session refresh failed, no session returned.');
                        observer.error(err); // Propagate original error if no new session
                        // Optionally trigger logout here
                        supabase.auth.signOut();
                      }
                    } catch (refreshCatchError) {
                      console.error('tRPC: Session refresh catch error:', refreshCatchError);
                      observer.error(err); // Propagate original error
                      supabase.auth.signOut();
                    }
                  } else {
                    observer.error(err); // Propagate non-auth errors
                  }
                },
                complete: () => observer.complete(),
              });
          }).catch(err => {
             console.error('tRPC: Error getting session for headers:', err);
             observer.error(new TRPCClientError('Failed to get session')); // Use TRPCClientError
          });

          // Return cleanup function if needed
          return () => {};
        });
      };
    },
    // The terminating HTTP link
    httpBatchLink({
      url: apiBaseUrl,
       headers() {
         // Headers are injected by the middleware link above
         return {};
       },
      // Add superjson transformer here if you use one
      // transformer: superjson,
    }),
  ];
}

export function Providers({ children }: { children: ReactNode }) {
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';

  // Initialize network monitoring and query client persistence
  useEffect(() => {
    const unsubscribeNetworkMonitoring = initializeNetworkMonitoring();
    resumeMutationsAndInvalidate(); // Try resuming mutations on app load
    return () => {
      unsubscribeNetworkMonitoring();
    };
  }, []);

  // Memoize tRPC client creation
  const [trpcClient] = useState(() =>
    trpc.createClient({
      links: getTRPCLinks(async () => { // Pass session getter to links setup
        const { data } = await supabase.auth.getSession();
        return data.session;
      }),
    })
  );

  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <TamaguiProvider
            config={config}
            defaultTheme={currentTheme}
            // disableInjectCSS // May not be needed depending on setup
        >
          {/* Use Tamagui's ToastProvider */}
          <ToastProvider
            // burntOptions={{ from: 'top' }} // Disabled until native module 'Burnt' is installed
            swipeDirection="horizontal"
            duration={4000}
            native={[]}
          >
            {children}
            {/* Add the safe-area aware ToastViewport */}
            <CurrentToastViewport />
          </ToastProvider>
        </TamaguiProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
}```
\n\n## Realtime Channel: compose.tsx
**File:** ./modals/compose.tsx
\n```
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { Stack, useRouter } from 'expo-router';
import { Button } from '@/components/ui/iOS/Button';
import Animated, { 
  SlideInDown, 
  // SlideOutDown, // Not using exit animation with gesture
  useSharedValue, 
  useAnimatedStyle, 
  withTiming, 
  runOnJS 
} from 'react-native-reanimated';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';

const { height: SCREEN_HEIGHT } = Dimensions.get('window');
const DISMISS_THRESHOLD = SCREEN_HEIGHT * 0.25; // Swipe 25% down to dismiss

export default function ComposeModal() {
  const router = useRouter();

  // Reanimated shared value for tracking vertical translation
  const translateY = useSharedValue(0);
  const context = useSharedValue({ y: 0 });

  // Gesture handler for swipe down
  const gesture = Gesture.Pan()
    .onStart(() => {
      context.value = { y: translateY.value };
    })
    .onUpdate((event) => {
      translateY.value = Math.max(0, context.value.y + event.translationY); // Only allow downward swipe
    })
    .onEnd(() => {
      if (translateY.value > DISMISS_THRESHOLD) {
        // Animate out and navigate back
        translateY.value = withTiming(SCREEN_HEIGHT, { duration: 200 }, () => {
          runOnJS(router.back)();
        });
      } else {
        // Snap back to original position
        translateY.value = withTiming(0, { duration: 150 });
      }
    });

  // Animated style for the view
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateY: translateY.value }],
    };
  });

  return (
    // Wrap with GestureDetector
    <GestureDetector gesture={gesture}>
      {/* Apply animated style and entrance animation */}
      <Animated.View 
        style={[styles.container, animatedStyle]}
        entering={SlideInDown.duration(300)} 
      >
        {/* Optional: Add a small drag handle indicator */}
        <View style={styles.handleIndicator} />

        {/* Use Stack.Screen to configure the modal title */}
        <Stack.Screen 
          options={{
            title: 'Compose New',
            // Ensure header interaction doesn't conflict with gesture
            // headerLeft: () => <Button title="Close" onPress={() => router.back()} />
          }} 
        />
        <Text style={{ fontSize: 20, marginBottom: 20 }}>Swipe Down to Dismiss</Text>
        <Button onPress={() => router.back()}>Close Modal</Button>
      </Animated.View>
    </GestureDetector>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1, 
    alignItems: 'center', 
    justifyContent: 'center',
    backgroundColor: 'white', // Modals usually have solid background
    borderTopLeftRadius: 10, // Apply radius only to top corners for modal sheet look
    borderTopRightRadius: 10,
    // Add shadow for depth if desired
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -3 },
    shadowOpacity: 0.1,
    shadowRadius: 5,
    elevation: 5, // For Android shadow
  },
  handleIndicator: {
    width: 40,
    height: 5,
    backgroundColor: '#ccc',
    borderRadius: 2.5,
    position: 'absolute',
    top: 10,
    alignSelf: 'center',
  }
}); ```
\n\n## Realtime Channel: habitRouter.ts
**File:** ./server/src/routers/habitRouter.ts
\n```
import { z } from "zod";
import { router, protectedProcedure } from "../router";
import { TRPCError } from "@trpc/server";
import {
  createHabitInput,
  updateHabitInput,
  createHabitEntryInput,
  updateHabitEntryInput,
} from '../types/trpc-types';
import {
  differenceInCalendarDays,
  parseISO,
  format
} from 'date-fns'; // Need date-fns

const HABIT_FIELDS =
  'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, sort_order, streak, best_streak, created_at, updated_at';

const HABIT_ENTRY_FIELDS =
  'id, user_id, habit_id, date, completed, quantity_value, notes, created_at';

async function calculateAndUpdateStreak(habitId: string, userId: string, supabase: any): Promise<{ currentStreak: number, bestStreak: number }> {
  try {
    // Fetch all entries for the habit, ordered by date descending
    const { data: entries, error: entriesError } = await supabase
      .from('habit_entries')
      .select('date, completed') // Only need date and completed status
      .eq('habit_id', habitId)
      .eq('user_id', userId)
      .order('date', { ascending: false });

    if (entriesError) {
      console.error(`Streak Calc Error: Failed to fetch entries for habit ${habitId}:`, entriesError);
      return { currentStreak: 0, bestStreak: 0 }; // Return 0 if entries can't be fetched
    }

    if (!entries || entries.length === 0) {
      // No entries, reset streak
      const { error: updateErr } = await supabase
        .from('habits')
        .update({ streak: 0 })
        .eq('id', habitId);
      if (updateErr) console.error(`Streak Calc Error: Failed to reset streak for habit ${habitId}`, updateErr);
      // Fetch best streak to return it accurately even if current is 0
      const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
      return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 };
    }

    let currentStreak = 0;
    const today = new Date();
    let expectedDate = today; // Start checking from today
    const todayStr = format(today, 'yyyy-MM-dd');
    const todayEntry = entries.find((e: any) => e.date === todayStr);

    // Determine starting point for streak check
    if (todayEntry?.completed) {
      currentStreak = 1;
      expectedDate = new Date(today.setDate(today.getDate() - 1)); // Start checking from yesterday
    } else {
      const yesterday = new Date(); // Need a fresh date object
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayStr = format(yesterday, 'yyyy-MM-dd');
      const yesterdayEntry = entries.find((e: any) => e.date === yesterdayStr);
      if (yesterdayEntry?.completed) {
        currentStreak = 1;
        expectedDate = new Date(yesterday.setDate(yesterday.getDate() - 1)); // Start checking from day before yesterday
      } else {
        currentStreak = 0;
        // No need to loop if streak is already 0 based on today/yesterday
      }
    }

    // Only loop if there's a potential streak > 0
    if (currentStreak > 0) {
      // Find index of the entry *before* the expectedDate (since we check backwards)
      let startIndex = entries.findIndex((e: any) => e.date === format(expectedDate, 'yyyy-MM-dd'));
      // If expected date wasn't found (e.g., yesterday was the start), adjust index
      if (startIndex === -1) {
        // Start from the entry after the one that established the initial streak (today or yesterday)
        const initialStreakDateStr = todayEntry?.completed ? todayStr : (format(new Date(new Date().setDate(new Date().getDate() - 1)), 'yyyy-MM-dd'));
        const initialEntryIndex = entries.findIndex((e: any) => e.date === initialStreakDateStr);
        startIndex = initialEntryIndex !== -1 ? initialEntryIndex + 1 : 0;
      }

      for (let i = startIndex; i < entries.length; i++) {
        const entry = entries[i];
        const entryDate = parseISO(entry.date);
        const expectedDateStr = format(expectedDate, 'yyyy-MM-dd');

        if (entry.date === expectedDateStr) {
          if (entry.completed) {
            currentStreak++;
            expectedDate.setDate(expectedDate.getDate() - 1); // Move to check previous day
          } else {
            break; // Streak broken by uncompleted entry
          }
        } else {
          // Check if the date difference breaks the streak (allowing for gaps)
          const previousDate = i > 0 ? parseISO(entries[i - 1].date) : parseISO(entries[0].date);
          const dateDiff = differenceInCalendarDays(previousDate, entryDate);

          if (dateDiff > 1) {
            break; // Gap too large, streak broken
          }

          // If gap is 1 day, but this entry wasn't completed, streak is broken
          if (!entry.completed) {
            break;
          }

          // If gap is 1 day and completed, it doesn't continue the *current* consecutive sequence
          // but doesn't necessarily break it either (e.g., completed Mon, Wed - streak is 1 from Wed).
          // For simplicity, we break the loop here, assuming the *consecutive* streak from today/yesterday is what matters.
          // A more complex implementation could find the *longest* streak ending recently.
          break;
        }
      }
    }

    // Fetch current best_streak
    const { data: habitData, error: habitFetchError } = await supabase
      .from('habits')
      .select('best_streak')
      .eq('id', habitId)
      .single();

    if (habitFetchError) {
      console.error(`Streak Calc Error: Failed to fetch habit ${habitId} for best_streak:`, habitFetchError);
      // Fallback best streak if fetch fails
      const bestStreakFallback = Math.max(currentStreak, 0); 
      const { error: updateError } = await supabase
        .from('habits')
        .update({ streak: currentStreak, best_streak: bestStreakFallback })
        .eq('id', habitId);
      if (updateError) console.error(`Streak Calc Error: Failed to update streak (fallback) for habit ${habitId}:`, updateError);
      console.log(`Streak Updated (Fallback Best) for habit ${habitId}: Current=${currentStreak}, Best=${bestStreakFallback}`);
      return { currentStreak, bestStreak: bestStreakFallback };
    }

    const bestStreak = Math.max(currentStreak, habitData?.best_streak || 0);

    // Update the habit record
    const { error: updateError } = await supabase
      .from('habits')
      .update({ streak: currentStreak, best_streak: bestStreak })
      .eq('id', habitId);

    if (updateError) {
      console.error(`Streak Calc Error: Failed to update streak for habit ${habitId}:`, updateError);
    }

    console.log(`Streak Updated for habit ${habitId}: Current=${currentStreak}, Best=${bestStreak}`);
    return { currentStreak, bestStreak };

  } catch (error) {
    console.error(`Unexpected error calculating streak for habit ${habitId}:`, error);
    // Attempt to fetch best streak even on error
    const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
    return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 }; // Return 0 current streak on error
  }
}

export const habitRouter = router({
  getHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (habitsError) throw habitsError;
        if (!habits) return [];

        const todayStr = new Date().toISOString().split('T')[0];

        const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id')
          .eq('user_id', ctx.userId)
          .eq('date', todayStr)
          .in('habit_id', habits.map(h => h.id));

        if (todayEntriesError) throw todayEntriesError;

        const completedMap = (habitEntriesToday || []).reduce<Record<string, boolean>>((acc, entry) => {
          acc[entry.habit_id] = true;
          return acc;
        }, {});

        const formattedHabits = habits.map(h => ({
          ...h,
          completedToday: !!completedMap[h.id]
        }));

        return formattedHabits;
      } catch (error: any) {
        throw new TRPCError({ 
          code: 'INTERNAL_SERVER_ERROR', 
          message: error.message || 'Failed to fetch habits'
        });
      }
    }),

  getHabitById: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .select(HABIT_FIELDS)
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (error) throw new TRPCError({ 
        code: error.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: error.message 
      });
      return data;
    }),

  createHabit: protectedProcedure
    .input(createHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .insert({
          ...input,
          user_id: ctx.userId,
          streak: 0,
          best_streak: 0
        })
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  updateHabit: protectedProcedure
    .input(updateHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { id, ...updateData } = input;

      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .update(updateData)
        .eq("id", id)
        .eq('user_id', ctx.userId)
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  deleteHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { error } = await ctx.supabaseAdmin
        .from("habits")
        .delete()
        .eq("id", input.id);

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return { id: input.id };
    }),

  listArchivedHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        return habits || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived habits',
        });
      }
    }),

  archiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to archive habit' });
      }
    }),

  unarchiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to unarchive habit' });
      }
    }),

  getHabitEntries: protectedProcedure
    .input(z.object({
      habitId: z.string().uuid(),
      startDate: z.string().optional(), 
      endDate: z.string().optional(),   
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { error: habitError } = await ctx.supabaseAdmin
          .from("habits")
          .select("id")
          .eq("id", input.habitId)
          .eq("user_id", ctx.userId)
          .single();

        if (habitError) {
          if (habitError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: habitError.message });
        }

        let query = ctx.supabaseAdmin
          .from('habit_entries')
          .select(HABIT_ENTRY_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('habit_id', input.habitId);

        if (input.startDate) query = query.gte('date', input.startDate);
        if (input.endDate) query = query.lte('date', input.endDate);

        const { data, error: entriesError } = await query.order('date', { ascending: false });

        if (entriesError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: entriesError.message });
        return data || [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to fetch habit entries' });
      }
    }),

  getHabitEntriesForHabit: protectedProcedure
    .input(z.object({ habitId: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      // TODO: Implement logic to fetch habit entries for a specific habit
      console.log(`Fetching entries for habit: ${input.habitId}, user: ${ctx.userId}`);
      // Example fetch:
      // const { data, error } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select(HABIT_ENTRY_FIELDS)
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .order('date', { ascending: false });
      // if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      // return data || [];
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),

  createHabitEntry: protectedProcedure
    .input(createHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .insert({ ...input, user_id: ctx.userId })
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });

        // Update streak after successful insert
        if (data) {
          await calculateAndUpdateStreak(input.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create habit entry',
        });
      }
    }),

  updateHabitEntry: protectedProcedure
    .input(updateHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: habitEntry, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) throw new TRPCError({ 
          code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
          message: "Habit entry not found or access denied" 
        });

        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId) // Ensure ownership
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });

        // Update streak after successful update
        if (data) {
          await calculateAndUpdateStreak(data.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update habit entry',
        });
      }
    }),

  deleteHabitEntry: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Fetch habitId *before* deleting the entry
        const { data: entryToDelete, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id') // Fetch habit_id
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !entryToDelete) {
          throw new TRPCError({ 
            code: fetchError?.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Habit entry not found or access denied.' 
          });
        }

        const { habit_id: habitIdForStreak } = entryToDelete; // Store before delete

        // Perform delete
        const { error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId); // Ensure user owns the entry being deleted

        if (error) throw error; // Throw if delete fails

        // Update streak *after* successful delete
        if (habitIdForStreak) { // Check if we got the habitId
          await calculateAndUpdateStreak(habitIdForStreak, ctx.userId, ctx.supabaseAdmin);
        }

        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete habit entry',
        });
      }
    }),

  toggleHabitEntry: protectedProcedure
    .input(z.object({ habitId: z.string().uuid(), date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/) }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Implement logic to find if entry exists for habitId/date/userId.
      // If exists, delete it.
      // If not exists, create it (need default values for boolean/quantity type).
      // Call calculateAndUpdateStreak after create/delete.
      console.log(`Toggling habit entry for habit: ${input.habitId}, date: ${input.date}`);
      // Example logic:
      // const { data: existingEntry, error: findError } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select('id')
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .eq('date', input.date)
      //   .maybeSingle();
      // if (findError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: findError.message });

      // if (existingEntry) {
      //   // Delete existing
      //   const { error: deleteError } = await ctx.supabaseAdmin.from('habit_entries').delete().eq('id', existingEntry.id);
      //   if (deleteError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: deleteError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'deleted', habitId: input.habitId, date: input.date };
      // } else {
      //   // Create new
      //   // Need to know habit type to set default 'completed' or 'quantity_value'
      //   const { data: newEntry, error: createError } = await ctx.supabaseAdmin
      //     .from('habit_entries')
      //     .insert({ habit_id: input.habitId, user_id: ctx.userId, date: input.date, completed: true /* or quantity_value: default */ })
      //     .select(HABIT_ENTRY_FIELDS)
      //     .single();
      //   if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'created', entry: newEntry };
      // }
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),
});```
\n\n## Realtime Channel: reminderRouter.ts
**File:** ./server/src/routers/reminderRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createReminderInput,
  updateReminderInput,
  GetRemindersForEntityInput,
  DeleteReminderInput,
} from '../types/trpc-types';

// Define fields for consistent selection
const REMINDER_FIELDS = 'id, user_id, related_entity_type, related_entity_id, reminder_time, message, is_active, created_at, updated_at';

export const reminderRouter = router({
  // Get all active reminders for the user (might need refinement later)
  getActiveReminders: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('is_active', true)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch active reminders',
        });
      }
    }),

  // Get reminders linked to a specific entity
  getRemindersForEntity: protectedProcedure
    .input(GetRemindersForEntityInput)
    .query(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('related_entity_type', input.related_entity_type)
          .eq('related_entity_id', input.related_entity_id)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch reminders for entity',
        });
      }
    }),

  createReminder: protectedProcedure
    .input(createReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // TODO: Potentially validate that related_entity_id exists and belongs to user?
        // This requires knowing the related_entity_type and querying the correct table.
        // For now, assume valid input.
        const { data: reminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return reminder;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create reminder',
        });
      }
    }),

  updateReminder: protectedProcedure
    .input(updateReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { data: updatedReminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return updatedReminder;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update reminder',
        });
      }
    }),

  deleteReminder: protectedProcedure
    .input(DeleteReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('reminders')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete reminder',
        });
      }
    }),
});
```
\n\n## Realtime Channel: principleRouter.ts
**File:** ./server/src/routers/principleRouter.ts
\n```
// server/src/routers/principleRouter.ts
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createPrincipleInput, updatePrincipleInput } from '../types/trpc-types'; // These now expect 'title' and 'body'

// Define fields for consistent selection, using 'title' and 'body'
const PRINCIPLE_FIELDS = 'id, user_id, title, body, sort_order, created_at, updated_at';

export const principleRouter = router({
  getPrinciples: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: principles, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principles || []; // Return empty array if null
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principles',
        });
      }
    }),

  getPrincipleById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) {
           if (error.code === 'PGRST116') { // Handle not found specifically
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found' });
           }
           throw error; // Rethrow other errors
        }
        // No need for !principle check if .single() is used and error isn't PGRST116

        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principle',
        });
      }
    }),

  createPrinciple: protectedProcedure
    .input(createPrincipleInput) // This Zod schema now expects 'title' and 'body'
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .insert({
            ...input, // Spread validated input, already contains 'title' and 'body'
            user_id: ctx.userId,
          })
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create principle',
        });
      }
    }),

  updatePrinciple: protectedProcedure
    .input(updatePrincipleInput) // This Zod schema now expects 'title' and 'body' (optional)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
           if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to update it' });
           }
           throw fetchError;
        }

        // Update
        const { data: updatedPrinciple, error } = await ctx.supabaseAdmin
          .from('principles')
          .update(updateData) // updateData contains validated 'title'/'body' if provided
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return updatedPrinciple;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update principle',
        });
      }
    }),

  deletePrinciple: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
            if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to delete it' });
           }
           throw fetchError;
        }

        // Delete
        const { error } = await ctx.supabaseAdmin
          .from('principles')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete principle',
        });
      }
    }),
});```
\n\n## Realtime Channel: rewardsRouter.ts
**File:** ./server/src/routers/rewardsRouter.ts
\n```
import { TRPCError } from '@trpc/server';
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { supabaseAdmin } from '../context';

// Corrected relative path
import { claimLootInput, awardBadgeInput } from '../types/trpc-types';

export const rewardsRouter = router({
  // Get all rewards for current user
  getUserRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Select specific fields aligned with our Zod types
        const { data: rewards, error } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('id, user_id, reward_id, earned_at, rewards(id, name, description, emoji, image_url, required_points, type)')
          .eq('user_id', ctx.userId)
          .order('earned_at', { ascending: false });

        if (error) throw error;
        return rewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user rewards',
        });
      }
    }),

  // Get available rewards that can be earned
  getAvailableRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Get all rewards with specific fields
        const { data: allRewards, error: rewardsError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('id, name, description, emoji, image_url, required_points, type, can_earn_multiple')
          .order('required_points', { ascending: true });

        if (rewardsError) throw rewardsError;

        // Get already earned rewards
        const { data: earnedRewards, error: earnedError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('reward_id')
          .eq('user_id', ctx.userId);

        if (earnedError) throw earnedError;

        // Filter out already earned one-time rewards
        const earnedIds = new Set((earnedRewards || []).map(er => er.reward_id));
        const availableRewards = allRewards?.filter(reward => 
          !earnedIds.has(reward.id) || reward.can_earn_multiple);

        return availableRewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch available rewards',
        });
      }
    }),

  // Get user points
  getUserPoints: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: userProfile, error } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (error) throw error;
        return {
          points: userProfile?.points || 0,
          lifetimePoints: userProfile?.lifetime_points || 0,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user points',
        });
      }
    }),

  // Earn a reward if eligible
  earnReward: protectedProcedure
    .input(claimLootInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get the reward details
        const { data: reward, error: rewardError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.rewardId)
          .single();

        if (rewardError || !reward) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Reward not found',
          });
        }

        // Check if user has enough points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        if (userProfile.points < reward.required_points) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Not enough points to earn this reward',
          });
        }

        // If the reward is one-time, check if already earned
        if (!reward.can_earn_multiple) {
          const { data: existingReward, error: existingError } = await ctx.supabaseAdmin
            .from('user_rewards')
            .select('id')
            .eq('user_id', ctx.userId)
            .eq('reward_id', input.rewardId)
            .single();

          if (existingReward) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'You have already earned this one-time reward',
            });
          }
        }

        // Begin transaction
        // 1. Deduct points from user
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: userProfile.points - reward.required_points,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // 2. Add reward to user's earned rewards
        const { data: userReward, error: insertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.rewardId,
            earned_at: new Date().toISOString(),
            points_spent: reward.required_points,
          })
          .select()
          .single();

        if (insertError) {
          // Rollback points if adding reward failed
          await ctx.supabaseAdmin
            .from('profiles')
            .update({
              points: userProfile.points,
            })
            .eq('id', ctx.userId);

          throw insertError;
        }

        return {
          success: true,
          reward: userReward,
          remainingPoints: userProfile.points - reward.required_points,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to earn reward',
        });
      }
    }),

  // Award points to user (e.g., for completing habits, tasks)
  awardPoints: protectedProcedure
    .input(awardBadgeInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get current user points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        // Get badge details
        const { data: badge, error: badgeError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.badgeId)
          .eq('type', 'badge')
          .single();

        if (badgeError || !badge) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Badge not found',
          });
        }

        // Default points to award
        const pointsToAward = 10;
        const currentPoints = userProfile.points || 0;
        const lifetimePoints = userProfile.lifetime_points || 0;
        const newPoints = currentPoints + pointsToAward;
        const newLifetimePoints = lifetimePoints + pointsToAward;

        // Update user points
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: newPoints,
            lifetime_points: newLifetimePoints,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // Record the point transaction
        const { data: pointTransaction, error: transactionError } = await ctx.supabaseAdmin
          .from('point_transactions')
          .insert({
            user_id: ctx.userId,
            points: pointsToAward,
            reason: `Earned badge: ${badge.name}`,
            source_type: 'badge',
            source_id: input.badgeId,
          })
          .select()
          .single();

        if (transactionError) throw transactionError;

        // Add badge to user's earned rewards
        const { data: userBadge, error: badgeInsertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.badgeId,
            reward_type: 'badge',
            earned_at: new Date().toISOString(),
            points_spent: 0, // Badges don't cost points
          })
          .select()
          .single();

        if (badgeInsertError) throw badgeInsertError;

        return {
          success: true,
          previousPoints: currentPoints,
          newPoints,
          pointsAdded: pointsToAward,
          transaction: pointTransaction,
          badge: userBadge,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to award badge',
        });
      }
    }),

  // Get point transaction history
  getPointHistory: protectedProcedure
    .input(z.object({
      limit: z.number().optional().default(20),
      cursor: z.string().optional(), // for pagination
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('point_transactions')
          .select('*')
          .eq('user_id', ctx.userId)
          .order('created_at', { ascending: false })
          .limit(input.limit);
          
        // Handle cursor-based pagination
        if (input.cursor) {
          query = query.lt('created_at', input.cursor);
        }
        
        const { data: transactions, error } = await query;

        if (error) throw error;
        
        // Determine if there are more results
        const lastItem = transactions && transactions.length > 0 
          ? transactions[transactions.length - 1] 
          : null;
          
        return {
          items: transactions || [],
          nextCursor: lastItem?.created_at,
          hasMore: (transactions?.length || 0) === input.limit,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch point history',
        });
      }
    }),
}); ```
\n\n## Realtime Channel: taskRouter.ts
**File:** ./server/src/routers/taskRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createTaskInput,
  updateTaskInput,
  updateTaskStatusInput,
  TaskStatusEnum, // Import the enum
  TaskPriorityEnum,
} from '../types/trpc-types';

// Define fields for selection consistency
const TASK_FIELDS =
  'id, user_id, title, notes, status, priority, due_date, goal_id, parent_task_id, recurrence_rule, recurrence_end_date, archived_at, sort_order, created_at, updated_at'; // Corrected: 'priority' instead of 'priority_enum' if that's the actual column name after migration
const GOAL_FIELDS = 'id, user_id, title, description, progress, target_date, archived_at, sort_order, created_at, updated_at';


// --- Helper function to update goal progress ---
async function updateGoalProgress(goalId: string, userId: string, supabase: any) {
  try {
    // 1. Fetch all non-archived tasks for the goal
    const { data: tasks, error: tasksError } = await supabase
      .from('tasks')
      .select('id, status') // Only need id and status
      .eq('goal_id', goalId)
      .eq('user_id', userId)
      .is('archived_at', null); // Exclude archived tasks

    if (tasksError) {
      console.error(`Error fetching tasks for goal ${goalId} during progress update:`, tasksError);
      // Decide how to handle this - maybe just log and skip update?
      return; // Exit if tasks can't be fetched
    }

    const totalTasks = tasks?.length || 0;
    const completedTasks = tasks?.filter((t: { status: string }) => t.status === TaskStatusEnum.enum.done).length || 0;

    // 2. Calculate progress (avoid division by zero)
    const newProgress = totalTasks > 0 ? completedTasks / totalTasks : 0;
    // Ensure progress is between 0 and 1, rounded to avoid floating point issues
    const clampedProgress = Math.round(Math.min(1, Math.max(0, newProgress)) * 100) / 100;

    // 3. Update the goal record
    const { error: updateError } = await supabase
      .from('goals')
      .update({ progress: clampedProgress })
      .eq('id', goalId)
      .eq('user_id', userId); // Ensure user owns the goal

    if (updateError) {
      console.error(`Error updating progress for goal ${goalId}:`, updateError);
      // Log error but don't necessarily throw, task toggle was successful
    } else {
        console.log(`Updated progress for goal ${goalId} to ${clampedProgress}`);
    }

  } catch (err) {
    console.error(`Unexpected error during goal progress update for goal ${goalId}:`, err);
    // Log unexpected errors
  }
}

export const taskRouter = router({
  getTasks: protectedProcedure // Gets non-archived tasks
    .input(z.object({
      goalId: z.string().uuid().optional(),
      // TODO: Add filters for status, priority, dates etc.?
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null); // Filter out archived

        if (input.goalId) {
          query = query.eq('goal_id', input.goalId);
        }

        // TODO: Add complex priority enum sorting? (e.g. high > medium > low)
        const { data: tasks, error } = await query
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('due_date', { ascending: true, nullsFirst: false }) // Order by due date (nulls last)
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tasks',
        });
      }
    }),

  getTaskById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(), // Use uuid validation
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!task) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found',
          });
        }

        // TODO: Parse with Task schema?
        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch task',
        });
      }
    }),

  createTask: protectedProcedure
    .input(createTaskInput) // Use imported input type
    .mutation(async ({ ctx, input }) => {
      try {
        // Verify goal_id if provided
        if (input.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', input.goal_id)
            .eq('user_id', ctx.userId) // Ensure goal belongs to user
            .is('archived_at', null) // Ensure goal is not archived
            .single();

          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived goal ID',
            });
          }
        }

        // Verify parent_task_id if provided
        if (input.parent_task_id) {
          const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
            .from('tasks')
            .select('id')
            .eq('id', input.parent_task_id)
            .eq('user_id', ctx.userId) // Ensure parent belongs to user
            .is('archived_at', null) // Ensure parent is not archived
            .single();

          if (parentError || !parentTask) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived parent task ID',
            });
          }
        }

        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .insert({
            ...input, // Spread validated input (includes new fields like parent_task_id, recurrence etc)
            user_id: ctx.userId,
            // Ensure due_date is used if present in input
            due_date: input.due_date ?? null, // Use correct field name
          })
          .select(TASK_FIELDS)
          .single();

        if (error) {
           // Handle specific errors like FK violations?
           console.error("Create task error:", error);
           throw error;
        }
        // TODO: Parse with Task schema?
        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create task',
        });
      }
    }),

  updateTask: protectedProcedure
    .input(updateTaskInput) // Use imported input type
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input; // Separate id from update payload

        // Check ownership
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id, parent_task_id') // Select parent_task_id for cycle check
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to update it',
          });
        }

        // Verify goal_id if being updated
        if (updateData.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', updateData.goal_id)
            .eq('user_id', ctx.userId)
            .is('archived_at', null)
            .single();

          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived goal ID',
            });
          }
        }
        // Handle setting goal_id to null
        if (updateData.goal_id === null) {
          updateData.goal_id = null;
        }

        // Verify parent_task_id if being updated
        if (updateData.parent_task_id) {
           // Basic cycle check
           if (updateData.parent_task_id === id) {
             throw new TRPCError({
               code: 'BAD_REQUEST',
               message: 'Task cannot be its own parent',
             });
           }
          const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
            .from('tasks')
            .select('id')
            .eq('id', updateData.parent_task_id)
            .eq('user_id', ctx.userId)
            .is('archived_at', null)
            .single();

          if (parentError || !parentTask) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived parent task ID',
            });
          }
          // TODO: Add deeper cycle detection if needed (check if new parent is a descendant)
        }
         // Handle setting parent_task_id to null
        if (updateData.parent_task_id === null) {
          updateData.parent_task_id = null;
        }

        // Ensure correct field name for due date if provided
        const payload: Record<string, any> = { ...updateData };
        if ('due_date' in payload) {
          payload.due_date = payload.due_date ?? null;
        }

        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update(payload) // Pass validated update data
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
             // Handle specific errors like FK violations?
           console.error("Update task error:", error);
           throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update task',
        });
      }
    }),

  deleteTask: protectedProcedure
    .input(z.object({
      id: z.string().uuid(), // Use uuid validation
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to delete it',
          });
        }

        // Delete the task (consider implications for subtasks - maybe archive instead?)
        // For now, direct delete.
        const { error } = await ctx.supabaseAdmin
          .from('tasks')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete task',
        });
      }
    }),

  // ---- Archive/Unarchive ----
  listArchivedTasks: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: tasks, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null) // Filter for archived tasks
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived tasks',
        });
      }
    }),

  archiveTask: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Consider archiving subtasks recursively?
      try {
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Task not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive task',
        });
      }
    }),

  unarchiveTask: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
       // TODO: Consider check if parent is archived?
      try {
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Task not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive task',
        });
      }
    }),

  // ---- Status Update ----
  updateTaskStatus: protectedProcedure
    .input(updateTaskStatusInput) // Uses { id: string().uuid(), status: TaskStatusEnum }
    .mutation(async ({ ctx, input }) => {
       try {
         // Check ownership first
         const { data: existing, error: fetchErr } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

         if (fetchErr || !existing) {
           throw new TRPCError({ code: 'NOT_FOUND', message: 'Task not found or permission denied.' });
         }

         // Perform update
         const { data: updatedTask, error: updateErr } = await ctx.supabaseAdmin
           .from('tasks')
           .update({ status: input.status })
           .eq('id', input.id)
           .select(TASK_FIELDS)
           .single();

         if (updateErr) throw updateErr;
         // TODO: Parse with Task schema?
         return updatedTask;
       } catch (error: any) {
         if (error instanceof TRPCError) throw error;
         throw new TRPCError({
           code: 'INTERNAL_SERVER_ERROR',
           message: error.message || 'Failed to update task status',
         });
       }
    }),

  // ---- Refactored Stubs ----
  listToday: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const todayStart = new Date();
        todayStart.setHours(0, 0, 0, 0);
        const todayEnd = new Date();
        todayEnd.setHours(23, 59, 59, 999);

        const { data: tasks, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .gte('due_date', todayStart.toISOString())
          .lte('due_date', todayEnd.toISOString())
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('due_date', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list tasks for today' });
      }
    }),

  listUpcoming: protectedProcedure
    .query(async ({ ctx }) => {
       try {
         const tomorrowStart = new Date();
         tomorrowStart.setDate(tomorrowStart.getDate() + 1);
         tomorrowStart.setHours(0, 0, 0, 0);

         const { data: tasks, error } = await ctx.supabaseAdmin
           .from('tasks')
           .select(TASK_FIELDS)
           .eq('user_id', ctx.userId)
           .is('archived_at', null)
           .gte('due_date', tomorrowStart.toISOString()) // Due date is tomorrow or later
           .order('due_date', { ascending: true, nullsFirst: false })
           .order('sort_order', { ascending: true, nullsFirst: false })
           .order('created_at', { ascending: false });

         if (error) throw error;
         // TODO: Parse with Task schema?
         return tasks || [];
       } catch (error: any) {
         throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list upcoming tasks' });
       }
    }),

 listOverdue: protectedProcedure
    .query(async ({ ctx }) => {
       try {
         const todayStart = new Date();
         todayStart.setHours(0, 0, 0, 0);

         const { data: tasks, error } = await ctx.supabaseAdmin
           .from('tasks')
           .select(TASK_FIELDS)
           .eq('user_id', ctx.userId)
           .is('archived_at', null)
           .lt('due_date', todayStart.toISOString()) // Due date is before today
           .not('status', 'in', `('${TaskStatusEnum.enum.done}')`) // Exclude completed tasks
           .order('due_date', { ascending: true, nullsFirst: false })
           .order('sort_order', { ascending: true, nullsFirst: false })
           .order('created_at', { ascending: false });

         if (error) throw error;
         // TODO: Parse with Task schema?
         return tasks || [];
       } catch (error: any) {
         throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list overdue tasks' });
       }
    }),

  toggleTask: protectedProcedure // Toggles between 'todo' and 'done'
    .input(z.object({
      taskId: z.string().uuid(),
      completed: z.boolean().optional() // Optional for backward compatibility
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // 1. Fetch the current task, including goal_id
        const { data: currentTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id, status, goal_id, title') // <-- Include goal_id and title
          .eq('id', input.taskId)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !currentTask) {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Task not found or permission denied.' });
        }

        // 2. Determine the new status
        let newStatus;
        if (input.completed !== undefined) {
          // If completed was explicitly provided, use it
          newStatus = input.completed ? TaskStatusEnum.enum.done : TaskStatusEnum.enum.todo;
        } else {
          // Otherwise toggle the current status
          newStatus = currentTask.status === TaskStatusEnum.enum.done
            ? TaskStatusEnum.enum.todo
            : TaskStatusEnum.enum.done;
        }

        // 3. Update the task status
        const { data: updatedTask, error: updateError } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ status: newStatus })
          .eq('id', input.taskId)
          .select(TASK_FIELDS) // Return the full updated task
          .single();

        if (updateError) throw updateError;

        // 4. *** NEW: Update goal progress if applicable ***
        if (currentTask.goal_id) {
           // Call the helper function asynchronously - no need to await here
           // unless the UI needs the updated goal immediately (unlikely for a toggle)
          updateGoalProgress(currentTask.goal_id, ctx.userId, ctx.supabaseAdmin);
        }

        // 5. Return the updated task
        return updatedTask;

      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        console.error("Error in toggleTask:", error); // Log unexpected errors
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to toggle task status',
        });
      }
    }),

  // --- Obsolete Stubs (keep or remove based on client usage) ---
  /*
  getTasksByGoal: protectedProcedure ... // Covered by getTasks with goalId filter
  getTodaysTasks: protectedProcedure ... // Replaced by listToday
  getUpcomingTasks: protectedProcedure ... // Replaced by listUpcoming
  updateTaskStatus_OLD: protectedProcedure ... // Replaced by updateTaskStatus and toggleTask
  */

});```
\n\n## Realtime Channel: valueRouter.ts
**File:** ./server/src/routers/valueRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createValueInput, updateValueInput } from '../types/trpc-types';

export const valueRouter = router({
  getValues: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: values, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return values;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch values',
        });
      }
    }),

  getValueById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!value) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found',
          });
        }

        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch value',
        });
      }
    }),

  createValue: protectedProcedure
    .input(createValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create value',
        });
      }
    }),

  updateValue: protectedProcedure
    .input(updateValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // First check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to update it',
          });
        }

        // Update the value
        const { data: updatedValue, error } = await ctx.supabaseAdmin
          .from('values')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return updatedValue;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update value',
        });
      }
    }),

  deleteValue: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to delete it',
          });
        }

        // Delete the value
        const { error } = await ctx.supabaseAdmin
          .from('values')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete value',
        });
      }
    }),
});```
\n\n## Realtime Channel: goalRouter.ts
**File:** ./server/src/routers/goalRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createGoalInput, updateGoalInput } from '../types/trpc-types';

const GOAL_FIELDS = 'id, user_id, title, description, progress, target_date, archived_at, sort_order, created_at, updated_at';

export const goalRouter = router({
  getGoals: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;

        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals',
        });
      }
    }),

  getGoalById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!goal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found',
          });
        }

        return goal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal',
        });
      }
    }),

  createGoal: protectedProcedure
    .input(createGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return goal;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal',
        });
      }
    }),

  updateGoal: protectedProcedure
    .input(updateGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to update it',
          });
        }

        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal',
        });
      }
    }),

  deleteGoal: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to delete it',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goals')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal',
        });
      }
    }),

  listActive: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals (in listActive stub)',
        });
      }
    }),

  listArchived: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived goals',
        });
      }
    }),

  archiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') { 
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive goal',
        });
      }
    }),

  unarchiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive goal',
        });
      }
    }),
});```
\n\n## Realtime Channel: goalProgressNoteRouter.ts
**File:** ./server/src/routers/goalProgressNoteRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createGoalProgressNoteInput,
  updateGoalProgressNoteInput,
  GetGoalProgressNotesInput,
  DeleteGoalProgressNoteInput,
} from '../types/trpc-types';

// Define fields for consistent selection
const GOAL_PROGRESS_NOTE_FIELDS = 'id, goal_id, user_id, note, created_at';

export const goalProgressNoteRouter = router({
  // Get all notes for a specific goal
  getNotesForGoal: protectedProcedure
    .input(GetGoalProgressNotesInput)
    .query(async ({ ctx, input }) => {
      try {
        // First, ensure the goal exists and belongs to the user
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        // Fetch the notes for that goal
        const { data, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .eq('user_id', ctx.userId) // Redundant check, but good practice
          .eq('goal_id', input.goal_id)
          .order('created_at', { ascending: false }); // Newest first

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal progress notes',
        });
      }
    }),

  createNote: protectedProcedure
    .input(createGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Ensure the goal exists and belongs to the user before adding a note
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        const { data: note, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return note;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal progress note',
        });
      }
    }),

  updateNote: protectedProcedure
    .input(updateGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership of the note
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { data: updatedNote, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return updatedNote;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal progress note',
        });
      }
    }),

  deleteNote: protectedProcedure
    .input(DeleteGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal progress note',
        });
      }
    }),
});
```
\n\n## Realtime Channel: trackedStateRouter.ts
**File:** ./server/src/routers/trackedStateRouter.ts
\n```
// File: server/src/routers/trackedStateRouter.ts

import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  // Ensure all necessary input types from trpc-types are imported
  createTrackedStateDefInput,
  updateTrackedStateDefInput,
  GetTrackedStateDefByIdInput,
  DeleteTrackedStateDefInput,
  CreateStateEntryInput,      // <--- Import for createEntry
  updateStateEntryInput,      // <--- Import for updateEntry
  GetStateEntriesInput,       // <--- Import for getEntries
  DeleteStateEntryInput       // <--- Import for deleteEntry
} from '../types/trpc-types';

// Use correct field names from database.types.ts & trpc-types.ts
const TRACKED_STATE_DEF_FIELDS = 'id, user_id, name, description, scale, custom_labels, unit, icon, target_min_value, target_max_value, created_at, updated_at, active, priority';
const STATE_ENTRY_FIELDS = 'id, user_id, definition_id, value_numeric, value_text, entry_timestamp, notes';

export const trackedStateRouter = router({
  getDefinitions: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('active', true)
          .order('priority', { ascending: true, nullsFirst: false }) // Corrected: nullsFirst
          .order('created_at', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tracked state definitions',
        });
      }
    }),

  getDefinitionById: protectedProcedure
    .input(GetTrackedStateDefByIdInput) // Use correct Zod schema
    .query(async ({ ctx, input }) => {
       try {
        const { data: definition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS)
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Tracked state definition not found.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return definition;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tracked state definition',
        });
      }
    }),

  createDefinition: protectedProcedure
    .input(createTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { data: definition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .insert({
            ...input, // input is now correctly typed
            user_id: ctx.userId,
          })
          .select(TRACKED_STATE_DEF_FIELDS)
          .single();

        if (error) throw error;
        return definition;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create tracked state definition',
        });
      }
    }),

  updateDefinition: protectedProcedure
    .input(updateTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { id, ...updateData } = input; // input is now correctly typed

        const { error: fetchError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Definition not found or access denied.',
          });
        }

        const { data: updatedDefinition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(TRACKED_STATE_DEF_FIELDS)
          .single();

        if (error) throw error;
        return updatedDefinition;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update tracked state definition',
        });
      }
    }),

  deleteDefinition: protectedProcedure
    .input(DeleteTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Definition not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .delete()
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id }; // input.id is now correctly typed
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete tracked state definition',
        });
      }
    }),

  // --- State Entry Procedures ---

  getEntries: protectedProcedure
    .input(GetStateEntriesInput) // <<<--- ADDED .input() BINDING
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('state_entries')
          .select(STATE_ENTRY_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('definition_id', input.tracked_state_def_id); // input is now typed

        if (input.startDate) { // input is now typed
          query = query.gte('entry_timestamp', input.startDate);
        }
        if (input.endDate) { // input is now typed
          query = query.lte('entry_timestamp', input.endDate);
        }

        query = query.order('entry_timestamp', { ascending: false });

        if (input.limit) { // input is now typed
          query = query.limit(input.limit);
        }

        const { data: entries, error } = await query;

        if (error) throw error;
        return entries ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch state entries',
        });
      }
    }),

  createEntry: protectedProcedure
    .input(CreateStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
      try {
        // Check definition ownership (already implemented correctly)
        const { error: defError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', input.tracked_state_def_id) // input is now typed
          .eq('user_id', ctx.userId)
          .single();

        if (defError) {
          throw new TRPCError({
            code: defError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Tracked state definition not found or invalid.',
          });
        }

        // Insert typed data
        const { data: entry, error } = await ctx.supabaseAdmin
          .from('state_entries')
          .insert({
            user_id: ctx.userId,
            definition_id: input.tracked_state_def_id, // input is now typed
            value_numeric: input.value_numeric,     // input is now typed
            value_text: input.value_text,         // input is now typed
            entry_timestamp: input.entry_timestamp || new Date().toISOString(), // input is now typed
            notes: input.notes,                 // input is now typed
          })
          .select(STATE_ENTRY_FIELDS)
          .single();

        if (error) throw error;
        return entry;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create state entry',
        });
      }
    }),

  updateEntry: protectedProcedure
    .input(updateStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input; // input is now typed

        // Check ownership (already implemented correctly)
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('state_entries')
          .select('id')
          .eq('id', id) // Use id from destructured input
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Entry not found or access denied.',
          });
        }

        // updateData is now correctly typed from the input schema
        const { data: updatedEntry, error } = await ctx.supabaseAdmin
          .from('state_entries')
          .update(updateData)
          .eq('id', id) // Use id from destructured input
          .eq('user_id', ctx.userId)
          .select(STATE_ENTRY_FIELDS)
          .single();

        if (error) throw error;
        return updatedEntry;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update state entry',
        });
      }
    }),

  deleteEntry: protectedProcedure
    .input(DeleteStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
       try {
        // Check ownership (already implemented correctly)
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('state_entries')
          .select('id')
          .eq('id', input.id) // input is now typed
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Entry not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('state_entries')
          .delete()
          .eq('id', input.id) // input is now typed
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id }; // input is now typed
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete state entry',
        });
      }
    }),
});```
\n\n## Realtime Channel: userRouter.ts
**File:** ./server/src/routers/userRouter.ts
\n```
import { z } from 'zod';
import { router, protectedProcedure, publicProcedure } from '../router';
import { TRPCError } from '@trpc/server';

export const userRouter = router({
  getProfile: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('id, username, avatar_url, full_name, bio, time_zone, onboarding_completed, created_at, updated_at')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  updateProfile: protectedProcedure
    .input(z.object({
      full_name: z.string().optional(),
      avatar_url: z.string().optional(),
      theme: z.string().optional(),
      time_zone: z.string().optional(),
      display_name: z.string().optional(),
      bio: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update(input)
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getUserSettings: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('id, user_id, notification_preferences, ui_preferences')
        .eq('user_id', ctx.userId)
        .single();
        
      if (error) {
        // If settings don't exist, create default settings
        if (error.code === 'PGRST116') {
          const { data: newSettings, error: createError } = await ctx.supabaseAdmin
            .from('user_settings')
            .insert({
              user_id: ctx.userId,
              notification_preferences: {
                email: true,
                push: true,
                task_reminders: true,
                goal_updates: true,
                habit_reminders: true
              },
              ui_preferences: {
                theme: 'system',
                compact_view: false,
                show_completed_tasks: true
              }
            })
            .select()
            .single();
            
          if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
          return newSettings;
        }
        
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      }
      
      return data;
    }),
    
  updateUserSettings: protectedProcedure
    .input(z.object({
      notification_preferences: z.object({
        email: z.boolean().optional(),
        push: z.boolean().optional(),
        task_reminders: z.boolean().optional(),
        goal_updates: z.boolean().optional(),
        habit_reminders: z.boolean().optional()
      }).optional(),
      ui_preferences: z.object({
        theme: z.string().optional(),
        compact_view: z.boolean().optional(),
        show_completed_tasks: z.boolean().optional()
      }).optional()
    }))
    .mutation(async ({ ctx, input }) => {
      // First check if settings exist
      const { data: existingSettings, error: fetchError } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('id')
        .eq('user_id', ctx.userId)
        .single();
        
      if (fetchError && fetchError.code === 'PGRST116') {
        // Create settings if they don't exist
        const defaultSettings = {
          user_id: ctx.userId,
          notification_preferences: {
            email: true,
            push: true,
            task_reminders: true,
            goal_updates: true,
            habit_reminders: true,
            ...input.notification_preferences
          },
          ui_preferences: {
            theme: 'system',
            compact_view: false,
            show_completed_tasks: true,
            ...input.ui_preferences
          }
        };
        
        const { data, error } = await ctx.supabaseAdmin
          .from('user_settings')
          .insert(defaultSettings)
          .select()
          .single();
          
        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        return data;
      } else if (fetchError) {
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: fetchError.message });
      }
      
      // Update existing settings
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .update(input)
        .eq('user_id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getOnboardingStatus: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('id, onboarding_completed')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { onboardingCompleted: data?.onboarding_completed || false };
    }),
    
  completeOnboarding: protectedProcedure
    .mutation(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update({ onboarding_completed: true })
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { success: true };
    }),
}); ```
\n\n## Realtime Channel: index.ts
**File:** ./server/src/index.ts
\n```
import express, { Request, Response } from 'express';
import cors from 'cors';
import { createExpressMiddleware } from '@trpc/server/adapters/express';
import { appRouter } from './router';
import { createContext } from './context';

const app = express();
const port = process.env.PORT || 3000;

// Enable CORS for client app
app.use(cors({
  origin: ['http://localhost:8081', 'http://localhost:19000', 'http://localhost:19006', 'exp://localhost:19000'],
  credentials: true,
}));

// Health check endpoint
app.get('/health', (_: Request, res: Response) => {
  res.status(200).json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Create tRPC middleware
app.use('/api/trpc', createExpressMiddleware({
  router: appRouter,
  createContext,
}));

// Start server
app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
  console.log(`tRPC API available at http://localhost:${port}/api/trpc`);
}); ```
\n\n## Realtime Channel: offline-sync.ts
**File:** ./utils/offline-sync.ts
\n```
import AsyncStorage from '@react-native-async-storage/async-storage';
import NetInfo from '@react-native-community/netinfo';
import { queryClient } from './query-client';
import { supabase } from './supabase';

// Keys for offline data
const OFFLINE_MUTATIONS_KEY = 'aether-offline-mutations';
const PENDING_ITEMS_KEY = 'aether-pending-items';

// Types
export interface PendingItem {
  id: string;
  type: string;
  data: any;
  createdAt: number;
  isNotSynced: boolean;
}

interface OfflineMutation {
  id: string;
  type: 'create' | 'update' | 'delete';
  entity: string;
  data: any;
  timestamp: number;
}

/**
 * Save a mutation to be processed when back online
 */
export async function saveOfflineMutation(
  type: 'create' | 'update' | 'delete',
  entity: string,
  data: any
): Promise<string> {
  try {
    // Generate a temporary ID for new items
    const id = `temp-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
    
    // Create mutation object
    const mutation: OfflineMutation = {
      id,
      type,
      entity,
      data,
      timestamp: Date.now(),
    };
    
    // Get existing mutations
    const existingMutationsStr = await AsyncStorage.getItem(OFFLINE_MUTATIONS_KEY);
    const existingMutations: OfflineMutation[] = existingMutationsStr 
      ? JSON.parse(existingMutationsStr) 
      : [];
    
    // Add new mutation
    existingMutations.push(mutation);
    
    // Save mutations back to storage
    await AsyncStorage.setItem(OFFLINE_MUTATIONS_KEY, JSON.stringify(existingMutations));
    
    // Also add to pending items for UI
    if (type === 'create' || type === 'update') {
      await addToPendingItems(id, entity, data);
    }
    
    return id;
  } catch (error) {
    console.error('Error saving offline mutation:', error);
    throw error;
  }
}

/**
 * Add an item to the pending items list for UI display
 */
async function addToPendingItems(id: string, type: string, data: any): Promise<void> {
  try {
    const existingItemsStr = await AsyncStorage.getItem(PENDING_ITEMS_KEY);
    const existingItems: PendingItem[] = existingItemsStr 
      ? JSON.parse(existingItemsStr)
      : [];
    
    // Create a pending item
    const pendingItem: PendingItem = {
      id,
      type,
      data,
      createdAt: Date.now(),
      isNotSynced: true,
    };
    
    // Add to list
    existingItems.push(pendingItem);
    
    // Save back to storage
    await AsyncStorage.setItem(PENDING_ITEMS_KEY, JSON.stringify(existingItems));
  } catch (error) {
    console.error('Error adding to pending items:', error);
  }
}

/**
 * Get all pending items for a specific type
 */
export async function getPendingItems(type: string): Promise<PendingItem[]> {
  try {
    const itemsStr = await AsyncStorage.getItem(PENDING_ITEMS_KEY);
    if (!itemsStr) return [];
    
    const items: PendingItem[] = JSON.parse(itemsStr);
    return items.filter(item => item.type === type);
  } catch (error) {
    console.error('Error getting pending items:', error);
    return [];
  }
}

/**
 * Synchronize offline mutations with the server
 */
export async function syncOfflineMutations(): Promise<boolean> {
  try {
    // Check if we're online
    const netInfo = await NetInfo.fetch();
    if (!netInfo.isConnected || netInfo.isInternetReachable === false) {
      console.log('Not connected to the internet, skipping sync');
      return false;
    }
    
    // Get all pending mutations
    const mutationsStr = await AsyncStorage.getItem(OFFLINE_MUTATIONS_KEY);
    if (!mutationsStr) return true; // Nothing to sync
    
    const mutations: OfflineMutation[] = JSON.parse(mutationsStr);
    if (!mutations.length) return true; // Nothing to sync
    
    console.log(`Syncing ${mutations.length} offline mutations...`);
    
    // Process each mutation in order
    const results = await Promise.allSettled(
      mutations.map(async (mutation) => {
        try {
          switch (mutation.type) {
            case 'create':
              return await processMutation('create', mutation);
            case 'update':
              return await processMutation('update', mutation);
            case 'delete':
              return await processMutation('delete', mutation);
            default:
              console.error('Unknown mutation type:', mutation.type);
              return false;
          }
        } catch (error) {
          console.error('Error processing mutation:', error);
          return false;
        }
      })
    );
    
    // Check results
    const allSucceeded = results.every(
      result => result.status === 'fulfilled' && result.value === true
    );
    
    if (allSucceeded) {
      // Clear pending mutations if all succeeded
      await AsyncStorage.removeItem(OFFLINE_MUTATIONS_KEY);
      await AsyncStorage.removeItem(PENDING_ITEMS_KEY);
      
      // Invalidate queries to refresh data
      queryClient.invalidateQueries();
      
      return true;
    } else {
      // Some mutations failed, remove the successful ones
      const successfulMutationIndexes = results.map((result, index) => 
        result.status === 'fulfilled' && result.value === true ? index : -1
      ).filter(index => index !== -1);
      
      const remainingMutations = mutations.filter(
        (_, index) => !successfulMutationIndexes.includes(index)
      );
      
      // Save remaining mutations
      await AsyncStorage.setItem(
        OFFLINE_MUTATIONS_KEY, 
        JSON.stringify(remainingMutations)
      );
      
      // Refresh query data
      queryClient.invalidateQueries();
      
      return false;
    }
  } catch (error) {
    console.error('Error syncing offline mutations:', error);
    return false;
  }
}

/**
 * Process a single mutation against the server
 */
async function processMutation(
  type: 'create' | 'update' | 'delete',
  mutation: OfflineMutation
): Promise<boolean> {
  try {
    // Get the entity table name
    const table = mutation.entity;
    
    switch (type) {
      case 'create': {
        // For create, we remove any temp id and insert the record
        const { id, ...data } = mutation.data;
        const { data: responseData, error } = await supabase
          .from(table)
          .insert(data)
          .select();
          
        if (error) throw error;
        return true;
      }
      
      case 'update': {
        // For update, we update the record by ID
        const { id, ...data } = mutation.data;
        const { error } = await supabase
          .from(table)
          .update(data)
          .eq('id', id);
          
        if (error) throw error;
        return true;
      }
      
      case 'delete': {
        // For delete, we delete the record by ID
        const { error } = await supabase
          .from(table)
          .delete()
          .eq('id', mutation.data.id);
          
        if (error) throw error;
        return true;
      }
      
      default:
        return false;
    }
  } catch (error) {
    console.error('Error processing mutation:', error);
    return false;
  }
}

/**
 * Hook up background sync when app comes online
 */
export function setupBackgroundSync(): () => void {
  // Subscribe to network changes
  const unsubscribe = NetInfo.addEventListener(state => {
    // When we go from offline to online, sync mutations
    if (state.isConnected && state.isInternetReachable !== false) {
      syncOfflineMutations()
        .then(success => {
          console.log('Background sync completed:', success ? 'success' : 'with errors');
        })
        .catch(error => {
          console.error('Background sync failed:', error);
        });
    }
  });
  
  return unsubscribe;
} ```
\n\n## Realtime Channel: settings.ts
**File:** ./utils/settings.ts
\n```
import * as SecureStore from 'expo-secure-store';
import { Platform } from 'react-native';

// Settings keys
export const APP_SETTINGS_KEY = 'aether_app_settings';

// Default settings
const DEFAULT_SETTINGS = {
  enableNotifications: true,
  enableDarkMode: null, // null means "use system setting"
  enableOfflineMode: true,
  syncOnCellular: true,
  lastSyncTimestamp: null,
};

// Type for app settings
export type AppSettings = typeof DEFAULT_SETTINGS;

/**
 * Get app settings from secure storage
 */
export async function getSettings(): Promise<AppSettings> {
  try {
    const storedSettings = await SecureStore.getItemAsync(APP_SETTINGS_KEY);
    if (!storedSettings) return DEFAULT_SETTINGS;
    
    return { ...DEFAULT_SETTINGS, ...JSON.parse(storedSettings) };
  } catch (error) {
    console.error('Error getting settings:', error);
    return DEFAULT_SETTINGS;
  }
}

/**
 * Save app settings to secure storage
 */
export async function saveSettings(settings: Partial<AppSettings>): Promise<void> {
  try {
    const currentSettings = await getSettings();
    const newSettings = { ...currentSettings, ...settings };
    
    await SecureStore.setItemAsync(
      APP_SETTINGS_KEY, 
      JSON.stringify(newSettings)
    );
  } catch (error) {
    console.error('Error saving settings:', error);
  }
}

/**
 * Update a single setting
 */
export async function updateSetting<K extends keyof AppSettings>(
  key: K, 
  value: AppSettings[K]
): Promise<void> {
  await saveSettings({ [key]: value } as Partial<AppSettings>);
}

/**
 * Get app version
 */
export function getAppVersion(): string {
  // In a real app, you would use expo-constants to get the app version
  // import Constants from 'expo-constants';
  // return Constants.expoConfig.version;
  return '1.0.0';
}

/**
 * Get platform information
 */
export function getPlatformInfo(): string {
  return `${Platform.OS} ${Platform.Version}`;
} ```
\n\n## Realtime Channel: nats-client.ts
**File:** ./utils/nats-client.ts
\n```
import { QueryClient } from '@tanstack/react-query';
import { connect, type ConnectionOptions, type NatsConnection, StringCodec } from 'nats.ws';

// Codec for encoding/decoding NATS messages
const sc = StringCodec();

// Type for cache update handlers
type CacheUpdateHandler = (data: any) => void;

// Global handlers for different subjects
const handlers: Record<string, CacheUpdateHandler[]> = {};

// Connection state
let natsConnection: NatsConnection | null = null;
let queryClient: QueryClient | null = null;
let isConnecting = false;

/**
 * Initialize the NATS client and connect to the server
 */
export async function initNatsClient(
  url: string, 
  qc: QueryClient,
  options: Partial<ConnectionOptions> = {}
): Promise<NatsConnection> {
  if (natsConnection) {
    return natsConnection;
  }
  
  if (isConnecting) {
    throw new Error('NATS connection is already in progress');
  }
  
  isConnecting = true;
  
  try {
    // Set the query client for cache updates
    queryClient = qc;
    
    // Connect to NATS server
    natsConnection = await connect({
      servers: url,
      // Add required polyfills for React Native
      // These would need to be properly implemented in a real app
      ...options,
    });
    
    console.log('Connected to NATS server');
    
    // Setup ping interval to keep connection alive
    const pingInterval = setInterval(() => {
      if (natsConnection && !natsConnection.isClosed) {
        // Note: Using a custom ping mechanism instead of the built-in one
        try {
          const start = Date.now();
          // Simple ping using a request to a dummy subject
          natsConnection.request('_PING_', undefined, { timeout: 1000 })
            .then(() => {
              const latency = Date.now() - start;
              console.log(`NATS server latency: ${latency}ms`);
            })
            .catch((err: Error) => {
              console.error('NATS ping error:', err.message);
            });
        } catch (err) {
          const error = err as Error;
          console.error('NATS ping error:', error.message);
        }
      } else {
        clearInterval(pingInterval);
      }
    }, 30000);
    
    // Handle connection close
    natsConnection.closed().then(() => {
      console.log('NATS connection closed');
      natsConnection = null;
      clearInterval(pingInterval);
      // Could implement reconnection logic here
    });
    
    return natsConnection;
  } catch (error) {
    console.error('Failed to connect to NATS server:', error);
    isConnecting = false;
    throw error;
  }
}

/**
 * Subscribe to a NATS subject and update the React Query cache
 */
export async function subscribeWithCache(
  subject: string,
  queryKey: unknown[],
  updateType: 'invalidate' | 'setData' = 'invalidate'
): Promise<() => void> {
  if (!natsConnection) {
    throw new Error('NATS client not initialized');
  }
  
  if (!queryClient) {
    throw new Error('QueryClient not set');
  }
  
  // Create subscription
  const subscription = natsConnection.subscribe(subject);
  
  // Setup message handler
  (async () => {
    for await (const msg of subscription) {
      try {
        const data = JSON.parse(sc.decode(msg.data));
        
        if (updateType === 'invalidate') {
          // Invalidate the cache for this query key
          queryClient.invalidateQueries({ queryKey });
        } else {
          // Update the cache directly
          queryClient.setQueryData(queryKey, data);
        }
        
        // Call any custom handlers
        if (handlers[subject]) {
          handlers[subject].forEach(handler => handler(data));
        }
      } catch (error) {
        const err = error as Error;
        console.error(`Error handling message for ${subject}:`, err.message);
      }
    }
  })();
  
  // Return unsubscribe function
  return () => {
    subscription.unsubscribe();
  };
}

/**
 * Add a custom handler for a subject
 */
export function addSubjectHandler(subject: string, handler: CacheUpdateHandler): () => void {
  if (!handlers[subject]) {
    handlers[subject] = [];
  }
  
  handlers[subject].push(handler);
  
  // Return a function to remove the handler
  return () => {
    if (handlers[subject]) {
      handlers[subject] = handlers[subject].filter(h => h !== handler);
    }
  };
}

/**
 * Get the NATS connection
 */
export function getNatsConnection(): NatsConnection | null {
  return natsConnection;
}

/**
 * Close the NATS connection
 */
export async function closeNatsConnection(): Promise<void> {
  if (natsConnection) {
    await natsConnection.close();
    natsConnection = null;
  }
} ```
\n\n## Realtime Channel: supabase.ts
**File:** ./utils/supabase.ts
\n```
import 'react-native-url-polyfill/auto';
import { createClient } from '@supabase/supabase-js';
import * as SecureStore from 'expo-secure-store';

// SecureStore adapter for Supabase auth persistence
const ExpoSecureStoreAdapter = {
  getItem: (key: string) => {
    return SecureStore.getItemAsync(key);
  },
  setItem: (key: string, value: string) => {
    return SecureStore.setItemAsync(key, value);
  },
  removeItem: (key: string) => {
    return SecureStore.deleteItemAsync(key);
  },
};

// Get Supabase URL and anon key from environment variables
// In production, these should be set in app.config.js or via EAS secrets
const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL || '';
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY || '';

if (!supabaseUrl || !supabaseAnonKey) {
  console.warn(
    'Supabase URL or anon key not found. Make sure to set EXPO_PUBLIC_SUPABASE_URL and EXPO_PUBLIC_SUPABASE_ANON_KEY environment variables.'
  );
}

// Create Supabase client
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: ExpoSecureStoreAdapter,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
});

// Helper function to check if user is authenticated
export const isAuthenticated = async () => {
  const { data, error } = await supabase.auth.getSession();
  return !!data.session;
};

// Helper function to get current user
export const getCurrentUser = async () => {
  const { data, error } = await supabase.auth.getUser();
  if (error) {
    console.error('Error getting user:', error.message);
    return null;
  }
  return data.user;
}; ```
\n\n## Realtime Channel: mock-api.ts
**File:** ./utils/mock-api.ts
\n```
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

// Initialize tRPC for our mock API
const t = initTRPC.create();

// Export a procedure builder
const router = t.router;
const publicProcedure = t.procedure;

// Example router with some procedures
export const appRouter = router({
  greeting: {
    hello: publicProcedure
      .input(z.object({ name: z.string().optional() }))
      .query(({ input }) => {
        return {
          greeting: `Hello ${input.name ?? 'world'}`,
        };
      }),
    goodbye: publicProcedure
      .query(() => {
        return {
          greeting: 'Goodbye!',
        };
      }),
  },
  user: {
    get: publicProcedure
      .input(z.object({ id: z.string() }))
      .query(({ input }) => {
        return {
          id: input.id,
          name: 'Mock User',
        };
      }),
    list: publicProcedure
      .query(() => {
        return [
          { id: '1', name: 'Mock User 1' },
          { id: '2', name: 'Mock User 2' },
        ];
      }),
  },
  auth: {
    refreshToken: publicProcedure
      .input(z.object({ refreshToken: z.string() }))
      .mutation(async ({ input }) => {
        console.log('Mock API: refreshToken called with', input.refreshToken);
        // Simulate checking refresh token and issuing new ones
        await new Promise(resolve => setTimeout(resolve, 300));
        if (input.refreshToken === 'valid-refresh-token') { // Example valid token
          return {
            accessToken: `mock-access-${Date.now()}`,
            refreshToken: `mock-refresh-${Date.now()}`,
          };
        } else {
          // Throw error for invalid refresh token
          throw new Error('Invalid refresh token'); 
        }
      }),
    // Add login/logout mutations here later
  },
  item: {
    add: publicProcedure
      .input(z.object({ name: z.string() }))
      .mutation(async ({ input }) => {
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 500));
        // In a real backend, save to DB
        console.log('Mock API: Adding item', input);
        return {
          id: Math.random().toString(36).substring(7), // Generate random ID
          name: input.name,
          status: 'added'
        };
      }),
  },
});

// Export type router type
export type AppRouter = typeof appRouter; ```
\n\n## Realtime Channel: Skeleton.tsx
**File:** ./components/ui/Skeleton.tsx
\n```
import React from 'react';
import { DimensionValue } from 'react-native';
import { YStack, XStack, styled, Stack } from 'tamagui';
import { useColorScheme } from '@/hooks/useColorScheme';

const SkeletonBase = styled(Stack, {
  name: 'SkeletonBase',
  backgroundColor: '$gray5',
  overflow: 'hidden',
  position: 'relative',
  variants: {
    colorMode: {
      light: { backgroundColor: '$gray5' },
      dark: { backgroundColor: '$gray9' },
    },
  } as const,
});

const SkeletonShimmer = styled(Stack, {
  name: 'SkeletonShimmer',
  position: 'absolute',
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  opacity: 0.5,
});

interface SkeletonProps {
  width?: DimensionValue;
  height?: DimensionValue;
  borderRadius?: number;
}

export function Skeleton({ width = '100%', height = 20, borderRadius = 4 }: SkeletonProps) {
  const colorScheme = useColorScheme();
  
  return (
    <SkeletonBase
      colorMode={colorScheme === 'dark' ? 'dark' : 'light'}
      width={width}
      height={height}
      borderRadius={borderRadius}
    />
  );
}

interface SkeletonRowProps {
  height?: DimensionValue;
  width?: DimensionValue;
  lines?: number;
  spacing?: number;
}

export function SkeletonRow({ height = 20, width = '100%', lines = 3, spacing = 10 }: SkeletonRowProps) {
  return (
    <YStack space={spacing}>
      {Array.from({ length: lines }).map((_, i) => (
        <Skeleton 
          key={i}
          height={height}
          width={i === lines - 1 && typeof width === 'string' ? '70%' : width}
        />
      ))}
    </YStack>
  );
}

interface SkeletonCardProps {
  height?: DimensionValue;
  width?: DimensionValue;
}

export function SkeletonCard({ height = 100, width = '100%' }: SkeletonCardProps) {
  return (
    <YStack space="$2">
      <Skeleton height={height} width={width} borderRadius={8} />
    </YStack>
  );
}

interface SkeletonAvatarProps {
  size?: number;
}

export function SkeletonAvatar({ size = 40 }: SkeletonAvatarProps) {
  return <Skeleton width={size} height={size} borderRadius={size / 2} />;
}

interface SkeletonProfileProps {
  avatarSize?: number;
}

export function SkeletonProfile({ avatarSize = 40 }: SkeletonProfileProps) {
  return (
    <XStack space="$3" alignItems="center">
      <SkeletonAvatar size={avatarSize} />
      <YStack space="$1" flex={1}>
        <Skeleton width="60%" height={16} />
        <Skeleton width="40%" height={12} />
      </YStack>
    </XStack>
  );
}

interface SkeletonCircleProps {
  size?: number;
}

export function SkeletonCircle({ size = 60 }: SkeletonCircleProps) {
  return <Skeleton width={size} height={size} borderRadius={size / 2} />;
}
```
\n\n## Realtime Channel: HabitTracker.tsx
**File:** ./components/planner/HabitTracker.tsx
\n```
import React, { useState } from "react";
import { View, StyleSheet } from "react-native";
import { XStack, YStack, Text, Button, H4, Separator } from "tamagui";
import StreakCalendar from './StreakCalendar';
import { Plus, Check } from "@tamagui/lucide-icons";
import { format } from "date-fns";

interface Habit {
  id: string;
  name: string;
  description?: string;
  completedDates: string[]; // ISO date strings
}

interface HabitTrackerProps {
  habits: Habit[];
  onAddHabit?: () => void;
  onToggleHabit?: (habitId: string, date: string, completed: boolean) => void;
  onHabitPress?: (habit: Habit) => void;
}

export function HabitTracker({
  habits = [],
  onAddHabit,
  onToggleHabit,
  onHabitPress,
}: HabitTrackerProps) {
  const today = format(new Date(), "yyyy-MM-dd");

  const handleToggleHabit = (habit: Habit) => {
    if (!onToggleHabit) return;
    
    const isCompleted = habit.completedDates.includes(today);
    onToggleHabit(habit.id, today, !isCompleted);
  };

  return (
    <YStack space="$4">
      <XStack justifyContent="space-between" alignItems="center">
        <H4>Habits</H4>
        <Button 
          size="$2" 
          circular 
          icon={<Plus size={16} />} 
          onPress={onAddHabit}
        />
      </XStack>

      {habits.length === 0 ? (
        <YStack 
          p="$4"
          alignItems="center" 
          justifyContent="center" 
          backgroundColor="$gray2" 
          borderRadius="$4"
        >
          <Text color="$gray11" textAlign="center">
            No habits yet. Add your first habit to start tracking.
          </Text>
        </YStack>
      ) : (
        <YStack space="$3">
          {habits.map((habit, index) => (
            <YStack key={habit.id} space="$2">
              {index > 0 && <Separator />}
              <HabitItem 
                habit={habit} 
                onToggle={() => handleToggleHabit(habit)}
                onPress={() => onHabitPress?.(habit)} 
              />
            </YStack>
          ))}
        </YStack>
      )}
    </YStack>
  );
}

interface HabitItemProps {
  habit: Habit;
  onToggle: () => void;
  onPress: () => void;
}

function HabitItem({ habit, onToggle, onPress }: HabitItemProps) {
  const today = format(new Date(), "yyyy-MM-dd");
  const isCompletedToday = habit.completedDates.includes(today);

  return (
    <XStack 
      p="$3"
      borderRadius="$4" 
      backgroundColor="$gray2"
      justifyContent="space-between"
      alignItems="center"
      pressStyle={{ opacity: 0.8 }}
      onPress={onPress}
    >
      <YStack space="$1" flex={1}>
        <Text fontSize="$3" fontWeight="$5">
          {habit.name}
        </Text>
        {habit.description && (
          <Text fontSize="$2" color="$gray11">
            {habit.description}
          </Text>
        )}
        
        <YStack mt="$2">
          <StreakCalendar
            completedDates={habit.completedDates}
          />
        </YStack>
      </YStack>

      <Button
        size="$3"
        circular
        backgroundColor={isCompletedToday ? "$primary9" : "$gray4"}
        onPress={(e) => {
          e.stopPropagation();
          onToggle();
        }}
        pressStyle={{
          backgroundColor: isCompletedToday ? "$primary8" : "$gray5",
        }}
      >
        <Check 
          size={18} 
          color={isCompletedToday ? "$gray1" : "$gray11"} 
        />
      </Button>
    </XStack>
  );
} ```
\n\n## Realtime Channel: EmptyOrSkeleton.tsx
**File:** ./components/EmptyOrSkeleton.tsx
\n```
import React, { ReactNode } from 'react';
import { StyleSheet, StyleProp, ViewStyle, TextStyle, ImageStyle, ImageSourcePropType, View, Image } from 'react-native';
import Animated from 'react-native-reanimated';
import { Text, YStack, StackProps } from 'tamagui';
import { useSkeleton, SkeletonOptions } from '@/hooks/useSkeleton';

export interface EmptyStateProps {
  /** Title text for the empty state */
  title?: string;
  /** Subtitle/description text for the empty state */
  message?: string;
  /** Optional image/illustration to display */
  image?: ImageSourcePropType;
  /** Optional custom component to render instead of default empty state */
  customEmptyComponent?: ReactNode;
  /** Style for the container */
  containerStyle?: StyleProp<ViewStyle>;
  /** Style for the title */
  titleStyle?: StyleProp<TextStyle>;
  /** Style for the message */
  messageStyle?: StyleProp<TextStyle>;
  /** Style for the image container */
  imageContainerStyle?: StyleProp<ViewStyle>;
  /** Style for the image */
  imageStyle?: StyleProp<ImageStyle>;
}

export interface EmptyOrSkeletonProps extends EmptyStateProps, StackProps {
  /** Whether data is loading */
  isLoading: boolean;
  /** Children to display when not loading and not empty */
  children: ReactNode;
  /** Whether the content is empty (no data) */
  isEmpty?: boolean;
  /** Number of skeleton placeholders to display when loading */
  skeletonCount?: number;
  /** Height of each skeleton item */
  skeletonHeight?: number;
  /** Width of each skeleton item (default: 100%) */
  skeletonWidth?: number | string;
  /** Gap between skeleton items */
  skeletonGap?: number;
  /** Border radius for skeleton items */
  skeletonBorderRadius?: number;
  /** Custom skeleton component */
  customSkeletonComponent?: ReactNode;
  /** Options for the skeleton animation */
  skeletonOptions?: SkeletonOptions;
}

/**
 * Placeholder component for the skeleton loading state
 */
const SkeletonPlaceholder = ({
  height, 
  width = '100%',
  borderRadius = 8,
  options
}: {
  height: number;
  width?: number | string;
  borderRadius?: number;
  options?: SkeletonOptions;
}) => {
  const { shimmerStyle, styles } = useSkeleton(options);
  
  return (
    <Animated.View 
      style={[
        styles.container, 
        { 
          height,
          width: typeof width === 'string' ? width : width,
          borderRadius
        } as ViewStyle
      ]}
    >
      <Animated.View style={[styles.shimmer, shimmerStyle]} />
    </Animated.View>
  );
};

/**
 * Default empty state component
 */
const EmptyState = ({
  title = 'No data found',
  message = 'There is nothing to display at the moment.',
  image,
  containerStyle,
  titleStyle,
  messageStyle,
  imageContainerStyle,
  imageStyle
}: EmptyStateProps) => {
  return (
    <YStack
      alignItems="center"
      justifyContent="center"
      padding="$4"
      space="$3"
      style={containerStyle}
    >
      {image && (
        <View style={[styles.imageContainer, imageContainerStyle]}>
          <Image source={image} style={[styles.image, imageStyle]} />
        </View>
      )}
      <Text 
        fontSize="$6" 
        fontWeight="bold" 
        textAlign="center"
        style={titleStyle}
      >
        {title}
      </Text>
      <Text 
        fontSize="$4" 
        color="$gray10" 
        textAlign="center"
        style={messageStyle}
      >
        {message}
      </Text>
    </YStack>
  );
};

/**
 * A component that conditionally renders skeleton, empty state, or content
 * based on loading and data states.
 */
export default function EmptyOrSkeleton({
  isLoading,
  isEmpty = false,
  children,
  skeletonCount = 3,
  skeletonHeight = 80,
  skeletonWidth = '100%',
  skeletonGap = 12,
  skeletonBorderRadius = 8,
  customSkeletonComponent,
  customEmptyComponent,
  skeletonOptions,
  title,
  message,
  image,
  containerStyle,
  titleStyle,
  messageStyle,
  imageContainerStyle,
  imageStyle,
  ...stackProps
}: EmptyOrSkeletonProps) {
  // If loading, show skeleton
  if (isLoading) {
    if (customSkeletonComponent) {
      return <>{customSkeletonComponent}</>;
    }
    
    return (
      <YStack space={skeletonGap} width="100%" {...stackProps}>
        {Array.from({ length: skeletonCount }).map((_, index) => (
          <SkeletonPlaceholder
            key={`skeleton-${index}`}
            height={skeletonHeight}
            width={skeletonWidth}
            borderRadius={skeletonBorderRadius}
            options={skeletonOptions}
          />
        ))}
      </YStack>
    );
  }
  
  // If empty, show empty state
  if (isEmpty) {
    if (customEmptyComponent) {
      return <>{customEmptyComponent}</>;
    }
    
    return (
      <EmptyState
        title={title}
        message={message}
        image={image}
        containerStyle={containerStyle}
        titleStyle={titleStyle}
        messageStyle={messageStyle}
        imageContainerStyle={imageContainerStyle}
        imageStyle={imageStyle}
      />
    );
  }
  
  // Otherwise, show children
  return <>{children}</>;
}

const styles = StyleSheet.create({
  imageContainer: {
    marginBottom: 20,
  },
  image: {
    width: 150,
    height: 150,
    resizeMode: 'contain',
  },
}); ```
\n\n## Realtime Channel: HabitCheckItem.tsx
**File:** ./components/dashboard/HabitCheckItem.tsx
\n```
import React, { useState, useEffect } from 'react';
import { Text, XStack, Button, YStack, useTheme } from 'tamagui';
import * as Haptics from 'expo-haptics';
import { trpc, RouterOutputs } from '@/utils/trpc';

// Custom types that match the backend expectations
type DashboardHabit = {
  id: string;
  name: string;  // Backend returns 'name'
  description?: string;
  habit_type?: string;
  streak?: number;
  completed: boolean; // Backend returns 'completed'
  duration_minutes?: number;
  last_entry_id?: string; // Add last_entry_id property
};

// Types for habit entry mutations
type CreateHabitEntryInput = {
  habit_id: string;
  date: string;
  completed?: boolean;
  quantity_value?: number | null;
  notes?: string | null;
};

type DeleteHabitEntryInput = {
  id: string; // Update property name
};

interface HabitCheckItemProps {
  habit: DashboardHabit;
  onToggle?: (habitId: string, completedToday: boolean) => void; 
}

export default function HabitCheckItem({ habit, onToggle }: HabitCheckItemProps) {
  const [checked, setChecked] = useState(habit.completed);
  const [isUpdating, setIsUpdating] = useState(false);
  const theme = useTheme(); 
  const utils = trpc.useUtils(); 

  // Define specific theme colors with safe access and fallbacks to theme variables
  const green10 = theme?.green10?.val ?? '$green10'; 
  const gray10 = theme?.gray10?.val ?? '$gray10'; 
  const orange10 = theme?.orange10?.val ?? '$orange10'; 


  const createEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: (updatedHabit) => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error creating habit entry:', error);
    }
  });

  const deleteEntryMutation = trpc.habit.deleteHabitEntry.useMutation({
    onSuccess: () => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error deleting habit entry:', error);
    }
  });

  useEffect(() => {
    setChecked(habit.completed);
  }, [habit.completed]);

  const handleToggle = () => {
    const newValue = !checked;
    setChecked(newValue); 
    setIsUpdating(true);

    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);

    const todayDateString = new Date().toISOString().split('T')[0];

    if (newValue) {
      const createInput: CreateHabitEntryInput = {
        habit_id: habit.id,
        date: todayDateString,
        completed: true, 
        quantity_value: null, 
        notes: null, 
      };
      createEntryMutation.mutate(createInput);
    } else {
      if (habit.last_entry_id) { 
        const deleteInput: DeleteHabitEntryInput = {
          id: habit.last_entry_id, 
        };
        deleteEntryMutation.mutate(deleteInput);
      } else {
        console.warn("Attempted to delete habit entry, but last_entry_id is missing.");
      }
    }

    if (onToggle) {
      onToggle(habit.id, newValue);
    }
  };

  const streakColor = checked ? green10 : gray10; // Use safe theme value
  const habitTypeColor = orange10; // Use safe theme value

  return (
    <XStack 
      backgroundColor="$backgroundStrong" // Use theme variable
      padding="$3"
      borderRadius="$4"
      alignItems="center"
      justifyContent="space-between"
      space="$3"
    >
      <YStack flex={1} gap="$1">
        <Text fontSize="$4" fontWeight="500" color="$color"> // Use theme variable
          {habit.name}
        </Text>
        
        {habit.streak != null && habit.streak > 0 && ( // Add null check
          <Text fontSize="$2" color={streakColor}> 
            Streak: {habit.streak ?? 0}
          </Text>
        )}
        {habit.habit_type && (
          <Text fontSize="$2" color={habitTypeColor}> // Use safe theme value
            ({habit.habit_type})
          </Text>
        )}
      </YStack>
      
      <Button
        size="$3"
        variant={checked ? undefined : 'outlined'} // Let variant handle appearance
        // Remove explicit colors - rely on theme/variant
        theme={checked ? 'green' : undefined} // Apply green theme when checked
        onPress={handleToggle}
        disabled={isUpdating} 
        iconAfter={checked ? <Text>✓</Text> : undefined}
      >
        {checked ? "Done" : "Check-in"}
      </Button>
    </XStack>
  );
}```
\n\n## Realtime Channel: TaskItem.tsx
**File:** ./components/dashboard/TaskItem.tsx
\n```
import React from 'react';
// Use Tamagui components
import { Text, XStack, YStack, Checkbox, Spinner } from 'tamagui'; 
import { trpc, RouterOutputs, RouterInputs } from '@/utils/trpc';
import { Check } from '@tamagui/lucide-icons';

// Custom Task type that matches the actual format returned from the backend
type Task = {
  id: string;
  name: string;  // Backend returns 'name' not 'title'
  status: string;
  priority?: number;
  due_date?: string; // Backend returns 'due_date' not 'due'
  notes?: string;
  goal_id?: string;
  // Include other fields as needed
};

interface TaskItemProps {
  task: Task;
  onPress: () => void;
}

export default function TaskItem({ task, onPress }: TaskItemProps) {
  
  // Setup toggleTask mutation with optimistic updates
  const utils = trpc.useContext();
  // Setup mutation for task toggling
  const toggleTaskMutation = trpc.task.toggleTask.useMutation({
    // Optimistically update the UI
    onMutate: async ({ taskId, completed }: { taskId: string; completed?: boolean }) => {
      // Default to toggling the current state if completed is not provided
      const newCompleted = completed !== undefined ? completed : !isCompleted;
      // Cancel outgoing fetches that might overwrite our optimistic update
      await utils.task.getTasks.cancel();
      await utils.dashboard.getDashboardData.cancel();
      
      // Get previous data for potential rollback
      const prevTasksData = utils.task.getTasks.getData();
      const prevDashboardData = utils.dashboard.getDashboardData.getData();
      
      // Optimistically update tasks data if present
      if (prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return old.map((t: any) => {
            if (t.id === taskId) {
              return {
                ...t,
                status: completed ? 'completed' : 'in-progress'
              };
            }
            return t;
          });
        });
      }
      
      // Optimistically update dashboard data if present
      if (prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return {
            ...old,
            tasks: old.tasks.map((t: any) => {
              if (t.id === taskId) {
                return {
                  ...t,
                  status: newCompleted ? 'completed' : 'in-progress'
                };
              }
              return t;
            }),
          };
        });
      }
      
      // Return previous data for rollback
      return { prevTasksData, prevDashboardData };
    },
    
    // If something goes wrong, rollback optimistic updates
    onError: (err: any, variables: any, context: any) => {
      if (context?.prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, context.prevTasksData);
      }
      if (context?.prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, context.prevDashboardData);
      }
      console.error('Error toggling task:', err);
    },
    
    // Always refetch after error or success
    onSettled: () => {
      utils.task.getTasks.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    }
  });

  // Handle checkbox toggle
  const handleToggle = () => {
    toggleTaskMutation.mutate({
      taskId: task.id, // Using taskId as expected by the backend
      completed: !isCompleted
    });
  };

  // Map priority to color
  const priorityColor = task.priority === 1 ? '$brandRed' : 
                        task.priority === 2 ? '$brandYellow' : 
                        '$brandGreen';
  
  // Format due date
  const formattedDate = task.due_date 
    ? new Date(task.due_date).toLocaleDateString(undefined, { 
        month: 'short', 
        day: 'numeric' 
      })
    : null;
    
  // Determine task completion status
  const isCompleted = task.status === 'completed';
  // No need for text style object since we use Tamagui props directly

  
  // Use YStack as the base component
  return (
    <YStack 
      backgroundColor="$backgroundStrong"
      padding="$3"
      borderRadius="$4"
      space="$1" // Add space between XStack and Date Text
    >
      <XStack alignItems="center" space="$2"> {/* Use XStack for horizontal layout */}
        {/* Checkbox for task completion */}
        <Checkbox
          size="$4"
          checked={isCompleted}
          onCheckedChange={handleToggle}
          disabled={toggleTaskMutation.isPending}
        >
          {toggleTaskMutation.isPending ? (
            <Spinner size="small" color="$brandPrimary" />
          ) : (
            <Checkbox.Indicator>
              <Check size={16} />
            </Checkbox.Indicator>
          )}
        </Checkbox>

        {/* Container for task details (clickable) */}
        <XStack flex={1} tag="pressable" onPress={onPress} pressStyle={{ opacity: 0.7 }}>
          {/* Priority Dot using YStack */}
          <YStack 
            width="$2" // Use size token for width
            height="$2" // Use size token for height
            borderRadius="$10" // Use a large radius token
            backgroundColor={priorityColor} 
            marginRight="$2" // Use space token for margin
          />
          <Text 
            fontSize="$4" // Use font size token
            fontWeight={task.priority === 1 ? '600' : '400'} // Keep fontWeight
            color="$color"
            flex={1} // Allow text to take remaining space
            opacity={isCompleted ? 0.7 : 1}
            textDecorationLine={isCompleted ? 'line-through' : undefined} // Proper Tamagui text decoration
          >
            {task.name}
          </Text>
        </XStack>
      </XStack>
      
      {formattedDate && (
        // Removed explicit margin, rely on outer YStack space
        <Text color="$gray9" fontSize="$2">
          Due: {formattedDate}
        </Text>
      )}
    </YStack>
  );
} ```
\n\n## Realtime Channel: dashboardRouter.test.ts
**File:** ./__tests__/server/routers/dashboardRouter.test.ts
\n```
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { createInnerTRPCContext, mockSupabaseAdmin, MockableTableOperations } from '../test-helpers';
import { DeepMockProxy, mockDeep } from 'jest-mock-extended';
import { appRouter } from '../../../server/src/router';
import { TRPCError } from '@trpc/server';

// Using mockSupabaseAdmin from test-helpers

// Type for database table names to avoid 'any' parameter type errors
type TableName = 'tasks' | 'goals' | 'habits' | 'habit_entries' | 'tracked_state_defs' | string;

/**
 * Create a test tRPC caller with proper context
 */
function createTestCaller(userId: string | null = 'test-user-id') {
  const ctx = createInnerTRPCContext({
    userId,
    supabase: mockSupabaseAdmin,
  });
  return appRouter.createCaller(ctx);
}

describe('dashboardRouter', () => {
  beforeEach(() => {
    // Reset all mocks before each test
    jest.clearAllMocks();
  });

  describe('getDashboardData', () => {
    it('should fetch dashboard data with default limits', async () => {
      // Mock data for habits aligned with updated schema
      const mockHabits = [
        {
          id: 'habit-1',
          user_id: 'test-user-id',
          title: 'Morning Run',
          cue: 'Wake up',
          routine: 'Go for a jog',
          reward: 'Coffee',
          streak: 3,
          best_streak: 5,
          created_at: '2024-04-20T12:00:00Z',
          updated_at: '2024-04-20T12:00:00Z'
        }
      ];

      // Mock data for goals aligned with updated schema
      const mockGoals = [
        {
          id: 'goal-1',
          user_id: 'test-user-id',
          title: 'Learn TypeScript',
          description: 'Master TypeScript for web development',
          progress: 0.5,
          target_date: '2024-06-01T00:00:00Z',
          created_at: '2024-04-15T10:00:00Z',
          updated_at: '2024-04-15T10:00:00Z'
        }
      ];

      // Mock data for tasks aligned with updated schema
      const mockTasks = [
        {
          id: 'task-1',
          user_id: 'test-user-id',
          title: 'Complete TypeScript course',
          notes: 'Focus on advanced types',
          status: 'in-progress',
          priority: 2,
          due: '2024-05-01T00:00:00Z',
          goal_id: 'goal-1',
          created_at: '2024-04-20T12:00:00Z',
          updated_at: '2024-04-20T12:00:00Z'
        }
      ];

      // Mock data for tracked states
      const mockTrackedStates: any[] = [];

      // Mock habit entries
      const mockHabitEntries = [
        {
          habit_id: 'habit-1',
          completed: true
        }
      ];

      // Create typed mock objects for each table, using our helper from test-helpers.ts
      function createTableMockWithData<T>(data: T) {
        const mock = mockDeep<MockableTableOperations>();
        
        // Configure chainable methods to return this (for method chaining)
        mock.select.mockReturnThis();
        mock.eq.mockReturnThis();
        mock.is.mockReturnThis();
        mock.neq.mockReturnThis();
        mock.or.mockReturnThis();
        mock.in.mockReturnThis();
        mock.order.mockReturnThis();
        mock.limit.mockReturnThis();
        
        // Make the mock awaitable with the provided data
        // Using a proper Promise interface implementation
        const response = { data, error: null, status: 200 };
        const mockPromise = Promise.resolve(response);
        
        // Add then/catch/finally methods to make the mock awaitable
        (mock as any).then = mockPromise.then.bind(mockPromise);
        (mock as any).catch = mockPromise.catch.bind(mockPromise);
        (mock as any).finally = mockPromise.finally.bind(mockPromise);
        
        return mock;
      }
      
      // Create mocks with the appropriate data
      const habitsTableMock = createTableMockWithData(mockHabits);
      const goalsTableMock = createTableMockWithData(mockGoals);
      const tasksTableMock = createTableMockWithData(mockTasks);
      const trackedStatesTableMock = createTableMockWithData(mockTrackedStates);
      const habitEntriesTableMock = createTableMockWithData(mockHabitEntries);

      // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
      mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
        if (table === 'habits') return habitsTableMock;
        if (table === 'goals') return goalsTableMock;
        if (table === 'tasks') return tasksTableMock;
        if (table === 'tracked_state_defs') return trackedStatesTableMock;
        if (table === 'habit_entries') return habitEntriesTableMock;
        
        // Default fallback - empty result mock
        return createTableMockWithData([]);
      });

      const caller = createTestCaller();
      const result = await caller.dashboard.getDashboardData();

      // Verify the result structure
      expect(result).toHaveProperty('habits');
      expect(result).toHaveProperty('goals');
      expect(result).toHaveProperty('tasks');
      expect(result).toHaveProperty('trackedStates');

      // Verify habits were formatted correctly
      expect(result.habits[0]).toEqual(expect.objectContaining({
        id: 'habit-1',
        title: 'Morning Run',
        streak: 3,
        completed: true
      }));

      // Verify goals were formatted correctly
      expect(result.goals[0]).toEqual(expect.objectContaining({
        id: 'goal-1',
        title: 'Learn TypeScript',
        progress: 0.5
      }));

      // Verify limits were passed correctly - now targeting the specific table mocks
      expect(habitsTableMock.limit).toHaveBeenCalledWith(5); // Default habit limit
      expect(tasksTableMock.limit).toHaveBeenCalledWith(10); // Default task limit
    });

    it('should fetch dashboard data with custom limits', async () => {
      // Create typed mock objects for each table
      const habitsTableMock = mockDeep<MockableTableOperations>();
      const goalsTableMock = mockDeep<MockableTableOperations>();
      const tasksTableMock = mockDeep<MockableTableOperations>();
      const trackedStatesTableMock = mockDeep<MockableTableOperations>();
      const habitEntriesTableMock = mockDeep<MockableTableOperations>();

      // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
      mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
        if (table === 'habits') return habitsTableMock;
        if (table === 'goals') return goalsTableMock;
        if (table === 'tasks') return tasksTableMock;
        if (table === 'tracked_state_defs') return trackedStatesTableMock;
        if (table === 'habit_entries') return habitEntriesTableMock;
        
        // Default case - should not happen in this test
        return mockDeep<MockableTableOperations>();
      });

      // No need to configure these mocks further - they already have their Promise behavior set
      // through the createTableMockWithData function with proper awaitable responses

      // Add specific behaviors needed for tasks
      tasksTableMock.neq.mockReturnThis();
      tasksTableMock.or.mockReturnThis();

      const caller = createTestCaller();
      await caller.dashboard.getDashboardData({
        habitLimit: 10,
        goalLimit: 15,
        taskLimit: 20
      });

      // Verify the custom limits were passed
      expect(mockSupabaseAdmin.limit).toHaveBeenCalledWith(10); // Custom habit limit
      expect(mockSupabaseAdmin.limit).toHaveBeenCalledWith(15); // Custom goal limit
      expect(mockSupabaseAdmin.limit).toHaveBeenCalledWith(20); // Custom task limit
    });

    it('should handle database errors properly', async () => {
      // Setup mock to simulate a database error
      mockSupabaseAdmin.from.mockImplementation(() => {
        return {
          ...mockSupabaseAdmin,
          select: jest.fn().mockReturnThis(),
          eq: jest.fn().mockReturnThis(),
          order: jest.fn().mockReturnThis(),
          limit: jest.fn().mockReturnValue({ 
            data: null, 
            error: { 
              message: 'Database error', 
              code: '42P01' // Table doesn't exist
            } 
          }),
        };
      });

      const caller = createTestCaller();
      
      // Expect the call to throw an INTERNAL_SERVER_ERROR
      await expect(caller.dashboard.getDashboardData()).rejects.toThrow(TRPCError);
    });

    it('should throw unauthorized error if no user is authenticated', async () => {
      const caller = createTestCaller(null);
      
      // Expect the call to throw an UNAUTHORIZED error
      await expect(caller.dashboard.getDashboardData()).rejects.toThrow(TRPCError);
    });
  });
});
```
\n\n## Realtime Channel: habitRouter.test.ts
**File:** ./__tests__/server/routers/habitRouter.test.ts
\n```
import { describe, it, expect, beforeEach, jest, afterEach } from '@jest/globals';
import { createInnerTRPCContext, mockSupabaseAdmin, resetSupabaseMocks } from '../test-helpers'; 
import { appRouter } from '../../../server/src/router';
import { TRPCError } from '@trpc/server';
import { Habit } from '../../../server/src/types/trpc-types'; 

/**
 * Helper function to create a test context
 * This mimics how the tRPC context would be created in a real request
 */
function createTestContext(userId: string | null = 'test-user-id') {
  return createInnerTRPCContext({
    userId,
    supabase: mockSupabaseAdmin,
  });
}

/**
 * Create a test tRPC caller with proper context
 * @param userId Optional user ID for authenticated routes
 * @returns A tRPC caller that can be used to call procedures
 */
function createTestCaller(userId: string | null = 'test-user-id') {
  const ctx = createTestContext(userId);
  return appRouter.createCaller(ctx);
}

// Helper function to create a properly awaitable mock with data
function createTableMockWithData<T>(data: T) {
  const mock = mockDeep<MockableTableOperations>();
  
  // Configure chainable methods to return this (for method chaining)
  mock.select.mockReturnThis();
  mock.eq.mockReturnThis();
  mock.order.mockReturnThis();
  mock.limit.mockReturnThis();
  mock.in.mockReturnThis();
  mock.update.mockReturnThis();
  mock.is.mockReturnThis();
  mock.isNull.mockReturnThis();
  mock.neq.mockReturnThis();
  mock.or.mockReturnThis();
  mock.filter.mockReturnThis();
  mock.delete.mockReturnThis();
  mock.upsert.mockReturnThis();
  mock.insert.mockReturnThis();
  
  // Add proper promise handling for awaitable operations
  const response = { data, error: null, status: 200, count: Array.isArray(data) ? data.length : undefined };
  const mockPromise = Promise.resolve(response);
  
  // Add then/catch/finally methods to make the mock awaitable
  (mock as any).then = mockPromise.then.bind(mockPromise);
  (mock as any).catch = mockPromise.catch.bind(mockPromise);
  (mock as any).finally = mockPromise.finally.bind(mockPromise);
  
  return mock;
}

describe('habitRouter', () => {
  beforeEach(() => {
    resetSupabaseMocks();
  });

  describe('getHabits', () => {
    it('should fetch active habits for the user with completion status', async () => {
      // --- Arrange --- 
      const userId = 'test-user-id';
      const todayStr = new Date().toISOString().split('T')[0];
      const mockHabits: Habit[] = [
        { id: 'habit-1', user_id: userId, title: 'Habit 1', cue: 'Morning', routine: 'Exercise', reward: 'Coffee', habit_type: 'boolean', goal_quantity: null, goal_unit: null, frequency_period: 'day', goal_frequency: 1, recurrence_rule: 'RRULE:FREQ=DAILY', recurrence_end_date: null, archived_at: null, streak: 5, best_streak: 10, created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
        { id: 'habit-2', user_id: userId, title: 'Habit 2', cue: 'Evening', routine: 'Read', reward: 'Relax', habit_type: 'quantity', goal_quantity: 30, goal_unit: 'minutes', frequency_period: 'week', goal_frequency: 3, recurrence_rule: 'RRULE:FREQ=WEEKLY;BYDAY=MO,WE,FR', recurrence_end_date: null, archived_at: null, streak: 2, best_streak: 2, created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
      ];
      const mockEntriesToday = [
        { habit_id: 'habit-1' }, // Only habit 1 is completed today
      ];

      // Create properly awaitable mocks with the test data
      const habitsMock = createTableMockWithData(mockHabits);
      const entriesMock = createTableMockWithData(mockEntriesToday);

      // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
      mockSupabaseAdmin.from.mockImplementation((table: string) => {
        if (table === 'habits') return habitsMock;
        if (table === 'habit_entries') return entriesMock;
        return createTableMockWithData([]); // Default empty result for other tables
      });
      
      // --- Act --- 
      const caller = createTestCaller(userId);
      const result = await caller.habit.getHabits();

      // --- Assert --- 
      expect(result).toHaveLength(2);
      // Check all fields, including new ones and completedToday
      expect(result[0]).toMatchObject({ 
        ...mockHabits[0], 
        frequency_period: 'day', 
        goal_frequency: 1,
        completedToday: true 
      });
      expect(result[1]).toMatchObject({ 
        ...mockHabits[1], 
        frequency_period: 'week',
        goal_frequency: 3,
        completedToday: false 
      });

      // Verify mocks - Check if specific methods were called
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(1, 'habits');
      expect(selectHabitsMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(eqHabitsMock).toHaveBeenCalledWith('user_id', userId);
      expect(isNullHabitsMock).toHaveBeenCalledWith('archived_at', null); // Check is call
      expect(habitsFilterMock).toHaveBeenCalledTimes(1); // Ensure filter was called

      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(2, 'habit_entries');
      expect(selectEntriesMock).toHaveBeenCalledWith('habit_id');
      expect(eqUserEntriesMock).toHaveBeenCalledWith('user_id', userId);
      expect(eqDateEntriesMock).toHaveBeenCalledWith('date', todayStr);
      // Check the final resolving mock was called correctly
      expect(entriesFilterMock).toHaveBeenCalledWith('habit_id', expect.arrayContaining([mockHabits[0].id, mockHabits[1].id]));
    });

    it('should return an empty array if no habits exist', async () => {
        // --- Arrange ---
      const userId = 'test-user-id';

      const habitsFilterMock = jest.fn<() => Promise<{ data: Habit[] | null; error: any }>>();
      habitsFilterMock.mockResolvedValue({ data: [], error: null }); // Resolve empty
      const isNullHabitsMock = jest.fn().mockReturnValue({ filter: habitsFilterMock });
      const eqHabitsMock = jest.fn().mockReturnValue({ isNull: isNullHabitsMock });
      const selectHabitsMock = jest.fn().mockReturnValue({ eq: eqHabitsMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectHabitsMock,
      } as any);

      // --- Act ---
      const caller = createTestCaller(userId);
      const result = await caller.habit.getHabits();

      // --- Assert ---
      expect(result).toEqual([]);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      // Ensure habit_entries was NOT called because the initial habit fetch was empty
      expect(mockSupabaseAdmin.from).toHaveBeenCalledTimes(1); 
      expect(habitsFilterMock).toHaveBeenCalledTimes(1); // Check filter was still called before resolving
    });

    it('should throw TRPCError on database error during habit fetch', async () => {
      // --- Arrange ---
      const userId = 'test-user-id';
      const dbError = { message: 'DB error fetching habits', code: '500' };
      
      const habitsFilterMock = jest.fn<() => Promise<{ data: Habit[] | null; error: any }>>();
      habitsFilterMock.mockResolvedValue({ data: null, error: dbError }); // Simulate error
      const isNullHabitsMock = jest.fn().mockReturnValue({ filter: habitsFilterMock });
      const eqHabitsMock = jest.fn().mockReturnValue({ isNull: isNullHabitsMock });
      const selectHabitsMock = jest.fn().mockReturnValue({ eq: eqHabitsMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectHabitsMock,
      } as any);
      
      // --- Act & Assert ---
      const caller = createTestCaller(userId);
      await expect(caller.habit.getHabits()).rejects.toThrowError(
        new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message })
      );
      expect(habitsFilterMock).toHaveBeenCalledTimes(1);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledTimes(1);
    });

    it('should throw TRPCError on database error during entry fetch', async () => {
        // --- Arrange ---
      const userId = 'test-user-id';
      const todayStr = new Date().toISOString().split('T')[0];
      const mockHabits: Habit[] = [
        { id: 'habit-1', user_id: userId, title: 'Habit 1', cue: 'Morning', routine: 'Exercise', reward: 'Coffee', habit_type: 'boolean', goal_quantity: null, goal_unit: null, frequency_period: 'day', goal_frequency: 1, recurrence_rule: 'RRULE:FREQ=DAILY', recurrence_end_date: null, archived_at: null, streak: 5, best_streak: 10, created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
      ];
      const dbError = { message: 'DB error fetching entries', code: '500' };

      // Mock successful habit fetch
      const habitsFilterMock = jest.fn<() => Promise<{ data: Habit[] | null; error: any }>>();
      habitsFilterMock.mockResolvedValue({ data: mockHabits, error: null });
      const isNullHabitsMock = jest.fn().mockReturnValue({ filter: habitsFilterMock });
      const eqHabitsMock = jest.fn().mockReturnValue({ isNull: isNullHabitsMock });
      const selectHabitsMock = jest.fn().mockReturnValue({ eq: eqHabitsMock });

      // Mock failing entry fetch
      const entriesFilterMock = jest.fn<() => Promise<{ data: any[] | null; error: any }>>();
      entriesFilterMock.mockResolvedValue({ data: null, error: dbError });
      const eqDateEntriesMock = jest.fn().mockReturnValue({ filter: entriesFilterMock });
      const eqUserEntriesMock = jest.fn().mockReturnValue({ eq: eqDateEntriesMock });
      const selectEntriesMock = jest.fn().mockReturnValue({ eq: eqUserEntriesMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectHabitsMock,
      } as any).mockReturnValueOnce({ // Mock for 'habit_entries'
        select: selectEntriesMock,
      } as any);
      
      // --- Act & Assert ---
      const caller = createTestCaller(userId);
      await expect(caller.habit.getHabits()).rejects.toThrowError(
        new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message })
      );
      expect(habitsFilterMock).toHaveBeenCalledTimes(1);
      expect(entriesFilterMock).toHaveBeenCalledTimes(1); // Ensure entry fetch was attempted
    });
  });

  describe('getHabitById', () => {
    it('should fetch a specific habit by ID', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-abc';
      const mockHabit: Habit = { id: habitId, user_id: userId, title: 'Test Habit', cue: null, routine: null, reward: null, habit_type: 'boolean', goal_quantity: null, goal_unit: null, frequency_period: 'day', goal_frequency: 1, recurrence_rule: null, recurrence_end_date: null, archived_at: null, streak: 0, best_streak: 0, created_at: new Date().toISOString(), updated_at: new Date().toISOString() };

      // Corrected mock structure for chained eq calls
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: mockHabit, error: null });
      const userEqMock = jest.fn().mockReturnValue({ single: singleMock });
      const idEqMock = jest.fn().mockReturnValue({ eq: userEqMock });
      const selectMock = jest.fn().mockReturnValue({ eq: idEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectMock
      } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      const result = await caller.habit.getHabitById({ id: habitId });
      expect(result).toEqual(mockHabit);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(selectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at'); // Check select fields
      expect(idEqMock).toHaveBeenCalledWith('id', habitId);
      expect(userEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(singleMock).toHaveBeenCalled();
    });

    it('should throw NOT_FOUND error if habit doesnt exist or belongs to another user', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-abc';
      // Router now throws specific error, not just Supabase error
      const expectedError = new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied' });

      // Corrected mock structure for failing call
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: null, error: { message: 'Row not found', code: 'PGRST116' } });
      const userEqMock = jest.fn().mockReturnValue({ single: singleMock });
      const idEqMock = jest.fn().mockReturnValue({ eq: userEqMock });
      const selectMock = jest.fn().mockReturnValue({ eq: idEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectMock
      } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.getHabitById({ id: habitId })).rejects.toThrowError(
        expectedError
      );
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(selectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(idEqMock).toHaveBeenCalledWith('id', habitId);
      expect(userEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(singleMock).toHaveBeenCalled();
    });

     it('should throw INTERNAL_SERVER_ERROR on other database errors', async () => {
       // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-db-error';
      const dbError = { message: 'Generic DB Error', code: '500' };
      const expectedError = new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message });

      // Corrected mock structure for generic error
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: null, error: dbError });
      const userEqMock = jest.fn().mockReturnValue({ single: singleMock });
      const idEqMock = jest.fn().mockReturnValue({ eq: userEqMock });
      const selectMock = jest.fn().mockReturnValue({ eq: idEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectMock
      } as any);

       // Act
      const caller = createTestCaller(userId);
       // Assert
      await expect(caller.habit.getHabitById({ id: habitId })).rejects.toThrowError(
        expectedError
      );
       expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
       expect(selectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
       expect(idEqMock).toHaveBeenCalledWith('id', habitId);
       expect(userEqMock).toHaveBeenCalledWith('user_id', userId);
       expect(singleMock).toHaveBeenCalled();
     });
   });

  describe('createHabit', () => { 
    it('should create a new habit with default streaks', async () => {
      // Arrange
      const userId = 'test-user-id';
      const inputData = { title: 'New Habit', habit_type: 'boolean' as const, frequency_period: 'day' as const, goal_frequency: 1 };
      const expectedOutput: Habit = { id: 'new-id', user_id: userId, ...inputData, streak: 0, best_streak: 0, created_at: new Date().toISOString(), updated_at: new Date().toISOString(), cue: null, routine: null, reward: null, goal_quantity: null, goal_unit: null, recurrence_rule: null, recurrence_end_date: null, archived_at: null };

      // Correct mock structure for insert -> select -> single
      // Explicitly type the mock function to help with type inference
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: expectedOutput, error: null }); 
      const selectMock = jest.fn().mockReturnValue({ single: singleMock });
      const insertMock = jest.fn().mockReturnValue({ select: selectMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        insert: insertMock
      } as any);

      // Act
      const caller = createTestCaller(userId);
      const result = await caller.habit.createHabit(inputData);

      // Assert
      expect(result).toEqual(expectedOutput);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      // Check insert arguments carefully
      expect(insertMock).toHaveBeenCalledWith(expect.objectContaining({ 
          ...inputData,
          user_id: userId, 
          streak: 0, 
          best_streak: 0 
      }));
      expect(selectMock).toHaveBeenCalled(); // Check select was called after insert
      expect(singleMock).toHaveBeenCalled(); // Check single was called after select
    });

    it('should throw TRPCError on database error', async () => {
      // Arrange
      const userId = 'test-user-id';
      const inputData = { title: 'Fail Habit', habit_type: 'boolean' as const, frequency_period: 'day' as const, goal_frequency: 1 };
      const dbError = { message: 'Insert failed', code: '500' };
      const expectedError = new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message });

      // Correct mock structure for failing insert
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: null, error: dbError });
      const selectMock = jest.fn().mockReturnValue({ single: singleMock });
      const insertMock = jest.fn().mockReturnValue({ select: selectMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
         insert: insertMock
      } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.createHabit(inputData)).rejects.toThrowError(
        expectedError
      );
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      // Check insert arguments
       expect(insertMock).toHaveBeenCalledWith(expect.objectContaining({ 
          ...inputData,
          user_id: userId, 
          streak: 0, 
          best_streak: 0 
      }));
      expect(selectMock).toHaveBeenCalled();
      expect(singleMock).toHaveBeenCalled();
    });
  });

  describe('updateHabit', () => { 
    it('should update an existing habit', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-to-update';
      const updateData = { title: 'Updated Title' };
      // Define the full initial and updated habit objects (need all fields for Habit type)
      const baseHabit = { id: habitId, user_id: userId, cue: null, routine: null, reward: null, habit_type: 'boolean' as const, goal_quantity: null, goal_unit: null, frequency_period: 'day' as const, goal_frequency: 1, recurrence_rule: null, recurrence_end_date: null, archived_at: null, streak: 5, best_streak: 10, created_at: new Date(Date.now() - 100000).toISOString(), updated_at: new Date(Date.now() - 50000).toISOString() }; 
      const initialHabit: Habit = { ...baseHabit, title: 'Old Title' };
      const updatedHabit: Habit = { ...initialHabit, ...updateData, updated_at: new Date().toISOString(), id: habitId, user_id: userId, cue: null, routine: null, reward: null, habit_type: 'boolean', goal_quantity: null, goal_unit: null, frequency_period: 'day', goal_frequency: 1, recurrence_rule: null, recurrence_end_date: null, archived_at: null, streak: 0, best_streak: 0, created_at: new Date().toISOString() };

      // Mock 1: Initial fetch for ownership check (getHabitById logic)
      const fetchSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      fetchSingleMock.mockResolvedValue({ data: initialHabit, error: null });
      const fetchUserEqMock = jest.fn().mockReturnValue({ single: fetchSingleMock });
      const fetchIdEqMock = jest.fn().mockReturnValue({ eq: fetchUserEqMock });
      const fetchSelectMock = jest.fn().mockReturnValue({ eq: fetchIdEqMock });

      // Mock 2: Update operation
      const updateSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      updateSingleMock.mockResolvedValue({ data: updatedHabit, error: null });
      const updateSelectMock = jest.fn().mockReturnValue({ single: updateSingleMock });
      const updateUserEqMock = jest.fn().mockReturnValue({ select: updateSelectMock });
      const updateIdEqMock = jest.fn().mockReturnValue({ eq: updateUserEqMock });
      const updateMock = jest.fn().mockReturnValue({ eq: updateIdEqMock });

      // Chain the mocks: from('habits') -> select (for fetch) -> update 
      mockSupabaseAdmin.from.mockReturnValueOnce({ select: fetchSelectMock } as any)
                             .mockReturnValueOnce({ update: updateMock } as any); // Second call to from('habits') is for update

      // Act
      const caller = createTestCaller(userId);
      const result = await caller.habit.updateHabit({ id: habitId, ...updateData });

      // Assert
      expect(result).toEqual(updatedHabit);

      // Assert fetch mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(1, 'habits');
      expect(fetchSelectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(fetchIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(fetchUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(fetchSingleMock).toHaveBeenCalled();

      // Assert update mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(2, 'habits');
      expect(updateMock).toHaveBeenCalledWith(expect.objectContaining(updateData));
      expect(updateIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(updateUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(updateSelectMock).toHaveBeenCalled();
      expect(updateSingleMock).toHaveBeenCalled();
    });

    it('should throw NOT_FOUND error if habit doesnt exist or belongs to another user during initial fetch', async () => { // Renamed for clarity
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'non-existent-habit';
      const updateData = { title: 'Wont Update' };
      const expectedError = new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied' });

      // Mock only the initial fetch, have it return not found
      const fetchSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      fetchSingleMock.mockResolvedValue({ data: null, error: { message: 'Row not found', code: 'PGRST116' } });
      const fetchUserEqMock = jest.fn().mockReturnValue({ single: fetchSingleMock });
      const fetchIdEqMock = jest.fn().mockReturnValue({ eq: fetchUserEqMock });
      const fetchSelectMock = jest.fn().mockReturnValue({ eq: fetchIdEqMock });

      // Only mock 'from' once for the fetch
      mockSupabaseAdmin.from.mockReturnValueOnce({ select: fetchSelectMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.updateHabit({ id: habitId, ...updateData })).rejects.toThrowError(expectedError);
      // Verify fetch mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenCalledTimes(1);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(fetchSelectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(fetchIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(fetchUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(fetchSingleMock).toHaveBeenCalled();
      // Crucially, ensure no update mock was ever created or called
    });

    it('should throw TRPCError on database error during update operation', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-to-update';
      const updateData = { title: 'Updated Title' };
      // Reuse initial habit definition
      const baseHabit = { id: habitId, user_id: userId, cue: null, routine: null, reward: null, habit_type: 'boolean' as const, goal_quantity: null, goal_unit: null, frequency_period: 'day' as const, goal_frequency: 1, recurrence_rule: null, recurrence_end_date: null, archived_at: null, streak: 5, best_streak: 10, created_at: new Date(Date.now() - 100000).toISOString(), updated_at: new Date(Date.now() - 50000).toISOString() }; 
      const initialHabit: Habit = { ...baseHabit, title: 'Old Title' };
      const dbError = { message: 'Update failed', code: '500' };
      const expectedError = new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message });

      // Mock 1: Initial fetch for ownership check (success)
      const fetchSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      fetchSingleMock.mockResolvedValue({ data: initialHabit, error: null });
      const fetchUserEqMock = jest.fn().mockReturnValue({ single: fetchSingleMock });
      const fetchIdEqMock = jest.fn().mockReturnValue({ eq: fetchUserEqMock });
      const fetchSelectMock = jest.fn().mockReturnValue({ eq: fetchIdEqMock });

      // Mock 2: Update operation (failure)
      const updateSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      updateSingleMock.mockResolvedValue({ data: null, error: dbError }); // Make the update return the error
      const updateSelectMock = jest.fn().mockReturnValue({ single: updateSingleMock });
      const updateUserEqMock = jest.fn().mockReturnValue({ select: updateSelectMock });
      const updateIdEqMock = jest.fn().mockReturnValue({ eq: updateUserEqMock });
      const updateMock = jest.fn().mockReturnValue({ eq: updateIdEqMock });

       // Chain the mocks: from('habits') -> select (for fetch) -> update (fails)
      mockSupabaseAdmin.from.mockReturnValueOnce({ select: fetchSelectMock } as any)
                             .mockReturnValueOnce({ update: updateMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.updateHabit({ id: habitId, ...updateData })).rejects.toThrowError(expectedError);

      // Assert fetch mock calls (should have succeeded)
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(1, 'habits');
      expect(fetchSelectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(fetchIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(fetchUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(fetchSingleMock).toHaveBeenCalled();

      // Assert update mock calls (should have been called but failed)
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(2, 'habits');
      expect(updateMock).toHaveBeenCalledWith(expect.objectContaining(updateData));
      expect(updateIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(updateUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(updateSelectMock).toHaveBeenCalled();
      expect(updateSingleMock).toHaveBeenCalled();
    });
  });

  describe('deleteHabit', () => { 
    it('should delete an existing habit and return true', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-to-delete';

      // Mock delete -> eq(id) -> eq(user_id) -> resolves successfully
      // Explicitly type the mock function to help with type inference
      const deleteUserEqMock = jest.fn<() => Promise<{ data: null; error: any }>>();
      deleteUserEqMock.mockResolvedValue({ data: null, error: null }); // Success is indicated by no error
      const deleteIdEqMock = jest.fn().mockReturnValue({ eq: deleteUserEqMock });
      const deleteMock = jest.fn().mockReturnValue({ eq: deleteIdEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ delete: deleteMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.deleteHabit({ id: habitId })).resolves.toBe(true);
      // Verify mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(deleteMock).toHaveBeenCalled();
      expect(deleteIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(deleteUserEqMock).toHaveBeenCalledWith('user_id', userId);
    });

    it('should throw NOT_FOUND error if habit to delete doesnt exist or belongs to another user', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'non-existent-habit';
      const expectedError = new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or cannot be deleted' });

      // Mock delete -> eq(id) -> eq(user_id) -> resolves with error (or indicates 0 rows affected)
      // Simulate a 'not found' scenario, Supabase might return an error or just indicate 0 rows affected.
      // Let's mock returning an error that the router interprets as NOT_FOUND.
      const dbError = { message: 'Row not found', code: 'PGRST116' }; // Example error
      const deleteUserEqMock = jest.fn<() => Promise<{ data: null; error: any }>>();
      deleteUserEqMock.mockResolvedValue({ data: null, error: dbError });
      const deleteIdEqMock = jest.fn().mockReturnValue({ eq: deleteUserEqMock });
      const deleteMock = jest.fn().mockReturnValue({ eq: deleteIdEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ delete: deleteMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.deleteHabit({ id: habitId })).rejects.toThrowError(expectedError);
      // Verify mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(deleteMock).toHaveBeenCalled();
      expect(deleteIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(deleteUserEqMock).toHaveBeenCalledWith('user_id', userId);
    });

    it('should throw TRPCError on database error during delete operation', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-delete-error';
      const dbError = { message: 'Internal DB Error', code: '500' };
      const expectedError = new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message });

      // Mock delete -> eq(id) -> eq(user_id) -> resolves with a generic error
      const deleteUserEqMock = jest.fn<() => Promise<{ data: null; error: any }>>();
      deleteUserEqMock.mockResolvedValue({ data: null, error: dbError });
      const deleteIdEqMock = jest.fn().mockReturnValue({ eq: deleteUserEqMock });
      const deleteMock = jest.fn().mockReturnValue({ eq: deleteIdEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ delete: deleteMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.deleteHabit({ id: habitId })).rejects.toThrowError(expectedError);
      // Verify mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(deleteMock).toHaveBeenCalled();
      expect(deleteIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(deleteUserEqMock).toHaveBeenCalledWith('user_id', userId);
    });
  });

  // TODO: Add describe blocks for archive/unarchive and habit entry procedures
});
```
\n\n## Realtime Channel: dashboardRouter.getWeeklyProgress.test.ts
**File:** ./__tests__/server/routers/dashboardRouter.getWeeklyProgress.test.ts
\n```
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { createInnerTRPCContext, mockSupabaseAdmin, MockableTableOperations } from '../test-helpers';
import { DeepMockProxy, mockDeep } from 'jest-mock-extended';
import { appRouter } from '../../../server/src/router';
import { TRPCError } from '@trpc/server';

// Type for database table names to avoid 'any' parameter type errors
type TableName = 'tasks' | 'goals' | 'habits' | 'habit_entries' | 'goal_progress_snapshots' | string;

// Using mockSupabaseAdmin from test-helpers

// Helper function to create test context
function createTestContext(userId: string | null = 'test-user-id') {
  return createInnerTRPCContext({
    userId,
    supabase: mockSupabaseAdmin,
  });
}

// Create test caller with context
function createTestCaller(userId: string | null = 'test-user-id') {
  const ctx = createTestContext(userId);
  return appRouter.createCaller(ctx);
}

describe('dashboardRouter.getWeeklyProgress', () => {
  beforeEach(() => {
    // Reset mocks before each test
    jest.clearAllMocks();
  });

  it('should fetch weekly progress with default parameters', async () => {
    // Setup mock data
    const habits = [
      { id: 'habit-1', name: 'Morning Run', frequency: 'daily', streak: 5, best_streak: 10 },
      { id: 'habit-2', name: 'Meditation', frequency: 'daily', streak: 3, best_streak: 7 },
    ];

    const habitEntries = [
      { id: 'entry-1', habit_id: 'habit-1', date: '2025-04-25', completed: true, habits: { id: 'habit-1', name: 'Morning Run', frequency: 'daily' } },
      { id: 'entry-2', habit_id: 'habit-1', date: '2025-04-26', completed: true, habits: { id: 'habit-1', name: 'Morning Run', frequency: 'daily' } },
      { id: 'entry-3', habit_id: 'habit-2', date: '2025-04-25', completed: false, habits: { id: 'habit-2', name: 'Meditation', frequency: 'daily' } },
    ];

    const completedTasks = [
      { id: 'task-1', title: 'Complete report', status: 'completed', updated_at: '2025-04-25T10:00:00Z', goal_id: 'goal-1' },
      { id: 'task-2', title: 'Send email', status: 'completed', updated_at: '2025-04-26T14:30:00Z', goal_id: null },
    ];

    const goalSnapshots = [
      { goal_id: 'goal-1', progress: 0.3, created_at: '2025-04-21T08:00:00Z' },
      { goal_id: 'goal-1', progress: 0.5, created_at: '2025-04-27T08:00:00Z' },
    ];

    // Create typed mock objects for each table
    const habitsTableMock = mockDeep<MockableTableOperations>();
    const habitEntriesTableMock = mockDeep<MockableTableOperations>();
    const tasksTableMock = mockDeep<MockableTableOperations>();
    const goalSnapshotsTableMock = mockDeep<MockableTableOperations>();

    // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
    mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
      if (table === 'habits') return habitsTableMock;
      if (table === 'habit_entries') return habitEntriesTableMock;
      if (table === 'tasks') return tasksTableMock;
      if (table === 'goal_progress_snapshots') return goalSnapshotsTableMock;
      
      // Default case - should not happen in this test
      return mockDeep<MockableTableOperations>();
    });

    // Configure each table mock's behavior
    // Habits table
    habitsTableMock.select.mockReturnThis();
    habitsTableMock.eq.mockReturnThis();
    habitsTableMock.order.mockReturnThis();
    habitsTableMock.limit.mockResolvedValue({ data: habits, error: null });

    // Habit entries table
    habitEntriesTableMock.select.mockReturnThis();
    habitEntriesTableMock.eq.mockReturnThis();
    habitEntriesTableMock.gte.mockReturnThis();
    habitEntriesTableMock.lte.mockReturnThis();
    habitEntriesTableMock.order.mockResolvedValue({ data: habitEntries, error: null });

    // Tasks table
    tasksTableMock.select.mockReturnThis();
    tasksTableMock.eq.mockReturnThis();
    tasksTableMock.gte.mockReturnThis();
    tasksTableMock.lte.mockReturnThis();
    // Add count method mock
    tasksTableMock.count.mockResolvedValue({ count: 10, error: null });
    tasksTableMock.order.mockResolvedValue({ data: completedTasks, error: null });

    // Goal progress snapshots table
    goalSnapshotsTableMock.select.mockReturnThis();
    goalSnapshotsTableMock.eq.mockReturnThis();
    goalSnapshotsTableMock.gte.mockReturnThis();
    goalSnapshotsTableMock.lte.mockReturnThis();
    goalSnapshotsTableMock.order.mockResolvedValue({ data: goalSnapshots, error: null });

    const caller = createTestCaller();
    const result = await caller.dashboard.getWeeklyProgress();

    // Verify structure of response
    expect(result).toHaveProperty('dailyProgress');
    expect(result).toHaveProperty('overallMetrics');
    expect(result).toHaveProperty('habitStreaks');
    expect(result).toHaveProperty('goalProgress');
    expect(result).toHaveProperty('dateRange');

    // Verify dates are processed correctly
    expect(result.dateRange.days.length).toBe(7); // Default is 7 days

    // Verify habit data is formatted correctly
    expect(result.habitStreaks).toContainEqual({
      id: 'habit-1',
      name: 'Morning Run',
      currentStreak: 5,
      bestStreak: 10,
    });

    // Verify goal progress is calculated correctly
    expect(result.goalProgress).toContainEqual(expect.objectContaining({
      goalId: 'goal-1',
      progressChange: 0.2, // 0.5 - 0.3
    }));
  });

  it('should handle custom date ranges', async () => {
    // Create typed mock objects for each table
    const tableMock = mockDeep<MockableTableOperations>();
    
    // Configure mockSupabaseAdmin.from to return the mock for any table
    mockSupabaseAdmin.from.mockImplementation(() => tableMock);
    
    // Configure basic behavior
    tableMock.select.mockReturnThis();
    tableMock.eq.mockReturnThis();
    tableMock.gte.mockReturnThis();
    tableMock.lte.mockReturnThis();
    tableMock.order.mockResolvedValue({ data: [], error: null });

    const caller = createTestCaller();
    const result = await caller.dashboard.getWeeklyProgress({ daysToInclude: 14 });

    // Verify date range is correct
    expect(result.dateRange.days.length).toBe(14);
  });

  it('should handle raw data inclusion when requested', async () => {
    // Setup minimal mock data
    const habitEntries = [
      { id: 'entry-1', habit_id: 'habit-1', date: '2025-04-25', completed: true },
    ];

    // Helper function to create mock table with data and thenable capability
    function createTableMockWithData<T>(data: T) {
      const mock = mockDeep<MockableTableOperations>();
      
      // Configure chainable methods to return this (for method chaining)
      mock.select.mockReturnThis();
      mock.eq.mockReturnThis();
      mock.gte.mockReturnThis();
      mock.lte.mockReturnThis();
      mock.order.mockReturnThis();
      
      // Make the mock awaitable with the provided data
      // Using a proper Promise interface implementation
      const response = { data, error: null, status: 200 };
      const mockPromise = Promise.resolve(response);
      
      // Add then/catch/finally methods to make the mock awaitable
      (mock as any).then = mockPromise.then.bind(mockPromise);
      (mock as any).catch = mockPromise.catch.bind(mockPromise);
      (mock as any).finally = mockPromise.finally.bind(mockPromise);
      
      return mock;
    }
    
    // Create typed mock objects with proper data
    const habitEntriesTableMock = createTableMockWithData(habitEntries);
    const defaultTableMock = createTableMockWithData([]);
    
    // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
    mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
      if (table === 'habit_entries') return habitEntriesTableMock;
      return defaultTableMock;
    });

    const caller = createTestCaller();
    const result = await caller.dashboard.getWeeklyProgress({ includeRawData: true });

    // Find the day that should have entries
    const dayWithData = result.dailyProgress.find(day => day.date === '2025-04-25');
    
    // Verify raw data is included
    expect(dayWithData).toHaveProperty('habitEntries');
    expect(dayWithData?.habitEntries).toHaveLength(1);
  });

  it('should handle database errors properly', async () => {
    // Create typed mock object for tables that will return an error
    const errorTableMock = mockDeep<MockableTableOperations>();
    
    // Configure mockSupabaseAdmin.from to return the error mock
    mockSupabaseAdmin.from.mockImplementation(() => errorTableMock);
    
    // Configure the mocked behavior to return an error
    errorTableMock.select.mockReturnThis();
    errorTableMock.eq.mockReturnThis();
    errorTableMock.gte.mockReturnThis();
    errorTableMock.lte.mockReturnThis();
    errorTableMock.order.mockResolvedValue({ 
      data: null, 
      error: { message: 'Database error', code: '42P01' } 
    });

    const caller = createTestCaller();
    
    // Expect the proper error to be thrown
    await expect(caller.dashboard.getWeeklyProgress()).rejects.toThrow(TRPCError);
  });

  it('should throw an error when user is not authenticated', async () => {
    const caller = createTestCaller(null);
    
    // Expect an unauthorized error
    await expect(caller.dashboard.getWeeklyProgress()).rejects.toThrow(TRPCError);
  });
});
```
\n\n## Realtime Channel: taskRouter.toggleTask.test.ts
**File:** ./__tests__/server/routers/taskRouter.toggleTask.test.ts
\n```
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { 
  createInnerTRPCContext, 
  mockSupabaseAdmin, 
  MockableTableOperations, 
  resetSupabaseMocks, 
  MockablePostgrestResponse 
} from '../test-helpers';
import { DeepMockProxy, mockDeep } from 'jest-mock-extended';
import { appRouter } from '../../../server/src/router';
import { TRPCError } from '@trpc/server';

// Type for database table names to avoid 'any' parameter type errors
type TableName = 'tasks' | 'goals' | 'habits' | string;

// Helper function to create test context
function createTestContext(userId: string | null = 'test-user-id') {
  return createInnerTRPCContext({
    userId,
    supabase: mockSupabaseAdmin,
  });
}

// Create test caller with context
function createTestCaller(userId: string | null = 'test-user-id') {
  const ctx = createTestContext(userId);
  return appRouter.createCaller(ctx);
}

describe('taskRouter.toggleTask', () => {
  beforeEach(() => {
    // Reset mocks before each test
    resetSupabaseMocks();
  });

  it('should toggle a task from incomplete to complete', async () => {
    const taskId = 'task-1';
    const userId = 'test-user-id';
    const initialTaskData = {
      id: taskId,
      user_id: userId,
      title: 'Test Task',
      notes: null,
      status: 'in-progress',
      priority: 2,
      due: null,
      goal_id: null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };
    const updatedTaskData = {
      id: taskId,
      user_id: userId,
      title: 'Test Task',
      notes: null,
      status: 'completed', // This is the expected final status
      priority: 2,
      due: null,
      goal_id: null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(), // Include fields returned by select
    };

    // Mock setup for 'tasks' table operations
    const fetchMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(fetchMock); // Consistently return fetchMock for 'tasks'

    // Configure chainable methods to return the mock itself
    fetchMock.select.mockReturnValue(fetchMock);
    fetchMock.eq.mockReturnValue(fetchMock);
    fetchMock.update.mockReturnValue(fetchMock);

    // Configure .single() to resolve differently for fetch vs update
    fetchMock.single
      .mockResolvedValueOnce({ data: initialTaskData, error: null }) // First call (fetch)
      .mockResolvedValueOnce({ data: updatedTaskData, error: null }); // Second call (update confirmation)

    const caller = createTestCaller(userId);
    const result = await caller.task.toggleTask({
      taskId: taskId,
    });

    // Verify the result
    expect(result.status).toBe('completed');

    // Verify calls
    expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('tasks');
    expect(fetchMock.select).toHaveBeenCalledWith('id, status, goal_id, title');
    expect(fetchMock.update).toHaveBeenCalledWith(expect.objectContaining({ status: 'completed' }));
    expect(fetchMock.eq).toHaveBeenCalledWith('id', taskId);
    expect(fetchMock.eq).toHaveBeenCalledWith('user_id', userId);
    expect(fetchMock.select).toHaveBeenCalledWith('id, title, status, goal_id, updated_at');
    expect(fetchMock.single).toHaveBeenCalledTimes(2); // Called for fetch and update
  });

  it('should toggle a task from complete to incomplete', async () => {
    const taskId = 'task-1';
    const userId = 'test-user-id';
    const initialTaskData = {
      id: taskId,
      title: 'Test Task',
      status: 'completed', // Starting completed
      goal_id: null,
    };
    const updatedTaskData = {
      id: taskId,
      title: 'Test Task',
      status: 'in-progress', // Expected final status
      goal_id: null,
      updated_at: new Date().toISOString(),
    };

    // Mock setup for 'tasks' table operations
    const fetchMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(fetchMock); // Consistently return fetchMock

    // Configure chainable methods
    fetchMock.select.mockReturnValue(fetchMock);
    fetchMock.eq.mockReturnValue(fetchMock);
    fetchMock.update.mockReturnValue(fetchMock);

    // Configure .single() resolutions
    fetchMock.single
      .mockResolvedValueOnce({ data: initialTaskData, error: null }) // First call (fetch)
      .mockResolvedValueOnce({ data: updatedTaskData, error: null }); // Second call (update confirmation)

    const caller = createTestCaller(userId);
    const result = await caller.task.toggleTask({
      taskId: taskId,
    });

    // Verify the result
    expect(result.status).toBe('in-progress');

    // Verify calls
    expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('tasks');
    expect(fetchMock.select).toHaveBeenCalledWith('id, status, goal_id, title');
    expect(fetchMock.update).toHaveBeenCalledWith(expect.objectContaining({ status: 'in-progress' }));
    expect(fetchMock.eq).toHaveBeenCalledWith('id', taskId);
    expect(fetchMock.eq).toHaveBeenCalledWith('user_id', userId);
    expect(fetchMock.select).toHaveBeenCalledWith('id, title, status, goal_id, updated_at');
    expect(fetchMock.single).toHaveBeenCalledTimes(2); // Called for fetch and update
  });

  it('should update goal progress when toggling a task with goal association', async () => {
    const taskId = 'task-1';
    const goalId = 'goal-1';
    const userId = 'test-user-id';

    // --- Task Mocks --- 
    const taskFetchMock = mockDeep<MockableTableOperations>();
    const initialTaskData = { id: taskId, title: 'Goal Task', status: 'in-progress', goal_id: goalId };
    const updatedTaskData = { ...initialTaskData, status: 'completed', updated_at: new Date().toISOString() };
    
    taskFetchMock.select.mockReturnValue(taskFetchMock);
    taskFetchMock.eq.mockReturnValue(taskFetchMock);
    taskFetchMock.update.mockReturnValue(taskFetchMock);
    taskFetchMock.single
      .mockResolvedValueOnce({ data: initialTaskData, error: null }) // Fetch task
      .mockResolvedValueOnce({ data: updatedTaskData, error: null }); // Update task

    // Helper function to create a properly awaitable mock with data
    function createTableMockWithData<T>(data: T) {
      const mock = mockDeep<MockableTableOperations>();
      
      // Configure chainable methods to return this (for method chaining)
      mock.select.mockReturnThis();
      mock.eq.mockReturnThis();
      mock.order.mockReturnThis();
      mock.limit.mockReturnThis();
      mock.in.mockReturnThis();
      mock.update.mockReturnThis();
      mock.is.mockReturnThis();
      mock.neq.mockReturnThis();
      mock.or.mockReturnThis();
      
      // Add proper promise handling for awaitable operations
      const response = { data, error: null, status: 200, count: Array.isArray(data) ? data.length : undefined };
      const mockPromise = Promise.resolve(response);
      
      // Add then/catch/finally methods to make the mock awaitable
      (mock as any).then = mockPromise.then.bind(mockPromise);
      (mock as any).catch = mockPromise.catch.bind(mockPromise);
      (mock as any).finally = mockPromise.finally.bind(mockPromise);
      
      return mock;
    }
    
    // --- Goal Task List Mock --- 
    // Create a properly awaitable mock with the goal tasks data
    const goalTasksData = [
        { id: taskId, status: 'completed' }, // The toggled task
        { id: 'task-2', status: 'in-progress' },
    ];
    const goalTasksListMock = createTableMockWithData(goalTasksData);

    // --- Goal Update Mock --- 
    const updatedGoalData = { id: goalId, name: 'Test Goal', progress: 0.5, /* other fields */ updated_at: new Date().toISOString() }; // Example with 50% progress
    
    // Create an awaitable mock with the goal update data
    const goalUpdateMock = createTableMockWithData(updatedGoalData);
    // Make sure single() returns a properly typed response
    goalUpdateMock.single.mockResolvedValue({ data: updatedGoalData, error: null });


    // --- Configure from() to return the right mock based on table --- 
    mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
      if (table === 'tasks') {
        // First call to 'tasks' is for the initial fetch/update of the specific task
        // Second call is to get all tasks for the goal
        // Need a way to differentiate... maybe check chained methods?
        // For now, let's assume the first call structure uses single(), the second doesn't directly
        // A more robust way might involve mockFn.mock.calls inspection or clearer separation.
        // Let's try returning taskFetchMock first, then goalTasksListMock.
        if (mockSupabaseAdmin.from.mock.calls.filter(c => c[0] === 'tasks').length <= 1) {
            return taskFetchMock;
        } else {
            return goalTasksListMock;
        }
      }
      if (table === 'goals') {
        return goalUpdateMock; // Only call to 'goals' is for the update
      }
      // Fallback for any other table calls in the test setup (if any)
      const defaultMock = mockDeep<MockableTableOperations>();
      defaultMock.select.mockReturnValue(defaultMock);
      defaultMock.eq.mockReturnValue(defaultMock);
      defaultMock.single.mockResolvedValue({ data: null, error: { message: 'Default mock', code: 'MOCK_ERR' } });
      return defaultMock;
    });

    const caller = createTestCaller(userId);
    const result = await caller.task.toggleTask({
      taskId: taskId,
    });

    // Assertions
    expect(result.status).toBe('completed');
    expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('tasks'); // Called multiple times
    expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('goals');
    
    // Verify task update
    expect(taskFetchMock.update).toHaveBeenCalledWith(expect.objectContaining({ status: 'completed' }));
    expect(taskFetchMock.single).toHaveBeenCalledTimes(2); // Fetch + Update task

    // Verify fetching goal tasks
    expect(goalTasksListMock.select).toHaveBeenCalledWith('id, status');
    expect(goalTasksListMock.eq).toHaveBeenCalledWith('goal_id', goalId);

    // Verify goal update
    expect(goalUpdateMock.update).toHaveBeenCalledWith({ progress: 0.5 }); // 1 out of 2 tasks complete
    expect(goalUpdateMock.eq).toHaveBeenCalledWith('id', goalId);
    expect(goalUpdateMock.select).toHaveBeenCalledWith('id, name, progress, updated_at');
    expect(goalUpdateMock.single).toHaveBeenCalledTimes(1);

    // Reset implementation for next tests if needed (though beforeEach should handle it)
    // mockSupabaseAdmin.from.mockRestore(); // Or reset in beforeEach

  });

  it('should not change status if already in the target state', async () => {
    const taskId = 'task-1';
    const userId = 'test-user-id';
    const existingTask = {
      id: taskId,
      title: 'Test Task',
      status: 'completed',
      goal_id: null,
    };

    // --- Configure from() for tasks table --- 
    const tasksTableMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(tasksTableMock);
    tasksTableMock.select.mockReturnValue(tasksTableMock);
    tasksTableMock.eq.mockReturnValue(tasksTableMock);
    tasksTableMock.single.mockResolvedValue({ data: existingTask, error: null });

    // --- Configure from() for goals table (should not be called) ---
    const goalsTableMock = mockDeep<MockableTableOperations>();
    // ... setup mocks for goals table ...
    // This setup is complex, let's simplify if goal logic isn't tested here
    // goalsTableMock.update.mockReturnValue(goalsTableMock);
    // goalsTableMock.eq.mockReturnValue(goalsTableMock);
    // goalsTableMock.select.mockReturnValue(goalsTableMock);
    // goalsTableMock.single.mockResolvedValue({ data: null, error: null });
    // mockSupabaseAdmin.from('goals').mockReturnValue(goalsTableMock);
    const caller = createTestCaller(userId);
    const result = await caller.task.toggleTask({
      taskId: taskId,
    });

    // Verify the result
    expect(result.status).toBe('completed');

    // Verify no update was performed
    expect(mockSupabaseAdmin.from('tasks').update).not.toHaveBeenCalled();
    expect(mockSupabaseAdmin.from('goals').update).not.toHaveBeenCalled(); // Ensure goal not updated
  });

  it('should throw NOT_FOUND error if task does not exist', async () => {
    // Mock the initial fetch to return no data
    const fetchMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(fetchMock);
    fetchMock.select.mockReturnValue(fetchMock);
    fetchMock.eq.mockReturnValue(fetchMock);
    fetchMock.single.mockResolvedValue({ data: null, error: null }); // Simulate task not found

    const caller = createTestCaller();
    await expect(caller.task.toggleTask({ taskId: 'nonexistent-task' }))
      .rejects.toMatchObject({ code: 'NOT_FOUND' });

    // Ensure update was not called
    expect(fetchMock.update).not.toHaveBeenCalled();
  });

  it('should throw an error if the database update fails', async () => {
    const taskId = 'task-1';
    const userId = 'test-user-id';
    const initialTaskData = { id: taskId, status: 'in-progress', goal_id: null, title: 'Test' };
    const dbError = { message: 'Update failed', code: 'DB_ERROR' };

    // Mock the initial fetch
    const fetchMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(fetchMock);
    fetchMock.select.mockReturnValue(fetchMock);
    fetchMock.eq.mockReturnValue(fetchMock);
    fetchMock.update.mockReturnValue(fetchMock); // Update returns mock for chaining

    // Mock .single() for initial fetch (success) and update (failure)
    fetchMock.single
      .mockResolvedValueOnce({ data: initialTaskData, error: null }) // Fetch succeeds
      .mockResolvedValueOnce({ data: null, error: dbError });       // Update fails

    const caller = createTestCaller(userId);
    await expect(caller.task.toggleTask({ taskId: taskId }))
      .rejects.toMatchObject({ message: 'Update failed', code: 'DB_ERROR' });

    // Verify update was attempted
    expect(fetchMock.update).toHaveBeenCalledWith(expect.objectContaining({ status: 'completed' }));
    expect(fetchMock.single).toHaveBeenCalledTimes(2); // Fetch + Update attempt
  });

});
```
\n\n## Realtime Channel: test-helpers.ts
**File:** ./__tests__/server/test-helpers.ts
\n```
import { mockDeep, mockReset, DeepMockProxy } from 'jest-mock-extended';
import { User, AuthError } from '@supabase/supabase-js';
import { type Context } from '@/server/src/context';
import { TRPCError } from '@trpc/server';

// --- Common Response Type --- 
// Represents the core structure of Supabase Postgrest responses
export type MockablePostgrestResponse<T> = Promise<{
  data: T | null;
  error: any;
  count?: number | null; 
  status?: number;
  statusText?: string;
}>;

// --- Interface for CHAINABLE Query Builder methods --- 
// These methods return the builder itself to allow chaining.
export interface MockableQueryBuilder {
  select: (query?: string, options?: { head?: boolean; count?: 'exact' | 'planned' | 'estimated' }) => MockableQueryBuilder;
  eq: (column: string, value: any) => MockableQueryBuilder;
  neq: (column: string, value: any) => MockableQueryBuilder;
  gt: (column: string, value: any) => MockableQueryBuilder;
  gte: (column: string, value: any) => MockableQueryBuilder;
  lt: (column: string, value: any) => MockableQueryBuilder;
  lte: (column: string, value: any) => MockableQueryBuilder;
  like: (column: string, pattern: string) => MockableQueryBuilder;
  ilike: (column: string, pattern: string) => MockableQueryBuilder;
  is: (column: string, value: boolean | null) => MockableQueryBuilder;
  in: (column: string, values: any[]) => MockableQueryBuilder;
  contains: (column: string, value: any) => MockableQueryBuilder;
  containedBy: (column: string, value: any) => MockableQueryBuilder;
  rangeGt: (column: string, range: string) => MockableQueryBuilder;
  rangeGte: (column: string, range: string) => MockableQueryBuilder;
  rangeLt: (column: string, range: string) => MockableQueryBuilder;
  rangeLte: (column: string, range: string) => MockableQueryBuilder;
  rangeAdjacent: (column: string, range: string) => MockableQueryBuilder;
  overlaps: (column: string, value: any) => MockableQueryBuilder;
  textSearch: (column: string, query: string, options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }) => MockableQueryBuilder;
  match: (query: Record<string, unknown>) => MockableQueryBuilder;
  not: (column: string, operator: string, value: any) => MockableQueryBuilder;
  or: (filters: string, options?: { referencedTable?: string }) => MockableQueryBuilder;
  filter: (column: string, operator: string, value: any) => MockableQueryBuilder;
  limit: (count: number, options?: { referencedTable?: string }) => MockableQueryBuilder;
  range: (from: number, to: number, options?: { referencedTable?: string }) => MockableQueryBuilder;
  order: (column: string, options?: { ascending?: boolean; nullsFirst?: boolean; referencedTable?: string }) => MockableQueryBuilder;
}

// --- Interface for Operations on a Table (after .from()) --- 
// Inherits chainable methods AND adds terminal methods returning Promises.
export interface MockableTableOperations extends MockableQueryBuilder {
  // Terminal methods (return Promises)
  single: <T = any>() => MockablePostgrestResponse<T>;
  maybeSingle: <T = any>() => MockablePostgrestResponse<T>;
  // Note: Insert/Update/Upsert often return arrays in Supabase v2, but the *methods* return the builder
  insert: <T = any>(values: any | any[], options?: any) => MockableTableOperations; 
  upsert: <T = any>(values: any | any[], options?: any) => MockableTableOperations; 
  update: <T = any>(values: any, options?: any) => MockableTableOperations; 
  delete: (options?: any) => MockableTableOperations; 
}

// --- Interface for the Supabase Client itself --- 
/**
 * Represents the structure of the Supabase client that we need to mock.
 * `from` returns an object combining chainable and terminal methods.
 */
export interface MockableSupabaseClient {
  // `from` now returns the object with both chainable and terminal methods
  from: (relation: string) => MockableTableOperations;

  // Top-level client methods
  auth: {
    getUser: (
      jwt?: string
    ) => Promise<{ data: { user: User | null }; error: AuthError | null }>;
    // Add other auth methods here if needed by tests (e.g., signUp, signInWithPassword)
  };
  rpc: <T = any>(fn: string, params?: object, options?: { head?: boolean; count?: 'exact' | 'planned' | 'estimated' }) => MockablePostgrestResponse<T>;
  // Add storage interface here if needed by tests
  // storage: { ... };
}

// --- Mock Implementation --- 

// Create a deep mock instance conforming to the refined interface
export const mockSupabaseAdmin = mockDeep<MockableSupabaseClient>();

// Helper to reset mocks
export function resetSupabaseMocks() {
  // Use mockReset for better compatibility with jest-mock-extended
  mockReset(mockSupabaseAdmin);

  // --- Re-apply default implementations after reset --- 

  // Default: Successful authentication
  mockSupabaseAdmin.auth.getUser.mockResolvedValue({
    data: { user: { id: 'test-user-id', /* other user props */ } as User },
    error: null,
  });

  // Default: Successful RPC call returning null data
  mockSupabaseAdmin.rpc.mockResolvedValue({ 
      data: null, 
      error: null, 
      count: 0, 
      status: 200, 
      statusText: 'OK' 
  });

  // Helper type to create Promise-like chain-terminating objects
  type AsyncResult<T> = Promise<{ data: T | null; error: any; count?: number; status?: number; statusText?: string; }>;

  // Helper function to create a proper mock that handles both chaining AND awaiting
  function createMockWithPromiseCapability<T>(defaultData: T | null = null): any {
    const mockObj = mockDeep<MockableTableOperations>();
    
    // Add an implicit then handler that allows awaiting the mock directly
    // This is what Supabase's actual Query Builder does
    const defaultResponse = { 
      data: defaultData, 
      error: null, 
      count: defaultData && Array.isArray(defaultData) ? defaultData.length : 0,
      status: 200, 
      statusText: 'OK' 
    };
    
    // Allow the mock to be awaited directly
    (mockObj as any).then = jest.fn((onFulfill, onReject) => {
      return Promise.resolve(defaultResponse).then(onFulfill, onReject);
    });
    
    return mockObj;
  }

  // Default behavior for 'from': Return a mock that handles chaining and terminal methods
  mockSupabaseAdmin.from.mockImplementation((relation: string) => {
    // This inner mock needs to satisfy MockableTableOperations
    // AND be awaitable like a promise for terminal operations
    const innerMock = createMockWithPromiseCapability<any[]>([]);

    // --- Configure Default CHAINABLE Methods (Return Self) --- 
    innerMock.select.mockReturnValue(innerMock);
    innerMock.eq.mockReturnValue(innerMock);
    innerMock.neq.mockReturnValue(innerMock);
    innerMock.gt.mockReturnValue(innerMock);
    innerMock.gte.mockReturnValue(innerMock);
    innerMock.lt.mockReturnValue(innerMock);
    innerMock.lte.mockReturnValue(innerMock);
    innerMock.like.mockReturnValue(innerMock);
    innerMock.ilike.mockReturnValue(innerMock);
    innerMock.is.mockReturnValue(innerMock);
    innerMock.in.mockReturnValue(innerMock);
    innerMock.contains.mockReturnValue(innerMock);
    innerMock.containedBy.mockReturnValue(innerMock);
    innerMock.rangeGt.mockReturnValue(innerMock);
    innerMock.rangeGte.mockReturnValue(innerMock);
    innerMock.rangeLt.mockReturnValue(innerMock);
    innerMock.rangeLte.mockReturnValue(innerMock);
    innerMock.rangeAdjacent.mockReturnValue(innerMock);
    innerMock.overlaps.mockReturnValue(innerMock);
    innerMock.textSearch.mockReturnValue(innerMock);
    innerMock.match.mockReturnValue(innerMock);
    innerMock.not.mockReturnValue(innerMock);
    innerMock.or.mockReturnValue(innerMock);
    innerMock.filter.mockReturnValue(innerMock);
    innerMock.limit.mockReturnValue(innerMock);
    innerMock.range.mockReturnValue(innerMock);
    innerMock.order.mockReturnValue(innerMock);

    // --- Configure Default TERMINAL Methods --- 
    // For single-returning methods, default to null
    const singleResponse = { 
      data: null, 
      error: null, 
      status: 200, 
      statusText: 'OK' 
    };
    
    innerMock.single.mockResolvedValue(singleResponse);
    innerMock.maybeSingle.mockResolvedValue(singleResponse);
    
    // For insert/update/upsert operations, return the builder that can be chained further or awaited
    innerMock.insert.mockImplementation(() => {
      const insertMock = createMockWithPromiseCapability();
      insertMock.select.mockReturnValue(insertMock);
      return insertMock;
    });
    
    innerMock.upsert.mockImplementation(() => {
      const upsertMock = createMockWithPromiseCapability();
      upsertMock.select.mockReturnValue(upsertMock);
      return upsertMock;
    });
    
    innerMock.update.mockImplementation(() => {
      const updateMock = createMockWithPromiseCapability();
      updateMock.select.mockReturnValue(updateMock);
      return updateMock;
    });
    
    innerMock.delete.mockImplementation(() => {
      const deleteMock = createMockWithPromiseCapability();
      deleteMock.select.mockReturnValue(deleteMock);
      return deleteMock;
    });

    return innerMock;
  });
}

// Initialize mocks on first load
resetSupabaseMocks();

// --- Context Creation --- 

// Expand this type as more tables are tested
export type TableName = 
  | 'users' 
  | 'user_profiles' 
  | 'user_settings'
  | 'values'
  | 'principles'
  | 'goals' 
  | 'tasks'
  | 'habits'
  | 'habit_entries'
  | 'tracked_state_defs' 
  | 'state_entries'     
  | 'reminders'         
  | 'goal_progress_notes'
  | 'rewards'           
  | 'user_badges';       

/**
 * Creates a TRPC context with a mocked Supabase client.
 * Ensures the user is authenticated unless explicitly bypassed.
 */
export function createInnerTRPCContext(opts: {
  userId: string | null;
  supabase?: any; // Keep as any for simplicity
}): Context {
  if (!opts.userId) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
      message: 'User must be authenticated to access this resource',
    });
  }

  return {
    userId: opts.userId,
    supabaseAdmin: opts.supabase || mockSupabaseAdmin,
  };
}

export function createTestContext(userId: string | null = 'test-user-id', supabase?: any) {
  return createInnerTRPCContext({
    userId,
    supabase,
  });
}

// Export mockDeep so it can be used directly in tests if needed
export { mockDeep };
```
\n\n## Realtime Channel: HabitCheckItem.test.tsx
**File:** ./__tests__/components/dashboard/HabitCheckItem.test.tsx
\n```
import React from 'react';
import { render, fireEvent, act } from '../test-utils';
import HabitCheckItem from '@/components/dashboard/HabitCheckItem';
import { trpc } from '@/utils/trpc';

// Mock the trpc hook
jest.mock('@/utils/trpc', () => ({
  trpc: {
    habit: {
      createHabitEntry: {
        useMutation: jest.fn().mockReturnValue({
          mutate: jest.fn(),
          isLoading: false,
          isError: false,
          error: null,
        }),
      },
      deleteHabitEntry: {
        useMutation: jest.fn().mockReturnValue({
          mutate: jest.fn(),
          isLoading: false,
          isError: false,
          error: null,
        }),
      },
    },
  },
}));

// Mock Haptics
jest.mock('expo-haptics', () => ({
  impactAsync: jest.fn(),
  ImpactFeedbackStyle: {
    Light: 'light',
  },
}));

describe('HabitCheckItem', () => {
  const mockHabit = {
    id: 'habit-1',
    title: 'Morning Run',
    streak: 3,
    completedToday: false,
    best_streak: 5,
    user_id: 'user-1',
    cue: 'Wake up',
    routine: 'Run 5k',
    reward: 'Coffee',
    habit_type: 'do',
    frequency_period: 'daily',
    goal_frequency: 1,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders correctly with uncompleted habit', () => {
    const { getByText } = render(<HabitCheckItem habit={mockHabit} />);
    
    expect(getByText('Morning Run')).toBeTruthy();
    expect(getByText(' 3 day streak')).toBeTruthy();
    expect(getByText('Check-in')).toBeTruthy();
  });

  it('renders correctly with completed habit for today', () => {
    const completedHabit = { ...mockHabit, completedToday: true };
    const { getByText } = render(<HabitCheckItem habit={completedHabit} />);
    
    expect(getByText('Morning Run')).toBeTruthy();
    expect(getByText(' 3 day streak')).toBeTruthy();
    expect(getByText('Done')).toBeTruthy();
  });

  it('calls createHabitEntry mutation when checking in', () => {
    const mockOnToggle = jest.fn();
    const mockCreateMutate = jest.fn();

    // Setup the mock create mutation
    (trpc.habit.createHabitEntry.useMutation as jest.Mock).mockReturnValue({
      mutate: mockCreateMutate,
      isLoading: false,
      isError: false,
      error: null,
    });

    const { getByText } = render(
      <HabitCheckItem habit={{...mockHabit, completedToday: false}} onToggle={mockOnToggle} />
    );

    // Press the check-in button
    fireEvent.press(getByText('Check-in'));

    // Verify the create mutation was called
    expect(mockCreateMutate).toHaveBeenCalledWith(expect.objectContaining({
      habitId: 'habit-1',
      date: expect.any(String),
      completed: true,
    }));

    // Verify the onToggle prop was called if provided
    expect(mockOnToggle).toHaveBeenCalledWith('habit-1', true);
  });

  it('calls deleteHabitEntry mutation when unchecking', () => {
    const mockOnToggle = jest.fn();
    const mockDeleteMutate = jest.fn();

    // Setup the mock delete mutation
    (trpc.habit.deleteHabitEntry.useMutation as jest.Mock).mockReturnValue({
      mutate: mockDeleteMutate,
      isLoading: false,
      isError: false,
      error: null,
    });

    const { getByText } = render(
      <HabitCheckItem habit={{...mockHabit, completedToday: true}} onToggle={mockOnToggle} />
    );

    // Press the done button
    fireEvent.press(getByText('Done'));

    // Verify the delete mutation was called
    expect(mockDeleteMutate).toHaveBeenCalledWith(expect.objectContaining({
      habitId: 'habit-1',
      date: expect.any(String),
    }));

    // Verify the onToggle prop was called if provided
    expect(mockOnToggle).toHaveBeenCalledWith('habit-1', false);
  });

  it('handles error state from mutation', async () => {
    // Mock console.error to prevent test output noise
    const originalConsoleError = console.error;
    console.error = jest.fn();

    // Assume createHabitEntry for error testing, could be delete too
    let errorCallback: (error: any) => void = () => {};
    
    (trpc.habit.createHabitEntry.useMutation as jest.Mock).mockImplementation(({ onError }) => {
      errorCallback = onError;
      return {
        mutate: jest.fn(),
        isLoading: false,
        isError: true,
      };
    });

    const { getByText } = render(<HabitCheckItem habit={mockHabit} />);

    // Press the check-in button (assuming initial state is not completed)
    fireEvent.press(getByText('Check-in'));

    // Simulate an error from the server
    await act(async () => {
      errorCallback(new Error('Network error'));
    });

    // Check that error was logged
    expect(console.error).toHaveBeenCalled();

    // Restore console.error
    console.error = originalConsoleError;
  });
});
```
\n\n## Realtime Channel: useSkeleton.ts
**File:** ./hooks/useSkeleton.ts
\n```
import { useEffect } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withTiming,
  withSequence,
  withDelay,
  Easing,
} from 'react-native-reanimated';
import { durations, easings } from '@/constants/motion';

export interface SkeletonOptions {
  /**
   * Width of the gradient shimmer (as % of the component width)
   * @default 0.7
   */
  shimmerWidth?: number;
  /**
   * Base color of the skeleton component
   * @default '#E1E9EE'
   */
  baseColor?: string;
  /**
   * Highlight color for the shimmer effect
   * @default '#F2F8FC'
   */
  highlightColor?: string;
  /**
   * Duration for a complete shimmer cycle in ms
   * @default 2000
   */
  duration?: number;
  /**
   * Delay before starting animation in ms
   * @default 0
   */
  delay?: number;
  /**
   * Whether animation should start automatically
   * @default true
   */
  autoStart?: boolean;
  /**
   * Loading state to determine if skeletons should be shown
   * @default false
   */
  isLoading?: boolean;
  /**
   * Number of skeleton items to generate
   * @default 1
   */
  count?: number;
  /**
   * Type of skeleton to generate
   * @default 'card'
   */
  type?: 'card' | 'row' | 'circle';
}

/**
 * Hook to create skeleton loading animations with shimmer effect
 */
export function useSkeleton(options: SkeletonOptions = {}) {
  const {
    shimmerWidth = 0.7,
    baseColor = '#E1E9EE',
    highlightColor = '#F2F8FC',
    duration = durations.long * 2,
    delay = 0,
    autoStart = true,
  } = options;
  
  // Animation value to track shimmer position
  const translateX = useSharedValue(-1);
  
  // Start the animation
  useEffect(() => {
    if (autoStart) {
      translateX.value = withDelay(
        delay,
        withRepeat(
          withSequence(
            withTiming(-1, { duration: 0 }),
            withTiming(1, { 
              duration, 
              easing: easings.linear 
            }),
          ),
          -1, // Infinite repeat
        ),
      );
    }
  }, [translateX, duration, delay, autoStart]);
  
  // Generate the animated styles for the shimmer effect
  const shimmerStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateX: translateX.value * (1 + shimmerWidth) }],
    };
  });
  
  // Create styles for both container and shimmer
  const styles = StyleSheet.create({
    container: {
      backgroundColor: baseColor,
      overflow: 'hidden',
    },
    shimmer: {
      width: `${shimmerWidth * 100}%`,
      height: '100%',
      backgroundColor: highlightColor,
      position: 'absolute',
      top: 0,
      bottom: 0,
      opacity: 0.7,
    },
  });
  
  // Utility function to manually start the animation
  const startAnimation = () => {
    translateX.value = withDelay(
      delay,
      withRepeat(
        withSequence(
          withTiming(-1, { duration: 0 }),
          withTiming(1, { 
            duration, 
            easing: easings.linear 
          }),
        ),
        -1, // Infinite repeat
      ),
    );
  };
  
  // Utility function to stop the animation
  const stopAnimation = () => {
    translateX.value = withTiming(-1, { duration: 200 });
  };
  
  // Generate array of skeletons based on count and type
  const generateSkeletons = () => {
    if (!options.isLoading) return [];
    
    const count = options.count || 1;
    const type = options.type || 'card';
    
    return Array.from({ length: count }).map((_, index) => ({
      key: `skeleton-${index}`,
      type,
    }));
  };
  
  return {
    baseColor,
    shimmerStyle,
    styles,
    startAnimation,
    stopAnimation,
    skeletons: generateSkeletons(),
  };
} ```
\n\n## Realtime Channel: useOfflineSync.ts
**File:** ./hooks/useOfflineSync.ts
\n```
import { useEffect, useCallback } from 'react';
import NetInfo from '@react-native-community/netinfo';
import { onlineManager } from '@tanstack/react-query';
import { saveOfflineMutation, syncOfflineMutations, getPendingItems, PendingItem, setupBackgroundSync } from '@/utils/offline-sync';
import { useState } from 'react';

/**
 * Hook to provide offline sync functionality
 */
export function useOfflineSync<T extends { id: string }>(entityType: string) {
  const [isOnline, setIsOnline] = useState(true);
  const [pendingItems, setPendingItems] = useState<PendingItem[]>([]);
  const [isSyncing, setIsSyncing] = useState(false);

  // Load pending items on mount
  useEffect(() => {
    loadPendingItems();
    
    // Set up network status listener
    const unsubscribe = NetInfo.addEventListener(state => {
      const online = state.isConnected !== false && state.isInternetReachable !== false;
      setIsOnline(online);
      
      // If going from offline to online, try to sync
      if (online) {
        syncItems();
      }
    });
    
    // Also set up background sync (network status changes outside this component)
    const unsubscribeBackground = setupBackgroundSync();
    
    return () => {
      unsubscribe();
      unsubscribeBackground();
    };
  }, [entityType]);

  // Load pending items from storage
  const loadPendingItems = useCallback(async () => {
    const items = await getPendingItems(entityType);
    setPendingItems(items);
  }, [entityType]);

  // Create an item (works offline)
  const createItem = useCallback(async (data: Omit<T, 'id'>): Promise<{ id: string, isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, create directly
        // In a real app, you'd use your API client (like supabase) here
        // const { data: newItem, error } = await supabase.from(entityType).insert(data).select();
        // if (error) throw error;
        // return { id: newItem.id, isOffline: false };
        
        // For demo purposes, simulate success
        return { id: `server-${Date.now()}`, isOffline: false };
      } else {
        // If offline, save to be synced later
        const tempId = await saveOfflineMutation('create', entityType, data);
        await loadPendingItems(); // Reload pending items
        return { id: tempId, isOffline: true };
      }
    } catch (error) {
      console.error('Error creating item:', error);
      // If API call fails, save offline
      const tempId = await saveOfflineMutation('create', entityType, data);
      await loadPendingItems(); // Reload pending items
      return { id: tempId, isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Update an item (works offline)
  const updateItem = useCallback(async (item: T): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, update directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).update(item).eq('id', item.id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('update', entityType, item);
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error updating item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('update', entityType, item);
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Delete an item (works offline)
  const deleteItem = useCallback(async (id: string): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, delete directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).delete().eq('id', id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('delete', entityType, { id });
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error deleting item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('delete', entityType, { id });
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Manually trigger sync
  const syncItems = useCallback(async (): Promise<boolean> => {
    if (isSyncing) return false;
    
    setIsSyncing(true);
    try {
      const success = await syncOfflineMutations();
      if (success) {
        await loadPendingItems(); // Reload pending items after successful sync
      }
      return success;
    } catch (error) {
      console.error('Error syncing items:', error);
      return false;
    } finally {
      setIsSyncing(false);
    }
  }, [isSyncing, loadPendingItems]);

  // Check if an item is pending sync
  const isItemPending = useCallback((id: string): boolean => {
    return pendingItems.some(item => item.id === id);
  }, [pendingItems]);

  return {
    isOnline,
    isSyncing,
    pendingItems,
    createItem,
    updateItem,
    deleteItem,
    syncItems,
    isItemPending,
  };
} ```
\n## Polling Implementation
\n\n## Polling: nats-client.ts
**File:** ./utils/nats-client.ts
\n```
import { QueryClient } from '@tanstack/react-query';
import { connect, type ConnectionOptions, type NatsConnection, StringCodec } from 'nats.ws';

// Codec for encoding/decoding NATS messages
const sc = StringCodec();

// Type for cache update handlers
type CacheUpdateHandler = (data: any) => void;

// Global handlers for different subjects
const handlers: Record<string, CacheUpdateHandler[]> = {};

// Connection state
let natsConnection: NatsConnection | null = null;
let queryClient: QueryClient | null = null;
let isConnecting = false;

/**
 * Initialize the NATS client and connect to the server
 */
export async function initNatsClient(
  url: string, 
  qc: QueryClient,
  options: Partial<ConnectionOptions> = {}
): Promise<NatsConnection> {
  if (natsConnection) {
    return natsConnection;
  }
  
  if (isConnecting) {
    throw new Error('NATS connection is already in progress');
  }
  
  isConnecting = true;
  
  try {
    // Set the query client for cache updates
    queryClient = qc;
    
    // Connect to NATS server
    natsConnection = await connect({
      servers: url,
      // Add required polyfills for React Native
      // These would need to be properly implemented in a real app
      ...options,
    });
    
    console.log('Connected to NATS server');
    
    // Setup ping interval to keep connection alive
    const pingInterval = setInterval(() => {
      if (natsConnection && !natsConnection.isClosed) {
        // Note: Using a custom ping mechanism instead of the built-in one
        try {
          const start = Date.now();
          // Simple ping using a request to a dummy subject
          natsConnection.request('_PING_', undefined, { timeout: 1000 })
            .then(() => {
              const latency = Date.now() - start;
              console.log(`NATS server latency: ${latency}ms`);
            })
            .catch((err: Error) => {
              console.error('NATS ping error:', err.message);
            });
        } catch (err) {
          const error = err as Error;
          console.error('NATS ping error:', error.message);
        }
      } else {
        clearInterval(pingInterval);
      }
    }, 30000);
    
    // Handle connection close
    natsConnection.closed().then(() => {
      console.log('NATS connection closed');
      natsConnection = null;
      clearInterval(pingInterval);
      // Could implement reconnection logic here
    });
    
    return natsConnection;
  } catch (error) {
    console.error('Failed to connect to NATS server:', error);
    isConnecting = false;
    throw error;
  }
}

/**
 * Subscribe to a NATS subject and update the React Query cache
 */
export async function subscribeWithCache(
  subject: string,
  queryKey: unknown[],
  updateType: 'invalidate' | 'setData' = 'invalidate'
): Promise<() => void> {
  if (!natsConnection) {
    throw new Error('NATS client not initialized');
  }
  
  if (!queryClient) {
    throw new Error('QueryClient not set');
  }
  
  // Create subscription
  const subscription = natsConnection.subscribe(subject);
  
  // Setup message handler
  (async () => {
    for await (const msg of subscription) {
      try {
        const data = JSON.parse(sc.decode(msg.data));
        
        if (updateType === 'invalidate') {
          // Invalidate the cache for this query key
          queryClient.invalidateQueries({ queryKey });
        } else {
          // Update the cache directly
          queryClient.setQueryData(queryKey, data);
        }
        
        // Call any custom handlers
        if (handlers[subject]) {
          handlers[subject].forEach(handler => handler(data));
        }
      } catch (error) {
        const err = error as Error;
        console.error(`Error handling message for ${subject}:`, err.message);
      }
    }
  })();
  
  // Return unsubscribe function
  return () => {
    subscription.unsubscribe();
  };
}

/**
 * Add a custom handler for a subject
 */
export function addSubjectHandler(subject: string, handler: CacheUpdateHandler): () => void {
  if (!handlers[subject]) {
    handlers[subject] = [];
  }
  
  handlers[subject].push(handler);
  
  // Return a function to remove the handler
  return () => {
    if (handlers[subject]) {
      handlers[subject] = handlers[subject].filter(h => h !== handler);
    }
  };
}

/**
 * Get the NATS connection
 */
export function getNatsConnection(): NatsConnection | null {
  return natsConnection;
}

/**
 * Close the NATS connection
 */
export async function closeNatsConnection(): Promise<void> {
  if (natsConnection) {
    await natsConnection.close();
    natsConnection = null;
  }
} ```
\n\n# 4️⃣ Core Query Hooks
\n\n## Hook: useSkeleton
**File:** hooks/useSkeleton.ts
\n```
import { useEffect } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withTiming,
  withSequence,
  withDelay,
  Easing,
} from 'react-native-reanimated';
import { durations, easings } from '@/constants/motion';

export interface SkeletonOptions {
  /**
   * Width of the gradient shimmer (as % of the component width)
   * @default 0.7
   */
  shimmerWidth?: number;
  /**
   * Base color of the skeleton component
   * @default '#E1E9EE'
   */
  baseColor?: string;
  /**
   * Highlight color for the shimmer effect
   * @default '#F2F8FC'
   */
  highlightColor?: string;
  /**
   * Duration for a complete shimmer cycle in ms
   * @default 2000
   */
  duration?: number;
  /**
   * Delay before starting animation in ms
   * @default 0
   */
  delay?: number;
  /**
   * Whether animation should start automatically
   * @default true
   */
  autoStart?: boolean;
  /**
   * Loading state to determine if skeletons should be shown
   * @default false
   */
  isLoading?: boolean;
  /**
   * Number of skeleton items to generate
   * @default 1
   */
  count?: number;
  /**
   * Type of skeleton to generate
   * @default 'card'
   */
  type?: 'card' | 'row' | 'circle';
}

/**
 * Hook to create skeleton loading animations with shimmer effect
 */
export function useSkeleton(options: SkeletonOptions = {}) {
  const {
    shimmerWidth = 0.7,
    baseColor = '#E1E9EE',
    highlightColor = '#F2F8FC',
    duration = durations.long * 2,
    delay = 0,
    autoStart = true,
  } = options;
  
  // Animation value to track shimmer position
  const translateX = useSharedValue(-1);
  
  // Start the animation
  useEffect(() => {
    if (autoStart) {
      translateX.value = withDelay(
        delay,
        withRepeat(
          withSequence(
            withTiming(-1, { duration: 0 }),
            withTiming(1, { 
              duration, 
              easing: easings.linear 
            }),
          ),
          -1, // Infinite repeat
        ),
      );
    }
  }, [translateX, duration, delay, autoStart]);
  
  // Generate the animated styles for the shimmer effect
  const shimmerStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateX: translateX.value * (1 + shimmerWidth) }],
    };
  });
  
  // Create styles for both container and shimmer
  const styles = StyleSheet.create({
    container: {
      backgroundColor: baseColor,
      overflow: 'hidden',
    },
    shimmer: {
      width: `${shimmerWidth * 100}%`,
      height: '100%',
      backgroundColor: highlightColor,
      position: 'absolute',
      top: 0,
      bottom: 0,
      opacity: 0.7,
    },
  });
  
  // Utility function to manually start the animation
  const startAnimation = () => {
    translateX.value = withDelay(
      delay,
      withRepeat(
        withSequence(
          withTiming(-1, { duration: 0 }),
          withTiming(1, { 
            duration, 
            easing: easings.linear 
          }),
        ),
        -1, // Infinite repeat
      ),
    );
  };
  
  // Utility function to stop the animation
  const stopAnimation = () => {
    translateX.value = withTiming(-1, { duration: 200 });
  };
  
  // Generate array of skeletons based on count and type
  const generateSkeletons = () => {
    if (!options.isLoading) return [];
    
    const count = options.count || 1;
    const type = options.type || 'card';
    
    return Array.from({ length: count }).map((_, index) => ({
      key: `skeleton-${index}`,
      type,
    }));
  };
  
  return {
    baseColor,
    shimmerStyle,
    styles,
    startAnimation,
    stopAnimation,
    skeletons: generateSkeletons(),
  };
} ```
\n\n## Hook: useColorScheme.web
**File:** hooks/useColorScheme.web.ts
\n```
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}
```
\n\n## Hook: useThemeColor
**File:** hooks/useThemeColor.ts
\n```
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}
```
\n\n## Hook: useColorScheme
**File:** hooks/useColorScheme.ts
\n```
export { useColorScheme } from 'react-native';
```
\n\n## Hook: useOfflineSync
**File:** hooks/useOfflineSync.ts
\n```
import { useEffect, useCallback } from 'react';
import NetInfo from '@react-native-community/netinfo';
import { onlineManager } from '@tanstack/react-query';
import { saveOfflineMutation, syncOfflineMutations, getPendingItems, PendingItem, setupBackgroundSync } from '@/utils/offline-sync';
import { useState } from 'react';

/**
 * Hook to provide offline sync functionality
 */
export function useOfflineSync<T extends { id: string }>(entityType: string) {
  const [isOnline, setIsOnline] = useState(true);
  const [pendingItems, setPendingItems] = useState<PendingItem[]>([]);
  const [isSyncing, setIsSyncing] = useState(false);

  // Load pending items on mount
  useEffect(() => {
    loadPendingItems();
    
    // Set up network status listener
    const unsubscribe = NetInfo.addEventListener(state => {
      const online = state.isConnected !== false && state.isInternetReachable !== false;
      setIsOnline(online);
      
      // If going from offline to online, try to sync
      if (online) {
        syncItems();
      }
    });
    
    // Also set up background sync (network status changes outside this component)
    const unsubscribeBackground = setupBackgroundSync();
    
    return () => {
      unsubscribe();
      unsubscribeBackground();
    };
  }, [entityType]);

  // Load pending items from storage
  const loadPendingItems = useCallback(async () => {
    const items = await getPendingItems(entityType);
    setPendingItems(items);
  }, [entityType]);

  // Create an item (works offline)
  const createItem = useCallback(async (data: Omit<T, 'id'>): Promise<{ id: string, isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, create directly
        // In a real app, you'd use your API client (like supabase) here
        // const { data: newItem, error } = await supabase.from(entityType).insert(data).select();
        // if (error) throw error;
        // return { id: newItem.id, isOffline: false };
        
        // For demo purposes, simulate success
        return { id: `server-${Date.now()}`, isOffline: false };
      } else {
        // If offline, save to be synced later
        const tempId = await saveOfflineMutation('create', entityType, data);
        await loadPendingItems(); // Reload pending items
        return { id: tempId, isOffline: true };
      }
    } catch (error) {
      console.error('Error creating item:', error);
      // If API call fails, save offline
      const tempId = await saveOfflineMutation('create', entityType, data);
      await loadPendingItems(); // Reload pending items
      return { id: tempId, isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Update an item (works offline)
  const updateItem = useCallback(async (item: T): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, update directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).update(item).eq('id', item.id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('update', entityType, item);
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error updating item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('update', entityType, item);
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Delete an item (works offline)
  const deleteItem = useCallback(async (id: string): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, delete directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).delete().eq('id', id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('delete', entityType, { id });
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error deleting item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('delete', entityType, { id });
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Manually trigger sync
  const syncItems = useCallback(async (): Promise<boolean> => {
    if (isSyncing) return false;
    
    setIsSyncing(true);
    try {
      const success = await syncOfflineMutations();
      if (success) {
        await loadPendingItems(); // Reload pending items after successful sync
      }
      return success;
    } catch (error) {
      console.error('Error syncing items:', error);
      return false;
    } finally {
      setIsSyncing(false);
    }
  }, [isSyncing, loadPendingItems]);

  // Check if an item is pending sync
  const isItemPending = useCallback((id: string): boolean => {
    return pendingItems.some(item => item.id === id);
  }, [pendingItems]);

  return {
    isOnline,
    isSyncing,
    pendingItems,
    createItem,
    updateItem,
    deleteItem,
    syncItems,
    isItemPending,
  };
} ```
\n## tRPC Query Usage Examples
\n\n## tRPC Query Example: compose.tsx
**File:** app/compose.tsx
\n```
// app/compose.tsx
import React from 'react';
import { ScrollView } from 'react-native'; // Using RN ScrollView directly
import { Stack, useRouter, useLocalSearchParams } from 'expo-router';
import { YStack, XStack, Form, Input, Label, TextArea, Button, Switch, Paragraph, Spinner } from 'tamagui';
import { useForm, Controller, ControllerRenderProps, FieldValues } from 'react-hook-form'; // Import ControllerRenderProps
import { zodResolver } from '@hookform/resolvers/zod';
import { useToastController } from '@tamagui/toast'; // Assuming ToastProvider is set up

import { trpc, type RouterInputs } from '@/utils/trpc'; // Assuming inputs are exported like this
import { haptics } from '@/utils/haptics'; // Assuming haptics helper exists

// Assuming your Zod schemas are exported like this. Adjust if necessary.
type CreateValueInput = RouterInputs['value']['createValue'];
type CreateStateInput = RouterInputs['state']['createDefinition'];

// 1️⃣ Define tagged types for discriminated union
type CreateValueInputTagged = CreateValueInput & { __type: 'value' };
type CreateStateInputTagged = CreateStateInput & { __type: 'state' };
type FormValues = CreateValueInputTagged | CreateStateInputTagged;

export default function ComposeModal() {
  const router = useRouter();
  const params = useLocalSearchParams<{ type: string }>();
  const type = params.type === 'value' || params.type === 'state' ? params.type : undefined;
  const toast = useToastController();
  const utils = trpc.useUtils();

  const isValue = type === 'value';

  // 2️⃣ Define stricter default values using tagged types
  const defaultValueValues: CreateValueInputTagged = {
    __type: 'value',
    title: '', // Use 'title' instead of 'name' - Patch #4
    description: ''
  };
  const defaultStateValues: CreateStateInputTagged = {
    __type: 'state',
    name: '',
    scale: '1-5',
    description: '',
    active: true,
    priority: 50
  };

  // --- Separate useMutation hooks ---
  const createValueMutation = trpc.value.createValue.useMutation({
    onSuccess: (data) => handleSuccess(data),
    onError: (error) => handleError(error),
  });
  const createStateDefMutation = trpc.state.createDefinition.useMutation({
    onSuccess: (data) => handleSuccess(data),
    onError: (error) => handleError(error),
  });

  // --- Form setup ---
  const { control, handleSubmit, formState: { errors }, reset } = useForm<FormValues>({
    // Note: ZodResolver might need specific configuration if schemas differ vastly
    // or consider not using it if relying solely on backend validation for this dynamic form.
    // Use the new stricter default value constants
    defaultValues: isValue ? defaultValueValues : defaultStateValues,
  });

  // Reset form if the type changes dynamically
  React.useEffect(() => {
    // Use the new stricter default value constants for reset
    reset(isValue ? defaultValueValues : defaultStateValues);
  }, [isValue, reset]);

  // --- Shared success/error handlers ---
  const handleSuccess = (data: any) => {
      toast.show('Created successfully!', { native: true });
      haptics.success();
      if (isValue) {
        utils.value.getValues.invalidate();
      } else {
        utils.state.getDefinitions.invalidate();
      }
      if (router.canGoBack()) {
        router.dismiss(); // Apply patch #5 - Use dismiss for modals
      } else {
        router.replace('/(tabs)/compass');
      }
  }

  const handleError = (error: any) => {
       toast.show(`Error: ${error.message}`, { type: 'error', native: true });
       haptics.error();
  }

  // --- Corrected onSubmit ---
  const onSubmit = (formData: FormValues) => {
    // 3️⃣ Use discriminant (__type) for type safety, remove casts
    if (formData.__type === 'value') {
      createValueMutation.mutate(formData);
    } else { // formData.__type === 'state'
      createStateDefMutation.mutate(formData);
    }
  };

  // Handle invalid type parameter gracefully
  if (!type) {
    return (
        <YStack flex={1} justifyContent="center" alignItems="center" padding="$4">
            <Paragraph color="$error">Invalid type specified.</Paragraph> {/* Use $error */}
            <Button onPress={() => router.back()} marginTop="$4">Go Back</Button>
        </YStack>
    );
  }

  // Determine current mutation state for button
  const isPending = isValue ? createValueMutation.isPending : createStateDefMutation.isPending;

  return (
    <ScrollView contentContainerStyle={{ flexGrow: 1 }}>
      <Form onSubmit={handleSubmit(onSubmit)} flex={1} padding="$4" space="$4" backgroundColor="$background">
        <Stack.Screen options={{ title: isValue ? 'Add Principle' : 'Define State' }} />

        {/* Conditionally render form fields */}
        {isValue ? (
          <>
            {/* --- Fields for Principle/Value --- */}
            <YStack space="$2">
              <Label htmlFor="title">Title</Label> {/* Patch #4: name -> title */}
              <Controller
                name="title" /* Patch #4: name -> title */
                control={control}
                rules={{ required: 'Title is required' }} /* Patch #4 */
                render={({ field }) => ( /* Use inferred types from FormValues */
                  <Input
                    id="title"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value}
                    placeholder="Principle Title"
                  />
                )}
              />
              {/* Use $error token */}
              {errors.title && <Paragraph color="$error">{errors.title?.message}</Paragraph>}
            </YStack>

            <YStack space="$2">
              <Label htmlFor="description">Description (Optional)</Label>
              <Controller
                name="description"
                control={control}
                render={({ field }) => ( // Use inferred types
                  <TextArea
                    id="description"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value ?? ''}
                    placeholder="Describe the principle..."
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && <Paragraph color="$error">{errors.description?.message}</Paragraph>}
            </YStack>
          </>
        ) : (
          <>
            {/* --- Fields for State Definition --- */}
            <YStack space="$2">
              <Label htmlFor="name">State Name</Label>
              <Controller
                name="name"
                control={control}
                rules={{ required: 'Name is required' }}
                render={({ field }) => ( // Use inferred types // Explicit type
                  <Input
                    id="name"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value}
                    placeholder="e.g., Energy Level, Mood" />
                )}
              />
              {errors.name && <Paragraph color="$error">{errors.name?.message}</Paragraph>}
            </YStack>

             <YStack space="$2">
               <Label htmlFor="scale">Scale</Label>
               <Controller
                 name="scale"
                 control={control}
                 rules={{ required: 'Scale is required' }}
                 render={({ field }) => ( // Use inferred types
                   <>
                    <Paragraph>Scale Selector Placeholder (Selected: {field.value})</Paragraph>
                    <XStack space="$2">
                      {/* Removed invalid theme prop */}
                      <Button size="$2" onPress={() => field.onChange('1-5')} theme={field.value === '1-5' ? 'active' : undefined}>1-5</Button>
                      <Button size="$2" onPress={() => field.onChange('1-10')} theme={field.value === '1-10' ? 'active' : undefined}>1-10</Button>
                    </XStack>
                   </>
                 )}
               />
                {errors.scale && <Paragraph color="$error">{errors.scale?.message}</Paragraph>}
             </YStack>

             <YStack space="$2">
              <Label htmlFor="description">Description (Optional)</Label>
              <Controller
                name="description"
                control={control}
                render={({ field }) => ( // Use inferred types
                  <TextArea
                    id="description"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value ?? ''}
                    placeholder="Describe when/how to track this state..."
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && <Paragraph color="$error">{errors.description?.message}</Paragraph>}
            </YStack>

            <XStack space="$4" alignItems="center">
               <Label htmlFor="active" flex={1}>Active</Label>
               <Controller
                 name="active"
                 control={control}
                 render={({ field }: { field: ControllerRenderProps<FieldValues, 'active'> }) => ( // Explicit type
                    <Switch
                      id="active"
                      checked={!!field.value} // Use checked
                      onCheckedChange={field.onChange} // Use onCheckedChange
                      size="$3"
                    >
                        <Switch.Thumb animation="quick" />
                    </Switch>
                 )}
               />
            </XStack>
          </>
        )}

        {/* Removed invalid theme prop */}
        <Form.Trigger asChild disabled={isPending}>
          <Button icon={isPending ? <Spinner /> : undefined}>
            {isPending ? 'Saving...' : 'Save'}
          </Button>
        </Form.Trigger>
      </Form>
    </ScrollView>
  );
}```
\n\n## tRPC Query Example: index.tsx
**File:** app/(tabs)/home/index.tsx
\n```
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/home/index.tsx
import React, { useCallback, useMemo } from 'react';
import { YStack, H1, Text, XStack, Button, ScrollView, Spinner } from 'tamagui';
import { SafeAreaView, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc, RouterOutputs } from '@/utils/trpc';
import DashboardSection from '@/components/dashboard/DashboardSection';
import GoalSummaryCard from '@/components/dashboard/GoalSummaryCard';
import HabitCheckItem from '@/components/dashboard/HabitCheckItem';
import TaskItem from '@/components/dashboard/TaskItem';
import StateIndicator from '@/components/dashboard/StateIndicator';
import DailyProgressBanner from '@/components/dashboard/DailyProgressBanner'; // Import Banner
import EmptyOrSkeleton from '@/components/ui/EmptyOrSkeleton';
import { SkeletonCard, SkeletonRow } from '@/components/ui/Skeleton';
import { useSkeleton } from '@/hooks/useSkeleton';
import { useColorScheme } from '@/hooks/useColorScheme';
import { useToastController } from '@tamagui/toast';
import { BlurView } from 'expo-blur';
import { Plus } from '@tamagui/lucide-icons';
import LottieView from 'lottie-react-native';
import SwipeableRow from '@/components/ui/SwipeableRow'; // Import SwipeableRow

// Types inferred from tRPC Router
type RouterOutput = RouterOutputs['dashboard']['getDashboardData'];
// --- Define types for the STRUCTURE AFTER mapping in useMemo ---
export type DashboardGoal = {
  id: string;
  title: string;
  progress: number;
  tasks: { completed: number; total: number };
  // Include other relevant fields if needed by GoalSummaryCard
  status?: string | null; 
  priority?: number | null;
};
export type DashboardHabit = {
  id: string;
  name: string;
  description?: string | null;
  completed: boolean; // Mapped from completedToday
  streak: number;
  last_entry_id?: string; // Mapped from habit.last_entry_id (null -> undefined)
  habit_type?: string | null;
};
export type DashboardTask = {
  id: string;
  name: string;
  status: string | null; // Allow null
  due_date?: Date | string | null;
  // Include other relevant fields if needed by TaskItem
};
export type DashboardState = {
  id: string;
  name: string | null;
  unit: string | null;
  currentValue: number | string | null;
  lastUpdated: string | null;
  lastEntry: { value: number | null; created_at: Date | string } | null; // Explicitly include lastEntry
};
// --- End mapped type definitions ---

export default function HomeScreen() {
  const colorScheme = useColorScheme();
  const toast = useToastController();
  const utils = trpc.useUtils(); // Get tRPC utils for mutations
  
  // Define types using RouterOutputs for clarity and safety
  // type DashboardGoal = RouterOutputs['dashboard']['getDashboardData']['goals'][number];
  // type DashboardHabit = RouterOutputs['dashboard']['getDashboardData']['habits'][number];
  // type DashboardTask = RouterOutputs['dashboard']['getDashboardData']['tasks'][number];

  // Use tRPC hooks to fetch data - Types are inferred but can be explicitly used
  const { 
    data: dashboardData, 
    isLoading, 
    error, 
    refetch,
    isRefetching 
  } = trpc.dashboard.getDashboardData.useQuery();

  // Define the habit entry mutation hook
  const createHabitEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: () => {
      refetch(); // Refresh data after successful mutation
      // Optional: Add success toast
      // toast.show('Habit updated!', { type: 'success' });
    },
    onError: (error) => {
      // Handle tRPC client error
      toast.show(error.message || 'Failed to update habit', { type: 'error' });
    }
  });

  // Handle errors
  React.useEffect(() => {
    if (error) {
      toast.show(error.message || 'Failed to load dashboard data', { type: 'error' });
    }
  }, [error, toast]);

  // Set up pull-to-refresh
  const onRefresh = useCallback(() => {
    refetch();
  }, [refetch]);

  // Custom skeleton states from your hooks
  const { isLoading: skeletonsLoading, count: skeletonCount = 3 } = {
    isLoading,
    count: 3 // Number of skeleton items to show
  };
  
  // Generate skeleton UI based on loading state
  const renderSkeletons = () => {
    return Array.from({ length: skeletonCount }).map((_, index) => (
      <SkeletonCard key={`skeleton-${index}`} />
    ));
  };

  // Get current date and greeting
  const greeting = getGreeting();
  const currentDate = new Date().toLocaleDateString('en-US', { 
    weekday: 'long', 
    month: 'long', 
    day: 'numeric' 
  });

  const dashboardDataMemo = useMemo(() => {
    // Fix: Add check to ensure dashboardData exists before accessing properties
    if (!dashboardData) {
      return null; // Or return default structure: { goals: [], habits: [], tasks: [], trackedStates: [] }
    }

    // Map and filter data, ensuring structure matches exported types
    return {
      // Filter goals to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      goals: (dashboardData.goals ?? [])
        .filter((goal): goal is typeof goal & { id: string } => !!goal?.id)
        .map((goal) => ({
        // Map to DashboardGoal structure
        id: goal.id, 
        title: goal.title ?? 'Untitled Goal', // Provide default for title
        progress: goal.progress ?? 0, 
        tasks: goal.tasks ?? { completed: 0, total: 0 }, 
        status: goal.status,
        priority: goal.priority,
      })),
      // Filter habits to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      habits: (dashboardData.habits ?? [])
        .filter((habit): habit is typeof habit & { id: string } => !!habit?.id)
        .map((habit) => ({
        // Map to DashboardHabit structure
        id: habit.id, 
        name: habit.name ?? 'Unnamed Habit', // Provide default for name
        description: habit.description,
        completed: habit.completedToday ?? false, // Map completedToday to completed
        streak: habit.streak ?? 0, 
        last_entry_id: habit.last_entry_id ?? undefined, // Map null to undefined
        habit_type: habit.habit_type,
      })),
      // Filter tasks to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      tasks: (dashboardData.tasks ?? [])
        .filter((task): task is typeof task & { id: string } => !!task?.id)
        .map((task) => ({
        // Map to DashboardTask structure
        id: task.id,
        name: task.name ?? 'Untitled Task', // Provide default name
        status: task.status,
        due_date: task.due_date,
      })),
      // Map trackedStates, ensuring lastEntry is preserved
      // Fix: Use nullish coalescing and optional chaining
      trackedStates: (dashboardData.trackedStates ?? [])
        .filter((state): state is typeof state & { id: string } => !!state?.id)
        .map((trackedState) => ({
        // Map to DashboardState structure
        id: trackedState.id,
        name: trackedState.name,
        unit: trackedState.unit,
        currentValue: trackedState.currentValue,
        lastUpdated: trackedState.lastUpdated,
        // Ensure lastEntry structure matches definition or is null
        lastEntry: trackedState.lastEntry ?? null, 
      })),
    };
  }, [dashboardData]);

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <ScrollView 
        showsVerticalScrollIndicator={false}
        contentContainerStyle={{ paddingBottom: 100 }}
        refreshControl={
          <RefreshControl
            refreshing={isRefetching}
            onRefresh={onRefresh}
            tintColor="transparent" // Hide default spinner
            colors={['transparent']} // Hide default spinner (Android)
            progressBackgroundColor="transparent" // Hide default bg (Android)
            refreshingComponent={
              <LottieView
                source={require('@/assets/refresh-sheikah.json')} // ASSUMES this file exists
                autoPlay
                loop
                style={{ width: 48, height: 48, alignSelf: 'center' }} // Center the animation
              />
            }
          />
        }
      >
        <YStack space="$4" paddingHorizontal="$4">
          {/* Header */}
          <YStack space="$1">
            <H1>{greeting}</H1>
            <Text color="$gray10">{currentDate}</Text>
          </YStack>

          {/* Daily Progress Banner */}
          <DailyProgressBanner 
            // tasksCompleted={...} 
            // totalTasks={...} 
            // habitsChecked={...} 
            // totalHabits={...} 
          />

          {/* Goals Section */}
          <DashboardSection 
            title="Goals"
            onSeeAll={() => router.push('/planner')}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load goals"
              />
            ) : !dashboardDataMemo?.goals || dashboardDataMemo.goals.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No goals yet"
                actionText="Create a goal"
                onAction={() => router.push('/planner/add-goal')}
              />
            ) : (
              <YStack space="$3">
                {dashboardDataMemo.goals.slice(0, 3).map((goal) => (
                  <SwipeableRow
                    key={goal.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.goal.delete.mutate({ id: goal.id })
                      console.log('Attempting to delete goal:', goal.id); // Placeholder
                      // utils.goal.delete.mutate({ id: goal.id });
                    }}
                  >
                    <GoalSummaryCard
                      goal={goal}
                      onPress={() => router.push(`/planner/goal/${goal.id}`)}
                    />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>

          {/* Today's Habits */}
          <DashboardSection 
            title="Today's Habits"
            onSeeAll={() => router.push('/planner?tab=habits')}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load habits"
              />
            ) : !dashboardDataMemo?.habits || dashboardDataMemo.habits.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No habits for today"
                actionText="Create a habit"
                onAction={() => router.push('/planner/add-habit')}
              />
            ) : (
              <YStack space="$2">
                {dashboardDataMemo.habits.slice(0, 4).map((habit) => (
                  <SwipeableRow
                    key={habit.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.habit.delete.mutate({ id: habit.id })
                      console.log('Attempting to delete habit:', habit.id); // Placeholder
                      // utils.habit.delete.mutate({ id: habit.id });
                    }}
                  >
                    <HabitCheckItem habit={habit} />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>

          {/* Today's State */}
          <DashboardSection
            title="Today's State"
            // TODO: Add navigation to a dedicated state tracking screen
            onSeeAll={() => console.log('Navigate to State Tracking screen')}
          >
            {isLoading ? (
              renderSkeletons() // Use generic skeletons or specific state skeletons
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load state"
              />
            ) : !dashboardDataMemo?.trackedStates || dashboardDataMemo.trackedStates.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No states being tracked"
                actionText="Track a state"
                // TODO: Navigate to state definition creation screen
                onAction={() => console.log('Navigate to Add State screen')}
              />
            ) : (
              <XStack space="$3" flexWrap="wrap"> 
                {dashboardDataMemo.trackedStates.map((stateData) => (
                  <StateIndicator
                    key={stateData.id}
                    state={stateData} // Pass the whole state object which includes lastEntry
                    lastEntry={stateData.lastEntry} // Pass lastEntry explicitly
                    // TODO: Handle interaction - e.g., navigate to state detail/entry screen
                    onPress={() => console.log('State pressed:', stateData.id)}
                  />
                ))}
              </XStack>
            )}
          </DashboardSection>

          {/* Upcoming Tasks */}
          <DashboardSection 
            title="Upcoming Tasks"
            onSeeAll={() => {/* Navigate to tasks list */}}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load tasks"
              />
            ) : !dashboardDataMemo?.tasks || dashboardDataMemo.tasks.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No upcoming tasks"
                actionText="Create a task"
                onAction={() => {/* Navigate to create task */}}
              />
            ) : (
              <YStack space="$2">
                {dashboardDataMemo.tasks.slice(0, 5).map((task) => (
                  <SwipeableRow
                    key={task.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.task.delete.mutate({ id: task.id })
                      console.log('Attempting to delete task:', task.id); // Placeholder
                      // utils.task.delete.mutate({ id: task.id });
                    }}
                  >
                    <TaskItem
                      task={{
                        // Explicitly pass props matching DashboardTask type
                        id: task.id, // Ensure id is passed
                        name: task.name, // Already defaulted in map
                        status: task.status, // Pass status
                        due_date: task.due_date, // Pass due_date
                      }}
                      isLast={false} // Adjust if needed for styling
                      onPress={() => console.log('Task Item Pressed:', task.id)}
                    />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>
        </YStack>
      </ScrollView>
      <QuickAddFAB />
    </SafeAreaView>
  );
}

// Helper function for greeting
function getGreeting() {
  const hour = new Date().getHours();
  if (hour < 12) return 'Good Morning';
  if (hour < 18) return 'Good Afternoon';
  return 'Good evening';
}

// Quick Add FAB Component
function QuickAddFAB() {
  return (
    <BlurView intensity={40} tint="default" style={{ position:'absolute', bottom:24, right:24, borderRadius:32, overflow: 'hidden' }}>
      <Button
        circular
        size="$5"
        backgroundColor="$accent"
        icon={Plus}
        elevate
        shadowColor="$shadowColor"
        shadowRadius={5}
        shadowOffset={{ width: 0, height: 2 }}
        pressStyle={{ scale: 0.95, opacity: 0.9 }}
        onPress={() => {
          router.push('/planner/add-task');
        }}
      />
    </BlurView>
  );
}
```
\n\n## tRPC Query Example: index.tsx
**File:** app/(tabs)/planner/index.tsx
\n```
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/planner/index.tsx
import React, { useState, Suspense } from 'react';
import { YStack, XStack, Text, Tabs, Button, Spinner, Card, ScrollView } from 'tamagui';
import { SafeAreaView, FlatList, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { RouterOutputs } from '@/utils/api-types';
import { SectionError } from '@/components/ui/ErrorBanner';


interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'goals',
    title: 'Goals',
    icon: <Ionicons name="trophy-outline" size={18} color="currentColor" />
  },
  {
    key: 'habits',
    title: 'Habits',
    icon: <Ionicons name="repeat-outline" size={18} color="currentColor" />
  },
  {
    key: 'calendar',
    title: 'Calendar',
    icon: <Ionicons name="calendar-outline" size={18} color="currentColor" />
  }
];

export default function PlannerScreen() {
  const [activeTab, setActiveTab] = useState<string>('goals');
  const colorScheme = useColorScheme();
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Planner</Text>
          <Button
            size="$3"
            circular
            onPress={() => {/* Handle new item */}}
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>
        
        {/* Tabs */}
        <Tabs
          defaultValue="goals"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List 
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {tab.icon}
                  <Text>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>
          
          {/* Tab Content */}
          <Tabs.Content value="goals" flex={1}>
            <ScrollView>
              <GoalsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="habits" flex={1}>
            <ScrollView>
              <HabitsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="calendar" flex={1}>
            <ScrollView>
              <CalendarTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Goals Tab
function GoalsTab() {
  // Fetch goals using tRPC
  const { data: goals, isLoading, error, refetch } = trpc.goal.getGoals.useQuery();
  
  // Define the inferred type for a single goal
  type PlannerGoal = RouterOutputs['goal']['getGoals'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load goals" 
      />
    );
  }
  
  if (!goals || goals.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No goals yet" 
        actionText="Create a goal" 
        onAction={() => router.push('/planner/add-goal')} 
      />
    );
  }
  
  return (
    <YStack space="$4">
      {goals.map((goal: PlannerGoal) => (
        <Button 
          key={goal.id} 
          height="$12" 
          justifyContent="flex-start" 
          paddingHorizontal="$3"
          onPress={() => router.push({ pathname: '/planner/goal/[id]', params: { id: goal.id } })}
        >
          <YStack>
            <Text fontWeight="bold">{goal.title}</Text>
            <Text fontSize="$2" color="$gray10">
              {goal.dueDate ? new Date(goal.dueDate).toLocaleDateString() : 'No due date'}
            </Text>
          </YStack>
        </Button>
      ))}
    </YStack>
  );
}

// Habits Tab
function HabitsTab() {
  // Fetch habits using tRPC
  const { data: habits, isLoading, error, refetch } = trpc.habit.getHabits.useQuery();
  
  // Define the inferred type for a single habit
  type PlannerHabit = RouterOutputs['habit']['getHabits'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={isLoading} count={3} type="row" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load habits" 
      />
    );
  }
  
  if (!habits || habits.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No habits yet" 
        actionText="Create a habit" 
        onAction={() => router.push('/planner/add-habit')} 
      />
    );
  }
  
  return (
    <YStack space="$3">
      {habits.map((habit: PlannerHabit) => (
        <XStack 
          key={habit.id} 
          justifyContent="space-between" 
          alignItems="center" 
          paddingVertical="$3" 
          paddingHorizontal="$3" 
          borderBottomWidth={1} 
          borderColor="$gray5"
          pressStyle={{ opacity: 0.7 }}
          tag="pressable"
          onPress={() => router.push({ pathname: '/planner/habit/[id]', params: { id: habit.id } })}
        >
          <Text>{habit.title}</Text>
          <Button
            size="$2"
            circular
            backgroundColor={habit.completed ? '$green9' : '$gray9'}
            onPress={() => {
              // Use today's date for the habit entry
              const today = new Date().toISOString().split('T')[0];
              
              // Create a mutation to toggle habit completion
              const toggleHabit = trpc.habit.createHabitEntry.useMutation({
                onSuccess: () => {
                  refetch(); // Refresh data after toggling
                },
                onError: (error) => {
                  // Show error message
                  console.error('Failed to toggle habit:', error.message);
                }
              });
              
              // Toggle the habit completion status
              toggleHabit.mutate({
                habitId: habit.id,
                completed: !habit.completed,
                date: today
              });
            }}
            icon={<Ionicons name="checkmark" size={18} color="white" />}
          />
        </XStack>
      ))}
    </YStack>
  );
}

// Calendar Tab
function CalendarTab() {
  return (
    <YStack alignItems="center" justifyContent="center" padding="$8">
      <Text fontSize="$5" textAlign="center">
        Calendar integration coming soon
      </Text>
      <Text marginTop="$2" color="$gray10" textAlign="center">
        This tab will display task and habit schedules in a calendar view
      </Text>
    </YStack>
  );
}
```
\n\n## tRPC Query Example: index.tsx
**File:** app/(tabs)/rewards/index.tsx
\n```
// Rewards screen with grid/list toggle and claim functionality
import React, { useState, useCallback } from 'react';
import { YStack, XStack, Text, Button, ScrollView, Card, Checkbox, useTheme, H1 } from 'tamagui';
import { SafeAreaView, View, FlatList, ImageBackground, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { RouterOutputs } from '@/utils/trpc'; // Import RouterOutputs
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton'; // Import helper component

// Define inferred type for rewards
type RewardItem = RouterOutputs['rewards']['getAvailableRewards'][number];

enum ViewMode {
  Grid = 'grid',
  List = 'list'
}

export default function RewardsScreen() {
  const [viewMode, setViewMode] = useState<ViewMode>(ViewMode.Grid);
  const colorScheme = useColorScheme();
  const theme = useTheme();

  // Define fallback colors
  const blue2 = theme?.blue2?.val ?? '#eff6ff';
  const blue5 = theme?.blue5?.val ?? '#60a5fa';
  const blue10 = theme?.blue10?.val ?? '#1e40af';
  const blue11 = theme?.blue11?.val ?? '#1e3a8a';
  const green9 = theme?.green9?.val ?? '#16a34a';

  // Fetch available rewards from tRPC
  const { 
    data: rewards, 
    isLoading, 
    error, 
    refetch 
  } = trpc.rewards.getAvailableRewards.useQuery();

  // Mutation for claiming rewards
  const claimMutation = trpc.rewards.earnReward.useMutation({
    onSuccess: (data) => {
      console.log('Reward claimed successfully:', data);
      // Maybe show confetti?
      Alert.alert('Reward Claimed!', `You spent ${data.reward.points_spent} points. Remaining: ${data.remainingPoints}`);
      refetch(); // Refetch the list of available rewards
    },
    onError: (err) => {
      console.error('Failed to claim reward:', err);
      Alert.alert('Claim Failed', err.message || 'Could not claim reward.');
    }
  });
  
  const handleClaimReward = useCallback((rewardId: string) => {
    if (claimMutation.isPending) return; // Prevent double-clicks
    
    Alert.alert(
      'Confirm Claim',
      'Are you sure you want to spend points on this reward?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Claim', 
          onPress: () => {
            claimMutation.mutate({ rewardId });
          },
          style: 'default'
        }
      ]
    );
  }, [claimMutation]);
  
  const renderItem = ({ item }: { item: RewardItem }) => { // Use inferred type
    // Assuming backend field is image_url, map to imagePath
    const imagePath = item.image_url; 
    // All items from getAvailableRewards are considered claimable (not yet claimed)
    const claimed = false; 
    // Map required_points to pointCost
    const pointCost = item.required_points;

    if (viewMode === ViewMode.Grid) {
      return (
        <Card
          size="$4"
          bordered
          width={160}
          height={200}
          margin="$2"
          overflow="hidden"
          elevation="$2"
          opacity={claimed ? 0.7 : 1}
        >
          <ImageBackground
            source={{ uri: imagePath }}
            style={{ width: '100%', height: 100 }}
          >
            <View style={{ 
              position: 'absolute', 
              top: 5, 
              right: 5, 
              backgroundColor: blue5,
              borderRadius: 10,
              padding: 4
            }}>
              <Text color="white" fontSize="$2" fontWeight="bold">
                {pointCost} pts
              </Text>
            </View>
          </ImageBackground>
          
          <YStack padding="$2" flex={1} justifyContent="space-between">
            <Text fontSize="$4" fontWeight="bold" numberOfLines={1}>
              {item.name}
            </Text>
            
            <Button
              size="$2"
              themeInverse={claimed}
              backgroundColor={claimed ? undefined : blue10}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </YStack>
        </Card>
      );
    } else {
      return (
        <Card
          bordered
          margin="$2"
          padding="$3"
          opacity={claimed ? 0.7 : 1}
        >
          <XStack space="$3" alignItems="center">
            {imagePath && (
              <View style={{ 
                width: 60, 
                height: 60, 
                borderRadius: 8, 
                overflow: 'hidden',
                backgroundColor: theme.gray3.val
              }}>
                <ImageBackground
                  source={{ uri: imagePath }}
                  style={{ width: '100%', height: '100%' }}
                />
              </View>
            )}
            
            <YStack flex={1} space="$1">
              <Text fontSize="$5" fontWeight="bold">{item.name}</Text>
              <Text fontSize="$3" color="$gray11" numberOfLines={2}>{item.description}</Text>
              <Text fontSize="$3" color={blue10} fontWeight="500">{pointCost} points</Text>
            </YStack>
            
            <Button
              size="$3"
              backgroundColor={claimed ? undefined : blue10}
              themeInverse={claimed}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </XStack>
        </Card>
      );
    }
  };
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        <YStack space="$4">
          {/* Header */}
          <XStack justifyContent="space-between" alignItems="center">
            <H1>Rewards</H1>
            
            <XStack space="$2">
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.Grid ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.Grid)}
              >
                <Ionicons 
                  name="grid-outline" 
                  size={22} 
                  color={viewMode === ViewMode.Grid ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
              
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.List ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.List)}
              >
                <Ionicons 
                  name="list-outline" 
                  size={22} 
                  color={viewMode === ViewMode.List ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
            </XStack>
          </XStack>
          
          {/* Stats */}
          <Card padding="$3" backgroundColor={blue2}>
            <XStack justifyContent="space-between" alignItems="center">
              <Text fontSize="$5" fontWeight="bold" color={blue11}>Your Points</Text>
              <Text fontSize="$6" fontWeight="bold" color={blue10}>275</Text>
            </XStack>
          </Card>
        </YStack>
        
        {/* Content Area */} 
        <EmptyOrSkeleton 
          isLoading={isLoading}
          isEmpty={!isLoading && !error && (!rewards || rewards.length === 0)}
          isError={!!error}
          text={error ? error.message : 'No rewards available yet.'} // Use text for error OR empty msg
          onRetry={refetch}
          type={viewMode === ViewMode.Grid ? 'card' : 'row'}
          count={viewMode === ViewMode.Grid ? 6 : 3}
        >
          <FlatList
            key={viewMode} // Change key based on viewMode to force re-render
            data={rewards}
            renderItem={renderItem}
            keyExtractor={(item, index) =>
              `${item?.id ?? `tmp-${index}`}-${viewMode}`   // fall back to index if ID is missing
            }
            
            // Optional: Log corrupt data in development
            onLayout={() => {
              if (__DEV__) {
                const missing = (rewards ?? []).filter(r => !r?.id);
                if (missing.length) console.warn('Rewards missing id:', missing);
              }
            }}
            numColumns={viewMode === ViewMode.Grid ? 2 : 1}
            contentContainerStyle={{ paddingBottom: 50 }} // Add padding at the bottom
            // Optional Optimizations (Patch #6)
            initialNumToRender={8}
            removeClippedSubviews={true} // Note: Can have visual glitches on iOS sometimes
          />
        </EmptyOrSkeleton>

      </YStack>
    </SafeAreaView>
  );
}
```
\n\n## tRPC Query Example: index.tsx
**File:** app/(tabs)/compass/index.tsx
\n```
// Compass screen with Principles and States tabs
import React, { useState } from 'react';
import { YStack, XStack, Text, Tabs, Button, ScrollView } from 'tamagui'; 
import { SafeAreaView } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc, type RouterOutputs } from '@/utils/trpc'; 
import { useColorScheme } from '@/hooks/useColorScheme'; 
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { router, type Href } from 'expo-router'; 
import { PrincipleCard } from '@/components/compass/PrincipleCard';
import PrinciplesTab from '@/components/compass/PrinciplesTab';
import { StateDefinitionCard } from '@/components/compass/StateDefinitionCard'; 

interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'principles',
    title: 'Principles',
    icon: <Ionicons name="compass-outline" size={18} color="currentColor" />
  },
  {
    key: 'states',
    title: 'States',
    icon: <Ionicons name="pulse-outline" size={18} color="currentColor" />
  }
];

export default function CompassScreen() {
  const [activeTab, setActiveTab] = useState<string>('principles');
  const colorScheme = useColorScheme();

  const handleAddPress = () => {
    const route = `/compose?type=${activeTab === 'principles' ? 'value' : 'state'}` as Href;
    router.push(route);
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Compass</Text>
          <Button
            size="$3"
            circular
            onPress={handleAddPress} 
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>

        {/* Tabs */}
        <Tabs
          defaultValue="principles"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {React.cloneElement(tab.icon as React.ReactElement, { color: activeTab === tab.key ? '$colorFocus' : '$color' })}
                  <Text color={activeTab === tab.key ? '$colorFocus' : '$color'}>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>

          {/* Tab Content */}
          <Tabs.Content value="principles" flex={1} key="principles-content">
            <ScrollView>
              <PrinciplesTab />
            </ScrollView>
          </Tabs.Content>

          <Tabs.Content value="states" flex={1} key="states-content">
            <ScrollView>
              <StatesTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Define the specific types from RouterOutputs
// Types are now defined in the PrinciplesTab component
type StateDefinition = RouterOutputs['state']['getDefinitions'][number]; 

// Principles Tab Component is now imported from '@/components/compass/PrinciplesTab'

// States Tab Component (manages data fetching and list rendering)
function StatesTab() {
  const { data: states, isLoading, error, refetch } = trpc.state.getDefinitions.useQuery(); 

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }

  if (error) {
    return (
      <EmptyOrSkeleton
        isEmpty={false}
        isError={true}
        onRetry={refetch}
        text="Failed to load tracked state definitions"
      />
    );
  }

  if (!states || states.length === 0) {
    return (
      <EmptyOrSkeleton
        isEmpty={true}
        text="No state definitions found"
        actionText="Define Your First State"
        onAction={() => router.push('/compose?type=state' as Href)}
      />
    );
  }

  return (
    <YStack space="$3"> 
      {states.map((state: StateDefinition) => (
        <StateDefinitionCard
          key={state.id}
          state={state}
          onPress={() => router.push(`/states/${state.id}` as Href)}
        />
      ))}
    </YStack>
  );
}

// 
// Removed inline PrincipleCard definition (extracted to components/compass/PrincipleCard.tsx)
// 

// 
// Removed inline StateDefinitionCard definition (extracted to components/compass/StateDefinitionCard.tsx)
// 
```
\n\n# 5️⃣ Dashboard Task
\n\n## SwipeableRow Component
**File:** components/ui/SwipeableRow.tsx
\n```
import React from 'react';
import { Swipeable } from 'react-native-gesture-handler';
import { XStack, Button, useTheme } from 'tamagui';
import { Trash, Check } from '@tamagui/lucide-icons';
import * as Haptics from 'expo-haptics';

type SwipeableRowProps = {
  children: React.ReactNode;
  onDelete?: () => void;
  onComplete?: () => void;
  // Add any other props needed, like unique key for Swipeable instance management
};

export default function SwipeableRow({ children, onDelete, onComplete }: SwipeableRowProps) {
  const theme = useTheme();

  const renderRightActions = () => {
    if (!onDelete) return null;
    return (
      <XStack flex={1} justifyContent="flex-end">
        <Button
          // size="$3" // Match ListItem size?
          backgroundColor="$destructive"
          borderTopRightRadius="$0" // Flatten edges
          borderBottomRightRadius="$0"
          icon={<Trash color={theme.color?.get()} />} // Use theme color for icon
          onPress={() => {
            Haptics.selectionAsync();
            onDelete();
            // Consider closing the Swipeable here if needed
          }}
          width={80} // Fixed width for the action button
          height="100%" // Fill height
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  const renderLeftActions = () => {
    if (!onComplete) return null;
    return (
      <XStack flex={1} justifyContent="flex-start">
        <Button
          // size="$3"
          backgroundColor="$success"
          borderTopLeftRadius="$0"
          borderBottomLeftRadius="$0"
          icon={<Check color={theme.color?.get()} />}
          onPress={() => {
            Haptics.selectionAsync();
            onComplete();
            // Consider closing the Swipeable here if needed
          }}
          width={80}
          height="100%"
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  return (
    <Swipeable
      renderRightActions={renderRightActions}
      renderLeftActions={renderLeftActions}
      overshootFriction={8} // Standard friction
      containerStyle={{ backgroundColor: '$background' }} // Ensure background matches item
    >
      {children}
    </Swipeable>
  );
}
```
\n\n## TaskItem Component
**File:** components/dashboard/TaskItem.tsx
\n```
import React from 'react';
// Use Tamagui components
import { Text, XStack, YStack, Checkbox, Spinner } from 'tamagui'; 
import { trpc, RouterOutputs, RouterInputs } from '@/utils/trpc';
import { Check } from '@tamagui/lucide-icons';

// Custom Task type that matches the actual format returned from the backend
type Task = {
  id: string;
  name: string;  // Backend returns 'name' not 'title'
  status: string;
  priority?: number;
  due_date?: string; // Backend returns 'due_date' not 'due'
  notes?: string;
  goal_id?: string;
  // Include other fields as needed
};

interface TaskItemProps {
  task: Task;
  onPress: () => void;
}

export default function TaskItem({ task, onPress }: TaskItemProps) {
  
  // Setup toggleTask mutation with optimistic updates
  const utils = trpc.useContext();
  // Setup mutation for task toggling
  const toggleTaskMutation = trpc.task.toggleTask.useMutation({
    // Optimistically update the UI
    onMutate: async ({ taskId, completed }: { taskId: string; completed?: boolean }) => {
      // Default to toggling the current state if completed is not provided
      const newCompleted = completed !== undefined ? completed : !isCompleted;
      // Cancel outgoing fetches that might overwrite our optimistic update
      await utils.task.getTasks.cancel();
      await utils.dashboard.getDashboardData.cancel();
      
      // Get previous data for potential rollback
      const prevTasksData = utils.task.getTasks.getData();
      const prevDashboardData = utils.dashboard.getDashboardData.getData();
      
      // Optimistically update tasks data if present
      if (prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return old.map((t: any) => {
            if (t.id === taskId) {
              return {
                ...t,
                status: completed ? 'completed' : 'in-progress'
              };
            }
            return t;
          });
        });
      }
      
      // Optimistically update dashboard data if present
      if (prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return {
            ...old,
            tasks: old.tasks.map((t: any) => {
              if (t.id === taskId) {
                return {
                  ...t,
                  status: newCompleted ? 'completed' : 'in-progress'
                };
              }
              return t;
            }),
          };
        });
      }
      
      // Return previous data for rollback
      return { prevTasksData, prevDashboardData };
    },
    
    // If something goes wrong, rollback optimistic updates
    onError: (err: any, variables: any, context: any) => {
      if (context?.prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, context.prevTasksData);
      }
      if (context?.prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, context.prevDashboardData);
      }
      console.error('Error toggling task:', err);
    },
    
    // Always refetch after error or success
    onSettled: () => {
      utils.task.getTasks.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    }
  });

  // Handle checkbox toggle
  const handleToggle = () => {
    toggleTaskMutation.mutate({
      taskId: task.id, // Using taskId as expected by the backend
      completed: !isCompleted
    });
  };

  // Map priority to color
  const priorityColor = task.priority === 1 ? '$brandRed' : 
                        task.priority === 2 ? '$brandYellow' : 
                        '$brandGreen';
  
  // Format due date
  const formattedDate = task.due_date 
    ? new Date(task.due_date).toLocaleDateString(undefined, { 
        month: 'short', 
        day: 'numeric' 
      })
    : null;
    
  // Determine task completion status
  const isCompleted = task.status === 'completed';
  // No need for text style object since we use Tamagui props directly

  
  // Use YStack as the base component
  return (
    <YStack 
      backgroundColor="$backgroundStrong"
      padding="$3"
      borderRadius="$4"
      space="$1" // Add space between XStack and Date Text
    >
      <XStack alignItems="center" space="$2"> {/* Use XStack for horizontal layout */}
        {/* Checkbox for task completion */}
        <Checkbox
          size="$4"
          checked={isCompleted}
          onCheckedChange={handleToggle}
          disabled={toggleTaskMutation.isPending}
        >
          {toggleTaskMutation.isPending ? (
            <Spinner size="small" color="$brandPrimary" />
          ) : (
            <Checkbox.Indicator>
              <Check size={16} />
            </Checkbox.Indicator>
          )}
        </Checkbox>

        {/* Container for task details (clickable) */}
        <XStack flex={1} tag="pressable" onPress={onPress} pressStyle={{ opacity: 0.7 }}>
          {/* Priority Dot using YStack */}
          <YStack 
            width="$2" // Use size token for width
            height="$2" // Use size token for height
            borderRadius="$10" // Use a large radius token
            backgroundColor={priorityColor} 
            marginRight="$2" // Use space token for margin
          />
          <Text 
            fontSize="$4" // Use font size token
            fontWeight={task.priority === 1 ? '600' : '400'} // Keep fontWeight
            color="$color"
            flex={1} // Allow text to take remaining space
            opacity={isCompleted ? 0.7 : 1}
            textDecorationLine={isCompleted ? 'line-through' : undefined} // Proper Tamagui text decoration
          >
            {task.name}
          </Text>
        </XStack>
      </XStack>
      
      {formattedDate && (
        // Removed explicit margin, rely on outer YStack space
        <Text color="$gray9" fontSize="$2">
          Due: {formattedDate}
        </Text>
      )}
    </YStack>
  );
} ```
\n\n## Task Completion Handler: SwipeableRow.tsx
**File:** ./components/ui/SwipeableRow.tsx
\n```
import React from 'react';
import { Swipeable } from 'react-native-gesture-handler';
import { XStack, Button, useTheme } from 'tamagui';
import { Trash, Check } from '@tamagui/lucide-icons';
import * as Haptics from 'expo-haptics';

type SwipeableRowProps = {
  children: React.ReactNode;
  onDelete?: () => void;
  onComplete?: () => void;
  // Add any other props needed, like unique key for Swipeable instance management
};

export default function SwipeableRow({ children, onDelete, onComplete }: SwipeableRowProps) {
  const theme = useTheme();

  const renderRightActions = () => {
    if (!onDelete) return null;
    return (
      <XStack flex={1} justifyContent="flex-end">
        <Button
          // size="$3" // Match ListItem size?
          backgroundColor="$destructive"
          borderTopRightRadius="$0" // Flatten edges
          borderBottomRightRadius="$0"
          icon={<Trash color={theme.color?.get()} />} // Use theme color for icon
          onPress={() => {
            Haptics.selectionAsync();
            onDelete();
            // Consider closing the Swipeable here if needed
          }}
          width={80} // Fixed width for the action button
          height="100%" // Fill height
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  const renderLeftActions = () => {
    if (!onComplete) return null;
    return (
      <XStack flex={1} justifyContent="flex-start">
        <Button
          // size="$3"
          backgroundColor="$success"
          borderTopLeftRadius="$0"
          borderBottomLeftRadius="$0"
          icon={<Check color={theme.color?.get()} />}
          onPress={() => {
            Haptics.selectionAsync();
            onComplete();
            // Consider closing the Swipeable here if needed
          }}
          width={80}
          height="100%"
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  return (
    <Swipeable
      renderRightActions={renderRightActions}
      renderLeftActions={renderLeftActions}
      overshootFriction={8} // Standard friction
      containerStyle={{ backgroundColor: '$background' }} // Ensure background matches item
    >
      {children}
    </Swipeable>
  );
}
```
\n\n## Task Completion Handler: TaskList.tsx
**File:** ./components/lists/TaskList.tsx
\n```
import React from 'react';
import { FlatList, RefreshControl, ListRenderItem } from 'react-native';
import { YStack, XStack, Text, Stack } from 'tamagui';
import { router } from 'expo-router';
import { RouterOutputs } from '@/utils/api-types';
import { AetherCard } from '@/components/ui/primitives';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { Ionicons } from '@expo/vector-icons';

type Task = RouterOutputs['task']['list'][number];

interface TaskListProps {
  tasks?: Task[];
  isLoading: boolean;
  isError?: boolean;
  refetch: () => void;
  onSelectTask?: (task: Task) => void;
  onCompleteTask?: (taskId: string, completed: boolean) => void;
}

/**
 * TaskCard - Individual task card component
 */
export function TaskCard({ 
  task, 
  onPress, 
  onComplete 
}: { 
  task: Task; 
  onPress: () => void; 
  onComplete?: (completed: boolean) => void;
}) {
  // Get the completion status of the task
  const [isCompleted, setIsCompleted] = React.useState(Boolean(task.completed));
  
  // Format the due date
  const formattedDate = task.due
    ? new Date(task.due).toLocaleDateString(undefined, {
        month: 'short',
        day: 'numeric',
      })
    : 'No due date';
    
  // Check if task is overdue
  const isOverdue = task.due && new Date(task.due) < new Date() && !isCompleted;

  const handleToggle = () => {
    const newStatus = !isCompleted;
    setIsCompleted(newStatus);
    if (onComplete) {
      onComplete(newStatus);
    }
  };

  return (
    <AetherCard 
      isInteractive 
      variant="default"
      onPress={onPress}
    >
      <YStack space="$2">
        {/* Title with completion toggle */}
        <XStack space="$3" justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center" flex={1}>
            <Stack 
              onPress={handleToggle}
              pressStyle={{ opacity: 0.8 }}
            >
              <Ionicons 
                name={isCompleted ? "checkmark-circle" : "checkmark-circle-outline"} 
                size={26} 
                color={isCompleted ? "$success" : "$colorMuted"} 
              />
            </Stack>
            <Text 
              fontSize="$5" 
              fontWeight="bold" 
              color={isCompleted ? "$colorMuted" : "$color"} 
              numberOfLines={1} 
              flex={1}
              textDecorationLine={isCompleted ? 'line-through' : 'none'}
            >
              {task.title}
            </Text>
          </XStack>
        </XStack>
        
        {/* Notes if available */}
        {task.notes && !isCompleted && (
          <Text color="$colorMuted" fontSize="$3" numberOfLines={2} paddingLeft="$7">
            {task.notes}
          </Text>
        )}
        
        {/* Footer with due date and goal information */}
        <XStack justifyContent="space-between" alignItems="center" paddingLeft="$7">
          <XStack space="$2" alignItems="center">
            <Ionicons 
              name="calendar-outline" 
              size={16} 
              color={isOverdue ? "$error" : "$colorMuted"} 
            />
            <Text 
              fontSize="$2" 
              color={isOverdue ? "$error" : "$colorMuted"}
              fontWeight={isOverdue ? "bold" : "normal"}
            >
              {isOverdue ? "Overdue: " : ""}{formattedDate}
            </Text>
          </XStack>
          
          {/* If task is linked to a goal, show goal name */}
          {task.goal_id && (
            <XStack 
              backgroundColor="$backgroundStrong" 
              paddingHorizontal="$2" 
              paddingVertical="$1" 
              borderRadius="$2"
            >
              <Text fontSize="$2" color="$primary">
                {task.goal?.title || 'Linked goal'}
              </Text>
            </XStack>
          )}
        </XStack>
      </YStack>
    </AetherCard>
  );
}

/**
 * TaskList - List component for displaying tasks
 */
export function TaskList({ 
  tasks, 
  isLoading, 
  isError, 
  refetch, 
  onSelectTask,
  onCompleteTask 
}: TaskListProps) {
  const renderTaskItem: ListRenderItem<Task> = ({ item }) => (
    <TaskCard 
      task={item} 
      onPress={() => {
        if (onSelectTask) {
          onSelectTask(item);
        } else {
          // Default navigation
          router.push({ 
            pathname: '/planner/task/[id]', 
            params: { id: item.id } 
          });
        }
      }}
      onComplete={(completed) => {
        if (onCompleteTask) {
          onCompleteTask(item.id, completed);
        }
      }}
    />
  );

  if (isLoading) {
    return <EmptyOrSkeleton isLoading count={3} type="card" />;
  }

  if (isError) {
    return (
      <YStack padding="$4" space="$4" alignItems="center" justifyContent="center">
        <Ionicons name="alert-circle-outline" size={48} color="$error" />
        <YStack>
          <YStack alignItems="center">
            <Text fontSize="$5" fontWeight="bold" color="$color" textAlign="center">
              Unable to load tasks
            </Text>
            <Text fontSize="$3" color="$colorMuted" textAlign="center" marginTop="$2">
              Please check your connection and try again
            </Text>
          </YStack>
        </YStack>
        <AetherCard onPress={refetch} isInteractive padding="$3" paddingHorizontal="$5">
          <XStack alignItems="center" space="$2">
            <Ionicons name="refresh-outline" size={18} color="$primary" />
            <Text fontSize="$4" fontWeight="500" color="$primary">
              Retry
            </Text>
          </XStack>
        </AetherCard>
      </YStack>
    );
  }

  if (!tasks || tasks.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty 
        text="No tasks yet" 
        actionText="Create a task" 
        onAction={() => router.push('/planner/add-task')} 
      />
    );
  }

  return (
    <FlatList
      data={tasks}
      keyExtractor={(item) => item.id}
      renderItem={renderTaskItem}
      contentContainerStyle={{ padding: 16, paddingBottom: 32 }}
      ItemSeparatorComponent={() => <YStack height="$4" />}
      refreshControl={
        <RefreshControl 
          refreshing={isLoading} 
          onRefresh={refetch} 
        />
      }
    />
  );
}
```
\n\n## Task Completion Handler: ConfettiBurst.tsx
**File:** ./components/rewards/ConfettiBurst.tsx
\n```
import React, { useEffect } from 'react';
import { StyleSheet, Dimensions } from 'react-native';
import { View } from 'tamagui';
import Animated, {
  useSharedValue,
  withDelay,
  withTiming,
  useAnimatedStyle,
  withSequence,
  runOnJS,
  Easing,
} from 'react-native-reanimated';
import { durations, easings } from '@/constants/motion';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

// Define confetti piece colors
const COLORS = [
  '#FF5252', // Red
  '#FFD740', // Amber
  '#64FFDA', // Teal
  '#448AFF', // Blue
  '#B388FF', // Deep Purple
  '#FF80AB', // Pink
  '#1DE9B6', // Green
  '#F48FB1', // Light Pink
];

// Number of confetti pieces
const CONFETTI_COUNT = 50;

// Confetti piece configuration
interface ConfettiPiece {
  id: number;
  x: number;
  y: number;
  size: number;
  color: string;
  rotation: number;
  delay: number;
  duration: number;
}

interface ConfettiBurstProps {
  /** Whether to show the confetti */
  isVisible: boolean;
  /** Called when animation completes */
  onComplete?: () => void;
  /** Number of confetti pieces to display (default: 50) */
  count?: number;
  /** Custom colors to use for confetti pieces */
  colors?: string[];
  /** Duration of the animation in ms (default: 2000) */
  duration?: number;
}

/**
 * A component that displays a burst of confetti animation
 */
export default function ConfettiBurst({
  isVisible,
  onComplete,
  count = CONFETTI_COUNT,
  colors = COLORS,
  duration = 2000,
}: ConfettiBurstProps) {
  // Create confetti pieces
  const pieces = React.useMemo(() => {
    const result: ConfettiPiece[] = [];
    
    for (let i = 0; i < count; i++) {
      result.push({
        id: i,
        x: Math.random() * SCREEN_WIDTH,
        y: -20, // Start above the screen
        size: Math.random() * 8 + 4, // Size between 4-12
        color: colors[Math.floor(Math.random() * colors.length)],
        rotation: Math.random() * 360,
        delay: Math.random() * 500, // Random delay up to 500ms
        duration: Math.random() * 1000 + 1500, // Duration between 1.5-2.5s
      });
    }
    
    return result;
  }, [count, colors]);
  
  // Trigger animation complete callback
  const animationComplete = () => {
    if (onComplete) {
      onComplete();
    }
  };
  
  return (
    <>
      {isVisible && (
        <View style={styles.container} pointerEvents="none">
          {pieces.map((piece) => (
            <ConfettiPiece
              key={piece.id}
              piece={piece}
              animationDuration={duration}
              onComplete={animationComplete}
            />
          ))}
        </View>
      )}
    </>
  );
}

// Individual confetti piece component
function ConfettiPiece({
  piece,
  animationDuration,
  onComplete,
}: {
  piece: ConfettiPiece;
  animationDuration: number;
  onComplete: () => void;
}) {
  const translateY = useSharedValue(piece.y);
  const translateX = useSharedValue(piece.x);
  const rotate = useSharedValue(piece.rotation);
  const opacity = useSharedValue(1);
  
  // Track if this is the last piece to complete
  const wasLastPiece = React.useRef(false);
  
  useEffect(() => {
    // Last piece will trigger onComplete
    if (piece.id === CONFETTI_COUNT - 1) {
      wasLastPiece.current = true;
    }
    
    // Start Y animation (falling down)
    translateY.value = withDelay(
      piece.delay,
      withTiming(
        SCREEN_HEIGHT + 50, // End below the screen
        {
          duration: piece.duration,
          easing: easings.accelerate,
        },
        () => {
          if (wasLastPiece.current) {
            runOnJS(onComplete)();
          }
        }
      )
    );
    
    // Swaying horizontal movement
    translateX.value = withDelay(
      piece.delay,
      withSequence(
        withTiming(piece.x - 50 + Math.random() * 100, {
          duration: piece.duration * 0.3,
          easing: easings.standard,
        }),
        withTiming(piece.x + 50 + Math.random() * 100, {
          duration: piece.duration * 0.3,
          easing: easings.standard,
        }),
        withTiming(piece.x - 25 + Math.random() * 50, {
          duration: piece.duration * 0.4,
          easing: easings.standard,
        })
      )
    );
    
    // Rotation animation
    rotate.value = withDelay(
      piece.delay,
      withTiming(piece.rotation + Math.random() * 720, {
        duration: piece.duration,
        easing: easings.standard,
      })
    );
    
    // Fade out toward the end
    opacity.value = withDelay(
      piece.delay + (piece.duration * 0.7),
      withTiming(0, {
        duration: piece.duration * 0.3,
        easing: easings.standard,
      })
    );
  }, []);
  
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: translateX.value },
        { translateY: translateY.value },
        { rotate: `${rotate.value}deg` },
      ],
      opacity: opacity.value,
    };
  });
  
  return (
    <Animated.View
      style={[
        {
          position: 'absolute',
          width: piece.size,
          height: piece.size * (Math.random() * 0.8 + 0.2), // Varying heights
          backgroundColor: piece.color,
          borderRadius: Math.random() > 0.5 ? piece.size / 2 : 0, // Some round, some square
        },
        animatedStyle,
      ]}
    />
  );
}

const styles = StyleSheet.create({
  container: {
    ...StyleSheet.absoluteFillObject,
    zIndex: 999,
    pointerEvents: 'none',
  },
}); ```
\n\n## Task Completion Handler: TaskList.test.tsx
**File:** ./__tests__/components/lists/TaskList.test.tsx
\n```
import React from 'react';
import { render, fireEvent } from '../test-utils';
import { TaskList, TaskCard } from '@/components/lists/TaskList';
import { router } from 'expo-router';

// Mock router.push
jest.mock('expo-router', () => ({
  router: {
    push: jest.fn(),
  },
}));

// Define sample mock data that matches our Supabase schema via tRPC
const mockTasks = [
  {
    id: 'task-1',
    title: 'Create UI components',
    notes: 'Focus on reusable design patterns',
    due: '2025-05-01',
    completed: false,
    goal_id: 'goal-1',
    goal: { title: 'App Refactoring' },
    user_id: 'user-123',
  },
  {
    id: 'task-2',
    title: 'Write tests',
    notes: 'Ensure good coverage of components',
    due: '2025-05-03',
    completed: true,
    goal_id: null,
    goal: null,
    user_id: 'user-123',
  },
];

describe('TaskCard Component', () => {
  it('renders task information correctly', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <TaskCard task={mockTasks[0]} onPress={onPressMock} />
    );
    
    expect(getByText('Create UI components')).toBeTruthy();
    expect(getByText('Focus on reusable design patterns')).toBeTruthy();
    expect(getByText('May 1')).toBeTruthy();
    expect(getByText('App Refactoring')).toBeTruthy();
  });
  
  it('handles completion toggle correctly', () => {
    const onPressMock = jest.fn();
    const onCompleteMock = jest.fn();
    const { getByTestId } = render(
      <TaskCard 
        task={mockTasks[0]} 
        onPress={onPressMock} 
        onComplete={onCompleteMock} 
      />
    );
    
    // Find the toggle button (checkmark)
    const toggleButton = getByTestId('icon-checkmark-circle-outline');
    fireEvent.press(toggleButton.parent);
    
    // Should call onComplete with true (completed)
    expect(onCompleteMock).toHaveBeenCalledWith(true);
  });
  
  it('displays completed task with line-through', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <TaskCard task={mockTasks[1]} onPress={onPressMock} />
    );
    
    const titleElement = getByText('Write tests');
    // Text should have line-through style
    expect(titleElement.props.style).toBeDefined();
    // Would check for textDecorationLine: 'line-through' here, but we're mocking styles
  });
  
  it('shows overdue status for past due tasks', () => {
    const pastDueTask = {
      ...mockTasks[0],
      due: '2025-04-01', // Past date
    };
    
    const { getByText } = render(
      <TaskCard task={pastDueTask} onPress={jest.fn()} />
    );
    
    // Should show "Overdue" text
    expect(getByText(/Overdue:/)).toBeTruthy();
  });
});

describe('TaskList Component', () => {
  it('renders loading state correctly', () => {
    const { getByTestId } = render(
      <TaskList isLoading={true} refetch={jest.fn()} />
    );
    
    expect(getByTestId('skeleton-loader')).toBeTruthy();
  });
  
  it('renders error state correctly', () => {
    const refetchMock = jest.fn();
    const { getByText } = render(
      <TaskList isLoading={false} isError={true} refetch={refetchMock} />
    );
    
    expect(getByText('Unable to load tasks')).toBeTruthy();
    
    // Test retry functionality
    fireEvent.press(getByText('Retry'));
    expect(refetchMock).toHaveBeenCalledTimes(1);
  });
  
  it('renders empty state correctly', () => {
    const { getByText } = render(
      <TaskList isLoading={false} tasks={[]} refetch={jest.fn()} />
    );
    
    expect(getByText('No tasks yet')).toBeTruthy();
    
    // Test create action
    fireEvent.press(getByText('Create a task'));
    expect(router.push).toHaveBeenCalledWith('/planner/add-task');
  });
  
  it('renders tasks correctly', () => {
    const { getAllByText } = render(
      <TaskList isLoading={false} tasks={mockTasks} refetch={jest.fn()} />
    );
    
    // Should render both tasks
    expect(getAllByText(/Create UI components|Write tests/).length).toBe(2);
  });
  
  it('calls onCompleteTask when provided', () => {
    const onCompleteTaskMock = jest.fn();
    const { getByText, getAllByTestId } = render(
      <TaskList 
        isLoading={false} 
        tasks={mockTasks} 
        refetch={jest.fn()} 
        onCompleteTask={onCompleteTaskMock} 
      />
    );
    
    // Find the first task's toggle button
    const toggleButtons = getAllByTestId('icon-checkmark-circle-outline');
    fireEvent.press(toggleButtons[0].parent);
    
    // Should call onCompleteTask with the task ID and completion status
    expect(onCompleteTaskMock).toHaveBeenCalledWith('task-1', true);
  });
});
```

  ```

- **index.js** (0.1 KB, 4 lines) *(No explicit exports)*

  ```js
// index.js - Custom entry point to guarantee Tamagui config loads first
import './tamagui.config';
import 'expo-router/entry';

  ```

- **jest.server.config.js** (0.6 KB, 23 lines) *(No explicit exports)*

  ```js
module.exports = {
  // Use Node.js environment for server tests
  testEnvironment: 'node',
  // Only transform TypeScript files
  transform: {
    '^.+\\.tsx?$': ['ts-jest']
  },
  // Don't need transformIgnorePatterns for server tests as we're not testing React Native components
  // Use our server-specific setup file
  setupFilesAfterEnv: ['./jest.server.setup.js'],
  // Match our server test files
  testMatch: ['**/__tests__/server/**/*.test.ts'],
  // Root directory
  rootDir: './',
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
  },
  // Clear mocks between tests
  clearMocks: true,
  // Don't watch files for changes
  watchman: false,
};

  ```

- **o3.txt** (48.8 KB, 1480 lines) *(No explicit exports)*

  ```txt
Debug Report - 2025-04-30T02:39:05.474Z
Generated by gather_debug_info.js
Focusing on files related to the runtime errors.

========================================
FILE: app/(tabs)/compass/index.tsx
ISSUE CONTEXT: Main compass screen that renders PrinciplesTab
----------------------------------------

// Compass screen with Principles and States tabs
import React, { useState } from 'react';
import { YStack, XStack, Text, Tabs, Button, ScrollView } from 'tamagui'; 
import { SafeAreaView } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc, type RouterOutputs } from '@/utils/trpc'; 
import { useColorScheme } from '@/hooks/useColorScheme'; 
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { router, type Href } from 'expo-router'; 
import { PrincipleCard } from '@/components/compass/PrincipleCard'; 
import { StateDefinitionCard } from '@/components/compass/StateDefinitionCard'; 

interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'principles',
    title: 'Principles',
    icon: <Ionicons name="compass-outline" size={18} color="currentColor" />
  },
  {
    key: 'states',
    title: 'States',
    icon: <Ionicons name="pulse-outline" size={18} color="currentColor" />
  }
];

export default function CompassScreen() {
  const [activeTab, setActiveTab] = useState<string>('principles');
  const colorScheme = useColorScheme();

  const handleAddPress = () => {
    const route = `/compose?type=${activeTab === 'principles' ? 'value' : 'state'}` as Href;
    router.push(route);
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Compass</Text>
          <Button
            size="$3"
            circular
            onPress={handleAddPress} 
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>

        {/* Tabs */}
        <Tabs
          defaultValue="principles"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {React.cloneElement(tab.icon as React.ReactElement, { color: activeTab === tab.key ? '$colorFocus' : '$color' })}
                  <Text color={activeTab === tab.key ? '$colorFocus' : '$color'}>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>

          {/* Tab Content */}
          <Tabs.Content value="principles" flex={1} key="principles-content">
            <ScrollView>
              <PrinciplesTab />
            </ScrollView>
          </Tabs.Content>

          <Tabs.Content value="states" flex={1} key="states-content">
            <ScrollView>
              <StatesTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Define the specific types from RouterOutputs
type Principle = RouterOutputs['value']['getValues'][number];
type StateDefinition = RouterOutputs['state']['getDefinitions'][number]; 

// Principles Tab Component (manages data fetching and list rendering)
function PrinciplesTab() {
  const { data: principles, isLoading, error, refetch } = trpc.value.getValues.useQuery();

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }

  if (error) {
    return (
      <EmptyOrSkeleton
        isEmpty={false}
        isError={true}
        onRetry={refetch}
        text="Failed to load principles"
      />
    );
  }

  if (!principles || principles.length === 0) {
    return (
      <EmptyOrSkeleton
        isEmpty={true}
        text="No principles defined yet"
        actionText="Add Your First Principle"
        onAction={() => router.push('/compose?type=value' as Href)}
      />
    );
  }

  return (
    <YStack space="$3"> 
      {principles.map((principle: Principle) => (
        <PrincipleCard
          key={principle.id}
          principle={principle}
          onPress={() => router.push(`/values/${principle.id}` as Href)}
        />
      ))}
    </YStack>
  );
}

// States Tab Component (manages data fetching and list rendering)
function StatesTab() {
  const { data: states, isLoading, error, refetch } = trpc.state.getDefinitions.useQuery(); 

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }

  if (error) {
    return (
      <EmptyOrSkeleton
        isEmpty={false}
        isError={true}
        onRetry={refetch}
        text="Failed to load tracked state definitions"
      />
    );
  }

  if (!states || states.length === 0) {
    return (
      <EmptyOrSkeleton
        isEmpty={true}
        text="No state definitions found"
        actionText="Define Your First State"
        onAction={() => router.push('/compose?type=state' as Href)}
      />
    );
  }

  return (
    <YStack space="$3"> 
      {states.map((state: StateDefinition) => (
        <StateDefinitionCard
          key={state.id}
          state={state}
          onPress={() => router.push(`/states/${state.id}` as Href)}
        />
      ))}
    </YStack>
  );
}

// 
// Removed inline PrincipleCard definition (extracted to components/compass/PrincipleCard.tsx)
// 

// 
// Removed inline StateDefinitionCard definition (extracted to components/compass/StateDefinitionCard.tsx)
// 


[EOF: app/(tabs)/compass/index.tsx]

========================================
FILE: components/compass/PrinciplesTab.tsx
ISSUE CONTEXT: TypeError: principles.map is not a function (it is undefined)
----------------------------------------

Error: File not found at /Users/tylerbedford/Documents/Coding Projects/AetherIphone/components/compass/PrinciplesTab.tsx
This missing file could be related to the routing or component errors.


[EOF: components/compass/PrinciplesTab.tsx]

========================================
FILE: app/(tabs)/rewards/index.tsx
ISSUE CONTEXT: Duplicate Key Warning: "Encountered two children with the same key, `.$undefined-grid=2undefined-grid`"
----------------------------------------

// Rewards screen with grid/list toggle and claim functionality
import React, { useState, useCallback } from 'react';
import { YStack, XStack, Text, Button, ScrollView, Card, Checkbox, useTheme, H1 } from 'tamagui';
import { SafeAreaView, View, FlatList, ImageBackground, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { RouterOutputs } from '@/utils/trpc'; // Import RouterOutputs
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton'; // Import helper component

// Define inferred type for rewards
type RewardItem = RouterOutputs['rewards']['getAvailableRewards'][number];

enum ViewMode {
  Grid = 'grid',
  List = 'list'
}

export default function RewardsScreen() {
  const [viewMode, setViewMode] = useState<ViewMode>(ViewMode.Grid);
  const colorScheme = useColorScheme();
  const theme = useTheme();

  // Define fallback colors
  const blue2 = theme?.blue2?.val ?? '#eff6ff';
  const blue5 = theme?.blue5?.val ?? '#60a5fa';
  const blue10 = theme?.blue10?.val ?? '#1e40af';
  const blue11 = theme?.blue11?.val ?? '#1e3a8a';
  const green9 = theme?.green9?.val ?? '#16a34a';

  // Fetch available rewards from tRPC
  const { 
    data: rewards, 
    isLoading, 
    error, 
    refetch 
  } = trpc.rewards.getAvailableRewards.useQuery();

  // Mutation for claiming rewards
  const claimMutation = trpc.rewards.earnReward.useMutation({
    onSuccess: (data) => {
      console.log('Reward claimed successfully:', data);
      // Maybe show confetti?
      Alert.alert('Reward Claimed!', `You spent ${data.reward.points_spent} points. Remaining: ${data.remainingPoints}`);
      refetch(); // Refetch the list of available rewards
    },
    onError: (err) => {
      console.error('Failed to claim reward:', err);
      Alert.alert('Claim Failed', err.message || 'Could not claim reward.');
    }
  });
  
  const handleClaimReward = useCallback((rewardId: string) => {
    if (claimMutation.isPending) return; // Prevent double-clicks
    
    Alert.alert(
      'Confirm Claim',
      'Are you sure you want to spend points on this reward?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Claim', 
          onPress: () => {
            claimMutation.mutate({ rewardId });
          },
          style: 'default'
        }
      ]
    );
  }, [claimMutation]);
  
  const renderItem = ({ item }: { item: RewardItem }) => { // Use inferred type
    // Assuming backend field is image_url, map to imagePath
    const imagePath = item.image_url; 
    // All items from getAvailableRewards are considered claimable (not yet claimed)
    const claimed = false; 
    // Map required_points to pointCost
    const pointCost = item.required_points;

    if (viewMode === ViewMode.Grid) {
      return (
        <Card
          size="$4"
          bordered
          width={160}
          height={200}
          margin="$2"
          overflow="hidden"
          elevation="$2"
          opacity={claimed ? 0.7 : 1}
        >
          <ImageBackground
            source={{ uri: imagePath }}
            style={{ width: '100%', height: 100 }}
          >
            <View style={{ 
              position: 'absolute', 
              top: 5, 
              right: 5, 
              backgroundColor: blue5,
              borderRadius: 10,
              padding: 4
            }}>
              <Text color="white" fontSize="$2" fontWeight="bold">
                {pointCost} pts
              </Text>
            </View>
          </ImageBackground>
          
          <YStack padding="$2" flex={1} justifyContent="space-between">
            <Text fontSize="$4" fontWeight="bold" numberOfLines={1}>
              {item.name}
            </Text>
            
            <Button
              size="$2"
              themeInverse={claimed}
              backgroundColor={claimed ? undefined : blue10}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </YStack>
        </Card>
      );
    } else {
      return (
        <Card
          bordered
          margin="$2"
          padding="$3"
          opacity={claimed ? 0.7 : 1}
        >
          <XStack space="$3" alignItems="center">
            {imagePath && (
              <View style={{ 
                width: 60, 
                height: 60, 
                borderRadius: 8, 
                overflow: 'hidden',
                backgroundColor: theme.gray3.val
              }}>
                <ImageBackground
                  source={{ uri: imagePath }}
                  style={{ width: '100%', height: '100%' }}
                />
              </View>
            )}
            
            <YStack flex={1} space="$1">
              <Text fontSize="$5" fontWeight="bold">{item.name}</Text>
              <Text fontSize="$3" color="$gray11" numberOfLines={2}>{item.description}</Text>
              <Text fontSize="$3" color={blue10} fontWeight="500">{pointCost} points</Text>
            </YStack>
            
            <Button
              size="$3"
              backgroundColor={claimed ? undefined : blue10}
              themeInverse={claimed}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </XStack>
        </Card>
      );
    }
  };
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        <YStack space="$4">
          {/* Header */}
          <XStack justifyContent="space-between" alignItems="center">
            <H1>Rewards</H1>
            
            <XStack space="$2">
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.Grid ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.Grid)}
              >
                <Ionicons 
                  name="grid-outline" 
                  size={22} 
                  color={viewMode === ViewMode.Grid ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
              
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.List ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.List)}
              >
                <Ionicons 
                  name="list-outline" 
                  size={22} 
                  color={viewMode === ViewMode.List ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
            </XStack>
          </XStack>
          
          {/* Stats */}
          <Card padding="$3" backgroundColor={blue2}>
            <XStack justifyContent="space-between" alignItems="center">
              <Text fontSize="$5" fontWeight="bold" color={blue11}>Your Points</Text>
              <Text fontSize="$6" fontWeight="bold" color={blue10}>275</Text>
            </XStack>
          </Card>
        </YStack>
        
        {/* Content Area */} 
        <EmptyOrSkeleton 
          isLoading={isLoading}
          isEmpty={!isLoading && (!rewards || rewards.length === 0)}
          isError={!!error}
          text={error ? error.message : 'No rewards available yet.'} // Use text for error OR empty msg
          onRetry={refetch}
          type={viewMode === ViewMode.Grid ? 'card' : 'row'}
          count={viewMode === ViewMode.Grid ? 6 : 3}
        >
          <FlatList
            key={viewMode} // Change key based on viewMode to force re-render
            data={rewards}
            renderItem={renderItem}
            keyExtractor={(item) => `${item.id}-${viewMode}`} // Apply patch #1
            numColumns={viewMode === ViewMode.Grid ? 2 : 1}
            contentContainerStyle={{ paddingBottom: 50 }} // Add padding at the bottom
            // Optional Optimizations (Patch #6)
            initialNumToRender={8}
            removeClippedSubviews={true} // Note: Can have visual glitches on iOS sometimes
          />
        </EmptyOrSkeleton>

      </YStack>
    </SafeAreaView>
  );
}


[EOF: app/(tabs)/rewards/index.tsx]

========================================
FILE: app/(tabs)/_layout.tsx
ISSUE CONTEXT: Warnings: "No route named planner/index & settings/index exists in nested children"
----------------------------------------

// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/_layout.tsx
import React from 'react';
import { Tabs } from 'expo-router';
import { Ionicons } from '@expo/vector-icons'; // Example icon library
import { useThemeColor } from '@/hooks/useThemeColor'; // Assuming path alias is set

export default function TabLayout() {
  const tabBarActiveTintColor = useThemeColor({}, 'tabIconSelected');
  const tabBarInactiveTintColor = useThemeColor({}, 'tabIconDefault');
  const backgroundColor = useThemeColor({}, 'background'); // Use standard background color

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: tabBarActiveTintColor,
        tabBarInactiveTintColor: tabBarInactiveTintColor,
        tabBarStyle: {
          backgroundColor: backgroundColor,
          // Add other styles like borderTopColor if needed
        },
        headerShown: false, // We might handle headers inside each screen or using Stack
      }}
    >
      <Tabs.Screen
        name="home/index"
        options={{
          title: 'Home',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="home-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="planner/index"
        options={{
          title: 'Planner',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="calendar-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="compass/index"
        options={{
          title: 'Compass',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="compass-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="rewards/index"
        options={{
          title: 'Rewards',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="gift-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="settings/index"
        options={{
          title: 'Settings',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="settings-outline" size={size} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}


[EOF: app/(tabs)/_layout.tsx]

========================================
FILE: app/(tabs)/planner/index.tsx
ISSUE CONTEXT: Possibly missing or index file needs to be created
----------------------------------------

// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/planner/index.tsx
import React, { useState, Suspense } from 'react';
import { YStack, XStack, Text, Tabs, Button, Spinner, Card } from 'tamagui';
import { SafeAreaView, FlatList, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { RouterOutputs } from '@/utils/api-types';
import { SectionError } from '@/components/ui/ErrorBanner';


interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'goals',
    title: 'Goals',
    icon: <Ionicons name="trophy-outline" size={18} color="currentColor" />
  },
  {
    key: 'habits',
    title: 'Habits',
    icon: <Ionicons name="repeat-outline" size={18} color="currentColor" />
  },
  {
    key: 'calendar',
    title: 'Calendar',
    icon: <Ionicons name="calendar-outline" size={18} color="currentColor" />
  }
];

export default function PlannerScreen() {
  const [activeTab, setActiveTab] = useState<string>('goals');
  const colorScheme = useColorScheme();
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Planner</Text>
          <Button
            size="$3"
            circular
            onPress={() => {/* Handle new item */}}
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>
        
        {/* Tabs */}
        <Tabs
          defaultValue="goals"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List 
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {tab.icon}
                  <Text>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>
          
          {/* Tab Content */}
          <Tabs.Content value="goals" flex={1}>
            <ScrollView>
              <GoalsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="habits" flex={1}>
            <ScrollView>
              <HabitsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="calendar" flex={1}>
            <ScrollView>
              <CalendarTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Goals Tab
function GoalsTab() {
  // Fetch goals using tRPC
  const { data: goals, isLoading, error, refetch } = trpc.goal.getGoals.useQuery();
  
  // Define the inferred type for a single goal
  type PlannerGoal = RouterOutputs['goal']['getGoals'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load goals" 
      />
    );
  }
  
  if (!goals || goals.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No goals yet" 
        actionText="Create a goal" 
        onAction={() => router.push('/planner/add-goal')} 
      />
    );
  }
  
  return (
    <YStack space="$4">
      {goals.map((goal: PlannerGoal) => (
        <Button 
          key={goal.id} 
          height="$12" 
          justifyContent="flex-start" 
          paddingHorizontal="$3"
          onPress={() => router.push({ pathname: '/planner/goal/[id]', params: { id: goal.id } })}
        >
          <YStack>
            <Text fontWeight="bold">{goal.title}</Text>
            <Text fontSize="$2" color="$gray10">
              {goal.dueDate ? new Date(goal.dueDate).toLocaleDateString() : 'No due date'}
            </Text>
          </YStack>
        </Button>
      ))}
    </YStack>
  );
}

// Habits Tab
function HabitsTab() {
  // Fetch habits using tRPC
  const { data: habits, isLoading, error, refetch } = trpc.habit.getHabits.useQuery();
  
  // Define the inferred type for a single habit
  type PlannerHabit = RouterOutputs['habit']['getHabits'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={isLoading} count={3} type="row" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load habits" 
      />
    );
  }
  
  if (!habits || habits.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No habits yet" 
        actionText="Create a habit" 
        onAction={() => router.push('/planner/add-habit')} 
      />
    );
  }
  
  return (
    <YStack space="$3">
      {habits.map((habit: PlannerHabit) => (
        <XStack 
          key={habit.id} 
          justifyContent="space-between" 
          alignItems="center" 
          paddingVertical="$3" 
          paddingHorizontal="$3" 
          borderBottomWidth={1} 
          borderColor="$gray5"
          pressStyle={{ opacity: 0.7 }}
          tag="pressable"
          onPress={() => router.push({ pathname: '/planner/habit/[id]', params: { id: habit.id } })}
        >
          <Text>{habit.title}</Text>
          <Button
            size="$2"
            circular
            backgroundColor={habit.completed ? '$green9' : '$gray9'}
            onPress={() => {
              // Use today's date for the habit entry
              const today = new Date().toISOString().split('T')[0];
              
              // Create a mutation to toggle habit completion
              const toggleHabit = trpc.habit.createHabitEntry.useMutation({
                onSuccess: () => {
                  refetch(); // Refresh data after toggling
                },
                onError: (error) => {
                  // Show error message
                  console.error('Failed to toggle habit:', error.message);
                }
              });
              
              // Toggle the habit completion status
              toggleHabit.mutate({
                habitId: habit.id,
                completed: !habit.completed,
                date: today
              });
            }}
            icon={<Ionicons name="checkmark" size={18} color="white" />}
          />
        </XStack>
      ))}
    </YStack>
  );
}

// Calendar Tab
function CalendarTab() {
  return (
    <YStack alignItems="center" justifyContent="center" padding="$8">
      <Text fontSize="$5" textAlign="center">
        Calendar integration coming soon
      </Text>
      <Text marginTop="$2" color="$gray10" textAlign="center">
        This tab will display task and habit schedules in a calendar view
      </Text>
    </YStack>
  );
}


[EOF: app/(tabs)/planner/index.tsx]

========================================
FILE: app/(tabs)/settings/index.tsx
ISSUE CONTEXT: Possibly missing or index file needs to be created
----------------------------------------

// Settings screen with account, preferences, and app settings
import React, { useState } from 'react';
import { YStack, XStack, Text, Button, Switch, Separator, ScrollView, Card, H1 } from 'tamagui';
import { SafeAreaView, View, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { supabase } from '@/utils/supabase';
import { useColorScheme } from '@/hooks/useColorScheme';
import { useUiStore } from '@/stores/uiStore';

interface SettingsSectionProps {
  title: string;
  icon: React.ReactNode;
  children: React.ReactNode;
}

const SettingsSection = ({ title, icon, children }: SettingsSectionProps) => {
  return (
    <YStack marginVertical="$2">
      <XStack alignItems="center" space="$2" marginBottom="$2">
        {icon}
        <Text fontSize="$5" fontWeight="bold">{title}</Text>
      </XStack>
      <Card padding="$3" bordered>
        {children}
      </Card>
    </YStack>
  );
};

interface SettingsRowProps {
  label: string;
  icon?: React.ReactNode;
  rightElement?: React.ReactNode;
  onPress?: () => void;
  showChevron?: boolean;
}

const SettingsRow = ({ label, icon, rightElement, onPress, showChevron = false }: SettingsRowProps) => {
  return (
    <XStack
      paddingVertical="$3"
      justifyContent="space-between"
      alignItems="center"
      onPress={onPress}
      pressStyle={onPress ? { opacity: 0.7 } : undefined}
    >
      <XStack space="$3" alignItems="center" flex={1}>
        {icon}
        <Text fontSize="$4">{label}</Text>
      </XStack>
      <XStack space="$2" alignItems="center">
        {rightElement}
        {showChevron && <Ionicons name="chevron-forward" size={18} color="#A0A0A0" />}
      </XStack>
    </XStack>
  );
};

export default function SettingsScreen() {
  const colorScheme = useColorScheme();
  const { isDarkMode, toggleTheme } = useUiStore();
  const [notificationsEnabled, setNotificationsEnabled] = useState(true);
  const [trackingEnabled, setTrackingEnabled] = useState(true);
  
  const handleLogout = async () => {
    Alert.alert(
      'Log Out',
      'Are you sure you want to log out?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Log Out', 
          style: 'destructive',
          onPress: async () => {
            await supabase.auth.signOut();
            router.replace('/(auth)/login');
          }
        }
      ]
    );
  };
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <ScrollView>
        <YStack flex={1} padding="$4">
          <H1 marginBottom="$4">Settings</H1>
          
          {/* Account Section */}
          <SettingsSection
            title="Account"
            icon={<Ionicons name="person-circle-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Edit Profile"
                icon={<Ionicons name="person-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/profile' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Security"
                icon={<Ionicons name="lock-closed-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/security' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Data & Privacy"
                icon={<Ionicons name="shield-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/privacy' as any)}
              />
            </YStack>
          </SettingsSection>
          
          {/* Appearance Section */}
          <SettingsSection
            title="Appearance"
            icon={<Ionicons name="color-palette-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Dark Mode"
                icon={<Ionicons name="moon-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={isDarkMode}
                    onCheckedChange={toggleTheme}
                  />
                }
              />
            </YStack>
          </SettingsSection>
          
          {/* Notifications Section */}
          <SettingsSection
            title="Notifications"
            icon={<Ionicons name="notifications-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Push Notifications"
                icon={<Ionicons name="push-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={notificationsEnabled}
                    onCheckedChange={setNotificationsEnabled}
                  />
                }
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Notification Settings"
                icon={<Ionicons name="options-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/notifications' as any)}
              />
            </YStack>
          </SettingsSection>
          
          {/* Privacy Section */}
          <SettingsSection
            title="Privacy & Data"
            icon={<Ionicons name="analytics-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Analytics Tracking"
                icon={<Ionicons name="trending-up-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={trackingEnabled}
                    onCheckedChange={setTrackingEnabled}
                  />
                }
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Export Data"
                icon={<Ionicons name="download-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => {
                  Alert.alert(
                    'Export Data',
                    'Your data will be prepared for export and sent to your email address.',
                    [
                      { text: 'Cancel', style: 'cancel' },
                      { text: 'Export', onPress: () => {
                        // Would call an API endpoint to initiate export
                        Alert.alert('Export Initiated', 'Check your email for the export file.');
                      }}
                    ]
                  );
                }}
              />
            </YStack>
          </SettingsSection>
          
          {/* Support Section */}
          <SettingsSection
            title="Support & About"
            icon={<Ionicons name="help-circle-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Help Center"
                icon={<Ionicons name="help-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/help' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="About Aether"
                icon={<Ionicons name="information-circle-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/about' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="App Version"
                icon={<Ionicons name="code-outline" size={20} color="#A0A0A0" />}
                rightElement={<Text color="$gray10">1.0.0</Text>}
              />
            </YStack>
          </SettingsSection>
          
          {/* Logout Button */}
          <Button
            marginTop="$6"
            marginBottom="$8"
            size="$4"
            themeInverse
            onPress={handleLogout}
          >
            Log Out
          </Button>
        </YStack>
      </ScrollView>
    </SafeAreaView>
  );
}


[EOF: app/(tabs)/settings/index.tsx]

========================================
FILE: app/(tabs)/planner/index.tsx
ISSUE CONTEXT: ReferenceError: Property "ScrollView" doesn't exist
----------------------------------------

// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/planner/index.tsx
import React, { useState, Suspense } from 'react';
import { YStack, XStack, Text, Tabs, Button, Spinner, Card } from 'tamagui';
import { SafeAreaView, FlatList, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { RouterOutputs } from '@/utils/api-types';
import { SectionError } from '@/components/ui/ErrorBanner';


interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'goals',
    title: 'Goals',
    icon: <Ionicons name="trophy-outline" size={18} color="currentColor" />
  },
  {
    key: 'habits',
    title: 'Habits',
    icon: <Ionicons name="repeat-outline" size={18} color="currentColor" />
  },
  {
    key: 'calendar',
    title: 'Calendar',
    icon: <Ionicons name="calendar-outline" size={18} color="currentColor" />
  }
];

export default function PlannerScreen() {
  const [activeTab, setActiveTab] = useState<string>('goals');
  const colorScheme = useColorScheme();
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Planner</Text>
          <Button
            size="$3"
            circular
            onPress={() => {/* Handle new item */}}
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>
        
        {/* Tabs */}
        <Tabs
          defaultValue="goals"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List 
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {tab.icon}
                  <Text>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>
          
          {/* Tab Content */}
          <Tabs.Content value="goals" flex={1}>
            <ScrollView>
              <GoalsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="habits" flex={1}>
            <ScrollView>
              <HabitsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="calendar" flex={1}>
            <ScrollView>
              <CalendarTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Goals Tab
function GoalsTab() {
  // Fetch goals using tRPC
  const { data: goals, isLoading, error, refetch } = trpc.goal.getGoals.useQuery();
  
  // Define the inferred type for a single goal
  type PlannerGoal = RouterOutputs['goal']['getGoals'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load goals" 
      />
    );
  }
  
  if (!goals || goals.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No goals yet" 
        actionText="Create a goal" 
        onAction={() => router.push('/planner/add-goal')} 
      />
    );
  }
  
  return (
    <YStack space="$4">
      {goals.map((goal: PlannerGoal) => (
        <Button 
          key={goal.id} 
          height="$12" 
          justifyContent="flex-start" 
          paddingHorizontal="$3"
          onPress={() => router.push({ pathname: '/planner/goal/[id]', params: { id: goal.id } })}
        >
          <YStack>
            <Text fontWeight="bold">{goal.title}</Text>
            <Text fontSize="$2" color="$gray10">
              {goal.dueDate ? new Date(goal.dueDate).toLocaleDateString() : 'No due date'}
            </Text>
          </YStack>
        </Button>
      ))}
    </YStack>
  );
}

// Habits Tab
function HabitsTab() {
  // Fetch habits using tRPC
  const { data: habits, isLoading, error, refetch } = trpc.habit.getHabits.useQuery();
  
  // Define the inferred type for a single habit
  type PlannerHabit = RouterOutputs['habit']['getHabits'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={isLoading} count={3} type="row" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load habits" 
      />
    );
  }
  
  if (!habits || habits.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No habits yet" 
        actionText="Create a habit" 
        onAction={() => router.push('/planner/add-habit')} 
      />
    );
  }
  
  return (
    <YStack space="$3">
      {habits.map((habit: PlannerHabit) => (
        <XStack 
          key={habit.id} 
          justifyContent="space-between" 
          alignItems="center" 
          paddingVertical="$3" 
          paddingHorizontal="$3" 
          borderBottomWidth={1} 
          borderColor="$gray5"
          pressStyle={{ opacity: 0.7 }}
          tag="pressable"
          onPress={() => router.push({ pathname: '/planner/habit/[id]', params: { id: habit.id } })}
        >
          <Text>{habit.title}</Text>
          <Button
            size="$2"
            circular
            backgroundColor={habit.completed ? '$green9' : '$gray9'}
            onPress={() => {
              // Use today's date for the habit entry
              const today = new Date().toISOString().split('T')[0];
              
              // Create a mutation to toggle habit completion
              const toggleHabit = trpc.habit.createHabitEntry.useMutation({
                onSuccess: () => {
                  refetch(); // Refresh data after toggling
                },
                onError: (error) => {
                  // Show error message
                  console.error('Failed to toggle habit:', error.message);
                }
              });
              
              // Toggle the habit completion status
              toggleHabit.mutate({
                habitId: habit.id,
                completed: !habit.completed,
                date: today
              });
            }}
            icon={<Ionicons name="checkmark" size={18} color="white" />}
          />
        </XStack>
      ))}
    </YStack>
  );
}

// Calendar Tab
function CalendarTab() {
  return (
    <YStack alignItems="center" justifyContent="center" padding="$8">
      <Text fontSize="$5" textAlign="center">
        Calendar integration coming soon
      </Text>
      <Text marginTop="$2" color="$gray10" textAlign="center">
        This tab will display task and habit schedules in a calendar view
      </Text>
    </YStack>
  );
}


[EOF: app/(tabs)/planner/index.tsx]

========================================
FILE: app/(tabs)/planner/_layout.tsx
ISSUE CONTEXT: Navigation structure for planner tab
----------------------------------------

// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/planner/_layout.tsx
import { Stack } from 'expo-router';
import React from 'react';

export default function PlannerLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      {/* The index screen is the default for the planner tab */}
      <Stack.Screen name="index" />
      {/* Add screens for the sub-pages */}
      <Stack.Screen name="add-task" options={{ presentation: 'modal', title: 'Add Task' }} />
      <Stack.Screen name="add-habit" options={{ presentation: 'modal', title: 'Add Habit' }} />
      <Stack.Screen name="add-goal" options={{ presentation: 'modal', title: 'Add Goal' }} />
      <Stack.Screen name="goal/[id]" options={{ title: 'Goal Details' }} />
      <Stack.Screen name="habit/[id]" options={{ title: 'Habit Details' }} />
    </Stack>
  );
}


[EOF: app/(tabs)/planner/_layout.tsx]

========================================
FILE: app/(tabs)/settings/_layout.tsx
ISSUE CONTEXT: Navigation structure for settings tab
----------------------------------------

// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/settings/_layout.tsx
import { Stack } from 'expo-router';
import React from 'react';

export default function SettingsLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      {/* The index screen is the default for the settings tab */}
      <Stack.Screen name="index" />
      {/* Add screens for the sub-pages */}
      <Stack.Screen name="profile" options={{ title: 'Edit Profile' }} />
      <Stack.Screen name="security" options={{ title: 'Security' }} />
      <Stack.Screen name="privacy" options={{ title: 'Data & Privacy' }} />
      <Stack.Screen name="notifications" options={{ title: 'Notifications' }} />
      <Stack.Screen name="help" options={{ title: 'Help & Support' }} />
      <Stack.Screen name="about" options={{ title: 'About Aether' }} />
    </Stack>
  );
}


[EOF: app/(tabs)/settings/_layout.tsx]


========================================
ERROR ANALYSIS AND RECOMMENDATIONS
----------------------------------------


Okay, let's break down the issues from the debug report and identify which other files would be helpful.

**1. Issue: `TypeError: principles.map is not a function` (in `PrinciplesTab.tsx`)**

* **Explanation:** As the report context suggests, this error happens because the `principles` variable (coming from the `trpc.value.getValues` query) is `undefined` when the `.map()` function tries to run. This occurs during the initial loading state or if the query returns an error.
* **Code Provided:** `app/(tabs)/compass/index.tsx` shows how `PrinciplesTab` is rendered, but not the internal code of `PrinciplesTab` itself.
* **IMPORTANT NOTE: The `components/compass/PrinciplesTab.tsx` file was NOT FOUND by the script.** This suggests either:
  1. The file is in a different location
  2. The component might be defined inline in another file
  3. The file might have a different name
* **Files Needed for Fix:**
  * **`components/compass/PrinciplesTab.tsx`**: This file is essential but missing. We need its content to see exactly how `principles` is being accessed and add the necessary checks (`if (isLoading)...`, `if (error)...`, `if (!principles || !Array.isArray(principles))...`) before the `.map()` call.

**2. Issue: Duplicate Key Warning (`.$undefined-grid=2undefined-grid`) in `RewardsScreen`**

* **Explanation:** The `FlatList` in `app/(tabs)/rewards/index.tsx` uses a `keyExtractor` function that combines `item.id` with `viewMode`. The generated key `.$undefined-grid=2undefined-grid` indicates that for at least one item in the `rewards` array (when `viewMode` is 'grid'), `item.id` is coming through as `undefined`. React requires unique string keys for list items.
* **Code Provided:** `app/(tabs)/rewards/index.tsx` shows the `FlatList` setup.
* **Analysis of Server Code:** If `server/src/routers/rewardsRouter.ts` was found, it should be checked to see if the `getAvailableRewards` procedure correctly selects the `id` field. If the router code looks okay, the issue might be in the database data itself.
* **Next Step:** Log the `rewards` data inside the `RewardsScreen` component right before the `FlatList` is rendered to find which item(s) are missing the `id`:
  ```javascript
  // Inside RewardsScreen component
  console.log("Rewards Data:", JSON.stringify(rewards, null, 2)); // Log before FlatList
  ```
* **Files Needed for Fix:**
  * **`server/src/routers/rewardsRouter.ts`**: To check the `getAvailableRewards` procedure.

**3. Issue: Routing Warnings (`No route named planner/index & settings/index exists...`)**

* **Explanation:** The provided code for `app/(tabs)/_layout.tsx` *does* use the correct naming (`name="planner/index"`, `name="settings/index"`). This should resolve the specific warnings mentioned in the logs.
* **Possible Reasons for Persisting Warnings:**
  * The running app might not have fully reflected the code change yet (clear cache, restart Metro with `npx expo start -c`).
  * There might be *other* places in the code (like `Link` components or `router.push` calls) that are still using old, incorrect short names.
  * The issue might be deeper within Expo Router's handling of nested layouts.
* **Action:** Confirm if the warnings specifically for `planner/index` and `settings/index` are still showing up *after* applying the fix and restarting/clearing cache. If so, search for `Link` or `router.push` calls that might still use short names.

**4. Issue: `ReferenceError: Property "ScrollView" doesn't exist` (in `PlannerScreen`)**

* **Explanation:** The code in `app/(tabs)/planner/index.tsx` uses the `<ScrollView>` component, but it's missing the corresponding import statement.
* **Code Provided:** `app/(tabs)/planner/index.tsx` shows the usage without the import.
* **✅ Fix:** Add the import to `app/(tabs)/planner/index.tsx`:
  ```javascript
  import { YStack, XStack, Text, Tabs, Button, Spinner, Card, ScrollView } from 'tamagui'; // Add ScrollView here
  // or if you intended the React Native one:
  // import { ScrollView } from 'react-native'; 
  ```

**Hypothesis Summary:**

* The `PrinciplesTab` error is likely the same "accessing undefined data before load/error check" issue seen previously, but **we couldn't find the actual file to confirm**.
* The `RewardsScreen` duplicate key error suggests inconsistent data (missing `id`s) coming from the `rewards.getAvailableRewards` tRPC call. Data inspection is needed.
* The `PlannerScreen` `ScrollView` error is a simple missing import - easy to fix.

For a more complete analysis, we would need to locate the missing `PrinciplesTab.tsx` file, possibly by checking other component directories, and also examine the data flowing through the `RewardsScreen` component.

  ```

- **package.json** (2.6 KB, 87 lines) *(No explicit exports)*

  ```json
{
  "name": "aetheriphone",
  "version": "1.0.0",
  "type": "module",
  "main": "expo-router/entry",
  "private": true,
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "lint": "expo lint",
    "generate": "node ./scripts/generate-all.js",
    "dev": "npm run generate && expo start"
  },
  "dependencies": {
    "@expo/vector-icons": "^14.0.2",
    "@gluestack-ui/config": "^1.1.20",
    "@gluestack-ui/themed": "^1.1.73",
    "@react-navigation/bottom-tabs": "^7.2.0",
    "@react-navigation/native": "^7.0.14",
    "@shopify/flash-list": "^1.8.0",
    "@supabase/supabase-js": "^2.49.4",
    "@tamagui/core": "1.126.1",
    "@tamagui/lucide-icons": "1.126.1",
    "@tamagui/stacks": "1.126.1",
    "@tamagui/themes": "1.126.1",
    "@tamagui/toast": "1.126.1",
    "@tanstack/query-async-storage-persister": "^5.74.4",
    "@tanstack/react-query": "^5.74.11",
    "@tanstack/react-query-persist-client": "^5.74.4",
    "@trpc/client": "^11.1.2",
    "@trpc/react-query": "^11.1.2",
    "burnt": "^0.13.0",
    "date-fns": "^4.1.0",
    "expo": "~52.0.46",
    "expo-blur": "~14.0.3",
    "expo-constants": "~17.0.8",
    "expo-dev-client": "~5.0.20",
    "expo-font": "~13.0.4",
    "expo-haptics": "~14.0.1",
    "expo-linking": "~7.0.5",
    "expo-router": "~4.0.20",
    "expo-secure-store": "^14.0.1",
    "expo-splash-screen": "~0.29.24",
    "expo-status-bar": "~2.0.1",
    "expo-web-browser": "~14.0.2",
    "lottie-react-native": "7.1.0",
    "moti": "^0.30.0",
    "nativewind": "^4.1.23",
    "react": "18.3.1",
    "react-dom": "18.3.1",
    "react-native": "0.76.9",
    "react-native-gesture-handler": "^2.25.0",
    "react-native-reanimated": "^3.17.5",
    "react-native-safe-area-context": "4.12.0",
    "react-native-screens": "~4.4.0",
    "react-native-svg": "15.8.0",
    "react-native-swipe-list-view": "^3.2.9",
    "react-native-url-polyfill": "^2.0.0",
    "superjson": "^2.2.2",
    "tamagui": "1.126.1",
    "text-encoding": "^0.7.0",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@babel/parser": "^7.27.0",
    "@babel/traverse": "^7.27.0",
    "@testing-library/react-native": "^13.2.0",
    "@types/react": "~18.3.12",
    "@types/react-test-renderer": "^18.3.0",
    "chalk": "^5.4.1",
    "eslint": "^8.57.0",
    "eslint-config-expo": "~8.0.1",
    "globby": "^14.1.0",
    "jest-expo": "~52.0.6",
    "micromatch": "^4.0.8",
    "nativewind": "^4.1.23",
    "tailwindcss": "^3.4.17",
    "typescript": "^5.3.3"
  },
  "resolutions": {
    "@gluestack-ui/config": "^1.1.20",
    "react-native-gesture-handler": "^2.25.0"
  }
}

  ```

- **project.txt** (127.5 KB, 3939 lines) *(No explicit exports)*

  ```txt
# Aether iPhone: Tamagui to Gluestack/NativeWind Migration
Generated on Wed Apr 30 00:52:25 CDT 2025

\n\n# 1️⃣ Core Design System
\nMigration path: Tamagui tokens → Gluestack UI + NativeWind
\n\n## Current tokens (tamagui.config.ts)
**Current implementation:** tamagui.config.ts
\n```
// tamagui.config.ts
import { createAnimations } from '@tamagui/animations-react-native';
import { createFont, createTamagui, createTokens } from 'tamagui';
import { Platform } from 'react-native';
import * as MotionConstants from '@/constants/motion'; // Import motion constants

// Font definitions - Zelda Theme
// Assumes 'CalamitySans' and 'HyliaSerif' are loaded via useFonts or similar
const headingFont = createFont({
  family: 'HyliaSerif', // Zelda Display Font
  size: {
    // Mapped closer to iOS Dynamic Type: https://developer.apple.com/design/human-interface-guidelines/typography
    1: 13,  // Caption 2
    2: 15,  // Subheadline
    3: 17,  // Body (true default)
    4: 20,  // Title 3
    5: 22,  // Title 2
    6: 28,  // Title 1
    7: 34,  // Large Title
    8: 40,  // Extra Large Title (custom)
    true: 17, // Default size (Body)
  },
  lineHeight: {
    // Approximate line heights based on new sizes
    1: 18, 2: 20, 3: 22, 4: 25, 5: 28, 6: 34, 7: 41, 8: 50, 
    true: 22,
  },
  weight: {
    // Prompt 2 asks for 400-700
    4: '400', // Normal
    6: '600', // Semi-bold/Bold
    7: '700', // Extra-bold/Black
    true: '400',
  },
  letterSpacing: {
    1: 0, 2: 0, 3: -0.5, 4: -0.5, 5: -1, 6: -1, 7: -1.5, 8: -1.5,
    true: 0,
  },
  // Required: Map weights to specific font faces if needed (e.g., 'HyliaSerif-Bold')
  // face: {
  //   400: { normal: 'HyliaSerif-Regular' },
  //   700: { normal: 'HyliaSerif-Bold' },
  // },
});

const bodyFont = createFont({
  family: 'CalamitySans', // Zelda Body Font
  size: {
    // Mapped closer to iOS Dynamic Type
    1: 11,  // Footnote
    2: 12,  // Caption 1
    3: 13,  // Caption 2
    4: 15,  // Subheadline
    5: 17,  // Body (true default)
    6: 20,  // Title 3 (matching headingFont.$4)
    true: 17, // Default body size
  },
  lineHeight: {
    // Approximate line heights
    1: 13, 2: 16, 3: 18, 4: 20, 5: 22, 6: 25,
    true: 22, // Default body line height
  },
  weight: {
    4: '400', // Regular
    5: '500', // Medium (if available)
    7: '700', // Bold (if needed/available)
    true: '400',
  },
  letterSpacing: {
    1: 0.1, 2: 0.1, 3: 0, 4: 0, 5: -0.1, 6: -0.1,
    true: 0,
  },
  // Required: Map weights to specific font faces if needed (e.g., 'CalamitySans-Medium')
  // face: {
  //   400: { normal: 'CalamitySans-Regular' },
  //   500: { normal: 'CalamitySans-Medium' },
  // },
});

const monoFont = createFont({
  family: Platform.select({ web: 'monospace', default: 'SpaceMono' }), // Keep SpaceMono for code
  size: {
    1: 12, 2: 14, 3: 15, 4: 16, 5: 18, 6: 20, true: 15,
  },
  lineHeight: {
    1: 18, 2: 22, 3: 24, 4: 26, 5: 28, 6: 32, true: 24,
  },
  weight: {
    4: '400', // Normal weight
    true: '400',
  },
  letterSpacing: {
    4: 0,
    true: 0,
  },
  face: {
    400: { normal: 'SpaceMono' }, // Map weight 400 to the loaded SpaceMono font
  },
});

// Animation driver using reanimated
const animations = createAnimations({
  fast: {
    type: 'timing',
    duration: MotionConstants.durations.standard,
    // easing: MotionConstants.easings.standard, // Removed as createAnimations defaults work well
  },
  medium: {
    type: 'timing',
    duration: MotionConstants.durations.modal,
  },
  slow: {
    type: 'timing',
    duration: MotionConstants.durations.long,
  },
  bouncy: {
    type: 'spring',
    damping: 9,
    mass: 0.9,
    stiffness: 150,
  },
  lazy: {
    type: 'spring',
    damping: 18,
    stiffness: 50,
  },
  quick: {
    type: 'spring',
    damping: 20,
    mass: 1.2,
    stiffness: 250,
  },
});

// Standard Radix Gray scale (light theme)
const gray = {
  gray1: '#fcfcfc', gray2: '#f8f8f8', gray3: '#f3f3f3', gray4: '#ededed', gray5: '#e8e8e8', gray6: '#e2e2e2', gray7: '#dbdbdb', gray8: '#c7c7c7', gray9: '#8f8f8f', gray10: '#858585', gray11: '#6f6f6f', gray12: '#171717',
};

// Standard Radix Gray scale (dark theme)
const grayDark = {
  gray1: '#191919', gray2: '#212121', gray3: '#282828', gray4: '#303030', gray5: '#393939', gray6: '#424242', gray7: '#4f4f4f', gray8: '#626262', gray9: '#737373', gray10: '#838383', gray11: '#ababab', gray12: '#ededed',
};

// Tokens (refined based on your existing config)
const tokens = createTokens({
  size: {
    0: 0, 1: 4, 2: 8, 3: 12, 4: 16, 5: 20, 6: 24, 7: 28, 8: 32, 9: 36, 10: 40, 11: 44, 12: 48, 13: 52, 14: 56, 15: 60, 16: 64, true: 16,
  },
  space: {
    0: 0, 1: 4, 2: 8, 3: 12, 4: 16, 5: 20, 6: 24, 7: 28, 8: 32, 9: 36, 10: 40, 11: 44, 12: 48, 13: 52, 14: 56, 15: 60, 16: 64, true: 16, '-1': -4, '-2': -8, '-3': -12, '-4': -16,
  },
  radius: {
    0: 0, 1: 3, 2: 5, 3: 8, 4: 10, 5: 14, 6: 16, 7: 20, 8: 24, 9: 28, 10: 32, true: 10, // Updated radius.5 to 14
  },
  zIndex: { 0: 0, 1: 100, 2: 200, 3: 300, 4: 400, 5: 500 },
  color: {
    // Zelda Palette (Prompt 1)
    ...gray, // Add light greys
    ...grayDark, // Add dark greys (will be overridden in dark theme definition)
    parchment: '#FDFFE0',
    sheikahCyan: '#86A5A9',
    korokGreen: '#92C582',
    darkText: '#536F50',
    guardianOrange: '#FF9F0A',
    darkTealBg: '#1A2E3A',
    darkCyanGlow: '#64FFDA',

    // Shadow Colors (Prompt 5)
    shadowColorLight: 'rgba(83, 111, 80, 1)', // dark desaturated text color
    shadowColorDark: 'rgba(0, 0, 0, 1)', // Black base
    white: '#FFFFFF',
    black: '#000000',
  },
});

// Define themes using Zelda Palette
const lightTheme = {
  // Base Colors
  background: tokens.color.parchment,      // Light bg
  backgroundStrong: tokens.color.white,     // Keep white for strong contrast areas if needed
  backgroundTransparent: 'rgba(253, 255, 224, 0)', // Fully transparent parchment
  color: tokens.color.darkText,             // Dark desaturated text
  colorSecondary: tokens.color.darkText,      // Use main text color, maybe slightly lighter if needed later
  colorTertiary: tokens.color.sheikahCyan,    // Use accent for tertiary info?
  borderColor: tokens.color.sheikahCyan,      // Use accent for borders
  borderColorHover: tokens.color.korokGreen,  // Korok green on hover?

  // Theme-specific states (can refine later)
  backgroundHover: tokens.color.parchment,    // Keep parchment, maybe slightly darker/lighter
  backgroundPress: tokens.color.parchment,    // Keep parchment
  backgroundFocus: tokens.color.parchment,    // Keep parchment
  colorHover: tokens.color.korokGreen,        // Korok green text on hover?
  colorPress: tokens.color.korokGreen,
  colorFocus: tokens.color.sheikahCyan,
  borderColorPress: tokens.color.korokGreen,
  borderColorFocus: tokens.color.sheikahCyan,

  // Semantic Tokens (Prompt 4)
  accent: tokens.color.sheikahCyan,
  surfaceSubtle: tokens.color.parchment,    // Base color, apply opacity in component (e.g., rgba(253,255,224,0.8))
  destructive: tokens.color.guardianOrange,

  // Standard Semantic Mapping (can use Zelda colors)
  primary: tokens.color.sheikahCyan,        // Map primary to accent
  secondary: tokens.color.korokGreen,       // Map secondary to korok green?
  success: tokens.color.korokGreen,
  warning: tokens.color.guardianOrange,     // Use guardian orange for warning
  error: tokens.color.guardianOrange,       // Use guardian orange for error
  info: tokens.color.sheikahCyan,

  // Semantic Aliases (Playbook 1.1)
  surface: tokens.color.parchment, // Maps to background
  onSurface: tokens.color.darkText,  // Maps to color
  outline: tokens.color.sheikahCyan, // Maps to borderColor

  // Shadows (Playbook 1.1 & Prompt 5)
  shadowColor: tokens.color.shadowColorLight, // Use darkText color base for shadow
  shadowColorHover: 'rgba(83, 111, 80, 0.15)',
  shadowSm: 'rgba(83, 111, 80, 0.10)', // 10% opacity
  shadowMd: 'rgba(83, 111, 80, 0.15)', // 15% opacity
  shadowLg: 'rgba(83, 111, 80, 0.20)', // 20% opacity

  // Toast Themes (Report Item 6)
  toast_success_background: tokens.color.korokGreen,
  toast_success_color: tokens.color.parchment,
  toast_error_background: tokens.color.guardianOrange,
  toast_error_color: tokens.color.parchment,
  toast_warning_background: tokens.color.guardianOrange, // Often same as error
  toast_warning_color: tokens.color.parchment,
  toast_info_background: tokens.color.sheikahCyan,
  toast_info_color: tokens.color.parchment,
};

const darkTheme: typeof lightTheme = {
  // Base Colors
  ...grayDark, // Override light greys with dark greys
  background: tokens.color.darkTealBg,      // Dark-mode bg
  backgroundStrong: tokens.color.black,       // Black for contrast?
  backgroundTransparent: 'rgba(26, 46, 58, 0)', // Fully transparent dark teal
  color: tokens.color.parchment,          // Use light parchment for text
  colorSecondary: tokens.color.sheikahCyan,   // Sheikah cyan for secondary text
  colorTertiary: tokens.color.korokGreen,     // Korok green for tertiary
  borderColor: tokens.color.sheikahCyan,      // Sheikah cyan borders
  borderColorHover: tokens.color.darkCyanGlow, // Glow cyan on hover?

  // Theme-specific states
  backgroundHover: tokens.color.darkTealBg,   // Keep bg, maybe slightly lighter
  backgroundPress: tokens.color.darkTealBg,
  backgroundFocus: tokens.color.darkTealBg,
  colorHover: tokens.color.darkCyanGlow,
  colorPress: tokens.color.darkCyanGlow,
  colorFocus: tokens.color.darkCyanGlow,
  borderColorPress: tokens.color.darkCyanGlow,
  borderColorFocus: tokens.color.darkCyanGlow,

  // Semantic Tokens (Prompt 4)
  accent: tokens.color.sheikahCyan,
  surfaceSubtle: tokens.color.darkTealBg, // Use dark bg, apply opacity in component
  destructive: tokens.color.guardianOrange,

  // Standard Semantic Mapping
  primary: tokens.color.darkCyanGlow,       // Use glow cyan for primary actions
  secondary: tokens.color.korokGreen,
  success: tokens.color.korokGreen,
  warning: tokens.color.guardianOrange,
  error: tokens.color.guardianOrange,
  info: tokens.color.sheikahCyan,

  // Semantic Aliases (Playbook 1.1)
  surface: tokens.color.darkTealBg,   // Maps to background
  onSurface: tokens.color.parchment,  // Maps to color
  outline: tokens.color.sheikahCyan, // Maps to borderColor

  // Shadows (Playbook 1.1 & Prompt 5)
  shadowColor: tokens.color.shadowColorDark, // Darker shadow for dark mode
  shadowColorHover: 'rgba(0, 0, 0, 0.30)',
  shadowSm: 'rgba(0, 0, 0, 0.20)', // 20% opacity
  shadowMd: 'rgba(0, 0, 0, 0.30)', // 30% opacity
  shadowLg: 'rgba(0, 0, 0, 0.40)', // 40% opacity

  // Toast Themes (Report Item 6)
  toast_success_background: tokens.color.korokGreen,
  toast_success_color: tokens.color.darkTealBg,
  toast_error_background: tokens.color.guardianOrange,
  toast_error_color: tokens.color.darkTealBg,
  toast_warning_background: tokens.color.guardianOrange, // Often same as error
  toast_warning_color: tokens.color.darkTealBg,
  toast_info_background: tokens.color.sheikahCyan,
  toast_info_color: tokens.color.darkTealBg,
};

// Create the Tamagui config
const config = createTamagui({
  animations,
  shouldAddPrefersColorThemes: true,
  themeClassNameOnRoot: true,
  shorthands: {
    // Keep your existing shorthands
    m: 'margin', mt: 'marginTop', mr: 'marginRight', mb: 'marginBottom', ml: 'marginLeft', mx: 'marginHorizontal', my: 'marginVertical',
    p: 'padding', pt: 'paddingTop', pr: 'paddingRight', pb: 'paddingBottom', pl: 'paddingLeft', px: 'paddingHorizontal', py: 'paddingVertical',
    bg: 'backgroundColor', br: 'borderRadius', bw: 'borderWidth', bc: 'borderColor',
    f: 'flex', fd: 'flexDirection', ai: 'alignItems', jc: 'justifyContent', w: 'width', h: 'height',
    ac: 'alignContent',
    als: 'alignSelf',
    btc: 'borderTopColor',
    bbc: 'borderBottomColor',
    blc: 'borderLeftColor',
    brc: 'borderRightColor',
    boc: 'borderColor',
    bs: 'borderStyle',
    dsp: 'display',
    fb: 'flexBasis',
    fg: 'flexGrow',
    fs: 'flexShrink',
    fw: 'flexWrap',
    mah: 'maxHeight',
    maw: 'maxWidth',
    mih: 'minHeight',
    miw: 'minWidth',
    op: 'opacity',
    ov: 'overflow',
    r: 'right',
    shac: 'shadowColor',
    shar: 'shadowRadius',
    shof: 'shadowOffset',
    shop: 'shadowOpacity',
    t: 'top',
    ta: 'textAlign',
    tt: 'textTransform',
    va: 'verticalAlign',
    zi: 'zIndex',
  },
  fonts: {
    // Use Zelda fonts
    heading: headingFont,
    body: bodyFont,
    mono: monoFont, // Keep mono
  },
  themes: {
    light: lightTheme,
    dark: darkTheme,
  },
  tokens,
  media: { // Keep standard media queries
    xs: { maxWidth: 660 }, sm: { maxWidth: 800 }, md: { maxWidth: 1020 }, lg: { maxWidth: 1280 }, xl: { maxWidth: 1420 }, xxl: { maxWidth: 1600 },
    gtXs: { minWidth: 661 }, gtSm: { minWidth: 801 }, gtMd: { minWidth: 1021 }, gtLg: { minWidth: 1281 },
    short: { maxHeight: 820 }, tall: { minHeight: 820 },
    hoverNone: { hover: 'none' }, pointerCoarse: { pointer: 'coarse' },
  },
  settings: {
      allowedStyleValues: 'somewhat-strict',
      autocompleteSpecificTokens: 'except-special',
  },
});

type AppConfig = typeof config;

// Augment Tamagui interface - this is crucial!
declare module '@tamagui/core' {
  // If AppConfig is defined and exported:
  interface TamaguiCustomConfig extends AppConfig {}
}

export default config;```
\n\n## tailwind.config.js (to be rewritten)
**Current implementation:** tailwind.config.js
\n```
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./app/**/*.{js,jsx,ts,tsx}",
    "./components/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {
      // iOS standard colors
      colors: {
        // iOS system colors
        'ios-blue': '#007AFF',
        'ios-dark-blue': '#0A84FF', // dark mode variant
        'ios-red': '#FF3B30',
        'ios-dark-red': '#FF453A', // dark mode variant
        'ios-green': '#34C759',
        'ios-dark-green': '#30D158', // dark mode variant
        'ios-orange': '#FF9500',
        'ios-dark-orange': '#FF9F0A', // dark mode variant
        'ios-purple': '#AF52DE',
        'ios-dark-purple': '#BF5AF2', // dark mode variant
        'ios-yellow': '#FFCC00',
        'ios-dark-yellow': '#FFD60A', // dark mode variant
        'ios-pink': '#FF2D55',
        'ios-dark-pink': '#FF375F', // dark mode variant
        'ios-indigo': '#5856D6',
        'ios-dark-indigo': '#5E5CE6', // dark mode variant
        
        // iOS gray palette
        'ios-gray': {
          1: '#8E8E93',
          2: '#AEAEB2',
          3: '#C7C7CC',
          4: '#D1D1D6',
          5: '#E5E5EA',
          6: '#F2F2F7',
        },
        'ios-dark-gray': {
          1: '#8E8E93',
          2: '#636366',
          3: '#48484A',
          4: '#3A3A3C',
          5: '#2C2C2E',
          6: '#1C1C1E',
        },
        
        // System background colors
        'ios-system': {
          DEFAULT: '#FFFFFF',
          secondary: '#F2F2F7',
          tertiary: '#FFFFFF',
        },
        'ios-dark-system': {
          DEFAULT: '#000000',
          secondary: '#1C1C1E',
          tertiary: '#2C2C2E',
        },
      },
      
      // iOS standard spacing
      spacing: {
        // Added standard iOS spacing if needed beyond Tailwind defaults
      },
      
      // iOS standard border radius
      borderRadius: {
        'ios-small': '4px',
        'ios-regular': '8px',
        'ios-large': '12px',
        'ios-xl': '16px',
      },
      
      // iOS system font weights
      fontWeight: {
        'ios-regular': '400',
        'ios-medium': '500', 
        'ios-semibold': '600',
        'ios-bold': '700',
      },
      
      // iOS shadows
      boxShadow: {
        'ios-small': '0 1px 2px rgba(0, 0, 0, 0.05)',
        'ios-medium': '0 2px 4px rgba(0, 0, 0, 0.1)',
        'ios-large': '0 4px 6px rgba(0, 0, 0, 0.1)',
      },
    },
  },
  plugins: [],
}; ```
\n\n## Motion constants
**Current implementation:** constants/motion.ts
\n```
import { Easing } from 'react-native-reanimated';

/**
 * Standard animation durations (in milliseconds)
 */
export const durations = {
  /** Ultra-fast for micro-interactions */
  micro: 80,
  /** Tap/press feedback */
  tap: 120,
  /** Default animation speed for most UI transitions */
  standard: 200,
  /** For more noticeable animations */
  medium: 250,
  /** Modal entrances/exits, complex transitions */
  modal: 300,
  /** Full screen transitions */
  screen: 350,
  /** Extended animations for emphasis */
  long: 450,
};

/**
 * Standard easing curves
 */
export const easings = {
  /** Quick acceleration, gradual deceleration - for elements entering the screen */
  enter: Easing.bezier(0.25, 0.1, 0.25, 1.0),
  /** Gradual acceleration, quick deceleration - for elements exiting the screen */
  exit: Easing.bezier(0.25, 0.0, 0.2, 1.0),
  /** For transitions between UI states */
  standard: Easing.bezier(0.4, 0.0, 0.2, 1.0),
  /** Quick in, quick out - for emphasis */
  energetic: Easing.bezier(0.55, 0.0, 0.1, 1.0),
  /** Linear - consistent motion with no acceleration/deceleration */
  linear: Easing.linear,
  /** Slow start, fast finish */
  accelerate: Easing.in(Easing.quad),
  /** Fast start, slow finish */
  decelerate: Easing.out(Easing.quad),
  /** Fast start and end, slower in the middle */
  emphasize: Easing.inOut(Easing.quad),
};

/**
 * Animation presets for common UI patterns
 */
export const presets = {
  fadeIn: {
    duration: durations.standard,
    easing: easings.enter,
  },
  fadeOut: {
    duration: durations.standard,
    easing: easings.exit,
  },
  slideIn: {
    duration: durations.modal,
    easing: easings.enter,
  },
  slideOut: {
    duration: durations.modal,
    easing: easings.exit,
  },
  scaleIn: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  scaleOut: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  tapFeedback: {
    duration: durations.tap,
    easing: easings.emphasize,
  },
  skeleton: {
    duration: durations.long * 2,
    easing: easings.linear,
  },
};

/**
 * Animation values for specific components
 */
export const componentAnimations = {
  toast: {
    show: {
      duration: durations.modal,
      easing: easings.enter,
    },
    hide: {
      duration: durations.standard,
      easing: easings.exit,
    },
  },
  modal: {
    overlay: {
      show: {
        duration: durations.modal,
        easing: easings.standard,
      },
      hide: {
        duration: durations.modal,
        easing: easings.standard,
      },
    },
    content: {
      show: {
        duration: durations.modal,
        easing: easings.enter,
      },
      hide: {
        duration: durations.standard,
        easing: easings.exit,
      },
    },
  },
  button: {
    press: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
    release: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
  },
  navigation: {
    screen: {
      duration: durations.screen,
      easing: easings.standard,
    },
    tab: {
      duration: durations.standard,
      easing: easings.standard,
    },
  },
}; ```
\n\n## Planned new files
* tokens.ts - Export Tailwind-ready object instead of Tamagui createTokens
* theme.glue.ts - Wire Zelda palette & fonts into Gluestack provider
* Primitives.tsx - Create wrappers for Gluestack equivalents
* Animations.ts - Create reusable Moti presets
\n\n# 2️⃣ Global Providers
\n\n## Current app/_layout.tsx (to be rewritten)
**Current implementation:** app/_layout.tsx
\n```
// app/_layout.tsx
import '../tamagui.config'; // Import config first!

import React, { useCallback, useEffect, useState, ReactNode, createContext, useContext } from 'react';
import { Slot, SplashScreen, useRouter, useSegments } from 'expo-router';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { StatusBar } from 'expo-status-bar';
import { View, ActivityIndicator, Platform } from 'react-native';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { useFonts } from 'expo-font';
import { useColorScheme } from 'react-native';
import { TamaguiProvider, Theme } from 'tamagui'; // Consolidate Tamagui imports
// tamagui config is already imported at the top of the file
import type { ThemeName } from '@tamagui/core'; // Ensure ThemeName is imported from @tamagui/core
import * as SecureStore from 'expo-secure-store'; // Import SecureStore

import { supabase } from '@/utils/supabase';

import type { Session } from '@supabase/supabase-js';

// Prevent the splash screen from auto-hiding
SplashScreen.preventAutoHideAsync();

/* ------------------------------------------------------------------ */
/*  1. Simple Auth-aware context                                       */
/* ------------------------------------------------------------------ */
interface AuthCtx {
  session: Session | null;
  isLoading: boolean;
}
export const AuthContext = React.createContext<AuthCtx>({
  session: null,
  isLoading: true,
});
export const useAuth = () => React.useContext(AuthContext);

/* ------------------------------------------------------------------ */
/*  2. The actual Provider                                             */
/* ------------------------------------------------------------------ */
function AuthProvider({ children }: { children: ReactNode }) {
  const [session, setSession] = useState<Session | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Initial session check
  useEffect(() => {
    supabase.auth.getSession().then(({ data }) => {
      setSession(data.session ?? null);
      setIsLoading(false);
      console.log('Initial session check:', data.session ? 'Session found' : 'No session');
    }).catch(error => {
        console.error("Error getting initial session:", error);
        setIsLoading(false);
    });

    // Subscribe to auth changes (login / logout / token refresh)
    const { data: authListener } = supabase.auth.onAuthStateChange(
      (_event, newSession) => {
        console.log('Auth state changed:', _event, newSession ? 'New session' : 'No session');
        setSession(newSession ?? null);
        // If the event is SIGNED_IN or TOKEN_REFRESHED, loading might briefly be true again
        // depending on how you handle redirects, but usually setting session is enough.
        // If SIGNED_OUT, ensure loading is false.
        if (_event === 'SIGNED_OUT') {
          setIsLoading(false);
        }
      },
    );

    return () => {
      authListener?.subscription.unsubscribe();
    };
  }, []);

  return (
    <AuthContext.Provider value={{ session, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
}

/* ------------------------------------------------------------------ */
/*  3. Enforce splash-screen logic & route guarding                    */
/* ------------------------------------------------------------------ */
function Root() {
  const { session, isLoading } = useAuth();
  const router = useRouter();
  const segments = useSegments(); // e.g., ["(tabs)", "home"] or ["(auth)", "login"]

  /* Load Fonts ----------------------------------------------------- */
  const [fontsLoaded, fontError] = useFonts({
    // Ensure font names match those used in tamagui.config.ts
    Inter: require('@tamagui/font-inter/otf/Inter-Medium.otf'),
    InterBold: require('@tamagui/font-inter/otf/Inter-Bold.otf'),
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
  });

  /* Handle Font Loading & Errors ----------------------------------- */
  useEffect(() => {
    if (fontError) {
      console.error("Font loading error:", fontError);
      // Decide how to handle font errors - maybe show an error message?
      // For now, we still need to hide splash eventually.
      SplashScreen.hideAsync();
    }
  }, [fontError]);

  /* Redirect Logic ------------------------------------------------- */
  useEffect(() => {
    // Wait until auth state is confirmed AND fonts are potentially loaded
    if (isLoading || !fontsLoaded && !fontError) return;

    const inAuthGroup = segments[0] === '(auth)';

    console.log(`Auth State: isLoading=${isLoading}, session=${!!session}, inAuthGroup=${inAuthGroup}, segments=${segments.join('/')}`);

    if (!session && !inAuthGroup) {
      console.log('Redirecting to login...');
      router.replace('/(auth)/login');
    } else if (session && inAuthGroup) {
      console.log('Redirecting to home...');
      router.replace('/(tabs)/home');
    } else {
        console.log('No redirect needed.');
    }
  }, [isLoading, session, segments, router, fontsLoaded, fontError]);

  /* Hide splash only when fonts loaded/error AND auth check done ---- */
  useEffect(() => {
    if ((fontsLoaded || fontError) && !isLoading) {
        console.log('Hiding SplashScreen...');
      SplashScreen.hideAsync();
    }
  }, [fontsLoaded, fontError, isLoading]);

  /* Show loading indicator until ready ----------------------------- */
  if (!fontsLoaded && !fontError || isLoading) {
    // Optionally, return the Splash Screen component itself or a custom loading view
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#1C1C1E' /* Approx dark bg */ }}>
        <ActivityIndicator size="large" color="#FFFFFF" />
      </View>
    );
  }

  // Once loaded and auth checked, render the content based on route
  return (
    <>
      <StatusBar style={Platform.OS === 'ios' ? 'light' : 'auto'} />
      <Slot />
    </>
  );
}

/* ------------------------------------------------------------------ */
/*  4. Wrap everything with SafeArea, Providers, etc.                  */
/* ------------------------------------------------------------------ */
import { ToastProvider, Toast, useToastState, ToastViewport } from '@tamagui/toast';
import { CheckCircle, AlertCircle, AlertTriangle, Info } from '@tamagui/lucide-icons';
import { YStack, XStack } from 'tamagui';
import { ThemeProvider, DarkTheme, DefaultTheme } from '@react-navigation/native';

const ACCENT_COLOR_KEY = 'userAccentColor';
const DEFAULT_ACCENT = 'blue'; // Set your default accent color theme name here

// Context to provide accent update function down the tree
const AccentContext = createContext({
  setAccent: (color: string) => {},
});
export const useAccent = () => useContext(AccentContext);

function RootLayoutNav() {
  const colorScheme = useColorScheme();
  const themeMode = colorScheme === 'dark' ? 'dark' : 'light';

  return (
    <ToastProvider swipeDirection="horizontal" duration={6000}>
      <Slot />
      <CurrentToast />
      <ToastViewport name="DefaultViewport" top={40} left={0} right={0} /> 
    </ToastProvider>
  );
}

function CurrentToast() {
  const currentToast = useToastState();

  if (!currentToast || currentToast.isHandledNatively) {
    return null;
  }

  const toastType = currentToast.customData?.type || 'info'; // Default to 'info'
  let themeName = 'toast_info'; // Default theme
  let IconComponent = Info;

  switch (toastType) {
    case 'success':
      themeName = 'toast_success';
      IconComponent = CheckCircle;
      break;
    case 'error':
      themeName = 'toast_error';
      IconComponent = AlertCircle;
      break;
    case 'warning':
      themeName = 'toast_warning';
      IconComponent = AlertTriangle;
      break;
  }

  return (
    <Theme name={themeName as ThemeName}> {/* Cast themeName to ThemeName */}
      <Toast
        key={currentToast.id}
        duration={currentToast.duration}
        enterStyle={{ opacity: 0, scale: 0.5, y: -25 }}
        exitStyle={{ opacity: 0, scale: 0.95, y: -10 }} // Adjusted exit style slightly
        y={0}
        opacity={1}
        scale={1}
        animation="bouncy" // Apply bouncy animation
        viewportName={currentToast.viewportName ?? 'DefaultViewport'}
        backgroundColor="$background" // Use background from the wrapped theme
        padding="$3"
        borderRadius="$4"
        marginHorizontal="$4"
        elevate
        shadowColor="$shadowColor"
      >
        <YStack space="$1">
          <XStack space="$2" alignItems="center">
            <IconComponent size={18} color="$color" /> {/* Use color from the wrapped theme */}
            <Toast.Title color="$color">{currentToast.title}</Toast.Title> {/* Use color from the wrapped theme */}
          </XStack>
          {!!currentToast.message && (
            <Toast.Description color="$color"> {/* Use color from the wrapped theme */}
              {currentToast.message}
            </Toast.Description>
          )}
        </YStack>
      </Toast>
    </Theme>
  );
}

function Providers({ children }: { children: React.ReactNode }) {
  const colorScheme = useColorScheme();
  const [accentColor, setAccentColor] = useState(DEFAULT_ACCENT);

  // Load accent color on mount
  useEffect(() => {
    const loadAccent = async () => {
      try {
        const savedAccent = await SecureStore.getItemAsync(ACCENT_COLOR_KEY);
        if (savedAccent) {
          setAccentColor(savedAccent);
        }
      } catch (error) {
        console.error('Failed to load accent color:', error);
      }
    };
    loadAccent();
  }, []);

  // Function to update and save accent color
  const handleSetAccent = useCallback(async (newColor: string) => {
    try {
      await SecureStore.setItemAsync(ACCENT_COLOR_KEY, newColor);
      setAccentColor(newColor);
    } catch (error) {
      console.error('Failed to save accent color:', error);
    }
  }, []);

  return (
    <AccentContext.Provider value={{ setAccent: handleSetAccent }}>
      <Theme name={accentColor as ThemeName}> {/* Cast accentColor to ThemeName */}
        {children}
      </Theme>
    </AccentContext.Provider>
  );
}

export default function RootLayout() {
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        {/* Core Providers (Tamagui, QueryClient, tRPC) */}
        <Providers>
          {/* Auth Provider manages session state */}
          <AuthProvider>
            {/* Root handles splash, font loading, and redirects */}
            <RootLayoutNav />
          </AuthProvider>
        </Providers>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}
```
\n\n## Current AppProvider.tsx (to be refactored)
**Current implementation:** providers/AppProvider.tsx
\n```
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { httpBatchLink } from '@trpc/client';
import { useEffect, useState, type ReactNode } from 'react';
import { Platform } from 'react-native';
import { TamaguiProvider } from 'tamagui';

import { NativeWindProvider } from '@/components/ui/nativewind-setup';
import config from '../tamagui.config';
import { trpc } from '@/utils/trpc';
import { useUiStore } from '@/stores/uiStore'; // Import store to get theme

/**
 * Complete app provider that integrates:
 * - tRPC
 * - React Query
 * - Tamagui
 * - NativeWind
 * - Additional providers can be added here
 */
export function AppProvider({ children }: { children: ReactNode }) {
  // Create Query Client
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 1000, // 5 seconds
        retry: Platform.OS === 'web' ? 3 : 1, // Less retries on mobile to save battery
      },
    },
  }));
  
  // Create tRPC client
  const [trpcClient] = useState(() => 
    trpc.createClient({
      links: [
        httpBatchLink({
          url: 'http://localhost:3000/api/trpc',
          fetch: (input, init) => {
            return fetch(input, {
              ...init,
              credentials: 'include',
            });
          },
        }),
      ],
    })
  );
  
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';
  
  // You could add NATS initialization here
  useEffect(() => {
    // Example: Initialize NATS for real-time updates
    // Note: This is commented out since we don't have a real NATS server to connect to
    /*
    try {
      const url = 'ws://localhost:4222';
      initNatsClient(url, queryClient)
        .then(conn => {
          console.log('NATS client initialized successfully');
          // Set up subscriptions to relevant topics
          subscribeWithCache('users.updates', ['users']);
          subscribeWithCache('messages.updates', ['messages']);
        })
        .catch(err => {
          console.error('Failed to initialize NATS client:', err);
        });
    } catch (error) {
      console.error('Error in NATS setup:', error);
    }
    
    // Cleanup on unmount
    return () => {
      closeNatsConnection().catch(err => {
        console.error('Error closing NATS connection:', err);
      });
    };
    */
  }, [queryClient]);
  
  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <NativeWindProvider theme={currentTheme}>
          <TamaguiProvider config={config}>
            {children}
          </TamaguiProvider>
        </NativeWindProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
} ```
\n\n## Current ConfettiProvider.tsx (to be refactored)
**Current implementation:** providers/ConfettiProvider.tsx
\n```
import { ReactNode, createContext, useCallback, useContext, useRef, useState } from 'react';
import { StyleSheet, Dimensions } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSequence,
  withDelay,
  runOnJS,
} from 'react-native-reanimated';
import { View } from 'tamagui';
import * as Haptics from 'expo-haptics';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');
const CONFETTI_COUNT = 50; // Number of confetti pieces
const COLORS = ['#ff4747', '#ffae47', '#fff347', '#47ff70', '#47d0ff', '#9147ff', '#ff47f3'];

interface ConfettiContextValue {
  showConfetti: () => void;
}

const ConfettiContext = createContext<ConfettiContextValue>({
  showConfetti: () => {},
});

export const useConfetti = () => useContext(ConfettiContext);

// Create a single confetti piece component
function ConfettiPiece({ 
  size, 
  color, 
  initialX, 
  initialY, 
  duration, 
  delay 
}: { 
  size: number, 
  color: string, 
  initialX: number, 
  initialY: number, 
  duration: number, 
  delay: number 
}) {
  const translateX = useSharedValue(initialX);
  const translateY = useSharedValue(initialY);
  const rotate = useSharedValue(0);
  const opacity = useSharedValue(1);

  // Create animation when component mounts
  useState(() => {
    // Random horizontal movement
    const targetX = initialX + (Math.random() * 2 - 1) * SCREEN_WIDTH * 0.5;
    
    // Fall down animation
    translateY.value = withDelay(
      delay,
      withTiming(SCREEN_HEIGHT + 100, { duration })
    );
    
    // Horizontal movement with some randomness
    translateX.value = withDelay(
      delay,
      withSequence(
        withTiming(targetX, { duration: duration * 0.4 }),
        withTiming(targetX + (Math.random() * 2 - 1) * 100, { duration: duration * 0.6 })
      )
    );
    
    // Rotation animation
    rotate.value = withDelay(
      delay,
      withTiming(Math.random() * 1080, { duration })
    );
    
    // Fade out toward the end
    opacity.value = withDelay(
      delay + duration * 0.7,
      withTiming(0, { duration: duration * 0.3 })
    );
  });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { rotate: `${rotate.value}deg` },
    ],
    opacity: opacity.value,
  }));

  return (
    <Animated.View
      style={[
        {
          position: 'absolute',
          width: size,
          height: size * (Math.random() * 0.8 + 0.2), // Varying heights
          backgroundColor: color,
          borderRadius: Math.random() > 0.5 ? size / 2 : 0, // Some round, some square
        },
        animatedStyle,
      ]}
    />
  );
}

export function ConfettiProvider({ children }: { children: ReactNode }) {
  const [isVisible, setIsVisible] = useState(false);
  const animationTimeout = useRef<NodeJS.Timeout | null>(null);
  
  // Generate confetti pieces data
  const generateConfettiData = useCallback(() => {
    const pieces = [];
    for (let i = 0; i < CONFETTI_COUNT; i++) {
      pieces.push({
        id: i,
        size: Math.random() * 8 + 4, // Size between 4-12
        color: COLORS[Math.floor(Math.random() * COLORS.length)],
        initialX: Math.random() * SCREEN_WIDTH,
        initialY: -20, // Start just above the screen
        duration: Math.random() * 1000 + 2000, // Duration between 2-3 seconds
        delay: Math.random() * 500, // Random delay up to 500ms
      });
    }
    return pieces;
  }, []);

  const [confettiPieces, setConfettiPieces] = useState(generateConfettiData());

  const showConfetti = useCallback(() => {
    // Trigger haptic feedback
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    
    // Clear any existing timeout
    if (animationTimeout.current) {
      clearTimeout(animationTimeout.current);
    }
    
    // Generate new confetti data and show
    setConfettiPieces(generateConfettiData());
    setIsVisible(true);
    
    // Hide confetti after animation completes
    animationTimeout.current = setTimeout(() => {
      setIsVisible(false);
    }, 3500); // Slightly longer than the max animation time to ensure all pieces are gone
  }, [generateConfettiData]);

  return (
    <ConfettiContext.Provider value={{ showConfetti }}>
      {children}
      {isVisible && (
        <View style={styles.confettiContainer} pointerEvents="none">
          {confettiPieces.map((piece) => (
            <ConfettiPiece
              key={piece.id}
              size={piece.size}
              color={piece.color}
              initialX={piece.initialX}
              initialY={piece.initialY}
              duration={piece.duration}
              delay={piece.delay}
            />
          ))}
        </View>
      )}
    </ConfettiContext.Provider>
  );
}

const styles = StyleSheet.create({
  confettiContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 9999,
    pointerEvents: 'none',
  },
}); ```
\n\n## Current Providers.tsx (to be refactored)
**Current implementation:** providers/Providers.tsx
\n```
// providers/Providers.tsx
import '../tamagui.config'; // Ensure Tamagui config is loaded first!
import { getConfig } from '@tamagui/core';
console.log('Effective Tamagui config keys:', Object.keys(getConfig() ?? {}));
import { QueryClientProvider } from '@tanstack/react-query';
import { persistQueryClient } from '@tanstack/react-query-persist-client';
import { TamaguiProvider, type TamaguiProviderProps } from 'tamagui';
import { ToastProvider, ToastViewport } from '@tamagui/toast'; // Import from Tamagui Toast
import React, { useEffect, useState, type ReactNode } from 'react';
import { Platform } from 'react-native'; // Import Platform

import config from '../tamagui.config'; // Import your config
import { trpc } from '../utils/trpc'; // Your tRPC hook setup
import { queryClient, persister, initializeNetworkMonitoring, resumeMutationsAndInvalidate } from '@/utils/query-client';
import { useUiStore } from '@/stores/uiStore';
import { supabase } from '@/utils/supabase'; // Needed for auth link
import { createTRPCClient, httpBatchLink, TRPCLink, TRPCClientError } from '@trpc/client'; // Import TRPC Client utils
import { observable } from '@trpc/server/observable';
import type { AppRouter } from '../server/src/router'; // Adjust path if needed
import type { Session } from '@supabase/supabase-js';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

// Setup query client persistence
persistQueryClient({
  queryClient,
  persister,
  maxAge: 1000 * 60 * 60 * 24, // 24 hours
  dehydrateOptions: {
    shouldDehydrateMutation: () => false, // Usually don't dehydrate mutations
  },
});

// New component for the viewport using safe area
const CurrentToastViewport = () => {
  const { top, bottom, left, right } = useSafeAreaInsets();
  return (
    <>
      {/* Adjust positioning based on your desired toast location */}
      <ToastViewport
        name="global_top"
        flexDirection="column" // Stack new toasts below older ones
        top={top + 10} // Add padding below status bar
        left={left + 10} // Add padding from sides
        right={right + 10}
      />
      <ToastViewport
        name="global_bottom"
        flexDirection="column-reverse"
        bottom={bottom + 10}
        left={left + 10}
        right={right + 10}
      />
    </>
  );
};

// Extract tRPC links setup
function getTRPCLinks(getSession: () => Promise<Session | null>): TRPCLink<AppRouter>[] {
  const apiBaseUrl = process.env.EXPO_PUBLIC_API_URL || 'http://localhost:3000/api/trpc'; // Default to localhost
  console.log('Using tRPC API URL:', apiBaseUrl);

  return [
    // Link to handle auth token injection and refresh
    (runtime) => {
      return ({ op, next }) => {
        return observable((observer) => {
          getSession().then(session => {
            const headers = (op.context?.headers || {}) as Record<string, string>;
            if (session?.access_token) {
              headers['Authorization'] = `Bearer ${session.access_token}`;
            }

            // Proceed with the request, ensuring context is passed correctly
            next({ ...op, context: { ...op.context, headers } })
              .subscribe({
                next: (value) => observer.next(value),
                error: async (err) => {
                  if (err instanceof TRPCClientError && err.data?.httpStatus === 401) {
                    console.log('tRPC: Token expired or invalid, attempting refresh...');
                    try {
                      // Supabase handles refresh internally if needed when getSession is called
                      const { data, error: refreshError } = await supabase.auth.refreshSession();
                      if (refreshError) throw refreshError;

                      if (data.session) {
                        console.log('tRPC: Session refreshed successfully, retrying request.');
                        const refreshedHeaders = { ...headers, Authorization: `Bearer ${data.session.access_token}` };
                        // Retry with new headers in context
                        next({ ...op, context: { ...op.context, headers: refreshedHeaders } }).subscribe(observer);
                      } else {
                        console.error('tRPC: Session refresh failed, no session returned.');
                        observer.error(err); // Propagate original error if no new session
                        // Optionally trigger logout here
                        supabase.auth.signOut();
                      }
                    } catch (refreshCatchError) {
                      console.error('tRPC: Session refresh catch error:', refreshCatchError);
                      observer.error(err); // Propagate original error
                      supabase.auth.signOut();
                    }
                  } else {
                    observer.error(err); // Propagate non-auth errors
                  }
                },
                complete: () => observer.complete(),
              });
          }).catch(err => {
             console.error('tRPC: Error getting session for headers:', err);
             observer.error(new TRPCClientError('Failed to get session')); // Use TRPCClientError
          });

          // Return cleanup function if needed
          return () => {};
        });
      };
    },
    // The terminating HTTP link
    httpBatchLink({
      url: apiBaseUrl,
       headers() {
         // Headers are injected by the middleware link above
         return {};
       },
      // Add superjson transformer here if you use one
      // transformer: superjson,
    }),
  ];
}

export function Providers({ children }: { children: ReactNode }) {
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';

  // Initialize network monitoring and query client persistence
  useEffect(() => {
    const unsubscribeNetworkMonitoring = initializeNetworkMonitoring();
    resumeMutationsAndInvalidate(); // Try resuming mutations on app load
    return () => {
      unsubscribeNetworkMonitoring();
    };
  }, []);

  // Memoize tRPC client creation
  const [trpcClient] = useState(() =>
    trpc.createClient({
      links: getTRPCLinks(async () => { // Pass session getter to links setup
        const { data } = await supabase.auth.getSession();
        return data.session;
      }),
    })
  );

  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <TamaguiProvider
            config={config}
            defaultTheme={currentTheme}
            // disableInjectCSS // May not be needed depending on setup
        >
          {/* Use Tamagui's ToastProvider */}
          <ToastProvider
            // burntOptions={{ from: 'top' }} // Disabled until native module 'Burnt' is installed
            swipeDirection="horizontal"
            duration={4000}
            native={[]}
          >
            {children}
            {/* Add the safe-area aware ToastViewport */}
            <CurrentToastViewport />
          </ToastProvider>
        </TamaguiProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
}```
\n\n## Planned new providers
* providers/TRPCProvider.tsx - Instantiate trpc.createClient() + React Query
* providers/SupabaseProvider.tsx - Context for supabase-js instance + session
\n\n# 3️⃣ Navigation Shells (Expo Router)
\n\n## Current tab layout (to be rewritten)
**Current implementation:** app/(tabs)/_layout.tsx
\n```
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/_layout.tsx
import React from 'react';
import { Tabs } from 'expo-router';
import { Ionicons } from '@expo/vector-icons'; // Example icon library
import { useThemeColor } from '@/hooks/useThemeColor'; // Assuming path alias is set

export default function TabLayout() {
  const tabBarActiveTintColor = useThemeColor({}, 'tabIconSelected');
  const tabBarInactiveTintColor = useThemeColor({}, 'tabIconDefault');
  const backgroundColor = useThemeColor({}, 'background'); // Use standard background color

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: tabBarActiveTintColor,
        tabBarInactiveTintColor: tabBarInactiveTintColor,
        tabBarStyle: {
          backgroundColor: backgroundColor,
          // Add other styles like borderTopColor if needed
        },
        headerShown: false, // We might handle headers inside each screen or using Stack
      }}
    >
      <Tabs.Screen
        name="home/index"
        options={{
          title: 'Home',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="home-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="planner/index"
        options={{
          title: 'Planner',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="calendar-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="compass/index"
        options={{
          title: 'Compass',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="compass-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="rewards/index"
        options={{
          title: 'Rewards',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="gift-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="settings/index"
        options={{
          title: 'Settings',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="settings-outline" size={size} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}
```
\n\n## Current auth layout
**Current implementation:** app/(auth)/_layout.tsx
\n```
// Auth Stack Layout
import React from 'react';
import { Stack } from 'expo-router';

export default function AuthLayout() {
  return (
    <Stack>
      <Stack.Screen 
        name="login" 
        options={{ 
          title: 'Sign In',
          headerShown: false
        }} 
      />
      <Stack.Screen 
        name="register" 
        options={{ 
          title: 'Create Account',
          headerShown: false
        }} 
      />
      <Stack.Screen 
        name="forgot-password" 
        options={{ 
          title: 'Reset Password',
          headerShown: false
        }} 
      />
    </Stack>
  );
}
```
\n\n# 4️⃣ Reusable Components
\n\n## Current UI primitives
\n\n## AetherListItem
**Current implementation:** components/ui/primitives/AetherListItem.tsx
\n```
import React from 'react';
import { XStack, YStack, Text, styled, GetProps, Stack } from 'tamagui';
import { Ionicons } from '@expo/vector-icons';

// Base ListItem container
const ListItemContainer = styled(XStack, {
  name: 'ListItemContainer',
  backgroundColor: '$cardBackground',
  paddingVertical: '$3',
  paddingHorizontal: '$4',
  borderRadius: '$3',
  alignItems: 'center',
  justifyContent: 'space-between',
  borderBottomWidth: 1,
  borderBottomColor: '$borderColor',
  minHeight: 60,
  
  variants: {
    isLast: {
      true: {
        borderBottomWidth: 0,
      },
    },
    interactive: {
      true: {
        pressStyle: {
          backgroundColor: '$backgroundPress',
          opacity: 0.9,
        },
        hoverStyle: {
          backgroundColor: '$backgroundHover',
        },
      },
    },
    variant: {
      default: {},
      header: {
        backgroundColor: '$backgroundStrong',
        borderBottomColor: '$borderColor',
        paddingVertical: '$2',
      },
    },
  } as const,
  
  defaultVariants: {
    isLast: false,
    interactive: true,
    variant: 'default',
  },
});

type ListItemContainerProps = GetProps<typeof ListItemContainer>;

export interface AetherListItemProps extends ListItemContainerProps {
  title: string;
  subtitle?: string;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  showChevron?: boolean;
  badge?: string | number;
}

/**
 * AetherListItem - A consistent list item component for use in lists, menus, and settings
 *
 * @param title - The primary text
 * @param subtitle - Optional secondary text shown below the title
 * @param leftIcon - Optional icon component to show on the left side
 * @param rightIcon - Optional icon component to show on the right side
 * @param showChevron - Whether to show a right chevron (useful for navigation items)
 * @param badge - Optional badge text/number to display
 * @param isLast - Whether this is the last item in a list (removes bottom border)
 * @param interactive - Whether the item should visually respond to touch
 */
export function AetherListItem({
  title,
  subtitle,
  leftIcon,
  rightIcon,
  showChevron = false,
  badge,
  isLast,
  interactive,
  ...props
}: AetherListItemProps) {
  return (
    <ListItemContainer isLast={isLast} interactive={interactive} {...props}>
      {/* Left section with icon and text */}
      <XStack space="$3" flex={1} alignItems="center">
        {leftIcon && (
          <Stack marginRight="$2">{leftIcon}</Stack>
        )}
        
        <YStack>
          <Text fontWeight="500" fontSize="$4">{title}</Text>
          {subtitle && (
            <Text fontSize="$2" color="$gray10">{subtitle}</Text>
          )}
        </YStack>
      </XStack>
      
      {/* Right section with badge, custom icon or chevron */}
      <XStack space="$2" alignItems="center">
        {badge && (
          <XStack 
            backgroundColor="$primary"
            paddingHorizontal="$2"
            paddingVertical="$1"
            borderRadius="$2"
          >
            <Text color="white" fontSize="$1" fontWeight="bold">{badge}</Text>
          </XStack>
        )}
        
        {rightIcon && rightIcon}
        
        {showChevron && (
          <Ionicons name="chevron-forward" size={16} color="$gray10" />
        )}
      </XStack>
    </ListItemContainer>
  );
}
```
\n\n## SectionHeader
**Current implementation:** components/ui/primitives/SectionHeader.tsx
\n```
import React from 'react';
import { XStack, Text, styled, GetProps, Button } from 'tamagui';

const SectionContainer = styled(XStack, {
  name: 'SectionContainer',
  paddingVertical: '$2',
  paddingHorizontal: '$4',
  marginTop: '$4',
  marginBottom: '$2',
  justifyContent: 'space-between',
  alignItems: 'center',
});

type SectionContainerProps = GetProps<typeof SectionContainer>;

export interface SectionHeaderProps extends SectionContainerProps {
  title: string;
  actionLabel?: string;
  onAction?: () => void;
}

/**
 * SectionHeader - A consistent section header with optional action button
 * 
 * Used to separate content sections in screens like Home, Settings, etc.
 *
 * @param title - The section title
 * @param actionLabel - Optional label for the action button
 * @param onAction - Optional callback when action button is pressed
 */
export function SectionHeader({ 
  title, 
  actionLabel, 
  onAction, 
  ...props 
}: SectionHeaderProps) {
  return (
    <SectionContainer {...props}>
      <Text 
        fontSize="$5" 
        fontWeight="600" 
        color="$color"
      >
        {title}
      </Text>
      
      {actionLabel && onAction && (
        <Button
          onPress={onAction}
          fontSize="$2"
          backgroundColor="transparent"
          color="$primary"
          paddingHorizontal="$2"
          height="$5"
        >
          {actionLabel}
        </Button>
      )}
    </SectionContainer>
  );
}
```
\n\n## AetherCard
**Current implementation:** components/ui/primitives/AetherCard.tsx
\n```
import React from 'react';
import { Card, CardProps, YStack, styled } from 'tamagui';

type AetherCardVariant = 'default' | 'elevated' | 'outlined';

interface AetherCardProps extends CardProps {
  variant?: AetherCardVariant;
  // Additional props specific to AetherCard
  isInteractive?: boolean;
}

// Create a styled Card component that uses our custom Tamagui theme variables
const StyledCard = styled(Card, {
  name: 'AetherCard',
  backgroundColor: '$cardBackground',
  borderRadius: '$4',
  padding: '$4',
  elevate: true,

  variants: {
    variant: {
      default: {
        // Using our theme tokens
        shadowColor: '$shadowColor',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 3,
        elevation: 2,
      },
      elevated: {
        shadowColor: '$shadowColor',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 6,
        elevation: 4,
      },
      outlined: {
        backgroundColor: 'transparent',
        borderWidth: 1,
        borderColor: '$borderColor',
        shadowOpacity: 0,
        elevation: 0,
      },
    },
    isInteractive: {
      true: {
        pressStyle: {
          backgroundColor: '$cardBackgroundPress',
          opacity: 0.9,
        },
        hoverStyle: {
          backgroundColor: '$cardBackgroundHover',
        },
      },
    },
  } as const,

  defaultVariants: {
    variant: 'default',
    isInteractive: false,
  },
});

/**
 * AetherCard - A stylized card component following Aether design system
 *
 * @param variant - The visual style variant: 'default', 'elevated', or 'outlined'
 * @param isInteractive - Whether the card responds to press/hover states
 */
export function AetherCard({ children, variant, isInteractive, ...props }: AetherCardProps) {
  return (
    <StyledCard variant={variant} isInteractive={isInteractive} {...props}>
      {children}
    </StyledCard>
  );
}
```
\n\n## Key components to migrate
\n\n## Container
**Current implementation:** components/ui/Container.tsx
\n```
import React, { ReactNode } from 'react';
import { SafeAreaView, SafeAreaViewProps } from 'react-native';
import { styled, useTheme, YStack } from 'tamagui';

interface ContainerProps extends SafeAreaViewProps {
  children: ReactNode;
}

const StyledSafeArea = styled(SafeAreaView, {
  name: 'StyledSafeArea',
  flex: 1,
});

export const Container: React.FC<ContainerProps> = ({ style, children, ...props }) => {
  const theme = useTheme();
  return (
    <StyledSafeArea
      style={[
        { backgroundColor: theme.background.val },
        style as any
      ]}
      {...props}
    >
      <YStack flex={1}>{children}</YStack>
    </StyledSafeArea>
  );
};

export default Container;
```
\n\n## EmptyOrSkeleton
**Current implementation:** components/ui/EmptyOrSkeleton.tsx
\n```
import React from 'react';
import { YStack, Text, Button } from 'tamagui';
import { SkeletonCard, SkeletonRow, SkeletonCircle } from './Skeleton';
import { SectionError } from './ErrorBanner';

export interface EmptyOrSkeletonProps {
  // Loading state
  isLoading?: boolean;
  count?: number;
  type?: 'card' | 'row' | 'circle';
  
  // Empty state
  isEmpty?: boolean;
  text?: string;
  actionText?: string;
  onAction?: () => void;
  
  // Error state
  isError?: boolean;
  onRetry?: () => void;
  
  // Children to render when not in any special state
  children?: React.ReactNode;
}

export const EmptyOrSkeleton = ({
  isLoading = false,
  count = 3,
  type = 'row',
  isEmpty = false,
  text = 'No items found',
  actionText = 'Add New',
  onAction,
  isError = false,
  onRetry,
  children
}: EmptyOrSkeletonProps) => {
  // Generate skeleton based on type
  const renderSkeletons = () => {
    const skeletons = [];
    for (let i = 0; i < count; i++) {
      if (type === 'card') {
        skeletons.push(<SkeletonCard key={i} />);
      } else if (type === 'circle') {
        skeletons.push(<SkeletonCircle key={i} />);
      } else {
        skeletons.push(<SkeletonRow key={i} />);
      }
    }
    return skeletons;
  };

  // Show skeleton if loading
  if (isLoading) {
    return (
      <YStack space="$3">
        {renderSkeletons()}
      </YStack>
    );
  }
  
  // Show error state if there's an error
  if (isError) {
    return (
      <SectionError 
        message={text} 
        onRetry={onRetry} 
      />
    );
  }
  
  // Show empty state if empty
  if (isEmpty) {
    return (
      <YStack
        padding="$4"
        alignItems="center"
        justifyContent="center"
        space="$3"
      >
        <Text textAlign="center" color="$gray11">
          {text}
        </Text>
        {onAction && (
          <Button size="$3" onPress={onAction}>
            {actionText}
          </Button>
        )}
      </YStack>
    );
  }
  
  // Default: return children
  return <>{children}</>;
};
```
\n\n## DashboardSection
**Current implementation:** components/dashboard/DashboardSection.tsx
\n```
import React, { ReactNode } from 'react';
import { Text, YStack, XStack, Button, Anchor, H4 } from 'tamagui';
import { router } from 'expo-router';
import { SkeletonRow } from '@/components/ui/Skeleton';
import { SectionError } from '@/components/ui/ErrorBanner';
import { BlurView } from 'expo-blur'; // Import BlurView

interface DashboardSectionProps<T> {
  title: string;
  data?: T[];
  isLoading?: boolean;
  emptyMessage?: string;
  seeAllRoute?: string;
  renderItem?: (item: T) => ReactNode;
  skeletonCount?: number;
  error?: string;
  onRetry?(): void;
  children?: ReactNode;
  onSeeAll?(): void;
}

export default function DashboardSection<T>({ 
  title, 
  data, 
  isLoading, 
  emptyMessage,
  seeAllRoute,
  renderItem,
  skeletonCount = 2,
  error,
  onRetry,
  children,
  onSeeAll
}: DashboardSectionProps<T>) {
  return (
    <YStack space="$2">
      <XStack justifyContent="space-between" alignItems="center" marginBottom="$2" paddingHorizontal="$2">
        <H4>{title}</H4>
        {((data && data.length > 0 && seeAllRoute) || onSeeAll) && (
          <Button 
            chromeless 
            size="$2" 
            onPress={() => {
              if (onSeeAll) {
                onSeeAll();
              } else if (seeAllRoute) {
                // Navigate to route using type assertions
                // Safe because the route will be a tab/screen name within the app
                router.push(seeAllRoute as any);
              }
            }}
          >
            See All
          </Button>
        )}
      </XStack>
      
      {/* Wrap content in BlurView */}
      <BlurView 
        intensity={50} 
        tint="default" 
        style={{ borderRadius: 12, overflow: 'hidden' }} 
      >
        <YStack padding="$3">
          {/* If children are provided, render them */}
          {children ? (
            children
          ) : isLoading ? (
            <SkeletonRow lines={skeletonCount} />
          ) : error ? (
            <SectionError message={error ? String(error) : 'An error occurred'} onRetry={onRetry} />
          ) : data && data.length === 0 ? (
            <YStack alignItems="center" padding="$4">
              <Text color="$gray10">{emptyMessage ?? 'No items found'}</Text>
            </YStack>
          ) : (
            data && renderItem && data.map(renderItem)
          )}
        </YStack>
      </BlurView>
    </YStack>
  );
} ```
\n\n## GoalSummaryCard
**Current implementation:** components/dashboard/GoalSummaryCard.tsx
\n```
import React from 'react';
import { Text, XStack, Button } from 'tamagui';
import ProgressRing from '@/components/aether/ProgressRing';
import { RouterOutputs } from '@/utils/trpc';
import { BlurView } from 'expo-blur'; // Import BlurView

// Define a custom type that includes everything we need
type DashboardGoal = {
  id: string;
  title: string;
  status?: string;
  priority?: number;
  progress: number;
  tasks?: {
    total: number;
    completed: number;
  };
};

interface GoalSummaryCardProps {
  goal: DashboardGoal;
  onPress: () => void;
}

export default function GoalSummaryCard({ goal, onPress }: GoalSummaryCardProps) {
  return (
    <BlurView 
      intensity={50} 
      tint="default" 
      style={{ borderRadius: 12, overflow: 'hidden' }}
    >
      <Button 
        chromeless // Remove default button styling
        padding="$3" 
        onPress={onPress}
        width="100%" // Ensure it fills the BlurView
      >
        <XStack alignItems="center" space="$3" flex={1}> 
          <ProgressRing
            progress={goal.progress}
            size={40}
            primaryColor="$primary"
          />
          <XStack flex={1} flexDirection="column">
            <Text fontSize="$4" fontWeight="500" color="$color">
              {goal.title}
            </Text>
            {goal.tasks && (
              <Text color="$gray9" fontSize="$2">
                {goal.tasks.completed}/{goal.tasks.total} tasks completed
              </Text>
            )}
          </XStack>
        </XStack>
      </Button>
    </BlurView>
  );
}```
\n\n## Planned new components
* SectionCard.tsx - Glazed parchment card with header, children slot
* StatBadge.tsx - Heart/rupee style KPI badge
* SkeletonCard.tsx - NativeWind animated placeholder
* EmptyState.tsx - Triforce-in-cloud illustration + call-to-action
\n\n# 5️⃣ Feature Screens
\n\n## Current implementations
\n\n## Current  screen
**Current implementation:** app/(tabs)/home/index.tsx
\n```
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/home/index.tsx
import React, { useCallback, useMemo } from 'react';
import { YStack, H1, Text, XStack, Button, ScrollView, Spinner } from 'tamagui';
import { SafeAreaView, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc, RouterOutputs } from '@/utils/trpc';
import DashboardSection from '@/components/dashboard/DashboardSection';
import GoalSummaryCard from '@/components/dashboard/GoalSummaryCard';
import HabitCheckItem from '@/components/dashboard/HabitCheckItem';
import TaskItem from '@/components/dashboard/TaskItem';
import StateIndicator from '@/components/dashboard/StateIndicator';
import DailyProgressBanner from '@/components/dashboard/DailyProgressBanner'; // Import Banner
import EmptyOrSkeleton from '@/components/ui/EmptyOrSkeleton';
import { SkeletonCard, SkeletonRow } from '@/components/ui/Skeleton';
import { useSkeleton } from '@/hooks/useSkeleton';
import { useColorScheme } from '@/hooks/useColorScheme';
import { useToastController } from '@tamagui/toast';
import { BlurView } from 'expo-blur';
import { Plus } from '@tamagui/lucide-icons';
import LottieView from 'lottie-react-native';
import SwipeableRow from '@/components/ui/SwipeableRow'; // Import SwipeableRow

// Types inferred from tRPC Router
type RouterOutput = RouterOutputs['dashboard']['getDashboardData'];
// --- Define types for the STRUCTURE AFTER mapping in useMemo ---
export type DashboardGoal = {
  id: string;
  title: string;
  progress: number;
  tasks: { completed: number; total: number };
  // Include other relevant fields if needed by GoalSummaryCard
  status?: string | null; 
  priority?: number | null;
};
export type DashboardHabit = {
  id: string;
  name: string;
  description?: string | null;
  completed: boolean; // Mapped from completedToday
  streak: number;
  last_entry_id?: string; // Mapped from habit.last_entry_id (null -> undefined)
  habit_type?: string | null;
};
export type DashboardTask = {
  id: string;
  name: string;
  status: string | null; // Allow null
  due_date?: Date | string | null;
  // Include other relevant fields if needed by TaskItem
};
export type DashboardState = {
  id: string;
  name: string | null;
  unit: string | null;
  currentValue: number | string | null;
  lastUpdated: string | null;
  lastEntry: { value: number | null; created_at: Date | string } | null; // Explicitly include lastEntry
};
// --- End mapped type definitions ---

export default function HomeScreen() {
  const colorScheme = useColorScheme();
  const toast = useToastController();
  const utils = trpc.useUtils(); // Get tRPC utils for mutations
  
  // Define types using RouterOutputs for clarity and safety
  // type DashboardGoal = RouterOutputs['dashboard']['getDashboardData']['goals'][number];
  // type DashboardHabit = RouterOutputs['dashboard']['getDashboardData']['habits'][number];
  // type DashboardTask = RouterOutputs['dashboard']['getDashboardData']['tasks'][number];

  // Use tRPC hooks to fetch data - Types are inferred but can be explicitly used
  const { 
    data: dashboardData, 
    isLoading, 
    error, 
    refetch,
    isRefetching 
  } = trpc.dashboard.getDashboardData.useQuery();

  // Define the habit entry mutation hook
  const createHabitEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: () => {
      refetch(); // Refresh data after successful mutation
      // Optional: Add success toast
      // toast.show('Habit updated!', { type: 'success' });
    },
    onError: (error) => {
      // Handle tRPC client error
      toast.show(error.message || 'Failed to update habit', { type: 'error' });
    }
  });

  // Handle errors
  React.useEffect(() => {
    if (error) {
      toast.show(error.message || 'Failed to load dashboard data', { type: 'error' });
    }
  }, [error, toast]);

  // Set up pull-to-refresh
  const onRefresh = useCallback(() => {
    refetch();
  }, [refetch]);

  // Custom skeleton states from your hooks
  const { isLoading: skeletonsLoading, count: skeletonCount = 3 } = {
    isLoading,
    count: 3 // Number of skeleton items to show
  };
  
  // Generate skeleton UI based on loading state
  const renderSkeletons = () => {
    return Array.from({ length: skeletonCount }).map((_, index) => (
      <SkeletonCard key={`skeleton-${index}`} />
    ));
  };

  // Get current date and greeting
  const greeting = getGreeting();
  const currentDate = new Date().toLocaleDateString('en-US', { 
    weekday: 'long', 
    month: 'long', 
    day: 'numeric' 
  });

  const dashboardDataMemo = useMemo(() => {
    // Fix: Add check to ensure dashboardData exists before accessing properties
    if (!dashboardData) {
      return null; // Or return default structure: { goals: [], habits: [], tasks: [], trackedStates: [] }
    }

    // Map and filter data, ensuring structure matches exported types
    return {
      // Filter goals to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      goals: (dashboardData.goals ?? [])
        .filter((goal): goal is typeof goal & { id: string } => !!goal?.id)
        .map((goal) => ({
        // Map to DashboardGoal structure
        id: goal.id, 
        title: goal.title ?? 'Untitled Goal', // Provide default for title
        progress: goal.progress ?? 0, 
        tasks: goal.tasks ?? { completed: 0, total: 0 }, 
        status: goal.status,
        priority: goal.priority,
      })),
      // Filter habits to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      habits: (dashboardData.habits ?? [])
        .filter((habit): habit is typeof habit & { id: string } => !!habit?.id)
        .map((habit) => ({
        // Map to DashboardHabit structure
        id: habit.id, 
        name: habit.name ?? 'Unnamed Habit', // Provide default for name
        description: habit.description,
        completed: habit.completedToday ?? false, // Map completedToday to completed
        streak: habit.streak ?? 0, 
        last_entry_id: habit.last_entry_id ?? undefined, // Map null to undefined
        habit_type: habit.habit_type,
      })),
      // Filter tasks to ensure they have an ID before mapping
      // Fix: Use nullish coalescing and optional chaining
      tasks: (dashboardData.tasks ?? [])
        .filter((task): task is typeof task & { id: string } => !!task?.id)
        .map((task) => ({
        // Map to DashboardTask structure
        id: task.id,
        name: task.name ?? 'Untitled Task', // Provide default name
        status: task.status,
        due_date: task.due_date,
      })),
      // Map trackedStates, ensuring lastEntry is preserved
      // Fix: Use nullish coalescing and optional chaining
      trackedStates: (dashboardData.trackedStates ?? [])
        .filter((state): state is typeof state & { id: string } => !!state?.id)
        .map((trackedState) => ({
        // Map to DashboardState structure
        id: trackedState.id,
        name: trackedState.name,
        unit: trackedState.unit,
        currentValue: trackedState.currentValue,
        lastUpdated: trackedState.lastUpdated,
        // Ensure lastEntry structure matches definition or is null
        lastEntry: trackedState.lastEntry ?? null, 
      })),
    };
  }, [dashboardData]);

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <ScrollView 
        showsVerticalScrollIndicator={false}
        contentContainerStyle={{ paddingBottom: 100 }}
        refreshControl={
          <RefreshControl
            refreshing={isRefetching}
            onRefresh={onRefresh}
            tintColor="transparent" // Hide default spinner
            colors={['transparent']} // Hide default spinner (Android)
            progressBackgroundColor="transparent" // Hide default bg (Android)
            refreshingComponent={
              <LottieView
                source={require('@/assets/refresh-sheikah.json')} // ASSUMES this file exists
                autoPlay
                loop
                style={{ width: 48, height: 48, alignSelf: 'center' }} // Center the animation
              />
            }
          />
        }
      >
        <YStack space="$4" paddingHorizontal="$4">
          {/* Header */}
          <YStack space="$1">
            <H1>{greeting}</H1>
            <Text color="$gray10">{currentDate}</Text>
          </YStack>

          {/* Daily Progress Banner */}
          <DailyProgressBanner 
            // tasksCompleted={...} 
            // totalTasks={...} 
            // habitsChecked={...} 
            // totalHabits={...} 
          />

          {/* Goals Section */}
          <DashboardSection 
            title="Goals"
            onSeeAll={() => router.push('/planner')}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load goals"
              />
            ) : !dashboardDataMemo?.goals || dashboardDataMemo.goals.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No goals yet"
                actionText="Create a goal"
                onAction={() => router.push('/planner/add-goal')}
              />
            ) : (
              <YStack space="$3">
                {dashboardDataMemo.goals.slice(0, 3).map((goal) => (
                  <SwipeableRow
                    key={goal.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.goal.delete.mutate({ id: goal.id })
                      console.log('Attempting to delete goal:', goal.id); // Placeholder
                      // utils.goal.delete.mutate({ id: goal.id });
                    }}
                  >
                    <GoalSummaryCard
                      goal={goal}
                      onPress={() => router.push(`/planner/goal/${goal.id}`)}
                    />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>

          {/* Today's Habits */}
          <DashboardSection 
            title="Today's Habits"
            onSeeAll={() => router.push('/planner?tab=habits')}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load habits"
              />
            ) : !dashboardDataMemo?.habits || dashboardDataMemo.habits.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No habits for today"
                actionText="Create a habit"
                onAction={() => router.push('/planner/add-habit')}
              />
            ) : (
              <YStack space="$2">
                {dashboardDataMemo.habits.slice(0, 4).map((habit) => (
                  <SwipeableRow
                    key={habit.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.habit.delete.mutate({ id: habit.id })
                      console.log('Attempting to delete habit:', habit.id); // Placeholder
                      // utils.habit.delete.mutate({ id: habit.id });
                    }}
                  >
                    <HabitCheckItem habit={habit} />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>

          {/* Today's State */}
          <DashboardSection
            title="Today's State"
            // TODO: Add navigation to a dedicated state tracking screen
            onSeeAll={() => console.log('Navigate to State Tracking screen')}
          >
            {isLoading ? (
              renderSkeletons() // Use generic skeletons or specific state skeletons
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load state"
              />
            ) : !dashboardDataMemo?.trackedStates || dashboardDataMemo.trackedStates.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No states being tracked"
                actionText="Track a state"
                // TODO: Navigate to state definition creation screen
                onAction={() => console.log('Navigate to Add State screen')}
              />
            ) : (
              <XStack space="$3" flexWrap="wrap"> 
                {dashboardDataMemo.trackedStates.map((stateData) => (
                  <StateIndicator
                    key={stateData.id}
                    state={stateData} // Pass the whole state object which includes lastEntry
                    lastEntry={stateData.lastEntry} // Pass lastEntry explicitly
                    // TODO: Handle interaction - e.g., navigate to state detail/entry screen
                    onPress={() => console.log('State pressed:', stateData.id)}
                  />
                ))}
              </XStack>
            )}
          </DashboardSection>

          {/* Upcoming Tasks */}
          <DashboardSection 
            title="Upcoming Tasks"
            onSeeAll={() => {/* Navigate to tasks list */}}
          >
            {isLoading ? (
              renderSkeletons()
            ) : error ? (
              <EmptyOrSkeleton
                isEmpty={false}
                isError={true}
                onRetry={refetch}
                text="Failed to load tasks"
              />
            ) : !dashboardDataMemo?.tasks || dashboardDataMemo.tasks.length === 0 ? (
              <EmptyOrSkeleton
                isEmpty={true}
                text="No upcoming tasks"
                actionText="Create a task"
                onAction={() => {/* Navigate to create task */}}
              />
            ) : (
              <YStack space="$2">
                {dashboardDataMemo.tasks.slice(0, 5).map((task) => (
                  <SwipeableRow
                    key={task.id}
                    onDelete={() => {
                      // TODO: Add confirmation dialog?
                      // Assuming mutation exists: utils.task.delete.mutate({ id: task.id })
                      console.log('Attempting to delete task:', task.id); // Placeholder
                      // utils.task.delete.mutate({ id: task.id });
                    }}
                  >
                    <TaskItem
                      task={{
                        // Explicitly pass props matching DashboardTask type
                        id: task.id, // Ensure id is passed
                        name: task.name, // Already defaulted in map
                        status: task.status, // Pass status
                        due_date: task.due_date, // Pass due_date
                      }}
                      isLast={false} // Adjust if needed for styling
                      onPress={() => console.log('Task Item Pressed:', task.id)}
                    />
                  </SwipeableRow>
                ))}
              </YStack>
            )}
          </DashboardSection>
        </YStack>
      </ScrollView>
      <QuickAddFAB />
    </SafeAreaView>
  );
}

// Helper function for greeting
function getGreeting() {
  const hour = new Date().getHours();
  if (hour < 12) return 'Good Morning';
  if (hour < 18) return 'Good Afternoon';
  return 'Good evening';
}

// Quick Add FAB Component
function QuickAddFAB() {
  return (
    <BlurView intensity={40} tint="default" style={{ position:'absolute', bottom:24, right:24, borderRadius:32, overflow: 'hidden' }}>
      <Button
        circular
        size="$5"
        backgroundColor="$accent"
        icon={Plus}
        elevate
        shadowColor="$shadowColor"
        shadowRadius={5}
        shadowOffset={{ width: 0, height: 2 }}
        pressStyle={{ scale: 0.95, opacity: 0.9 }}
        onPress={() => {
          router.push('/planner/add-task');
        }}
      />
    </BlurView>
  );
}
```
\n\n## Current  screen
**Current implementation:** app/(tabs)/planner/index.tsx
\n```
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/planner/index.tsx
import React, { useState, Suspense } from 'react';
import { YStack, XStack, Text, Tabs, Button, Spinner, Card, ScrollView } from 'tamagui';
import { SafeAreaView, FlatList, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { RouterOutputs } from '@/utils/api-types';
import { SectionError } from '@/components/ui/ErrorBanner';


interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'goals',
    title: 'Goals',
    icon: <Ionicons name="trophy-outline" size={18} color="currentColor" />
  },
  {
    key: 'habits',
    title: 'Habits',
    icon: <Ionicons name="repeat-outline" size={18} color="currentColor" />
  },
  {
    key: 'calendar',
    title: 'Calendar',
    icon: <Ionicons name="calendar-outline" size={18} color="currentColor" />
  }
];

export default function PlannerScreen() {
  const [activeTab, setActiveTab] = useState<string>('goals');
  const colorScheme = useColorScheme();
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Planner</Text>
          <Button
            size="$3"
            circular
            onPress={() => {/* Handle new item */}}
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>
        
        {/* Tabs */}
        <Tabs
          defaultValue="goals"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List 
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {tab.icon}
                  <Text>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>
          
          {/* Tab Content */}
          <Tabs.Content value="goals" flex={1}>
            <ScrollView>
              <GoalsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="habits" flex={1}>
            <ScrollView>
              <HabitsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="calendar" flex={1}>
            <ScrollView>
              <CalendarTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Goals Tab
function GoalsTab() {
  // Fetch goals using tRPC
  const { data: goals, isLoading, error, refetch } = trpc.goal.getGoals.useQuery();
  
  // Define the inferred type for a single goal
  type PlannerGoal = RouterOutputs['goal']['getGoals'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load goals" 
      />
    );
  }
  
  if (!goals || goals.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No goals yet" 
        actionText="Create a goal" 
        onAction={() => router.push('/planner/add-goal')} 
      />
    );
  }
  
  return (
    <YStack space="$4">
      {goals.map((goal: PlannerGoal) => (
        <Button 
          key={goal.id} 
          height="$12" 
          justifyContent="flex-start" 
          paddingHorizontal="$3"
          onPress={() => router.push({ pathname: '/planner/goal/[id]', params: { id: goal.id } })}
        >
          <YStack>
            <Text fontWeight="bold">{goal.title}</Text>
            <Text fontSize="$2" color="$gray10">
              {goal.dueDate ? new Date(goal.dueDate).toLocaleDateString() : 'No due date'}
            </Text>
          </YStack>
        </Button>
      ))}
    </YStack>
  );
}

// Habits Tab
function HabitsTab() {
  // Fetch habits using tRPC
  const { data: habits, isLoading, error, refetch } = trpc.habit.getHabits.useQuery();
  
  // Define the inferred type for a single habit
  type PlannerHabit = RouterOutputs['habit']['getHabits'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={isLoading} count={3} type="row" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load habits" 
      />
    );
  }
  
  if (!habits || habits.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No habits yet" 
        actionText="Create a habit" 
        onAction={() => router.push('/planner/add-habit')} 
      />
    );
  }
  
  return (
    <YStack space="$3">
      {habits.map((habit: PlannerHabit) => (
        <XStack 
          key={habit.id} 
          justifyContent="space-between" 
          alignItems="center" 
          paddingVertical="$3" 
          paddingHorizontal="$3" 
          borderBottomWidth={1} 
          borderColor="$gray5"
          pressStyle={{ opacity: 0.7 }}
          tag="pressable"
          onPress={() => router.push({ pathname: '/planner/habit/[id]', params: { id: habit.id } })}
        >
          <Text>{habit.title}</Text>
          <Button
            size="$2"
            circular
            backgroundColor={habit.completed ? '$green9' : '$gray9'}
            onPress={() => {
              // Use today's date for the habit entry
              const today = new Date().toISOString().split('T')[0];
              
              // Create a mutation to toggle habit completion
              const toggleHabit = trpc.habit.createHabitEntry.useMutation({
                onSuccess: () => {
                  refetch(); // Refresh data after toggling
                },
                onError: (error) => {
                  // Show error message
                  console.error('Failed to toggle habit:', error.message);
                }
              });
              
              // Toggle the habit completion status
              toggleHabit.mutate({
                habitId: habit.id,
                completed: !habit.completed,
                date: today
              });
            }}
            icon={<Ionicons name="checkmark" size={18} color="white" />}
          />
        </XStack>
      ))}
    </YStack>
  );
}

// Calendar Tab
function CalendarTab() {
  return (
    <YStack alignItems="center" justifyContent="center" padding="$8">
      <Text fontSize="$5" textAlign="center">
        Calendar integration coming soon
      </Text>
      <Text marginTop="$2" color="$gray10" textAlign="center">
        This tab will display task and habit schedules in a calendar view
      </Text>
    </YStack>
  );
}
```
\n\n## Current  screen
**Current implementation:** app/(tabs)/compass/index.tsx
\n```
// Compass screen with Principles and States tabs
import React, { useState } from 'react';
import { YStack, XStack, Text, Tabs, Button, ScrollView } from 'tamagui'; 
import { SafeAreaView } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc, type RouterOutputs } from '@/utils/trpc'; 
import { useColorScheme } from '@/hooks/useColorScheme'; 
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { router, type Href } from 'expo-router'; 
import { PrincipleCard } from '@/components/compass/PrincipleCard';
import PrinciplesTab from '@/components/compass/PrinciplesTab';
import { StateDefinitionCard } from '@/components/compass/StateDefinitionCard'; 

interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'principles',
    title: 'Principles',
    icon: <Ionicons name="compass-outline" size={18} color="currentColor" />
  },
  {
    key: 'states',
    title: 'States',
    icon: <Ionicons name="pulse-outline" size={18} color="currentColor" />
  }
];

export default function CompassScreen() {
  const [activeTab, setActiveTab] = useState<string>('principles');
  const colorScheme = useColorScheme();

  const handleAddPress = () => {
    const route = `/compose?type=${activeTab === 'principles' ? 'value' : 'state'}` as Href;
    router.push(route);
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Compass</Text>
          <Button
            size="$3"
            circular
            onPress={handleAddPress} 
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>

        {/* Tabs */}
        <Tabs
          defaultValue="principles"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {React.cloneElement(tab.icon as React.ReactElement, { color: activeTab === tab.key ? '$colorFocus' : '$color' })}
                  <Text color={activeTab === tab.key ? '$colorFocus' : '$color'}>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>

          {/* Tab Content */}
          <Tabs.Content value="principles" flex={1} key="principles-content">
            <ScrollView>
              <PrinciplesTab />
            </ScrollView>
          </Tabs.Content>

          <Tabs.Content value="states" flex={1} key="states-content">
            <ScrollView>
              <StatesTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Define the specific types from RouterOutputs
// Types are now defined in the PrinciplesTab component
type StateDefinition = RouterOutputs['state']['getDefinitions'][number]; 

// Principles Tab Component is now imported from '@/components/compass/PrinciplesTab'

// States Tab Component (manages data fetching and list rendering)
function StatesTab() {
  const { data: states, isLoading, error, refetch } = trpc.state.getDefinitions.useQuery(); 

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }

  if (error) {
    return (
      <EmptyOrSkeleton
        isEmpty={false}
        isError={true}
        onRetry={refetch}
        text="Failed to load tracked state definitions"
      />
    );
  }

  if (!states || states.length === 0) {
    return (
      <EmptyOrSkeleton
        isEmpty={true}
        text="No state definitions found"
        actionText="Define Your First State"
        onAction={() => router.push('/compose?type=state' as Href)}
      />
    );
  }

  return (
    <YStack space="$3"> 
      {states.map((state: StateDefinition) => (
        <StateDefinitionCard
          key={state.id}
          state={state}
          onPress={() => router.push(`/states/${state.id}` as Href)}
        />
      ))}
    </YStack>
  );
}

// 
// Removed inline PrincipleCard definition (extracted to components/compass/PrincipleCard.tsx)
// 

// 
// Removed inline StateDefinitionCard definition (extracted to components/compass/StateDefinitionCard.tsx)
// 
```
\n\n## Current  screen
**Current implementation:** app/(tabs)/rewards/index.tsx
\n```
// Rewards screen with grid/list toggle and claim functionality
import React, { useState, useCallback } from 'react';
import { YStack, XStack, Text, Button, ScrollView, Card, Checkbox, useTheme, H1 } from 'tamagui';
import { SafeAreaView, View, FlatList, ImageBackground, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { RouterOutputs } from '@/utils/trpc'; // Import RouterOutputs
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton'; // Import helper component

// Define inferred type for rewards
type RewardItem = RouterOutputs['rewards']['getAvailableRewards'][number];

enum ViewMode {
  Grid = 'grid',
  List = 'list'
}

export default function RewardsScreen() {
  const [viewMode, setViewMode] = useState<ViewMode>(ViewMode.Grid);
  const colorScheme = useColorScheme();
  const theme = useTheme();

  // Define fallback colors
  const blue2 = theme?.blue2?.val ?? '#eff6ff';
  const blue5 = theme?.blue5?.val ?? '#60a5fa';
  const blue10 = theme?.blue10?.val ?? '#1e40af';
  const blue11 = theme?.blue11?.val ?? '#1e3a8a';
  const green9 = theme?.green9?.val ?? '#16a34a';

  // Fetch available rewards from tRPC
  const { 
    data: rewards, 
    isLoading, 
    error, 
    refetch 
  } = trpc.rewards.getAvailableRewards.useQuery();

  // Mutation for claiming rewards
  const claimMutation = trpc.rewards.earnReward.useMutation({
    onSuccess: (data) => {
      console.log('Reward claimed successfully:', data);
      // Maybe show confetti?
      Alert.alert('Reward Claimed!', `You spent ${data.reward.points_spent} points. Remaining: ${data.remainingPoints}`);
      refetch(); // Refetch the list of available rewards
    },
    onError: (err) => {
      console.error('Failed to claim reward:', err);
      Alert.alert('Claim Failed', err.message || 'Could not claim reward.');
    }
  });
  
  const handleClaimReward = useCallback((rewardId: string) => {
    if (claimMutation.isPending) return; // Prevent double-clicks
    
    Alert.alert(
      'Confirm Claim',
      'Are you sure you want to spend points on this reward?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Claim', 
          onPress: () => {
            claimMutation.mutate({ rewardId });
          },
          style: 'default'
        }
      ]
    );
  }, [claimMutation]);
  
  const renderItem = ({ item }: { item: RewardItem }) => { // Use inferred type
    // Assuming backend field is image_url, map to imagePath
    const imagePath = item.image_url; 
    // All items from getAvailableRewards are considered claimable (not yet claimed)
    const claimed = false; 
    // Map required_points to pointCost
    const pointCost = item.required_points;

    if (viewMode === ViewMode.Grid) {
      return (
        <Card
          size="$4"
          bordered
          width={160}
          height={200}
          margin="$2"
          overflow="hidden"
          elevation="$2"
          opacity={claimed ? 0.7 : 1}
        >
          <ImageBackground
            source={{ uri: imagePath }}
            style={{ width: '100%', height: 100 }}
          >
            <View style={{ 
              position: 'absolute', 
              top: 5, 
              right: 5, 
              backgroundColor: blue5,
              borderRadius: 10,
              padding: 4
            }}>
              <Text color="white" fontSize="$2" fontWeight="bold">
                {pointCost} pts
              </Text>
            </View>
          </ImageBackground>
          
          <YStack padding="$2" flex={1} justifyContent="space-between">
            <Text fontSize="$4" fontWeight="bold" numberOfLines={1}>
              {item.name}
            </Text>
            
            <Button
              size="$2"
              themeInverse={claimed}
              backgroundColor={claimed ? undefined : blue10}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </YStack>
        </Card>
      );
    } else {
      return (
        <Card
          bordered
          margin="$2"
          padding="$3"
          opacity={claimed ? 0.7 : 1}
        >
          <XStack space="$3" alignItems="center">
            {imagePath && (
              <View style={{ 
                width: 60, 
                height: 60, 
                borderRadius: 8, 
                overflow: 'hidden',
                backgroundColor: theme.gray3.val
              }}>
                <ImageBackground
                  source={{ uri: imagePath }}
                  style={{ width: '100%', height: '100%' }}
                />
              </View>
            )}
            
            <YStack flex={1} space="$1">
              <Text fontSize="$5" fontWeight="bold">{item.name}</Text>
              <Text fontSize="$3" color="$gray11" numberOfLines={2}>{item.description}</Text>
              <Text fontSize="$3" color={blue10} fontWeight="500">{pointCost} points</Text>
            </YStack>
            
            <Button
              size="$3"
              backgroundColor={claimed ? undefined : blue10}
              themeInverse={claimed}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </XStack>
        </Card>
      );
    }
  };
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        <YStack space="$4">
          {/* Header */}
          <XStack justifyContent="space-between" alignItems="center">
            <H1>Rewards</H1>
            
            <XStack space="$2">
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.Grid ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.Grid)}
              >
                <Ionicons 
                  name="grid-outline" 
                  size={22} 
                  color={viewMode === ViewMode.Grid ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
              
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.List ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.List)}
              >
                <Ionicons 
                  name="list-outline" 
                  size={22} 
                  color={viewMode === ViewMode.List ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
            </XStack>
          </XStack>
          
          {/* Stats */}
          <Card padding="$3" backgroundColor={blue2}>
            <XStack justifyContent="space-between" alignItems="center">
              <Text fontSize="$5" fontWeight="bold" color={blue11}>Your Points</Text>
              <Text fontSize="$6" fontWeight="bold" color={blue10}>275</Text>
            </XStack>
          </Card>
        </YStack>
        
        {/* Content Area */} 
        <EmptyOrSkeleton 
          isLoading={isLoading}
          isEmpty={!isLoading && !error && (!rewards || rewards.length === 0)}
          isError={!!error}
          text={error ? error.message : 'No rewards available yet.'} // Use text for error OR empty msg
          onRetry={refetch}
          type={viewMode === ViewMode.Grid ? 'card' : 'row'}
          count={viewMode === ViewMode.Grid ? 6 : 3}
        >
          <FlatList
            key={viewMode} // Change key based on viewMode to force re-render
            data={rewards}
            renderItem={renderItem}
            keyExtractor={(item, index) =>
              `${item?.id ?? `tmp-${index}`}-${viewMode}`   // fall back to index if ID is missing
            }
            
            // Optional: Log corrupt data in development
            onLayout={() => {
              if (__DEV__) {
                const missing = (rewards ?? []).filter(r => !r?.id);
                if (missing.length) console.warn('Rewards missing id:', missing);
              }
            }}
            numColumns={viewMode === ViewMode.Grid ? 2 : 1}
            contentContainerStyle={{ paddingBottom: 50 }} // Add padding at the bottom
            // Optional Optimizations (Patch #6)
            initialNumToRender={8}
            removeClippedSubviews={true} // Note: Can have visual glitches on iOS sometimes
          />
        </EmptyOrSkeleton>

      </YStack>
    </SafeAreaView>
  );
}
```
\n\n## Current  screen
**Current implementation:** app/(tabs)/settings/index.tsx
\n```
// Settings screen with account, preferences, and app settings
import React, { useState } from 'react';
import { YStack, XStack, Text, Button, Switch, Separator, ScrollView, Card, H1 } from 'tamagui';
import { SafeAreaView, View, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { supabase } from '@/utils/supabase';
import { useColorScheme } from 'react-native';
import { useAccent } from '@/app/_layout'; // Import the useAccent hook

interface SettingsSectionProps {
  title: string;
  icon: React.ReactNode;
  children: React.ReactNode;
}

const SettingsSection = ({ title, icon, children }: SettingsSectionProps) => {
  return (
    <YStack marginVertical="$2">
      <XStack alignItems="center" space="$2" marginBottom="$2">
        {icon}
        <Text fontSize="$5" fontWeight="bold">{title}</Text>
      </XStack>
      <Card padding="$3" bordered>
        {children}
      </Card>
    </YStack>
  );
};

interface SettingsRowProps {
  label: string;
  icon?: React.ReactNode;
  rightElement?: React.ReactNode;
  onPress?: () => void;
  showChevron?: boolean;
}

const SettingsRow = ({ label, icon, rightElement, onPress, showChevron = false }: SettingsRowProps) => {
  return (
    <XStack
      paddingVertical="$3"
      justifyContent="space-between"
      alignItems="center"
      onPress={onPress}
      pressStyle={onPress ? { opacity: 0.7 } : undefined}
    >
      <XStack space="$3" alignItems="center" flex={1}>
        {icon}
        <Text fontSize="$4">{label}</Text>
      </XStack>
      <XStack space="$2" alignItems="center">
        {rightElement}
        {showChevron && <Ionicons name="chevron-forward" size={18} color="#A0A0A0" />}
      </XStack>
    </XStack>
  );
};

export default function SettingsScreen() {
  const colorScheme = useColorScheme();
  const [notificationsEnabled, setNotificationsEnabled] = useState(true);
  const [trackingEnabled, setTrackingEnabled] = useState(true);
  const { setAccent } = useAccent(); // Get the function to update accent color
  const [selectedAccent, setSelectedAccent] = useState('blue'); // Placeholder state for selected accent

  const handleLogout = async () => {
    Alert.alert(
      'Log Out',
      'Are you sure you want to log out?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Log Out', 
          style: 'destructive',
          onPress: async () => {
            await supabase.auth.signOut();
            router.replace('/(auth)/login');
          }
        }
      ]
    );
  };

  const AccentSelector = ({ currentAccent, onSelect }: { currentAccent: string, onSelect: (accent: string) => void }) => {
    const accents = ['blue', 'green', 'orange', 'red']; // Example accents corresponding to theme names
    return (
      <XStack space="$2">
        {accents.map((accent) => (
          <Button 
            key={accent} 
            onPress={() => {
              onSelect(accent);
              setAccent(accent); // Call setAccent with the selected accent
            }} 
            theme={accent as any} // Preview the theme (cast needed for demo)
            backgroundColor={accent === currentAccent ? '$backgroundStrong' : '$background'}
          >
            {accent.charAt(0).toUpperCase() + accent.slice(1)}
          </Button>
        ))}
      </XStack>
    );
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <ScrollView>
        <YStack flex={1} padding="$4">
          <H1 marginBottom="$4">Settings</H1>
          
          {/* Account Section */}
          <SettingsSection
            title="Account"
            icon={<Ionicons name="person-circle-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Edit Profile"
                icon={<Ionicons name="person-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/profile' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Security"
                icon={<Ionicons name="lock-closed-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/security' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Data & Privacy"
                icon={<Ionicons name="shield-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/privacy' as any)}
              />
            </YStack>
          </SettingsSection>
          
          {/* Appearance Section */}
          <SettingsSection
            title="Appearance"
            icon={<Ionicons name="color-palette-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Theme"
                icon={<Ionicons name="moon-outline" size={20} color="#A0A0A0" />}
                rightElement={<Text color="$gray10">{colorScheme === 'dark' ? 'Dark (System)' : 'Light (System)'}</Text>}
              />
              <SettingsRow
                label="Accent Color"
                icon={<Ionicons name="color-palette-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <AccentSelector 
                    currentAccent={selectedAccent} 
                    onSelect={(accent) => setSelectedAccent(accent)} 
                  />
                }
              />
            </YStack>
          </SettingsSection>
          
          {/* Notifications Section */}
          <SettingsSection
            title="Notifications"
            icon={<Ionicons name="notifications-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Push Notifications"
                icon={<Ionicons name="push-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={notificationsEnabled}
                    onCheckedChange={setNotificationsEnabled}
                  />
                }
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Notification Settings"
                icon={<Ionicons name="options-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/notifications' as any)}
              />
            </YStack>
          </SettingsSection>
          
          {/* Privacy Section */}
          <SettingsSection
            title="Privacy & Data"
            icon={<Ionicons name="analytics-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Analytics Tracking"
                icon={<Ionicons name="trending-up-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={trackingEnabled}
                    onCheckedChange={setTrackingEnabled}
                  />
                }
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Export Data"
                icon={<Ionicons name="download-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => {
                  Alert.alert(
                    'Export Data',
                    'Your data will be prepared for export and sent to your email address.',
                    [
                      { text: 'Cancel', style: 'cancel' },
                      { text: 'Export', onPress: () => {
                        // Would call an API endpoint to initiate export
                        Alert.alert('Export Initiated', 'Check your email for the export file.');
                      }}
                    ]
                  );
                }}
              />
            </YStack>
          </SettingsSection>
          
          {/* Support Section */}
          <SettingsSection
            title="Support & About"
            icon={<Ionicons name="help-circle-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Help Center"
                icon={<Ionicons name="help-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/help' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="About Aether"
                icon={<Ionicons name="information-circle-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/about' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="App Version"
                icon={<Ionicons name="code-outline" size={20} color="#A0A0A0" />}
                rightElement={<Text color="$gray10">1.0.0</Text>}
              />
            </YStack>
          </SettingsSection>
          
          {/* Logout Button */}
          <Button
            marginTop="$6"
            marginBottom="$8"
            size="$4"
            themeInverse
            onPress={handleLogout}
          >
            Log Out
          </Button>
        </YStack>
      </ScrollView>
    </SafeAreaView>
  );
}
```
\n\n# 6️⃣ Utils & Hooks
\n\n## supabase
**Current implementation:** utils/supabase.ts
\n```
import 'react-native-url-polyfill/auto';
import { createClient } from '@supabase/supabase-js';
import * as SecureStore from 'expo-secure-store';

// SecureStore adapter for Supabase auth persistence
const ExpoSecureStoreAdapter = {
  getItem: (key: string) => {
    return SecureStore.getItemAsync(key);
  },
  setItem: (key: string, value: string) => {
    return SecureStore.setItemAsync(key, value);
  },
  removeItem: (key: string) => {
    return SecureStore.deleteItemAsync(key);
  },
};

// Get Supabase URL and anon key from environment variables
// In production, these should be set in app.config.js or via EAS secrets
const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL || '';
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY || '';

if (!supabaseUrl || !supabaseAnonKey) {
  console.warn(
    'Supabase URL or anon key not found. Make sure to set EXPO_PUBLIC_SUPABASE_URL and EXPO_PUBLIC_SUPABASE_ANON_KEY environment variables.'
  );
}

// Create Supabase client
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: ExpoSecureStoreAdapter,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
});

// Helper function to check if user is authenticated
export const isAuthenticated = async () => {
  const { data, error } = await supabase.auth.getSession();
  return !!data.session;
};

// Helper function to get current user
export const getCurrentUser = async () => {
  const { data, error } = await supabase.auth.getUser();
  if (error) {
    console.error('Error getting user:', error.message);
    return null;
  }
  return data.user;
}; ```
\n\n## trpc
**Current implementation:** utils/trpc.ts
\n```
import { createTRPCReact } from '@trpc/react-query';
import { type inferRouterInputs, type inferRouterOutputs } from '@trpc/server';

// Import the real AppRouter type from our server
import { type AppRouter } from '../server/src/router';

// Import types using the updated path
import { RouterInputs as TypedRouterInputs, RouterOutputs as TypedRouterOutputs } from '../server/src/types/trpc-types';

/**
 * tRPC React client
 * The client for consuming your tRPC API from React components
 */
export const trpc = createTRPCReact<AppRouter>();

/**
 * Inference helpers for input/output types
 * Use the pre-defined types from trpc-types.ts
 */
export type RouterInputs = TypedRouterInputs;
export type RouterOutputs = TypedRouterOutputs; ```
\n\n# Type Definitions (for reference)
\n\n## api-types
**Current implementation:** utils/api-types.ts
\n```
/**
 * This file was auto-generated by the generate-trpc-types script.
 * Do not edit manually! Instead, run the script again.
 */

import type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from '../server/src/router';

/**
 * Inference helper for inputs.
 *
 * @example type HelloInput = RouterInputs['example']['hello']
 */
export type RouterInputs = inferRouterInputs<AppRouter>;

/**
 * Inference helper for outputs.
 *
 * @example type HelloOutput = RouterOutputs['example']['hello']
 */
export type RouterOutputs = inferRouterOutputs<AppRouter>;
```
\n\n## trpc-types
**Current implementation:** server/src/types/trpc-types.ts
\n```
// server/src/types/trpc-types.ts
/*
  Aether – Shared tRPC Types
  ------------------------------------------------------------------
  Every Zod schema that powers a router lives here so both the server
  (routers) and the client (React Query hooks) reference a **single**
  source‑of‑truth.  Import these types everywhere else – **never** hand‑roll
  shapes again.
*/

import { z } from 'zod';
import { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from '../router';

/* ------------------------------------------------------------------
 * Enums (keep in sync with DB enums)
 * ----------------------------------------------------------------*/
export const TaskStatusEnum = z.enum(['todo', 'doing', 'done', 'blocked', 'pending']);
export const TaskPriorityEnum = z.enum(['low', 'medium', 'high']);
export const RewardTypeEnum = z.enum(['badge', 'achievement', 'item', 'discount']);
export const HabitTypeEnum = z.enum(['boolean', 'quantity']);
export const HabitFrequencyPeriodEnum = z.enum(['day', 'week', 'month']);

/* ------------------------------------------------------------------
 * Domain Models (DB row shapes) – keep in sync with Supabase tables
 * ----------------------------------------------------------------*/
export const UserProfile = z.object({
  id: z.string().uuid(),
  username: z.string().nullish(),
  avatar_url: z.string().url().nullish(),
  full_name: z.string().nullish(),
  bio: z.string().nullish(),
  points: z.number().int().nonnegative().default(0),
  time_zone: z.string().nullish(),
  onboarding_completed: z.boolean().default(false),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type UserProfile = z.infer<typeof UserProfile>;

export const NotificationPrefs = z.object({
  email: z.boolean().default(true),
  push: z.boolean().default(true),
  task_reminders: z.boolean().default(true),
  goal_updates: z.boolean().default(true),
  habit_reminders: z.boolean().default(true),
});

export const UiPrefs = z.object({
  theme: z.enum(['system', 'light', 'dark']).default('system'),
  compact_view: z.boolean().default(false),
  show_completed_tasks: z.boolean().default(true),
  first_day_of_week: z.number().int().min(0).max(6).default(0),
});

export const UserSettings = z.object({
  id: z.string().uuid().optional(),
  user_id: z.string().uuid(),
  notification_preferences: NotificationPrefs,
  ui_preferences: UiPrefs,
});
export type UserSettings = z.infer<typeof UserSettings>;

export const Value = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), 
  description: z.string().nullish(),
  color: z.string().nullish(),
  icon: z.string().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type Value = z.infer<typeof Value>;

export const Principle = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), // <<< Changed from 'name' to 'title'
  body: z.string(), // <<< Renamed from description for clarity, matching migration
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type Principle = z.infer<typeof Principle>;

export const Goal = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  description: z.string().nullish(),
  progress: z.number().nullish(),
  target_date: z.string().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime().nullish(),
  updated_at: z.string().datetime().nullish(),
});
export type Goal = z.infer<typeof Goal>;

export const Task = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  notes: z.string().nullish(),
  status: TaskStatusEnum.default('todo'),
  priority_enum: TaskPriorityEnum.nullish(), // <<< Renamed from priority
  due_date: z.string().datetime().nullish(),
  goal_id: z.string().uuid().nullish(),
  parent_task_id: z.string().uuid().nullish(),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Task = z.infer<typeof Task>;

export const Habit = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  cue: z.string().nullish(),
  routine: z.string().nullish(),
  reward: z.string().nullish(),
  streak: z.number().nonnegative().default(0),
  best_streak: z.number().nonnegative().default(0),
  habit_type: HabitTypeEnum.default('boolean'),
  goal_quantity: z.number().int().nullish(),
  goal_unit: z.string().nullish(),
  frequency_period: HabitFrequencyPeriodEnum.default('day'),
  goal_frequency: z.number().int().positive().default(1),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(), // <<< Added sort_order
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Habit = z.infer<typeof Habit>;

export const HabitEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  habit_id: z.string().uuid(),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be in YYYY-MM-DD format"),
  completed: z.boolean().default(false),
  quantity_value: z.number().int().nullish(),
  notes: z.string().nullish(),
  created_at: z.string().datetime(),
});
export type HabitEntry = z.infer<typeof HabitEntry>;

export const TrackedStateDef = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  name: z.string(),
  // category: z.string(), // Category seems removed/replaced in DB schema by scale/custom_labels
  scale: z.enum(['1-5', 'low-high', 'custom']), // <<< Added scale
  custom_labels: z.array(z.string()).nullish(), // <<< Added custom_labels
  unit: z.string().nullish(), // Keep unit if still used alongside scale
  icon: z.string().nullish(), // Keep icon if still used
  target_min_value: z.number().nullish(), // <<< Added
  target_max_value: z.number().nullish(), // <<< Added
  active: z.boolean().default(true), // <<< Added active
  priority: z.number().int().default(1), // <<< Added priority
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type TrackedStateDef = z.infer<typeof TrackedStateDef>;

export const StateEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  definition_id: z.string().uuid(), // <<< Renamed from tracked_state_def_id for consistency? check DB
  value_numeric: z.number().optional().nullable(),
  value_text: z.string().optional().nullable(),
  entry_timestamp: z.string().datetime({ message: "Invalid datetime string. Must be UTC ISO 8601" }).optional(),
  notes: z.string().optional().nullable(), // <<< Added notes
});
export type StateEntry = z.infer<typeof StateEntry>;

export const Reward = z.object({
  id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullish(),
  type: RewardTypeEnum,
  required_points: z.number().int().nonnegative().default(0),
  can_earn_multiple: z.boolean().default(false),
  image_url: z.string().url().nullish(),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Reward = z.infer<typeof Reward>;

export const UserReward = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  reward_id: z.string().uuid(),
  reward_type: z.string().nullish(), // From DB schema
  earned_at: z.string().datetime(),
  points_spent: z.number().int().nonnegative().default(0),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type UserReward = z.infer<typeof UserReward>;

export const PointTransaction = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  points: z.number().int(),
  reason: z.string(),
  source_type: z.string(),
  source_id: z.string().uuid().nullish(),
  created_at: z.string().datetime(),
});
export type PointTransaction = z.infer<typeof PointTransaction>;

export const BadgeDefinition = z.object({
  id: z.string(), // From DB: text primary key
  title: z.string(),
  description: z.string().nullish(),
  icon: z.string(),
});
export type BadgeDefinition = z.infer<typeof BadgeDefinition>;

export const UserBadge = z.object({
  // Note: user_badges might be merged into user_rewards with type='badge'
  user_id: z.string().uuid(),
  badge_id: z.string(), // Matches badge_definitions.id (text)
  earned_at: z.string().datetime(),
  progress: z.number().nullish(), // From DB schema
});
export type UserBadge = z.infer<typeof UserBadge>;

export const Reminder = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
  reminder_time: z.string().datetime(),
  is_active: z.boolean().default(true),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Reminder = z.infer<typeof Reminder>;

export const GoalProgressNote = z.object({
  id: z.string().uuid(),
  goal_id: z.string().uuid(),
  user_id: z.string().uuid(),
  note: z.string(),
  created_at: z.string().datetime(),
});
export type GoalProgressNote = z.infer<typeof GoalProgressNote>;

/* ------------------------------------------------------------------
 * Router‑level Schemas – inputs & outputs for every procedure
 * ----------------------------------------------------------------*/
export const greetingInput = z.object({ name: z.string().optional() });
export const greetingOutput = z.object({ greeting: z.string() });

// User
export const updateProfileInput = UserProfile.partial().omit({ id: true, created_at: true, updated_at: true });
export const updateSettingsInput = z.object({
  notification_preferences: NotificationPrefs.partial().optional(),
  ui_preferences: UiPrefs.partial().optional(),
});

// Values
export const createValueInput = Value.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateValueInput = createValueInput.partial().extend({ id: z.string().uuid() });

// Principles
// Uses 'title' and 'body' from the updated Principle schema
export const createPrincipleInput = Principle.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updatePrincipleInput = createPrincipleInput.partial().extend({ id: z.string().uuid() });

// Goals
export const createGoalInput = Goal.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateGoalInput = createGoalInput.partial().extend({ id: z.string().uuid() });

// Tasks
export const createTaskInput = Task.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateTaskInput = createTaskInput.partial().extend({ id: z.string().uuid() });
export const updateTaskStatusInput = z.object({ id: z.string().uuid(), status: TaskStatusEnum });

// Habits
export const createHabitInput = Habit.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateHabitInput = createHabitInput.partial().extend({ id: z.string().uuid() });

// Habit Entries
export const createHabitEntryInput = HabitEntry.omit({ id: true, user_id: true, created_at: true });
export const updateHabitEntryInput = createHabitEntryInput.partial().extend({ id: z.string().uuid() });

// Tracked State Definitions
export const createTrackedStateDefInput = TrackedStateDef.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateTrackedStateDefInput = createTrackedStateDefInput.partial().extend({ id: z.string().uuid() });
export const GetTrackedStateDefByIdInput = z.object({ id: z.string().uuid() });
export const DeleteTrackedStateDefInput = z.object({ id: z.string().uuid() });

// State Entries
export const CreateStateEntryInput = StateEntry.omit({ id: true, user_id: true })
.extend({
  tracked_state_def_id: z.string().uuid(), // Ensure this is required
  // Values are optional in base schema
});
export const updateStateEntryInput = CreateStateEntryInput.partial().extend({ id: z.string().uuid() });
export const GetStateEntriesInput = z.object({
  tracked_state_def_id: z.string().uuid(), // Renamed from definition_id to match DB? Check usage.
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  limit: z.number().int().positive().optional(),
});
export const DeleteStateEntryInput = z.object({ id: z.string().uuid() });

// Rewards (Assuming rewards definitions are managed elsewhere)
// No create/update for Reward definitions needed via API?
export const claimLootInput = z.object({
  rewardId: z.string().uuid(), // Use rewardId to match router
});

// Badges
export const awardBadgeInput = z.object({
  badgeId: z.string(), // Matches text ID in badge_definitions
  description: z.string().optional(), // Example custom field if needed
});

// Reminders
export const createReminderInput = Reminder.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateReminderInput = createReminderInput.partial().extend({ id: z.string().uuid() });
export const GetRemindersForEntityInput = z.object({
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
});
export const DeleteReminderInput = z.object({ id: z.string().uuid() });

// Goal Progress Notes
export const createGoalProgressNoteInput = GoalProgressNote.omit({ id: true, user_id: true, created_at: true });
export const updateGoalProgressNoteInput = createGoalProgressNoteInput.partial().extend({ id: z.string().uuid() });
export const GetGoalProgressNotesInput = z.object({ goal_id: z.string().uuid() });
export const DeleteGoalProgressNoteInput = z.object({ id: z.string().uuid() });

/* ------------------------------------------------------------------
 * Aggregate Router Types – automatically inferred
 * ----------------------------------------------------------------*/
export type RouterInputs = inferRouterInputs<AppRouter>;
export type RouterOutputs = inferRouterOutputs<AppRouter>;

/*
  Usage (client‑side):

  const utils = trpc.useUtils();
  type TasksOutput = RouterOutputs['task']['getTasks'];
  type CreateTaskInput = RouterInputs['task']['createTask'];
*/```
\n\n# 7️⃣ Assets
\n\n## Font Files in assets/fonts:
total 184
drwxr-xr-x  3 tylerbedford  staff     96 Apr 23 09:37 .
drwxr-xr-x  5 tylerbedford  staff    160 Apr 29 22:50 ..
-rwxr-xr-x  1 tylerbedford  staff  93252 Apr 21 23:33 SpaceMono-Regular.ttf
\n\n## Lottie Files in assets:
assets/refresh-sheikah.json

  ```

- **project_structure.txt** (6.0 KB, 187 lines) *(No explicit exports)*

  ```txt
/Users/tylerbedford/Documents/Coding Projects/AetherIphone
├── AETHER_TODO.md
├── Projects/
│   └── AetherIphone/
│       ├── __tests__/
│       │   ├── components/
│       │   │   ├── lists/
│       │   │   └── ui/
│       │   │       └── primitives/
│       │   └── server/
│       │       └── routers/
│       ├── components/
│       │   ├── lists/
│       │   └── ui/
│       │       └── primitives/
│       └── supabase/
│           └── migrations/
├── README.md
├── REFACTORING_PLAN_V2.yaml
├── SUPABASE_INTEGRATION.md
├── __tests__/
│   ├── components/
│   │   ├── dashboard/
│   │   │   └── HabitCheckItem.test.tsx
│   │   ├── lists/
│   │   │   ├── GoalList.test.tsx
│   │   │   ├── HabitList.test.tsx
│   │   │   └── TaskList.test.tsx
│   │   ├── ui/
│   │   │   └── primitives/
│   │   │       ├── AetherCard.test.tsx
│   │   │       └── AetherListItem.test.tsx
│   └── server/
│       ├── routers/
│       │   ├── dashboardRouter.getWeeklyProgress.test.ts
│       │   ├── dashboardRouter.test.ts
│       │   ├── habitRouter.test.ts
│       │   └── taskRouter.toggleTask.test.ts
│       └── test-helpers.ts
│   └── test-utils.tsx
├── aether_styling_context.txt
├── app/
│   ├── (auth)/
│   │   ├── _layout.tsx
│   │   ├── forgot-password.tsx
│   │   ├── login.tsx
│   │   └── register.tsx
│   ├── (tabs)/
│   │   ├── _layout.tsx
│   │   ├── compass/
│   │   │   └── index.tsx
│   │   ├── home/
│   │   │   └── index.tsx
│   │   ├── journal/
│   │   │   ├── _layout.tsx
│   │   │   ├── entries/
│   │   │   │   ├── index.tsx
│   │   │   │   └── [id].tsx
│   │   │   └── index.tsx
│   │   ├── profile/
│   │   │   └── index.tsx
│   │   └── settings/
│   │       ├── _layout.tsx
│   │       ├── account.tsx
│   │       ├── appearance.tsx
│   │       ├── data-sync.tsx
│   │       ├── feedback.tsx
│   │       └── index.tsx
│   ├── _layout.tsx
│   ├── index.tsx
│   └── modal.tsx
├── app.config.ts
├── app.json
├── assets/
│   ├── animations/
│   │   └── sheikah-loader.json
│   ├── fonts/
│   │   └── SpaceMono-Regular.ttf
│   ├── images/
│   │   ├── adaptive-icon.png
│   │   ├── favicon.png
│   │   ├── icon.png
│   │   └── splash.png
│   └── refresh-sheikah.json
├── babel.config.js
├── components/
│   ├── AuthForm.tsx
│   ├── ControlledInput.tsx
│   ├── ControlledSwitch.tsx
│   ├── DashboardHeader.tsx
│   ├── EditScreenInfo.tsx
│   ├── ExternalLink.tsx
│   ├── Themed.tsx
│   ├── calendar/
│   │   └── DateStrip.tsx
│   ├── dashboard/
│   │   ├── DashboardSection.tsx
│   │   ├── GoalSummaryCard.tsx
│   │   ├── HabitCheckItem.tsx
│   │   ├── StateIndicator.tsx
│   │   ├── TaskItem.tsx
│   │   └── WeeklyProgressChart.tsx
│   ├── hooks/
│   │   └── useRefreshControl.tsx
│   ├── lists/
│   │   ├── GoalList.tsx
│   │   ├── HabitList.tsx
│   │   └── TaskList.tsx
│   ├── modal/
│   │   └── AddItemModal.tsx
│   └── ui/
│       ├── EmptyOrSkeleton.tsx
│       └── primitives/
│           ├── AetherCard.tsx
│           ├── AetherIconButton.tsx
│           ├── AetherListItem.tsx
│           ├── AetherSegmentedControl.tsx
│           ├── AetherSheet.tsx
│           └── AetherSwitch.tsx
├── constants/
│   ├── Colors.ts
│   ├── Motion.ts
│   └── Styles.ts
├── debug_context.txt
├── eas.json
├── expo-env.d.ts
├── gather_debug_info.js
├── index.js
├── jest.config.server.js
├── jest.config.ui.js
├── jest.setup.js
├── metro.config.js
├── package.json
├── postcss.config.js
├── providers/
│   └── Providers.tsx
├── scripts/
│   ├── generate-all.js
│   ├── generate-trpc-client.js
│   └── generate-trpc-types.js
├── server/
│   ├── index.ts
│   ├── src/
│   │   ├── context.ts
│   │   ├── db/
│   │   │   └── schema.ts
│   │   ├── lib/
│   │   │   └── dateUtils.ts
│   │   ├── router.ts
│   │   ├── routers/
│   │   │   ├── _app.ts
│   │   │   ├── auth.ts
│   │   │   ├── dashboard.ts
│   │   │   ├── goal.ts
│   │   │   ├── habit.ts
│   │   │   ├── journal.ts
│   │   │   └── task.ts
│   │   ├── trpc.ts
│   │   └── types/
│   │       └── trpc.ts
│   └── tsconfig.json
├── stores/
│   ├── authStore.ts
│   └── uiStore.ts
├── supabase/
│   ├── config.toml
│   ├── functions/
│   │   └── _shared/
│   │       ├── cors.ts
│   │       └── supabaseAdmin.ts
│   ├── migrations/
│   │   └── ... (omitted content)
│   └── seed.sql
├── tailwind.config.js
├── tamagui.config.ts
├── tsconfig.json
├── types/
│   ├── api.ts
│   ├── components.ts
│   └── domain.ts
├── utils/
│   ├── api.ts
│   ├── query-client.ts
│   ├── supabase.ts
│   └── trpc.ts
└── yarn.lock

  ```

- **refactor_checklist.md** (5.6 KB, 134 lines) *(No explicit exports)*

  ```md
# Aether App – Holistic Refactor Checklist

> Generated: 2025-04-27

This document is derived from a **second-pass audit** of the current codebase (`app/`, `components/`, `utils/`, `types/`) and the **Supabase schema** in `types/database.types.ts`.  It enumerates every outstanding task, design consideration, and cross-dependency needed to land the new Home / Planner / Compass / Rewards architecture.

---

## 0  Legend
- [ ] = Not started   ☐
- [~] = In-progress    ~
- [x] = Done           ✔

---

## 1  Design-System / Tamagui
| ID | Task | Blocking / Notes |
|:-|---|---|
| DS-1 | [x] Finalize **brand tokens** (`$brandBlue`, `$brandGreen`, …) in `tamagui.config.ts`. | ✓ Added brand colors with light/dark variants |
| DS-2 | [x] Generate **light / dark** theme objects with Tamagui CLI, merge overrides. | ✓ Updated theme objects with brand colors |
| DS-3 | [x] Create shared **Card**, **ListItem**, **SectionHeader** primitives with spacing & shadows. | ✓ Created in components/ui/primitives |
| DS-4 | [ ] Audit code for **literal hex / spacing** → replace with tokens. | Will be done incrementally as we refactor screens |
| DS-5 | [x] Enable **system colour-scheme** in `Providers.tsx` (currently forced light). | ✓ Using currentTheme from useUiStore |

---

## 2  Data Layer (tRPC ⇄ Supabase)
| ID | Task | Tables / Types | Blocks |
|:-|---|---|---|
| DL-1 | [~] Ensure **goalRouter**, **habitRouter**, **taskRouter** have full CRUD + list procedures. | `goals`, `habits`, `tasks` | |
| DL-1a | [x] Implement **habitRouter.toggleHabit** for dashboard habit check-in. | `habits`, `habit_entries` | |
| DL-2 | [ ] Create **dashboardRouter.getDashboardData** aggregate query. | multiple | |
| DL-3 | [ ] Add **analyticsRouter** (`streaks`, `goalProgress`, `points`). | materialised views | Compass |
| DL-4 | [ ] Implement **rewardsRouter** (`list`, `earnReward`). | `rewards`, `points_ledger`, `badge_definitions` | Rewards |
| DL-5 | [ ] Wire **Supabase JWT refresh** in tRPC link (Providers). | | |
| DL-6 | [ ] Integrate **offline-mutation queue** helper in every mutation. | utils/offline-mutations.ts | |

---

## 3  Screens – Functional Requirements

### 3.1  Home (Dashboard)
- [ ] Fetch `dashboard.getDashboardData`.
- [ ] Render sections:
  - GoalProgressCard list (progress ring).
  - HabitCheckItem list (today entries).  **Mutation:** `habit.toggleEntry` (optimistic + haptics).
  - TaskRow list (upcoming ≤ tomorrow).
- [ ] Quick-action buttons → create modals.
- [ ] Empty & error states via `EmptyOrSkeleton` / `SectionError`.

### 3.2  Planner
- [ ] Segmented Tabs (`Goals | Habits | Tasks`).
- [ ] Each tab = `FlatList` powered by `goal.list`, `habit.list`, `task.list`.
- [ ] Pull-to-refresh, skeleton, empty.
- [ ] Swipe actions: delete / mark done.
- [ ] “+” FAB routes to context-aware add-* modal.

### 3.3  Compass
- [ ] Queries: `analytics.streaks`, `analytics.goalProgress`, `analytics.points`.
- [ ] Charts: `StreakChart`, `ProgressChart` (victory-native).
- [ ] Time-range filter (7 d / 30 d / All).
- [ ] Empty placeholder until views ready.

### 3.4  Rewards
- [ ] List `rewards.list` & `badges.list`.
- [ ] Grid / list toggle (existing code partial).
- [ ] `earnReward` mutation with confirmation alert & toast.
- [ ] Points balance top-bar (from `analytics.points`).

### 3.5  Settings
- [ ] Profile form (bind to `profiles` table).
- [ ] Toggle rows persisted via `utils/settings.ts`.
- [ ] Static pages (About, Help) markdown render.

---

## 4  Creation & Detail Screens
| Entity | Create Fields | Detail Functions |
|-|-|-|
| Goal | title, description, target_date | edit, delete, progress slider |
| Habit | title, cue, routine, reward | streak graph, edit, delete |
| Task | title, notes, due, priority, goal_id (optional) | mark done, edit, delete |

All use **react-hook-form + zod** and share `FormField` component.

---

## 5  Reusable Components to Implement
- [x] `GoalCard`, `HabitCard`, `TaskCard` (Tap-able Card rows) - implemented in components/lists/*.
- [x] `GoalList`, `HabitList`, `TaskList` (FlatList wrappers) - implemented in components/lists/*.
- [ ] `StreakChart`, `ProgressChart` (SVG charts).
- [ ] `BadgeCard`, `PointsBalanceBar`.
- [ ] `SectionError` banner.

---

## 6  UX Enhancements
- [ ] Global haptics: success/error cues (`utils/haptics.ts`).
- [ ] Toast feedback via `@tamagui/toast`.
- [ ] Safe-area aware `ToastViewport` (already done).

---

## 7  Testing & CI
- [x] Jest configuration with proper transformers for React Native and Tamagui.
- [x] Unit tests for primitive components (AetherCard, AetherListItem).
- [x] Unit tests for list components with mock data matching Supabase schema.
- [x] Type-safe tests ensuring database → server → UI type consistency.
- [ ] Test coverage for UI component edge cases (loading, error, empty states).
- [ ] Detox e2e: auth flow, add habit, toggle habit, dashboard refresh.
- [ ] GitHub Actions: lint, test, `expo prebuild`, `eas build --profile preview`.

---

## 8  Technical Debt / Notes
- Planner & Compass screens currently monolithic; will be split per list/tab.
- TypeScript strict mode is **on** – types must be correct.
- Some `ScrollView` imports still present after FlatList migration (clean up).
- `Providers.tsx` temporarily forces `light` theme; remove once DS-2 done.

---

## 9  Priority Roadmap (macro)
1. **DS-1 → DS-3** (Design system foundation)
2. **DL-1 + DL-2** (Core routers) & **DL-6** (offline queue)
3. **Home** rewrite (shows immediate value)
4. **Planner** refactor (lists & CRUD)
5. **Creation / Detail** screens
6. **Analytics views + Compass** MVP
7. **Rewards** MVP
8. **Testing & CI** hardening

> **Next Action:** Start DS-1: finalise brand tokens in `tamagui.config.ts`.

  ```

- **refactoring_plan.md** (8.8 KB, 195 lines) *(No explicit exports)*

  ```md
# Aether iOS App – Comprehensive Refactor Plan

> **Last updated:** 2025-04-27
>
> This document lays out, in exhaustive detail, how every screen, component, and data interaction in the app should be structured.  It weaves together best-practice guidance from **Expo**, **Tamagui**, **tRPC**, and **Supabase**.

---

## 1  Objectives

1.  Fully embrace iOS design conventions while staying cross-platform-ready.
2.  Establish a robust data layer (tRPC ⇄ Supabase) with offline resilience.
3.  Standardise UI via Tamagui tokens, themes, and reusable components.
4.  Tighten navigation, error handling, accessibility, and performance.
5.  Automate quality via tests and CI/EAS pipelines.

---

## 2  Guiding Principles & Key Packages

| Domain  | Principle | Practical Rules |
|---------|-----------|-----------------|
| **Expo** | Lean on file-based routing (Expo Router) and EAS Build/Submit. | • Keep `_layout.tsx` files focused on navigator config.<br>• Use `expo-constants` + `expo-secure-store` for env secrets in client.<br>• Always wrap root in `SafeAreaProvider`.<br>• Use `expo-updates` channels for staging & prod. |
| **Tamagui** | Treat `tamagui.config.ts` as single source of design truth. | • Reference tokens (`$blue9`, `$space.3`) – never hard-code.<br>• Theme switching: system‐color-scheme by default (re-enable once light theme stabilised).<br>• Respect iOS HIG: generous whitespace & 16 pt default body.<br>• Use `YStack/XStack` instead of `View`/`Row`. |
| **tRPC** | End-to-end types, react-query integration. | • Each model gets `list`, `getById`, `create`, `update`, `delete` procedures.<br>• Split routers by domain (goalRouter, habitRouter, taskRouter, authRouter).<br>• Authed links inject Supabase JWT, refresh on 401. |
| **Supabase** | Postgres + RLS for multitenancy. | • Tables: `goals`, `habits`, `tasks`, `habit_entries`, `rewards`.<br>• Use row-level security: policy `user_id = auth.uid()`.<br>• Database schema lives in `/supabase/migrations`. |

---

## 3  Navigation Hierarchy

```
app/
  _layout.tsx          ← root Stack (auth-gate)
  index.tsx            ← redirects based on auth
  (auth)/              ← login / register / forgot-password
  (tabs)/              ← MainBottomTabs
    _layout.tsx        ← Tab navigator
    home/
      index.tsx        ← Dashboard
    compass/
      index.tsx        ← Analytics / insights
    planner/
      _layout.tsx      ← Planner stack
      index.tsx        ← Master lists (Goals / Habits / Tasks)
      add-goal.tsx
      add-habit.tsx
      add-task.tsx
      goal/[id].tsx
      habit/[id].tsx
    rewards/
      index.tsx        ← Points & redemptions
    settings/
      _layout.tsx      ← Settings stack
      index.tsx        ← List of subsections
      profile.tsx • security.tsx • notifications.tsx • privacy.tsx • about.tsx • help.tsx
```

**Modal vs Push**  
Creation screens (`add-*`) open as **modal** (`presentation:"modal"` in route options). Detail screens push onto Planner stack.

---

## 4  Screen-by-Screen Specs

### 4.1  Home (`(tabs)/home/index.tsx`)
| Concern | Specification |
|---------|---------------|
| **Purpose** | Daily snapshot: goals progress, today’s habits, upcoming tasks. |
| **Data** | `trpc.dashboard.getDashboardData.useQuery()` returns:<br>• `todayHabits: HabitWithEntryStatus[]`<br>• `upcomingTasks: Task[]`<br>• `goalProgress: GoalProgressSummary[]` |
| **UI Layout** | `ScrollView` inside `SafeAreaView`<br>1.  Header (date, greeting).<br>2.  Quick actions (`Add Habit`, `Add Task`).<br>3.  Sections (each uses `DashboardSection`). |
| **Components** | `GoalProgressCard`, `HabitCheckItem`, `TaskRow`, `EmptyOrSkeleton`, `SectionError`. |
| **State Flow** | • Loading → skeleton placeholders.<br>• Error → `SectionError` with retry.<br>• Success → render data. |
| **Interactions** | • Habit toggle → `trpc.habit.toggleEntry.useMutation()` (optimistic).<br>• Quick actions navigate to modal create screens. |

### 4.2  Planner Index (`(tabs)/planner/index.tsx`)
| | |
|---|---|
| **Purpose** | Full management: list, filter, search all goals/habits/tasks. |
| **Data** | Three queries in parallel with `useSuspenseQueries`:<br>• `trpc.goal.list`<br>• `trpc.habit.list`<br>• `trpc.task.list` |
| **UI** | Segmented control (`Tabs` from Tamagui) switching between lists.<br>Each list is a `FlatList` with pull-to-refresh.<br>FAB (`+`) opens context-aware create modal. |
| **Empty State** | Illustrated placeholder with “Create first x” button. |

### 4.3  Creation Modals (`add-goal.tsx`, `add-habit.tsx`, `add-task.tsx`)
* Use `react-hook-form` + `zodResolver` for validation.
* Fields follow tamagui `<Fieldset><Label><Input/></Fieldset>` pattern.
* Submit triggers appropriate `create` mutation; on success:
  1. Invalidate relevant list/dash queries via `queryClient.invalidateQueries()`.
  2. Show success toast (`Toast.show({message})`).
  3. Dismiss modal (`router.back()`).

### 4.4  Detail Screens
* Fetch by ID query.
* Show read-only view first, edit via top-right `Edit`.
* Edit toggles form mode; on save uses `update` mutation.
* Danger zone section for `Delete` (with confirmation alert).  

### 4.5  Compass & Rewards (MVP)
* Placeholder charts via `react-native-svg` + `victory-native`.
* Data endpoints to be defined later (analytics / point ledger).

### 4.6  Settings Stack
* Grouped list UI (`ListItem` with chevron).
* Each subsection is a simple form or markdown doc.

---

## 5  Reusable Components Library
| Component | Description | Notes |
|-----------|-------------|-------|
| `DashboardSection` | Card-like container with title & optional action. | Accepts `isLoading`, `isError`, etc. |
| `EmptyOrSkeleton` | Wrapper deciding Skeleton / Empty state / children. | Centralises UX logic. |
| `SectionError` | Banner with retry button. | Use $gray3 background, $red9 accents. |
| `ProgressRing` | Circular SVG progress. | Now typed with `ColorTokens`. |
| `FormField` | Label + Input + error msg. | Driven by RHF context. |
| `ToastViewport` | Safe-area aware toasts (already implemented). | |

---

## 6  State & Logic
* **Zustand stores**: `uiStore` (theme, network), `authStore` (session, user).
* **Offline**: react-query mutation queue; network detector triggers flush.
* **Auth**: Supabase listener → refresh JWT → inject into tRPC link header.

---

## 7  Environment & Secrets
```ini
# app.config.js reads these via process.env
EXPO_PUBLIC_SUPABASE_URL     = https://xyz.supabase.co
EXPO_PUBLIC_SUPABASE_ANON_KEY= ********
EXPO_PUBLIC_API_URL          = https://api.myapp.com/trpc
```
* In EAS, configure **development**, **preview**, **production** channels each with distinct env groups.

---

## 8  Testing & CI
* **Unit**: Jest + @testing-library/react-native (components, hooks).
* **E2E**: Detox flows – login, create habit, toggle habit, logout.
* **CI**: GitHub Actions → run `yarn test`, `expo prebuild --platform ios`, `eas build --profile preview`.

---

## 9  TODO Checklist (Living)

- [ ] **Fix remaining TypeScript & Markdown lints**  
  _Context:_ CI must be green before EAS builds.

- [ ] **Home screen polish**  
  - [ ] Final spacing & theming tweaks  
  - [ ] Hook `utils/offline-mutations.ts` into habit toggle  
  - [ ] Add success haptic via `utils/haptics.ts`

- [ ] **Offline mutation wiring (global prerequisite)**  
  _Integrate `queueOfflineMutation()` into every create/update/toggle/delete mutation across the app._

- [ ] **Add haptics feedback (cross-cutting)**  
  _Call `triggerSuccess()` / `triggerError()` after key user actions._

- [ ] **Planner refactor**  
  - [ ] Implement segmented lists in `(tabs)/planner/index.tsx` using `useSuspenseQueries`  
  - [ ] Swipe-to-delete with optimistic update (depends on offline wiring)

- [ ] **Creation modals**  
  - [ ] Build `add-goal.tsx` (react-hook-form + zod)  
  - [ ] Build `add-habit.tsx`  
  - [ ] Build `add-task.tsx`  
  _Prerequisite:_ offline mutation wiring.

- [ ] **Detail screens**  
  - [ ] Fetch by ID queries  
  - [ ] Edit mode with update mutation  
  - [ ] Delete action with confirmation (depends on offline wiring)

- [ ] **Compass & Rewards MVP**  
  - [ ] Define Supabase views (`goal_progress_view`, `streaks_view`)  
  - [ ] Create `rewards` / `points_ledger` tables & tRPC routers  
  - [ ] Implement charts with `victory-native`

- [ ] **Settings stack implementation**  
  - [ ] Profile form bound to `profiles` table  
  - [ ] Toggle switches saved via `utils/settings.ts`

- [ ] **Token audit** – replace any literal colour/spacing values with Tamagui tokens.

- [ ] **Remove duplicate** `app/planner/add-habit.tsx` once confirmed unused.

- [ ] **Testing & CI**  
  - [ ] Jest unit coverage for utils & components  
  - [ ] Detox e2e flows (auth, create habit, toggle habit)  
  - [ ] GitHub Actions + EAS Build pipelines

> **Next Immediate Step:** Start Planner index refactor (checkbox above).

  ```

- **styling_report.txt** (6.9 KB, 235 lines) *(No explicit exports)*

  ```txt
# AetherIphone Tamagui Styling Report

This document outlines the styling approach used in the AetherIphone application, leveraging the Tamagui UI library.

## 1. Core Theme Setup (`Providers.tsx`)

The application's root is wrapped by `TamaguiProvider` within `Providers.tsx`. This provider injects the theme configuration and dynamically sets the theme based on the user's system preferences (light/dark mode).

```typescript
// Simplified snippet from providers/Providers.tsx
import { TamaguiProvider } from 'tamagui';
import config from '../tamagui.config';
import { useColorScheme } from 'react-native';

export function Providers({ children }: { children: React.ReactNode }) {
  const colorScheme = useColorScheme() ?? 'light';

  return (
    <TamaguiProvider config={config} defaultTheme={colorScheme}>
      {/* ... other providers ... */}
      {children}
    </TamaguiProvider>
  );
}
```

## 2. Theme Configuration (`tamagui.config.ts`)

This file is the central definition for the application's design system.

### 2.1. Tokens

Tokens define the fundamental building blocks (colors, spacing, fonts, etc.).

```typescript
// Snippet from tamagui.config.ts (Tokens)
const tokens = createTokens({
  size: { 0: 0, 1: 4, ..., 16: 64, true: 16 },
  space: { 0: 0, 1: 4, ..., 16: 64, true: 16, '-1': -4, ... },
  radius: { 0: 0, 1: 3, ..., 10: 32, true: 10 },
  zIndex: { 0: 0, 1: 100, ..., 5: 500 },
  color: {
    // Light Theme Brand Colors
    brandBlue: '#007AFF',
    brandGreen: '#34C759',
    // ... other brand colors ...

    // Dark Theme Brand Colors
    brandBlue_dark: '#0A84FF',
    brandGreen_dark: '#30D158',
    // ... other dark brand colors ...

    // Radix Grays (Light & Dark)
    gray1: '#fcfcfc', ..., gray12: '#171717',
    gray1_dark: '#191919', ..., gray12_dark: '#ededed',

    white: '#FFFFFF',
    black: '#000000',
  },
});
```

### 2.2. Themes

Themes map semantic roles (like background, text color, primary action color) to specific tokens for both light and dark modes.

```typescript
// Snippet from tamagui.config.ts (Themes)
const lightTheme = {
  background: tokens.color.gray2,
  backgroundHover: tokens.color.gray3,
  backgroundPress: tokens.color.gray4,
  backgroundStrong: tokens.color.white, // e.g., Card background
  color: tokens.color.gray12,
  colorSecondary: tokens.color.gray11,
  borderColor: tokens.color.gray6,
  borderColorFocus: tokens.color.brandBlue,
  primary: tokens.color.brandBlue,
  success: tokens.color.brandGreen,
  error: tokens.color.brandRed,
  inputBackground: tokens.color.white,
  cardBackground: tokens.color.white,
  shadowColor: tokens.color.gray8,
  // ... other light theme definitions
};

const darkTheme: typeof lightTheme = {
  background: tokens.color.gray1_dark,
  backgroundHover: tokens.color.gray3_dark,
  // ... maps roles to dark tokens ...
  color: tokens.color.gray12_dark,
  borderColor: tokens.color.gray5_dark,
  borderColorFocus: tokens.color.brandBlue_dark,
  primary: tokens.color.brandBlue_dark,
  cardBackground: tokens.color.gray2_dark,
  shadowColor: tokens.color.black, // Example: Darker shadow
  // ... other dark theme definitions
};

// Config creation
const config = createTamagui({
  // ... fonts, animations ...
  tokens,
  themes: {
    light: lightTheme,
    dark: darkTheme,
  },
});
```

## 3. Theme Usage Examples

Components leverage the theme configuration for consistent styling.

### 3.1. Screen Example (`app/(tabs)/planner/index.tsx`)

Screens use layout components and apply theme tokens for spacing, sizing, and colors.

```typescript
// Snippet from app/(tabs)/planner/index.tsx
import { YStack, XStack, Text, Tabs, Button, ScrollView } from 'tamagui';

// ...
<YStack flex={1} padding="$4"> // Use space token for padding
  <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
    <Text fontSize={24} fontWeight="bold">Planner</Text>
    <Button
      size="$3" // Use size token
      // ...
    />
  </XStack>

  <Tabs.List
    backgroundColor="$backgroundStrong" // Use semantic color token
    borderRadius="$4" // Use radius token
    marginBottom="$4"
  >
    {TABS.map((tab) => (
      <Tabs.Tab
        key={tab.key}
        flex={1}
        value={tab.key}
        padding="$3"
        borderRadius="$2"
        backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'} // Conditional semantic color
      >
        {/* ... */}
      </Tabs.Tab>
    ))}
  </Tabs.List>

  {/* Example Goal Item using Button */}
  <Button
    key={goal.id}
    height="$12" // Use size token
    // ...
  >
    <YStack>
      <Text fontWeight="bold">{goal.title}</Text>
      <Text fontSize="$2" color="$gray10"> {/* Use direct color token */} 
        {/* ... */}
      </Text>
    </YStack>
  </Button>

</YStack>
```

### 3.2. Primitive Component Example (`components/ui/primitives/AetherCard.tsx`)

Custom components are built using Tamagui's `styled` API and theme tokens, often with variants for different appearances.

```typescript
// Snippet from components/ui/primitives/AetherCard.tsx
import { Card, CardProps, styled } from 'tamagui';

const StyledCard = styled(Card, {
  name: 'AetherCard',
  backgroundColor: '$cardBackground', // Use semantic color
  borderRadius: '$4', // Use radius token
  padding: '$4', // Use space token
  elevate: true,

  variants: {
    variant: {
      default: {
        shadowColor: '$shadowColor',
        // ... default styles using tokens
      },
      elevated: {
        shadowColor: '$shadowColor',
        // ... elevated styles using tokens
      },
      outlined: {
        backgroundColor: 'transparent',
        borderColor: '$borderColor', // Use semantic color
        // ... outlined styles using tokens
      },
    },
    isInteractive: {
      true: {
        pressStyle: {
          backgroundColor: '$cardBackgroundPress', // Use semantic color for interaction
          opacity: 0.9,
        },
        hoverStyle: {
          backgroundColor: '$cardBackgroundHover', // Use semantic color for interaction
        },
      },
    },
  } as const,

  defaultVariants: {
    variant: 'default',
    isInteractive: false,
  },
});

export function AetherCard({ children, variant, isInteractive, ...props }: AetherCardProps) {
  return (
    <StyledCard variant={variant} isInteractive={isInteractive} {...props}>
      {children}
    </StyledCard>
  );
}
```

## 4. Summary & Best Practices

- **Consistency:** Using theme tokens (`$size`, `$color`, `$space`) ensures visual consistency.
- **Semantic Colors:** Leveraging semantic theme roles (`$background`, `$primary`, `$cardBackground`) allows components to adapt automatically to light/dark modes.
- **Custom Components:** Building reusable, themed components (like `AetherCard`) encapsulates styling logic.
- **Avoid Hardcoding:** Minimize hardcoded style values (like hex codes or pixel values) directly in components; prefer theme tokens.
- **Platform Adaptation:** The configuration handles font differences between web and native automatically.

  ```

- **tailwind.config.js** (3.1 KB, 110 lines) *(No explicit exports)*

  ```js
/** @type {import('tailwindcss').Config} */
// Import the Zelda theme tokens
const zelda = require('./design-system/tokens');
// Import NativeWind preset
const nativewind = require('nativewind/preset');

module.exports = {
  presets: [nativewind],
  content: [
    "./app/**/*.{js,jsx,ts,tsx}",
    "./components/**/*.{js,jsx,ts,tsx}",
    "./design-system/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {
      fontFamily: {
        'heading': ['HyliaSerif'],
        'body': ['CalamitySans'],
      },
      colors: {
        // Zelda theme colors
        'parchment': zelda.colors.parchment,
        'sheikahCyan': zelda.colors.sheikahCyan,
        'korokGreen': zelda.colors.korokGreen,
        'darkText': zelda.colors.darkText,
        'guardianOrange': zelda.colors.guardianOrange,
        'darkTealBg': zelda.colors.darkTealBg,
        'cyanGlow': zelda.colors.cyanGlow,
        
        // iOS standard colors
        // iOS system colors
        'ios-blue': '#007AFF',
        'ios-dark-blue': '#0A84FF', // dark mode variant
        'ios-red': '#FF3B30',
        'ios-dark-red': '#FF453A', // dark mode variant
        'ios-green': '#34C759',
        'ios-dark-green': '#30D158', // dark mode variant
        'ios-orange': '#FF9500',
        'ios-dark-orange': '#FF9F0A', // dark mode variant
        'ios-purple': '#AF52DE',
        'ios-dark-purple': '#BF5AF2', // dark mode variant
        'ios-yellow': '#FFCC00',
        'ios-dark-yellow': '#FFD60A', // dark mode variant
        'ios-pink': '#FF2D55',
        'ios-dark-pink': '#FF375F', // dark mode variant
        'ios-indigo': '#5856D6',
        'ios-dark-indigo': '#5E5CE6', // dark mode variant
        
        // iOS gray palette
        'ios-gray': {
          1: '#8E8E93',
          2: '#AEAEB2',
          3: '#C7C7CC',
          4: '#D1D1D6',
          5: '#E5E5EA',
          6: '#F2F2F7',
        },
        'ios-dark-gray': {
          1: '#8E8E93',
          2: '#636366',
          3: '#48484A',
          4: '#3A3A3C',
          5: '#2C2C2E',
          6: '#1C1C1E',
        },
        
        // System background colors
        'ios-system': {
          DEFAULT: '#FFFFFF',
          secondary: '#F2F2F7',
          tertiary: '#FFFFFF',
        },
        'ios-dark-system': {
          DEFAULT: '#000000',
          secondary: '#1C1C1E',
          tertiary: '#2C2C2E',
        },
      },
      
      // iOS standard spacing
      spacing: {
        // Added standard iOS spacing if needed beyond Tailwind defaults
      },
      
      // iOS standard border radius
      borderRadius: {
        'ios-small': '4px',
        'ios-regular': '8px',
        'ios-large': '12px',
        'ios-xl': '16px',
      },
      
      // iOS system font weights
      fontWeight: {
        'ios-regular': '400',
        'ios-medium': '500', 
        'ios-semibold': '600',
        'ios-bold': '700',
      },
      
      // iOS shadows
      boxShadow: {
        'ios-small': '0 1px 2px rgba(0, 0, 0, 0.05)',
        'ios-medium': '0 2px 4px rgba(0, 0, 0, 0.1)',
        'ios-large': '0 4px 6px rgba(0, 0, 0, 0.1)',
      },
    },
  },
  plugins: [],
}; 
  ```

- **tamagui.config.ts** (12.8 KB, 365 lines) Exports: `default`

  ```ts
// tamagui.config.ts
import { createAnimations } from '@tamagui/animations-react-native';
import { createFont, createTamagui, createTokens } from 'tamagui';
import { Platform } from 'react-native';
import * as MotionConstants from '@/constants/motion'; // Import motion constants

// Font definitions - Zelda Theme
// Assumes 'CalamitySans' and 'HyliaSerif' are loaded via useFonts or similar
const headingFont = createFont({
  family: 'HyliaSerif', // Zelda Display Font
  size: {
    // Mapped closer to iOS Dynamic Type: https://developer.apple.com/design/human-interface-guidelines/typography
    1: 13,  // Caption 2
    2: 15,  // Subheadline
    3: 17,  // Body (true default)
    4: 20,  // Title 3
    5: 22,  // Title 2
    6: 28,  // Title 1
    7: 34,  // Large Title
    8: 40,  // Extra Large Title (custom)
    true: 17, // Default size (Body)
  },
  lineHeight: {
    // Approximate line heights based on new sizes
    1: 18, 2: 20, 3: 22, 4: 25, 5: 28, 6: 34, 7: 41, 8: 50, 
    true: 22,
  },
  weight: {
    // Prompt 2 asks for 400-700
    4: '400', // Normal
    6: '600', // Semi-bold/Bold
    7: '700', // Extra-bold/Black
    true: '400',
  },
  letterSpacing: {
    1: 0, 2: 0, 3: -0.5, 4: -0.5, 5: -1, 6: -1, 7: -1.5, 8: -1.5,
    true: 0,
  },
  // Required: Map weights to specific font faces if needed (e.g., 'HyliaSerif-Bold')
  // face: {
  //   400: { normal: 'HyliaSerif-Regular' },
  //   700: { normal: 'HyliaSerif-Bold' },
  // },
});

const bodyFont = createFont({
  family: 'CalamitySans', // Zelda Body Font
  size: {
    // Mapped closer to iOS Dynamic Type
    1: 11,  // Footnote
    2: 12,  // Caption 1
    3: 13,  // Caption 2
    4: 15,  // Subheadline
    5: 17,  // Body (true default)
    6: 20,  // Title 3 (matching headingFont.$4)
    true: 17, // Default body size
  },
  lineHeight: {
    // Approximate line heights
    1: 13, 2: 16, 3: 18, 4: 20, 5: 22, 6: 25,
    true: 22, // Default body line height
  },
  weight: {
    4: '400', // Regular
    5: '500', // Medium (if available)
    7: '700', // Bold (if needed/available)
    true: '400',
  },
  letterSpacing: {
    1: 0.1, 2: 0.1, 3: 0, 4: 0, 5: -0.1, 6: -0.1,
    true: 0,
  },
  // Required: Map weights to specific font faces if needed (e.g., 'CalamitySans-Medium')
  // face: {
  //   400: { normal: 'CalamitySans-Regular' },
  //   500: { normal: 'CalamitySans-Medium' },
  // },
});

const monoFont = createFont({
  family: Platform.select({ web: 'monospace', default: 'SpaceMono' }), // Keep SpaceMono for code
  size: {
    1: 12, 2: 14, 3: 15, 4: 16, 5: 18, 6: 20, true: 15,
  },
  lineHeight: {
    1: 18, 2: 22, 3: 24, 4: 26, 5: 28, 6: 32, true: 24,
  },
  weight: {
    4: '400', // Normal weight
    true: '400',
  },
  letterSpacing: {
    4: 0,
    true: 0,
  },
  face: {
    400: { normal: 'SpaceMono' }, // Map weight 400 to the loaded SpaceMono font
  },
});

// Animation driver using reanimated
const animations = createAnimations({
  fast: {
    type: 'timing',
    duration: MotionConstants.durations.standard,
    // easing: MotionConstants.easings.standard, // Removed as createAnimations defaults work well
  },
  medium: {
    type: 'timing',
    duration: MotionConstants.durations.modal,
  },
  slow: {
    type: 'timing',
    duration: MotionConstants.durations.long,
  },
  bouncy: {
    type: 'spring',
    damping: 9,
    mass: 0.9,
    stiffness: 150,
  },
  lazy: {
    type: 'spring',
    damping: 18,
    stiffness: 50,
  },
  quick: {
    type: 'spring',
    damping: 20,
    mass: 1.2,
    stiffness: 250,
  },
});

// Standard Radix Gray scale (light theme)
const gray = {
  gray1: '#fcfcfc', gray2: '#f8f8f8', gray3: '#f3f3f3', gray4: '#ededed', gray5: '#e8e8e8', gray6: '#e2e2e2', gray7: '#dbdbdb', gray8: '#c7c7c7', gray9: '#8f8f8f', gray10: '#858585', gray11: '#6f6f6f', gray12: '#171717',
};

// Standard Radix Gray scale (dark theme)
const grayDark = {
  gray1: '#191919', gray2: '#212121', gray3: '#282828', gray4: '#303030', gray5: '#393939', gray6: '#424242', gray7: '#4f4f4f', gray8: '#626262', gray9: '#737373', gray10: '#838383', gray11: '#ababab', gray12: '#ededed',
};

// Tokens (refined based on your existing config)
const tokens = createTokens({
  size: {
    0: 0, 1: 4, 2: 8, 3: 12, 4: 16, 5: 20, 6: 24, 7: 28, 8: 32, 9: 36, 10: 40, 11: 44, 12: 48, 13: 52, 14: 56, 15: 60, 16: 64, true: 16,
  },
  space: {
    0: 0, 1: 4, 2: 8, 3: 12, 4: 16, 5: 20, 6: 24, 7: 28, 8: 32, 9: 36, 10: 40, 11: 44, 12: 48, 13: 52, 14: 56, 15: 60, 16: 64, true: 16, '-1': -4, '-2': -8, '-3': -12, '-4': -16,
  },
  radius: {
    0: 0, 1: 3, 2: 5, 3: 8, 4: 10, 5: 14, 6: 16, 7: 20, 8: 24, 9: 28, 10: 32, true: 10, // Updated radius.5 to 14
  },
  zIndex: { 0: 0, 1: 100, 2: 200, 3: 300, 4: 400, 5: 500 },
  color: {
    // Zelda Palette (Prompt 1)
    ...gray, // Add light greys
    ...grayDark, // Add dark greys (will be overridden in dark theme definition)
    parchment: '#FDFFE0',
    sheikahCyan: '#86A5A9',
    korokGreen: '#92C582',
    darkText: '#536F50',
    guardianOrange: '#FF9F0A',
    darkTealBg: '#1A2E3A',
    darkCyanGlow: '#64FFDA',

    // Shadow Colors (Prompt 5)
    shadowColorLight: 'rgba(83, 111, 80, 1)', // dark desaturated text color
    shadowColorDark: 'rgba(0, 0, 0, 1)', // Black base
    white: '#FFFFFF',
    black: '#000000',
  },
});

// Define themes using Zelda Palette
const lightTheme = {
  // Base Colors
  background: tokens.color.parchment,      // Light bg
  backgroundStrong: tokens.color.white,     // Keep white for strong contrast areas if needed
  backgroundTransparent: 'rgba(253, 255, 224, 0)', // Fully transparent parchment
  color: tokens.color.darkText,             // Dark desaturated text
  colorSecondary: tokens.color.darkText,      // Use main text color, maybe slightly lighter if needed later
  colorTertiary: tokens.color.sheikahCyan,    // Use accent for tertiary info?
  borderColor: tokens.color.sheikahCyan,      // Use accent for borders
  borderColorHover: tokens.color.korokGreen,  // Korok green on hover?

  // Theme-specific states (can refine later)
  backgroundHover: tokens.color.parchment,    // Keep parchment, maybe slightly darker/lighter
  backgroundPress: tokens.color.parchment,    // Keep parchment
  backgroundFocus: tokens.color.parchment,    // Keep parchment
  colorHover: tokens.color.korokGreen,        // Korok green text on hover?
  colorPress: tokens.color.korokGreen,
  colorFocus: tokens.color.sheikahCyan,
  borderColorPress: tokens.color.korokGreen,
  borderColorFocus: tokens.color.sheikahCyan,

  // Semantic Tokens (Prompt 4)
  accent: tokens.color.sheikahCyan,
  surfaceSubtle: tokens.color.parchment,    // Base color, apply opacity in component (e.g., rgba(253,255,224,0.8))
  destructive: tokens.color.guardianOrange,

  // Standard Semantic Mapping (can use Zelda colors)
  primary: tokens.color.sheikahCyan,        // Map primary to accent
  secondary: tokens.color.korokGreen,       // Map secondary to korok green?
  success: tokens.color.korokGreen,
  warning: tokens.color.guardianOrange,     // Use guardian orange for warning
  error: tokens.color.guardianOrange,       // Use guardian orange for error
  info: tokens.color.sheikahCyan,

  // Semantic Aliases (Playbook 1.1)
  surface: tokens.color.parchment, // Maps to background
  onSurface: tokens.color.darkText,  // Maps to color
  outline: tokens.color.sheikahCyan, // Maps to borderColor

  // Shadows (Playbook 1.1 & Prompt 5)
  shadowColor: tokens.color.shadowColorLight, // Use darkText color base for shadow
  shadowColorHover: 'rgba(83, 111, 80, 0.15)',
  shadowSm: 'rgba(83, 111, 80, 0.10)', // 10% opacity
  shadowMd: 'rgba(83, 111, 80, 0.15)', // 15% opacity
  shadowLg: 'rgba(83, 111, 80, 0.20)', // 20% opacity

  // Toast Themes (Report Item 6)
  toast_success_background: tokens.color.korokGreen,
  toast_success_color: tokens.color.parchment,
  toast_error_background: tokens.color.guardianOrange,
  toast_error_color: tokens.color.parchment,
  toast_warning_background: tokens.color.guardianOrange, // Often same as error
  toast_warning_color: tokens.color.parchment,
  toast_info_background: tokens.color.sheikahCyan,
  toast_info_color: tokens.color.parchment,
};

const darkTheme: typeof lightTheme = {
  // Base Colors
  ...grayDark, // Override light greys with dark greys
  background: tokens.color.darkTealBg,      // Dark-mode bg
  backgroundStrong: tokens.color.black,       // Black for contrast?
  backgroundTransparent: 'rgba(26, 46, 58, 0)', // Fully transparent dark teal
  color: tokens.color.parchment,          // Use light parchment for text
  colorSecondary: tokens.color.sheikahCyan,   // Sheikah cyan for secondary text
  colorTertiary: tokens.color.korokGreen,     // Korok green for tertiary
  borderColor: tokens.color.sheikahCyan,      // Sheikah cyan borders
  borderColorHover: tokens.color.darkCyanGlow, // Glow cyan on hover?

  // Theme-specific states
  backgroundHover: tokens.color.darkTealBg,   // Keep bg, maybe slightly lighter
  backgroundPress: tokens.color.darkTealBg,
  backgroundFocus: tokens.color.darkTealBg,
  colorHover: tokens.color.darkCyanGlow,
  colorPress: tokens.color.darkCyanGlow,
  colorFocus: tokens.color.darkCyanGlow,
  borderColorPress: tokens.color.darkCyanGlow,
  borderColorFocus: tokens.color.darkCyanGlow,

  // Semantic Tokens (Prompt 4)
  accent: tokens.color.sheikahCyan,
  surfaceSubtle: tokens.color.darkTealBg, // Use dark bg, apply opacity in component
  destructive: tokens.color.guardianOrange,

  // Standard Semantic Mapping
  primary: tokens.color.darkCyanGlow,       // Use glow cyan for primary actions
  secondary: tokens.color.korokGreen,
  success: tokens.color.korokGreen,
  warning: tokens.color.guardianOrange,
  error: tokens.color.guardianOrange,
  info: tokens.color.sheikahCyan,

  // Semantic Aliases (Playbook 1.1)
  surface: tokens.color.darkTealBg,   // Maps to background
  onSurface: tokens.color.parchment,  // Maps to color
  outline: tokens.color.sheikahCyan, // Maps to borderColor

  // Shadows (Playbook 1.1 & Prompt 5)
  shadowColor: tokens.color.shadowColorDark, // Darker shadow for dark mode
  shadowColorHover: 'rgba(0, 0, 0, 0.30)',
  shadowSm: 'rgba(0, 0, 0, 0.20)', // 20% opacity
  shadowMd: 'rgba(0, 0, 0, 0.30)', // 30% opacity
  shadowLg: 'rgba(0, 0, 0, 0.40)', // 40% opacity

  // Toast Themes (Report Item 6)
  toast_success_background: tokens.color.korokGreen,
  toast_success_color: tokens.color.darkTealBg,
  toast_error_background: tokens.color.guardianOrange,
  toast_error_color: tokens.color.darkTealBg,
  toast_warning_background: tokens.color.guardianOrange, // Often same as error
  toast_warning_color: tokens.color.darkTealBg,
  toast_info_background: tokens.color.sheikahCyan,
  toast_info_color: tokens.color.darkTealBg,
};

// Create the Tamagui config
const config = createTamagui({
  animations,
  shouldAddPrefersColorThemes: true,
  themeClassNameOnRoot: true,
  shorthands: {
    // Keep your existing shorthands
    m: 'margin', mt: 'marginTop', mr: 'marginRight', mb: 'marginBottom', ml: 'marginLeft', mx: 'marginHorizontal', my: 'marginVertical',
    p: 'padding', pt: 'paddingTop', pr: 'paddingRight', pb: 'paddingBottom', pl: 'paddingLeft', px: 'paddingHorizontal', py: 'paddingVertical',
    bg: 'backgroundColor', br: 'borderRadius', bw: 'borderWidth', bc: 'borderColor',
    f: 'flex', fd: 'flexDirection', ai: 'alignItems', jc: 'justifyContent', w: 'width', h: 'height',
    ac: 'alignContent',
    als: 'alignSelf',
    btc: 'borderTopColor',
    bbc: 'borderBottomColor',
    blc: 'borderLeftColor',
    brc: 'borderRightColor',
    boc: 'borderColor',
    bs: 'borderStyle',
    dsp: 'display',
    fb: 'flexBasis',
    fg: 'flexGrow',
    fs: 'flexShrink',
    fw: 'flexWrap',
    mah: 'maxHeight',
    maw: 'maxWidth',
    mih: 'minHeight',
    miw: 'minWidth',
    op: 'opacity',
    ov: 'overflow',
    r: 'right',
    shac: 'shadowColor',
    shar: 'shadowRadius',
    shof: 'shadowOffset',
    shop: 'shadowOpacity',
    t: 'top',
    ta: 'textAlign',
    tt: 'textTransform',
    va: 'verticalAlign',
    zi: 'zIndex',
  },
  fonts: {
    // Use Zelda fonts
    heading: headingFont,
    body: bodyFont,
    mono: monoFont, // Keep mono
  },
  themes: {
    light: lightTheme,
    dark: darkTheme,
  },
  tokens,
  media: { // Keep standard media queries
    xs: { maxWidth: 660 }, sm: { maxWidth: 800 }, md: { maxWidth: 1020 }, lg: { maxWidth: 1280 }, xl: { maxWidth: 1420 }, xxl: { maxWidth: 1600 },
    gtXs: { minWidth: 661 }, gtSm: { minWidth: 801 }, gtMd: { minWidth: 1021 }, gtLg: { minWidth: 1281 },
    short: { maxHeight: 820 }, tall: { minHeight: 820 },
    hoverNone: { hover: 'none' }, pointerCoarse: { pointer: 'coarse' },
  },
  settings: {
      allowedStyleValues: 'somewhat-strict',
      autocompleteSpecificTokens: 'except-special',
  },
});

type AppConfig = typeof config;

// Augment Tamagui interface - this is crucial!
declare module '@tamagui/core' {
  // If AppConfig is defined and exported:
  interface TamaguiCustomConfig extends AppConfig {}
}

export default config;
  ```

- **testing_strategy.md** (10.9 KB, 205 lines) *(No explicit exports)*

  ```md
# Testing Strategy

> “If you don’t like unit testing your product, most likely your customers won’t like to test it either.” – Anonymous

This document codifies **how and why** we test every layer of the Aether iPhone application to enable **Test-Driven Development (TDD)**, short feedback cycles, and confidently ship high-quality code.

---

## 1. Tech-Stack & How the Pieces Interact

| Layer | Primary Tech | Purpose | Notes |
|-------|--------------|---------|-------|
| **UI** | Expo + React Native, Tamagui (design system), React Navigation | Interactive surfaces | Tamagui primitives → feature components → screens → stacks/tabs |
| **State** | TanStack Query, Zustand | Remote & local state | React Query for server cache, Async-Storage persister; Zustand for ephemeral UI state |
| **Networking** | tRPC 11, Supabase JS v2 | RPC & DB access | Procedures call Supabase; auth context injected |
| **Backend** | Supabase Postgres (hosted) | Data persistence | Tested via mocked Supabase client to avoid network |
| **Utility** | date-fns, utils/* | Pure helpers | No side-effects, easiest to unit-test |
| **Tooling** | TypeScript, ESLint, Prettier | Static guarantees | `ts-jest` reuses the same TS config |
| **Testing** | Jest 29, Jest-Expo 52, React-Native-Testing-Library 13, Jest-Mock-Extended 4, MSW 2 | Unit / integration | UI runner vs Node runner share config fragments |

> All technologies above are **typed** and **mock-friendly**, which is critical for TDD.

### 1.1 Supabase Schema & Type-Generation

* **Source of Truth** – `/supabase/schema.sql` maintained via Supabase Studio migrations.
* **Type Generation** – `npm run generate-types` executes `supabase gen types typescript --project-id <id>`. Output lives at `types/supabase.ts` and is imported everywhere (`Database['public']['Tables']['tasks']`).
* **Why** – guarantees compile-time correctness of column names, data shapes, and row-level security (RLS) policies exposed via `insert()/update()`.
* **Testing Impact** – mocks use these generated types so any schema drift instantly breaks tests.

---

## 2. Pyramid of Tests

```
          E2E (future: Detox)
        Integration (tRPC ↔ Supabase, Screen ↔ Store)
      Unit (Components, Hooks, Utils, Routers)
  Static Analysis (TypeScript, ESLint)
```

1. **Static Analysis** – compile & lint gates prevent many runtime errors.
2. **Unit Tests** – fast, deterministic, isolate a single module.
3. **Integration Tests** – wire several modules; catch contract drift.
4. **(Optional) E2E** – device-level confidence once the core is solid.

Coverage goal: **≥90 % lines / 100 % critical paths**.

---

## 3. Testing Concerns by Folder

| Path | What to Test | Example Utilities |
|------|--------------|-------------------|
| `components/ui/primitives` | Rendering, style props, accessibility | Snapshot + RTL queries |
| `components/*` lists/cards | Interaction callbacks, conditional rendering | Fire events, assert mockFn calls |
| `screens/*` | Navigation, data hooks, optimistic updates | Mock React-Navigation & React Query provider |
| `modals/*` | Visibility toggles, onDismiss side-effects | Render with mocked store |
| `hooks/*` | Return value, edge cases | Jest timers for async hooks |
| `stores/*` (Zustand) | Initial state, actions mutate correctly | Wrap in `act()` |
| `server/src/routers` | Input validation, happy/edge/error paths | `createCaller()` with DeepMock Supabase |
| `utils/*` | Pure output given input | Table-driven tests |
| **tRPC ↔ Supabase** | Procedure executes correct query chain, returns typed data, handles errors | DeepMock Supabase, assert `.from('tasks').update(...).eq(...).single()` |

### 3.1 Mapping of Procedures ➟ Tables ➟ UI

| Procedure | Supabase Table/Function | Primary UI Consumer | Key Assertions |
|-----------|-------------------------|---------------------|----------------|
| `tasks.list` | `public.tasks` | `TaskList` screen | Returns tasks belonging to user ordered by `created_at` |
| `tasks.toggleTask` | `public.tasks`, `public.goals` (progress calc) | Checkbox in `TaskListItem` | Updates status, cascades goal progress, optimistic cache update |
| `goals.list` | `public.goals` | `GoalList` screen | Pagination & total progress |
| `dashboard.getWeeklyProgress` | SQL `select_weekly_progress` function | Dashboard chart | Aggregates by date; ensures 7 entries |
| `habits.completeHabit` | `public.habits`, `public.habit_completions` | `HabitCheckItem` | Inserts completion row, updates streak |

For each mapping we create **router unit tests** (mock Supabase) **and** **hook/UI integration tests** (MSW mocks). This guarantees end-to-end correctness without real network.

---

## 4. Bidirectional Coverage Matrix (Screen → DB and DB → Screen)

> To ensure **holistic** coverage we loop through the stack **twice**:
>
> 1. **Screen-centric** – every user-facing route is traced down to the exact DB rows it eventually mutates or reads.
> 2. **Schema-centric** – every table/function is traced upward to the screens that surface or modify its data.
>
>  Any missing arrow in either loop exposes a **testing gap**.

### 4.1 Screen-Centric Trace

| Screen (Route) | Primary Hooks | tRPC Procedure(s) | Supabase Table(s)/Function(s) | Current Tests? |
|---------------|--------------|-------------------|-------------------------------|----------------|
| `(tabs)/home` → `TaskList` | `useTasks()` | `tasks.list`, `tasks.toggleTask` | `public.tasks`, `public.goals` | ✅ (`TaskList`, `TaskListItem`, router tests) |
| `(tabs)/planner` → `PlannerScreen` | `usePlanner()` | `planner.getPlan`, `tasks.create` | `public.tasks`, `public.planner` | ⚠️ **Missing Planner tests** |
| `(tabs)/compass` → `CompassScreen` | `useGoals()` | `goals.list`, `goals.create` | `public.goals` | ⚠️ Only router tests, no UI integration |
| `(tabs)/rewards` → `RewardsScreen` | `useRewards()` | `rewards.list`, `rewards.claim` | `public.rewards`, `public.reward_claims` | ❌ **No tests** |
| `(tabs)/settings` → `SettingsScreen` | — (local) | — | — | n/a |
| `(auth)/signin` | Supabase Auth UI | — | `auth.users` | Jest-Expo snapshot only |
| `planner/*` nested routes | `useTaskForm()` | `tasks.create`, `tasks.update` | `public.tasks` | ✅ unit but ⚠️ missing form validation tests |

### 4.2 Schema-Centric Trace

| Table / Function | Used By Procedure(s) | Surface Screen(s) | Tests Present? |
|------------------|----------------------|-------------------|----------------|
| `public.tasks` | `tasks.*`, `planner.getPlan` | Home, Planner | ✅ many but form gaps |
| `public.goals` | `goals.*`, `tasks.toggleTask` | Compass, Home (goal badges) | ⚠️ missing Compass UI tests |
| `public.habits` & `public.habit_completions` | `habits.*` | Dashboard HabitCheck | ✅ router, ⚠️ UI integration flaky |
| `public.rewards`, `public.reward_claims` | `rewards.*` | Rewards Screen | ❌ no tests |
| `select_weekly_progress()` | `dashboard.getWeeklyProgress` | Dashboard Charts | ✅ router + chart snapshot |
| `auth.users` | Supabase Auth | Auth stack | Manual e2e only |

### 4.3 Gap List & Action Items

1. **PlannerScreen integration** – build MSW mocks for `planner.getPlan`, test drag-and-drop reorder.
2. **CompassScreen goal list** – RTL tests verifying progress bars and empty-state.
3. **Rewards flow** – unit tests for `rewards` router + UI tests for claim interaction.
4. **Task Form validation** – test Zod schema errors render helper text.
5. **HabitCheckItem race condition** – flaky UI test; stabilise with fake timers.
6. **Auth flow** – light coverage acceptable until E2E added.

> All new tests should follow the Contract Flow (4.4) and update this matrix.

---

## 5. Tooling Configuration

### 5.1 Jest Runners

| Runner | Config | Targets |
|--------|--------|---------|
| **UI** | `jest.config.ui.js` (jest-expo preset) | RN components/screens |
| **Server** | `jest.config.server.js` (ts-jest preset) | tRPC routers, utils |

Both share `jest.setup.js` for globals and custom matchers.

### 5.2 Mocking Conventions

| Dependency | Technique | File |
|------------|-----------|------|
| Supabase client | `jest-mock-extended` deep mocks with chainable builders | `__tests__/server/test-helpers.ts` |
| React Navigation | Manual stubs | `jest.setup.js` |
| Tamagui | `@tamagui/core/testing` → **TODO** replace with custom fallback until package publishes CJS build |
| Network / 3rd-party | MSW request handlers | `__tests__/mocks/server.ts` |

### 5.3 Utilities

* **`createTestCaller(userId?)`** – spins up tRPC caller with desired auth context.
* **`resetSupabaseMocks()`** – zeroes call counts between tests.
* **Fixtures** – stored under `__tests__/fixtures` for large JSON blobs.

### 5.4 Contract & Integration Testing Flow

1. **Router → Supabase Contract**
   * Deep-mock Supabase with `jest-mock-extended` typed by `types/supabase.ts`.
   * Use `expect(mock.from('tasks').update).toHaveBeenCalledWith(/* typed */)`.
2. **Hook → Router Contract** (`src/hooks/trpc/*`)
   * Mock tRPC client with MSW; return fixture data that matches Supabase types.
   * Assert React Query cache keys and optimistic rollback.
3. **UI → Hook Contract**
   * Render component with `TestWrapper` (React Query provider + Navigation).
   * Fire events, assert that mutation hook was called and UI updates (loading states, toasts).

> These layers mirror production call-stack: **UI → Hook → tRPC → Supabase**. Each layer is verified in isolation **and** in pairwise combination to spot contract drift early.

---

## 6. Red-Green-Refactor Workflow

1. **Write a failing test first** (red) – describe desired behaviour.
2. **Make it pass** (green) – minimal implementation.
3. **Refactor safely** – rely on green suite; improve design.
4. **Commit** – each passing step; CI gate rejects red.

> The rule of thumb: *No production code without a failing test*.

---

## 7. Continuous Integration

* **GitHub Actions** workflow `ci.yml` (TBD)
  * Install deps with cache.
  * Run `yarn test:ci` (UI & server) and `expo lint`.
  * Upload coverage to Codecov.
* Pull-request status required before merge.

---

## 8. Future Work

1. **E2E with Detox / Maestro** once UI stabilises.
2. **Visual regression** snapshots via Loki.
3. **Performance** tests for large lists with Flash-List.
4. **Contract testing** of Supabase RPC functions with the staging DB.

---

## 9. Appendix – Why This Approach?

* **Type Safety + Unit Tests** catch ~80 % of bugs before runtime.
* **Jest single toolchain** keeps cognitive load low for both Node & RN.
* **Deep mocks** for Supabase isolate server logic from network flakiness while still asserting correct query chains.
* **MSW** enables true integration tests for React Query hooks without hitting real endpoints.
* **Separation of runners** makes RN tests boot faster; Node tests avoid Metro.
* **TDD** enforces design clarity – API surfaces are defined by test expectations.

> This strategy lets us iterate quickly while maintaining iron-clad confidence across the entire stack.

  ```

- **tsconfig.json** (0.4 KB, 27 lines) *(No explicit exports)*

  ```json
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "baseUrl": ".",
    "jsx": "react-native",
    "paths": {
      "@/*": [
        "./*"
      ],
      "server/*": [
        "./server/*"
      ]
    },
    "types": [
      "./expo-env.d.ts"
    ]
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts",
    "server/**/*.ts",
    "nativewind-env.d.ts"
  ]
}
  ```

### __tests__

- **__tests__/test-utils.tsx** (0.9 KB, 28 lines) Exports: `render`

  ```tsx
// __tests__/test-utils.tsx
import React, { ReactElement } from 'react';
import { render, RenderOptions } from '@testing-library/react-native';
import { TamaguiProvider } from 'tamagui';
// Ensure the path to your config is correct
// It might be '../tamagui.config' or './tamagui.config' depending on your structure
import config from '../tamagui.config';

const AllTheProviders = ({ children }: { children: React.ReactNode }) => {
  // Ensure you're providing the correct defaultTheme if your app uses one
  return (
    <TamaguiProvider config={config} defaultTheme="light">
      {children}
    </TamaguiProvider>
  );
};

const customRender = (
  ui: ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>,
) => render(ui, { wrapper: AllTheProviders, ...options });

// Re-export everything from testing-library
export * from '@testing-library/react-native';

// Override render method
export { customRender as render };

  ```

### __tests__/components

- **__tests__/components/dashboard/HabitCheckItem.test.tsx** (4.7 KB, 170 lines) *(No explicit exports)*

  ```tsx
import React from 'react';
import { render, fireEvent, act } from '../test-utils';
import HabitCheckItem from '@/components/dashboard/HabitCheckItem';
import { trpc } from '@/utils/trpc';

// Mock the trpc hook
jest.mock('@/utils/trpc', () => ({
  trpc: {
    habit: {
      createHabitEntry: {
        useMutation: jest.fn().mockReturnValue({
          mutate: jest.fn(),
          isLoading: false,
          isError: false,
          error: null,
        }),
      },
      deleteHabitEntry: {
        useMutation: jest.fn().mockReturnValue({
          mutate: jest.fn(),
          isLoading: false,
          isError: false,
          error: null,
        }),
      },
    },
  },
}));

// Mock Haptics
jest.mock('expo-haptics', () => ({
  impactAsync: jest.fn(),
  ImpactFeedbackStyle: {
    Light: 'light',
  },
}));

describe('HabitCheckItem', () => {
  const mockHabit = {
    id: 'habit-1',
    title: 'Morning Run',
    streak: 3,
    completedToday: false,
    best_streak: 5,
    user_id: 'user-1',
    cue: 'Wake up',
    routine: 'Run 5k',
    reward: 'Coffee',
    habit_type: 'do',
    frequency_period: 'daily',
    goal_frequency: 1,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders correctly with uncompleted habit', () => {
    const { getByText } = render(<HabitCheckItem habit={mockHabit} />);
    
    expect(getByText('Morning Run')).toBeTruthy();
    expect(getByText(' 3 day streak')).toBeTruthy();
    expect(getByText('Check-in')).toBeTruthy();
  });

  it('renders correctly with completed habit for today', () => {
    const completedHabit = { ...mockHabit, completedToday: true };
    const { getByText } = render(<HabitCheckItem habit={completedHabit} />);
    
    expect(getByText('Morning Run')).toBeTruthy();
    expect(getByText(' 3 day streak')).toBeTruthy();
    expect(getByText('Done')).toBeTruthy();
  });

  it('calls createHabitEntry mutation when checking in', () => {
    const mockOnToggle = jest.fn();
    const mockCreateMutate = jest.fn();

    // Setup the mock create mutation
    (trpc.habit.createHabitEntry.useMutation as jest.Mock).mockReturnValue({
      mutate: mockCreateMutate,
      isLoading: false,
      isError: false,
      error: null,
    });

    const { getByText } = render(
      <HabitCheckItem habit={{...mockHabit, completedToday: false}} onToggle={mockOnToggle} />
    );

    // Press the check-in button
    fireEvent.press(getByText('Check-in'));

    // Verify the create mutation was called
    expect(mockCreateMutate).toHaveBeenCalledWith(expect.objectContaining({
      habitId: 'habit-1',
      date: expect.any(String),
      completed: true,
    }));

    // Verify the onToggle prop was called if provided
    expect(mockOnToggle).toHaveBeenCalledWith('habit-1', true);
  });

  it('calls deleteHabitEntry mutation when unchecking', () => {
    const mockOnToggle = jest.fn();
    const mockDeleteMutate = jest.fn();

    // Setup the mock delete mutation
    (trpc.habit.deleteHabitEntry.useMutation as jest.Mock).mockReturnValue({
      mutate: mockDeleteMutate,
      isLoading: false,
      isError: false,
      error: null,
    });

    const { getByText } = render(
      <HabitCheckItem habit={{...mockHabit, completedToday: true}} onToggle={mockOnToggle} />
    );

    // Press the done button
    fireEvent.press(getByText('Done'));

    // Verify the delete mutation was called
    expect(mockDeleteMutate).toHaveBeenCalledWith(expect.objectContaining({
      habitId: 'habit-1',
      date: expect.any(String),
    }));

    // Verify the onToggle prop was called if provided
    expect(mockOnToggle).toHaveBeenCalledWith('habit-1', false);
  });

  it('handles error state from mutation', async () => {
    // Mock console.error to prevent test output noise
    const originalConsoleError = console.error;
    console.error = jest.fn();

    // Assume createHabitEntry for error testing, could be delete too
    let errorCallback: (error: any) => void = () => {};
    
    (trpc.habit.createHabitEntry.useMutation as jest.Mock).mockImplementation(({ onError }) => {
      errorCallback = onError;
      return {
        mutate: jest.fn(),
        isLoading: false,
        isError: true,
      };
    });

    const { getByText } = render(<HabitCheckItem habit={mockHabit} />);

    // Press the check-in button (assuming initial state is not completed)
    fireEvent.press(getByText('Check-in'));

    // Simulate an error from the server
    await act(async () => {
      errorCallback(new Error('Network error'));
    });

    // Check that error was logged
    expect(console.error).toHaveBeenCalled();

    // Restore console.error
    console.error = originalConsoleError;
  });
});

  ```

- **__tests__/components/lists/GoalList.test.tsx** (3.9 KB, 140 lines) *(No explicit exports)*

  ```tsx
import React from 'react';
import { render, fireEvent } from '../test-utils';
import { GoalList, GoalCard } from '@/components/lists/GoalList';
import { router } from 'expo-router';

// Mock router.push
jest.mock('expo-router', () => ({
  router: {
    push: jest.fn(),
  },
}));

// Define sample mock data that matches our Supabase schema via tRPC
const mockGoals = [
  {
    id: 'goal-1',
    title: 'Complete Project',
    description: 'Finish the Aether app refactoring',
    progress: 75,
    target_date: '2025-05-15',
    user_id: 'user-123',
  },
  {
    id: 'goal-2',
    title: 'Learn TypeScript',
    description: 'Master advanced TypeScript concepts',
    progress: 30,
    target_date: '2025-06-30',
    user_id: 'user-123',
  },
];

describe('GoalCard Component', () => {
  it('renders goal information correctly', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <GoalCard goal={mockGoals[0]} onPress={onPressMock} />
    );
    
    expect(getByText('Complete Project')).toBeTruthy();
    expect(getByText('Finish the Aether app refactoring')).toBeTruthy();
    expect(getByText('75%')).toBeTruthy();
    expect(getByText('May 15')).toBeTruthy();
  });
  
  it('handles press events', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <GoalCard goal={mockGoals[0]} onPress={onPressMock} />
    );
    
    // Find the card and press it
    const card = getByText('Complete Project').parent.parent.parent;
    fireEvent.press(card);
    
    expect(onPressMock).toHaveBeenCalledTimes(1);
  });
});

describe('GoalList Component', () => {
  it('renders loading state correctly', () => {
    const { getByTestId } = render(
      <GoalList isLoading={true} refetch={jest.fn()} />
    );
    
    expect(getByTestId('skeleton-loader')).toBeTruthy();
  });
  
  it('renders error state correctly', () => {
    const refetchMock = jest.fn();
    const { getByText } = render(
      <GoalList isLoading={false} isError={true} refetch={refetchMock} />
    );
    
    expect(getByText('Unable to load goals')).toBeTruthy();
    
    // Test retry functionality
    fireEvent.press(getByText('Retry'));
    expect(refetchMock).toHaveBeenCalledTimes(1);
  });
  
  it('renders empty state correctly', () => {
    const { getByText } = render(
      <GoalList isLoading={false} goals={[]} refetch={jest.fn()} />
    );
    
    expect(getByText('No goals yet')).toBeTruthy();
    
    // Test create action
    fireEvent.press(getByText('Create a goal'));
    expect(router.push).toHaveBeenCalledWith('/planner/add-goal');
  });
  
  it('renders goals correctly', () => {
    const { getAllByText } = render(
      <GoalList isLoading={false} goals={mockGoals} refetch={jest.fn()} />
    );
    
    // Should render both goals
    expect(getAllByText(/Complete Project|Learn TypeScript/).length).toBe(2);
  });
  
  it('navigates to goal detail on press', () => {
    const { getByText } = render(
      <GoalList isLoading={false} goals={mockGoals} refetch={jest.fn()} />
    );
    
    // Press the first goal
    const goalTitle = getByText('Complete Project');
    fireEvent.press(goalTitle.parent.parent.parent);
    
    // Should navigate to the goal detail page
    expect(router.push).toHaveBeenCalledWith({
      pathname: '/planner/goal/[id]',
      params: { id: 'goal-1' }
    });
  });
  
  it('calls onSelectGoal when provided', () => {
    const onSelectMock = jest.fn();
    const { getByText } = render(
      <GoalList 
        isLoading={false} 
        goals={mockGoals} 
        refetch={jest.fn()} 
        onSelectGoal={onSelectMock} 
      />
    );
    
    // Press the first goal
    const goalTitle = getByText('Complete Project');
    fireEvent.press(goalTitle.parent.parent.parent);
    
    // Should call the onSelectGoal callback
    expect(onSelectMock).toHaveBeenCalledWith(mockGoals[0]);
    // Should not navigate (router.push should not be called)
    expect(router.push).not.toHaveBeenCalled();
  });
});

  ```

- **__tests__/components/lists/HabitList.test.tsx** (3.7 KB, 131 lines) *(No explicit exports)*

  ```tsx
import React from 'react';
import { render, fireEvent } from '../test-utils';
import { HabitList, HabitCard } from '@/components/lists/HabitList';
import { router } from 'expo-router';

// Mock router.push
jest.mock('expo-router', () => ({
  router: {
    push: jest.fn(),
  },
}));

// Define sample mock data that matches our Supabase schema via tRPC
const mockHabits = [
  {
    id: 'habit-1',
    title: 'Morning Meditation',
    streak: 5,
    best_streak: 21,
    cue: 'After waking up',
    routine: 'Meditate for 10 minutes',
    reward: 'Feel centered and calm',
    user_id: 'user-123',
  },
  {
    id: 'habit-2',
    title: 'Code Review',
    streak: 12,
    best_streak: 30,
    cue: 'After lunch',
    routine: 'Review code for 20 minutes',
    reward: 'Learn new patterns',
    user_id: 'user-123',
  },
];

describe('HabitCard Component', () => {
  it('renders habit information correctly', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <HabitCard habit={mockHabits[0]} onPress={onPressMock} />
    );
    
    expect(getByText('Morning Meditation')).toBeTruthy();
    expect(getByText('Current: 5 days')).toBeTruthy();
    expect(getByText('Best: 21 days')).toBeTruthy();
  });
  
  it('handles toggle correctly', () => {
    const onPressMock = jest.fn();
    const onToggleMock = jest.fn();
    const { getByTestId } = render(
      <HabitCard 
        habit={mockHabits[0]} 
        onPress={onPressMock} 
        onToggle={onToggleMock} 
      />
    );
    
    // Find the toggle button (checkmark)
    const toggleButton = getByTestId('icon-checkmark-circle-outline');
    fireEvent.press(toggleButton.parent);
    
    // Should call onToggle with true (completed)
    expect(onToggleMock).toHaveBeenCalledWith(true);
  });
});

describe('HabitList Component', () => {
  it('renders loading state correctly', () => {
    const { getByTestId } = render(
      <HabitList isLoading={true} refetch={jest.fn()} />
    );
    
    expect(getByTestId('skeleton-loader')).toBeTruthy();
  });
  
  it('renders error state correctly', () => {
    const refetchMock = jest.fn();
    const { getByText } = render(
      <HabitList isLoading={false} isError={true} refetch={refetchMock} />
    );
    
    expect(getByText('Unable to load habits')).toBeTruthy();
    
    // Test retry functionality
    fireEvent.press(getByText('Retry'));
    expect(refetchMock).toHaveBeenCalledTimes(1);
  });
  
  it('renders empty state correctly', () => {
    const { getByText } = render(
      <HabitList isLoading={false} habits={[]} refetch={jest.fn()} />
    );
    
    expect(getByText('No habits yet')).toBeTruthy();
    
    // Test create action
    fireEvent.press(getByText('Create a habit'));
    expect(router.push).toHaveBeenCalledWith('/planner/add-habit');
  });
  
  it('renders habits correctly', () => {
    const { getAllByText } = render(
      <HabitList isLoading={false} habits={mockHabits} refetch={jest.fn()} />
    );
    
    // Should render both habits
    expect(getAllByText(/Morning Meditation|Code Review/).length).toBe(2);
  });
  
  it('calls onToggleHabit when provided', () => {
    const onToggleHabitMock = jest.fn();
    const { getByText, getAllByTestId } = render(
      <HabitList 
        isLoading={false} 
        habits={mockHabits} 
        refetch={jest.fn()} 
        onToggleHabit={onToggleHabitMock} 
      />
    );
    
    // Find the first habit's toggle button
    const toggleButtons = getAllByTestId('icon-checkmark-circle-outline');
    fireEvent.press(toggleButtons[0].parent);
    
    // Should call onToggleHabit with the habit ID and completion status
    expect(onToggleHabitMock).toHaveBeenCalledWith('habit-1', true);
  });
});

  ```

- **__tests__/components/lists/TaskList.test.tsx** (4.5 KB, 158 lines) *(No explicit exports)*

  ```tsx
import React from 'react';
import { render, fireEvent } from '../test-utils';
import { TaskList, TaskCard } from '@/components/lists/TaskList';
import { router } from 'expo-router';

// Mock router.push
jest.mock('expo-router', () => ({
  router: {
    push: jest.fn(),
  },
}));

// Define sample mock data that matches our Supabase schema via tRPC
const mockTasks = [
  {
    id: 'task-1',
    title: 'Create UI components',
    notes: 'Focus on reusable design patterns',
    due: '2025-05-01',
    completed: false,
    goal_id: 'goal-1',
    goal: { title: 'App Refactoring' },
    user_id: 'user-123',
  },
  {
    id: 'task-2',
    title: 'Write tests',
    notes: 'Ensure good coverage of components',
    due: '2025-05-03',
    completed: true,
    goal_id: null,
    goal: null,
    user_id: 'user-123',
  },
];

describe('TaskCard Component', () => {
  it('renders task information correctly', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <TaskCard task={mockTasks[0]} onPress={onPressMock} />
    );
    
    expect(getByText('Create UI components')).toBeTruthy();
    expect(getByText('Focus on reusable design patterns')).toBeTruthy();
    expect(getByText('May 1')).toBeTruthy();
    expect(getByText('App Refactoring')).toBeTruthy();
  });
  
  it('handles completion toggle correctly', () => {
    const onPressMock = jest.fn();
    const onCompleteMock = jest.fn();
    const { getByTestId } = render(
      <TaskCard 
        task={mockTasks[0]} 
        onPress={onPressMock} 
        onComplete={onCompleteMock} 
      />
    );
    
    // Find the toggle button (checkmark)
    const toggleButton = getByTestId('icon-checkmark-circle-outline');
    fireEvent.press(toggleButton.parent);
    
    // Should call onComplete with true (completed)
    expect(onCompleteMock).toHaveBeenCalledWith(true);
  });
  
  it('displays completed task with line-through', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <TaskCard task={mockTasks[1]} onPress={onPressMock} />
    );
    
    const titleElement = getByText('Write tests');
    // Text should have line-through style
    expect(titleElement.props.style).toBeDefined();
    // Would check for textDecorationLine: 'line-through' here, but we're mocking styles
  });
  
  it('shows overdue status for past due tasks', () => {
    const pastDueTask = {
      ...mockTasks[0],
      due: '2025-04-01', // Past date
    };
    
    const { getByText } = render(
      <TaskCard task={pastDueTask} onPress={jest.fn()} />
    );
    
    // Should show "Overdue" text
    expect(getByText(/Overdue:/)).toBeTruthy();
  });
});

describe('TaskList Component', () => {
  it('renders loading state correctly', () => {
    const { getByTestId } = render(
      <TaskList isLoading={true} refetch={jest.fn()} />
    );
    
    expect(getByTestId('skeleton-loader')).toBeTruthy();
  });
  
  it('renders error state correctly', () => {
    const refetchMock = jest.fn();
    const { getByText } = render(
      <TaskList isLoading={false} isError={true} refetch={refetchMock} />
    );
    
    expect(getByText('Unable to load tasks')).toBeTruthy();
    
    // Test retry functionality
    fireEvent.press(getByText('Retry'));
    expect(refetchMock).toHaveBeenCalledTimes(1);
  });
  
  it('renders empty state correctly', () => {
    const { getByText } = render(
      <TaskList isLoading={false} tasks={[]} refetch={jest.fn()} />
    );
    
    expect(getByText('No tasks yet')).toBeTruthy();
    
    // Test create action
    fireEvent.press(getByText('Create a task'));
    expect(router.push).toHaveBeenCalledWith('/planner/add-task');
  });
  
  it('renders tasks correctly', () => {
    const { getAllByText } = render(
      <TaskList isLoading={false} tasks={mockTasks} refetch={jest.fn()} />
    );
    
    // Should render both tasks
    expect(getAllByText(/Create UI components|Write tests/).length).toBe(2);
  });
  
  it('calls onCompleteTask when provided', () => {
    const onCompleteTaskMock = jest.fn();
    const { getByText, getAllByTestId } = render(
      <TaskList 
        isLoading={false} 
        tasks={mockTasks} 
        refetch={jest.fn()} 
        onCompleteTask={onCompleteTaskMock} 
      />
    );
    
    // Find the first task's toggle button
    const toggleButtons = getAllByTestId('icon-checkmark-circle-outline');
    fireEvent.press(toggleButtons[0].parent);
    
    // Should call onCompleteTask with the task ID and completion status
    expect(onCompleteTaskMock).toHaveBeenCalledWith('task-1', true);
  });
});

  ```

- **__tests__/components/ui/primitives/AetherCard.test.tsx** (1.7 KB, 61 lines) *(No explicit exports)*

  ```tsx
import React from 'react';
import { Text } from 'tamagui';
import { AetherCard } from '@/components/ui/primitives/AetherCard';
import { render, fireEvent } from '../../../test-utils';

describe('AetherCard Component', () => {
  it('renders correctly with default props', () => {
    const { getByText } = render(
      <AetherCard>
        <Text>Test Card Content</Text>
      </AetherCard>
    );
    
    expect(getByText('Test Card Content')).toBeTruthy();
  });
  
  it('applies the correct variant styles', () => {
    const { rerender, getByTestId } = render(
      <AetherCard testID="test-card" variant="default">
        <Text>Default Variant</Text>
      </AetherCard>
    );
    
    // Test default variant
    let card = getByTestId('test-card');
    expect(card.props.style).toBeDefined();
    
    // Test elevated variant
    rerender(
      <AetherCard testID="test-card" variant="elevated">
        <Text>Elevated Variant</Text>
      </AetherCard>
    );
    card = getByTestId('test-card');
    expect(card.props.style).toBeDefined();
    
    // Test outlined variant
    rerender(
      <AetherCard testID="test-card" variant="outlined">
        <Text>Outlined Variant</Text>
      </AetherCard>
    );
    card = getByTestId('test-card');
    expect(card.props.style).toBeDefined();
  });
  
  it('handles press events when interactive', () => {
    const onPressMock = jest.fn();
    const { getByTestId } = render(
      <AetherCard testID="interactive-card" isInteractive onPress={onPressMock}>
        <Text>Interactive Card</Text>
      </AetherCard>
    );
    
    const card = getByTestId('interactive-card');
    fireEvent.press(card);
    
    expect(onPressMock).toHaveBeenCalledTimes(1);
  });
});

  ```

- **__tests__/components/ui/primitives/AetherListItem.test.tsx** (2.0 KB, 79 lines) *(No explicit exports)*

  ```tsx
import React from 'react';
import { render, fireEvent } from '@testing-library/react-native';
import { AetherListItem } from '@/components/ui/primitives/AetherListItem';

describe('AetherListItem Component', () => {
  it('renders with required props', () => {
    const { getByText } = render(
      <AetherListItem title="Test Item" />
    );
    
    expect(getByText('Test Item')).toBeTruthy();
  });
  
  it('renders with subtitle', () => {
    const { getByText } = render(
      <AetherListItem 
        title="Test Item" 
        subtitle="This is a subtitle" 
      />
    );
    
    expect(getByText('Test Item')).toBeTruthy();
    expect(getByText('This is a subtitle')).toBeTruthy();
  });
  
  it('renders with badge', () => {
    const { getByText } = render(
      <AetherListItem 
        title="Test Item" 
        badge="5" 
      />
    );
    
    expect(getByText('Test Item')).toBeTruthy();
    expect(getByText('5')).toBeTruthy();
  });
  
  it('renders with chevron when showChevron is true', () => {
    const { getByTestId } = render(
      <AetherListItem 
        title="Test Item" 
        showChevron 
      />
    );
    
    expect(getByTestId('icon-chevron-forward')).toBeTruthy();
  });
  
  it('handles press events', () => {
    const onPressMock = jest.fn();
    const { getByText } = render(
      <AetherListItem 
        title="Test Item" 
        onPress={onPressMock}
      />
    );
    
    const item = getByText('Test Item').parent.parent;
    fireEvent.press(item);
    
    expect(onPressMock).toHaveBeenCalledTimes(1);
  });
  
  it('applies the correct styles for the last item', () => {
    const { getByText, rerender } = render(
      <AetherListItem title="Regular Item" />
    );
    
    // Check regular item
    let item = getByText('Regular Item').parent.parent;
    expect(item.props.style).toBeDefined();
    
    // Check last item
    rerender(<AetherListItem title="Last Item" isLast />);
    item = getByText('Last Item').parent.parent;
    expect(item.props.style).toBeDefined();
  });
});

  ```

### __tests__/server

- **__tests__/server/routers/dashboardRouter.getWeeklyProgress.test.ts** (9.1 KB, 232 lines) *(No explicit exports)*

  ```ts
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { createInnerTRPCContext, mockSupabaseAdmin, MockableTableOperations } from '../test-helpers';
import { DeepMockProxy, mockDeep } from 'jest-mock-extended';
import { appRouter } from '../../../server/src/router';
import { TRPCError } from '@trpc/server';

// Type for database table names to avoid 'any' parameter type errors
type TableName = 'tasks' | 'goals' | 'habits' | 'habit_entries' | 'goal_progress_snapshots' | string;

// Using mockSupabaseAdmin from test-helpers

// Helper function to create test context
function createTestContext(userId: string | null = 'test-user-id') {
  return createInnerTRPCContext({
    userId,
    supabase: mockSupabaseAdmin,
  });
}

// Create test caller with context
function createTestCaller(userId: string | null = 'test-user-id') {
  const ctx = createTestContext(userId);
  return appRouter.createCaller(ctx);
}

describe('dashboardRouter.getWeeklyProgress', () => {
  beforeEach(() => {
    // Reset mocks before each test
    jest.clearAllMocks();
  });

  it('should fetch weekly progress with default parameters', async () => {
    // Setup mock data
    const habits = [
      { id: 'habit-1', name: 'Morning Run', frequency: 'daily', streak: 5, best_streak: 10 },
      { id: 'habit-2', name: 'Meditation', frequency: 'daily', streak: 3, best_streak: 7 },
    ];

    const habitEntries = [
      { id: 'entry-1', habit_id: 'habit-1', date: '2025-04-25', completed: true, habits: { id: 'habit-1', name: 'Morning Run', frequency: 'daily' } },
      { id: 'entry-2', habit_id: 'habit-1', date: '2025-04-26', completed: true, habits: { id: 'habit-1', name: 'Morning Run', frequency: 'daily' } },
      { id: 'entry-3', habit_id: 'habit-2', date: '2025-04-25', completed: false, habits: { id: 'habit-2', name: 'Meditation', frequency: 'daily' } },
    ];

    const completedTasks = [
      { id: 'task-1', title: 'Complete report', status: 'completed', updated_at: '2025-04-25T10:00:00Z', goal_id: 'goal-1' },
      { id: 'task-2', title: 'Send email', status: 'completed', updated_at: '2025-04-26T14:30:00Z', goal_id: null },
    ];

    const goalSnapshots = [
      { goal_id: 'goal-1', progress: 0.3, created_at: '2025-04-21T08:00:00Z' },
      { goal_id: 'goal-1', progress: 0.5, created_at: '2025-04-27T08:00:00Z' },
    ];

    // Create typed mock objects for each table
    const habitsTableMock = mockDeep<MockableTableOperations>();
    const habitEntriesTableMock = mockDeep<MockableTableOperations>();
    const tasksTableMock = mockDeep<MockableTableOperations>();
    const goalSnapshotsTableMock = mockDeep<MockableTableOperations>();

    // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
    mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
      if (table === 'habits') return habitsTableMock;
      if (table === 'habit_entries') return habitEntriesTableMock;
      if (table === 'tasks') return tasksTableMock;
      if (table === 'goal_progress_snapshots') return goalSnapshotsTableMock;
      
      // Default case - should not happen in this test
      return mockDeep<MockableTableOperations>();
    });

    // Configure each table mock's behavior
    // Habits table
    habitsTableMock.select.mockReturnThis();
    habitsTableMock.eq.mockReturnThis();
    habitsTableMock.order.mockReturnThis();
    habitsTableMock.limit.mockResolvedValue({ data: habits, error: null });

    // Habit entries table
    habitEntriesTableMock.select.mockReturnThis();
    habitEntriesTableMock.eq.mockReturnThis();
    habitEntriesTableMock.gte.mockReturnThis();
    habitEntriesTableMock.lte.mockReturnThis();
    habitEntriesTableMock.order.mockResolvedValue({ data: habitEntries, error: null });

    // Tasks table
    tasksTableMock.select.mockReturnThis();
    tasksTableMock.eq.mockReturnThis();
    tasksTableMock.gte.mockReturnThis();
    tasksTableMock.lte.mockReturnThis();
    // Add count method mock
    tasksTableMock.count.mockResolvedValue({ count: 10, error: null });
    tasksTableMock.order.mockResolvedValue({ data: completedTasks, error: null });

    // Goal progress snapshots table
    goalSnapshotsTableMock.select.mockReturnThis();
    goalSnapshotsTableMock.eq.mockReturnThis();
    goalSnapshotsTableMock.gte.mockReturnThis();
    goalSnapshotsTableMock.lte.mockReturnThis();
    goalSnapshotsTableMock.order.mockResolvedValue({ data: goalSnapshots, error: null });

    const caller = createTestCaller();
    const result = await caller.dashboard.getWeeklyProgress();

    // Verify structure of response
    expect(result).toHaveProperty('dailyProgress');
    expect(result).toHaveProperty('overallMetrics');
    expect(result).toHaveProperty('habitStreaks');
    expect(result).toHaveProperty('goalProgress');
    expect(result).toHaveProperty('dateRange');

    // Verify dates are processed correctly
    expect(result.dateRange.days.length).toBe(7); // Default is 7 days

    // Verify habit data is formatted correctly
    expect(result.habitStreaks).toContainEqual({
      id: 'habit-1',
      name: 'Morning Run',
      currentStreak: 5,
      bestStreak: 10,
    });

    // Verify goal progress is calculated correctly
    expect(result.goalProgress).toContainEqual(expect.objectContaining({
      goalId: 'goal-1',
      progressChange: 0.2, // 0.5 - 0.3
    }));
  });

  it('should handle custom date ranges', async () => {
    // Create typed mock objects for each table
    const tableMock = mockDeep<MockableTableOperations>();
    
    // Configure mockSupabaseAdmin.from to return the mock for any table
    mockSupabaseAdmin.from.mockImplementation(() => tableMock);
    
    // Configure basic behavior
    tableMock.select.mockReturnThis();
    tableMock.eq.mockReturnThis();
    tableMock.gte.mockReturnThis();
    tableMock.lte.mockReturnThis();
    tableMock.order.mockResolvedValue({ data: [], error: null });

    const caller = createTestCaller();
    const result = await caller.dashboard.getWeeklyProgress({ daysToInclude: 14 });

    // Verify date range is correct
    expect(result.dateRange.days.length).toBe(14);
  });

  it('should handle raw data inclusion when requested', async () => {
    // Setup minimal mock data
    const habitEntries = [
      { id: 'entry-1', habit_id: 'habit-1', date: '2025-04-25', completed: true },
    ];

    // Helper function to create mock table with data and thenable capability
    function createTableMockWithData<T>(data: T) {
      const mock = mockDeep<MockableTableOperations>();
      
      // Configure chainable methods to return this (for method chaining)
      mock.select.mockReturnThis();
      mock.eq.mockReturnThis();
      mock.gte.mockReturnThis();
      mock.lte.mockReturnThis();
      mock.order.mockReturnThis();
      
      // Make the mock awaitable with the provided data
      // Using a proper Promise interface implementation
      const response = { data, error: null, status: 200 };
      const mockPromise = Promise.resolve(response);
      
      // Add then/catch/finally methods to make the mock awaitable
      (mock as any).then = mockPromise.then.bind(mockPromise);
      (mock as any).catch = mockPromise.catch.bind(mockPromise);
      (mock as any).finally = mockPromise.finally.bind(mockPromise);
      
      return mock;
    }
    
    // Create typed mock objects with proper data
    const habitEntriesTableMock = createTableMockWithData(habitEntries);
    const defaultTableMock = createTableMockWithData([]);
    
    // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
    mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
      if (table === 'habit_entries') return habitEntriesTableMock;
      return defaultTableMock;
    });

    const caller = createTestCaller();
    const result = await caller.dashboard.getWeeklyProgress({ includeRawData: true });

    // Find the day that should have entries
    const dayWithData = result.dailyProgress.find(day => day.date === '2025-04-25');
    
    // Verify raw data is included
    expect(dayWithData).toHaveProperty('habitEntries');
    expect(dayWithData?.habitEntries).toHaveLength(1);
  });

  it('should handle database errors properly', async () => {
    // Create typed mock object for tables that will return an error
    const errorTableMock = mockDeep<MockableTableOperations>();
    
    // Configure mockSupabaseAdmin.from to return the error mock
    mockSupabaseAdmin.from.mockImplementation(() => errorTableMock);
    
    // Configure the mocked behavior to return an error
    errorTableMock.select.mockReturnThis();
    errorTableMock.eq.mockReturnThis();
    errorTableMock.gte.mockReturnThis();
    errorTableMock.lte.mockReturnThis();
    errorTableMock.order.mockResolvedValue({ 
      data: null, 
      error: { message: 'Database error', code: '42P01' } 
    });

    const caller = createTestCaller();
    
    // Expect the proper error to be thrown
    await expect(caller.dashboard.getWeeklyProgress()).rejects.toThrow(TRPCError);
  });

  it('should throw an error when user is not authenticated', async () => {
    const caller = createTestCaller(null);
    
    // Expect an unauthorized error
    await expect(caller.dashboard.getWeeklyProgress()).rejects.toThrow(TRPCError);
  });
});

  ```

- **__tests__/server/routers/dashboardRouter.test.ts** (8.5 KB, 235 lines) *(No explicit exports)*

  ```ts
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { createInnerTRPCContext, mockSupabaseAdmin, MockableTableOperations } from '../test-helpers';
import { DeepMockProxy, mockDeep } from 'jest-mock-extended';
import { appRouter } from '../../../server/src/router';
import { TRPCError } from '@trpc/server';

// Using mockSupabaseAdmin from test-helpers

// Type for database table names to avoid 'any' parameter type errors
type TableName = 'tasks' | 'goals' | 'habits' | 'habit_entries' | 'tracked_state_defs' | string;

/**
 * Create a test tRPC caller with proper context
 */
function createTestCaller(userId: string | null = 'test-user-id') {
  const ctx = createInnerTRPCContext({
    userId,
    supabase: mockSupabaseAdmin,
  });
  return appRouter.createCaller(ctx);
}

describe('dashboardRouter', () => {
  beforeEach(() => {
    // Reset all mocks before each test
    jest.clearAllMocks();
  });

  describe('getDashboardData', () => {
    it('should fetch dashboard data with default limits', async () => {
      // Mock data for habits aligned with updated schema
      const mockHabits = [
        {
          id: 'habit-1',
          user_id: 'test-user-id',
          title: 'Morning Run',
          cue: 'Wake up',
          routine: 'Go for a jog',
          reward: 'Coffee',
          streak: 3,
          best_streak: 5,
          created_at: '2024-04-20T12:00:00Z',
          updated_at: '2024-04-20T12:00:00Z'
        }
      ];

      // Mock data for goals aligned with updated schema
      const mockGoals = [
        {
          id: 'goal-1',
          user_id: 'test-user-id',
          title: 'Learn TypeScript',
          description: 'Master TypeScript for web development',
          progress: 0.5,
          target_date: '2024-06-01T00:00:00Z',
          created_at: '2024-04-15T10:00:00Z',
          updated_at: '2024-04-15T10:00:00Z'
        }
      ];

      // Mock data for tasks aligned with updated schema
      const mockTasks = [
        {
          id: 'task-1',
          user_id: 'test-user-id',
          title: 'Complete TypeScript course',
          notes: 'Focus on advanced types',
          status: 'in-progress',
          priority: 2,
          due: '2024-05-01T00:00:00Z',
          goal_id: 'goal-1',
          created_at: '2024-04-20T12:00:00Z',
          updated_at: '2024-04-20T12:00:00Z'
        }
      ];

      // Mock data for tracked states
      const mockTrackedStates: any[] = [];

      // Mock habit entries
      const mockHabitEntries = [
        {
          habit_id: 'habit-1',
          completed: true
        }
      ];

      // Create typed mock objects for each table, using our helper from test-helpers.ts
      function createTableMockWithData<T>(data: T) {
        const mock = mockDeep<MockableTableOperations>();
        
        // Configure chainable methods to return this (for method chaining)
        mock.select.mockReturnThis();
        mock.eq.mockReturnThis();
        mock.is.mockReturnThis();
        mock.neq.mockReturnThis();
        mock.or.mockReturnThis();
        mock.in.mockReturnThis();
        mock.order.mockReturnThis();
        mock.limit.mockReturnThis();
        
        // Make the mock awaitable with the provided data
        // Using a proper Promise interface implementation
        const response = { data, error: null, status: 200 };
        const mockPromise = Promise.resolve(response);
        
        // Add then/catch/finally methods to make the mock awaitable
        (mock as any).then = mockPromise.then.bind(mockPromise);
        (mock as any).catch = mockPromise.catch.bind(mockPromise);
        (mock as any).finally = mockPromise.finally.bind(mockPromise);
        
        return mock;
      }
      
      // Create mocks with the appropriate data
      const habitsTableMock = createTableMockWithData(mockHabits);
      const goalsTableMock = createTableMockWithData(mockGoals);
      const tasksTableMock = createTableMockWithData(mockTasks);
      const trackedStatesTableMock = createTableMockWithData(mockTrackedStates);
      const habitEntriesTableMock = createTableMockWithData(mockHabitEntries);

      // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
      mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
        if (table === 'habits') return habitsTableMock;
        if (table === 'goals') return goalsTableMock;
        if (table === 'tasks') return tasksTableMock;
        if (table === 'tracked_state_defs') return trackedStatesTableMock;
        if (table === 'habit_entries') return habitEntriesTableMock;
        
        // Default fallback - empty result mock
        return createTableMockWithData([]);
      });

      const caller = createTestCaller();
      const result = await caller.dashboard.getDashboardData();

      // Verify the result structure
      expect(result).toHaveProperty('habits');
      expect(result).toHaveProperty('goals');
      expect(result).toHaveProperty('tasks');
      expect(result).toHaveProperty('trackedStates');

      // Verify habits were formatted correctly
      expect(result.habits[0]).toEqual(expect.objectContaining({
        id: 'habit-1',
        title: 'Morning Run',
        streak: 3,
        completed: true
      }));

      // Verify goals were formatted correctly
      expect(result.goals[0]).toEqual(expect.objectContaining({
        id: 'goal-1',
        title: 'Learn TypeScript',
        progress: 0.5
      }));

      // Verify limits were passed correctly - now targeting the specific table mocks
      expect(habitsTableMock.limit).toHaveBeenCalledWith(5); // Default habit limit
      expect(tasksTableMock.limit).toHaveBeenCalledWith(10); // Default task limit
    });

    it('should fetch dashboard data with custom limits', async () => {
      // Create typed mock objects for each table
      const habitsTableMock = mockDeep<MockableTableOperations>();
      const goalsTableMock = mockDeep<MockableTableOperations>();
      const tasksTableMock = mockDeep<MockableTableOperations>();
      const trackedStatesTableMock = mockDeep<MockableTableOperations>();
      const habitEntriesTableMock = mockDeep<MockableTableOperations>();

      // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
      mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
        if (table === 'habits') return habitsTableMock;
        if (table === 'goals') return goalsTableMock;
        if (table === 'tasks') return tasksTableMock;
        if (table === 'tracked_state_defs') return trackedStatesTableMock;
        if (table === 'habit_entries') return habitEntriesTableMock;
        
        // Default case - should not happen in this test
        return mockDeep<MockableTableOperations>();
      });

      // No need to configure these mocks further - they already have their Promise behavior set
      // through the createTableMockWithData function with proper awaitable responses

      // Add specific behaviors needed for tasks
      tasksTableMock.neq.mockReturnThis();
      tasksTableMock.or.mockReturnThis();

      const caller = createTestCaller();
      await caller.dashboard.getDashboardData({
        habitLimit: 10,
        goalLimit: 15,
        taskLimit: 20
      });

      // Verify the custom limits were passed
      expect(mockSupabaseAdmin.limit).toHaveBeenCalledWith(10); // Custom habit limit
      expect(mockSupabaseAdmin.limit).toHaveBeenCalledWith(15); // Custom goal limit
      expect(mockSupabaseAdmin.limit).toHaveBeenCalledWith(20); // Custom task limit
    });

    it('should handle database errors properly', async () => {
      // Setup mock to simulate a database error
      mockSupabaseAdmin.from.mockImplementation(() => {
        return {
          ...mockSupabaseAdmin,
          select: jest.fn().mockReturnThis(),
          eq: jest.fn().mockReturnThis(),
          order: jest.fn().mockReturnThis(),
          limit: jest.fn().mockReturnValue({ 
            data: null, 
            error: { 
              message: 'Database error', 
              code: '42P01' // Table doesn't exist
            } 
          }),
        };
      });

      const caller = createTestCaller();
      
      // Expect the call to throw an INTERNAL_SERVER_ERROR
      await expect(caller.dashboard.getDashboardData()).rejects.toThrow(TRPCError);
    });

    it('should throw unauthorized error if no user is authenticated', async () => {
      const caller = createTestCaller(null);
      
      // Expect the call to throw an UNAUTHORIZED error
      await expect(caller.dashboard.getDashboardData()).rejects.toThrow(TRPCError);
    });
  });
});

  ```

- **__tests__/server/routers/habitRouter.test.ts** (31.5 KB, 597 lines) (1 TODOs) *(No explicit exports)*

  ```ts
import { describe, it, expect, beforeEach, jest, afterEach } from '@jest/globals';
import { createInnerTRPCContext, mockSupabaseAdmin, resetSupabaseMocks } from '../test-helpers'; 
import { appRouter } from '../../../server/src/router';
import { TRPCError } from '@trpc/server';
import { Habit } from '../../../server/src/types/trpc-types'; 

/**
 * Helper function to create a test context
 * This mimics how the tRPC context would be created in a real request
 */
function createTestContext(userId: string | null = 'test-user-id') {
  return createInnerTRPCContext({
    userId,
    supabase: mockSupabaseAdmin,
  });
}

/**
 * Create a test tRPC caller with proper context
 * @param userId Optional user ID for authenticated routes
 * @returns A tRPC caller that can be used to call procedures
 */
function createTestCaller(userId: string | null = 'test-user-id') {
  const ctx = createTestContext(userId);
  return appRouter.createCaller(ctx);
}

// Helper function to create a properly awaitable mock with data
function createTableMockWithData<T>(data: T) {
  const mock = mockDeep<MockableTableOperations>();
  
  // Configure chainable methods to return this (for method chaining)
  mock.select.mockReturnThis();
  mock.eq.mockReturnThis();
  mock.order.mockReturnThis();
  mock.limit.mockReturnThis();
  mock.in.mockReturnThis();
  mock.update.mockReturnThis();
  mock.is.mockReturnThis();
  mock.isNull.mockReturnThis();
  mock.neq.mockReturnThis();
  mock.or.mockReturnThis();
  mock.filter.mockReturnThis();
  mock.delete.mockReturnThis();
  mock.upsert.mockReturnThis();
  mock.insert.mockReturnThis();
  
  // Add proper promise handling for awaitable operations
  const response = { data, error: null, status: 200, count: Array.isArray(data) ? data.length : undefined };
  const mockPromise = Promise.resolve(response);
  
  // Add then/catch/finally methods to make the mock awaitable
  (mock as any).then = mockPromise.then.bind(mockPromise);
  (mock as any).catch = mockPromise.catch.bind(mockPromise);
  (mock as any).finally = mockPromise.finally.bind(mockPromise);
  
  return mock;
}

describe('habitRouter', () => {
  beforeEach(() => {
    resetSupabaseMocks();
  });

  describe('getHabits', () => {
    it('should fetch active habits for the user with completion status', async () => {
      // --- Arrange --- 
      const userId = 'test-user-id';
      const todayStr = new Date().toISOString().split('T')[0];
      const mockHabits: Habit[] = [
        { id: 'habit-1', user_id: userId, title: 'Habit 1', cue: 'Morning', routine: 'Exercise', reward: 'Coffee', habit_type: 'boolean', goal_quantity: null, goal_unit: null, frequency_period: 'day', goal_frequency: 1, recurrence_rule: 'RRULE:FREQ=DAILY', recurrence_end_date: null, archived_at: null, streak: 5, best_streak: 10, created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
        { id: 'habit-2', user_id: userId, title: 'Habit 2', cue: 'Evening', routine: 'Read', reward: 'Relax', habit_type: 'quantity', goal_quantity: 30, goal_unit: 'minutes', frequency_period: 'week', goal_frequency: 3, recurrence_rule: 'RRULE:FREQ=WEEKLY;BYDAY=MO,WE,FR', recurrence_end_date: null, archived_at: null, streak: 2, best_streak: 2, created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
      ];
      const mockEntriesToday = [
        { habit_id: 'habit-1' }, // Only habit 1 is completed today
      ];

      // Create properly awaitable mocks with the test data
      const habitsMock = createTableMockWithData(mockHabits);
      const entriesMock = createTableMockWithData(mockEntriesToday);

      // Configure mockSupabaseAdmin.from to return the appropriate mock for each table
      mockSupabaseAdmin.from.mockImplementation((table: string) => {
        if (table === 'habits') return habitsMock;
        if (table === 'habit_entries') return entriesMock;
        return createTableMockWithData([]); // Default empty result for other tables
      });
      
      // --- Act --- 
      const caller = createTestCaller(userId);
      const result = await caller.habit.getHabits();

      // --- Assert --- 
      expect(result).toHaveLength(2);
      // Check all fields, including new ones and completedToday
      expect(result[0]).toMatchObject({ 
        ...mockHabits[0], 
        frequency_period: 'day', 
        goal_frequency: 1,
        completedToday: true 
      });
      expect(result[1]).toMatchObject({ 
        ...mockHabits[1], 
        frequency_period: 'week',
        goal_frequency: 3,
        completedToday: false 
      });

      // Verify mocks - Check if specific methods were called
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(1, 'habits');
      expect(selectHabitsMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(eqHabitsMock).toHaveBeenCalledWith('user_id', userId);
      expect(isNullHabitsMock).toHaveBeenCalledWith('archived_at', null); // Check is call
      expect(habitsFilterMock).toHaveBeenCalledTimes(1); // Ensure filter was called

      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(2, 'habit_entries');
      expect(selectEntriesMock).toHaveBeenCalledWith('habit_id');
      expect(eqUserEntriesMock).toHaveBeenCalledWith('user_id', userId);
      expect(eqDateEntriesMock).toHaveBeenCalledWith('date', todayStr);
      // Check the final resolving mock was called correctly
      expect(entriesFilterMock).toHaveBeenCalledWith('habit_id', expect.arrayContaining([mockHabits[0].id, mockHabits[1].id]));
    });

    it('should return an empty array if no habits exist', async () => {
        // --- Arrange ---
      const userId = 'test-user-id';

      const habitsFilterMock = jest.fn<() => Promise<{ data: Habit[] | null; error: any }>>();
      habitsFilterMock.mockResolvedValue({ data: [], error: null }); // Resolve empty
      const isNullHabitsMock = jest.fn().mockReturnValue({ filter: habitsFilterMock });
      const eqHabitsMock = jest.fn().mockReturnValue({ isNull: isNullHabitsMock });
      const selectHabitsMock = jest.fn().mockReturnValue({ eq: eqHabitsMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectHabitsMock,
      } as any);

      // --- Act ---
      const caller = createTestCaller(userId);
      const result = await caller.habit.getHabits();

      // --- Assert ---
      expect(result).toEqual([]);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      // Ensure habit_entries was NOT called because the initial habit fetch was empty
      expect(mockSupabaseAdmin.from).toHaveBeenCalledTimes(1); 
      expect(habitsFilterMock).toHaveBeenCalledTimes(1); // Check filter was still called before resolving
    });

    it('should throw TRPCError on database error during habit fetch', async () => {
      // --- Arrange ---
      const userId = 'test-user-id';
      const dbError = { message: 'DB error fetching habits', code: '500' };
      
      const habitsFilterMock = jest.fn<() => Promise<{ data: Habit[] | null; error: any }>>();
      habitsFilterMock.mockResolvedValue({ data: null, error: dbError }); // Simulate error
      const isNullHabitsMock = jest.fn().mockReturnValue({ filter: habitsFilterMock });
      const eqHabitsMock = jest.fn().mockReturnValue({ isNull: isNullHabitsMock });
      const selectHabitsMock = jest.fn().mockReturnValue({ eq: eqHabitsMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectHabitsMock,
      } as any);
      
      // --- Act & Assert ---
      const caller = createTestCaller(userId);
      await expect(caller.habit.getHabits()).rejects.toThrowError(
        new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message })
      );
      expect(habitsFilterMock).toHaveBeenCalledTimes(1);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledTimes(1);
    });

    it('should throw TRPCError on database error during entry fetch', async () => {
        // --- Arrange ---
      const userId = 'test-user-id';
      const todayStr = new Date().toISOString().split('T')[0];
      const mockHabits: Habit[] = [
        { id: 'habit-1', user_id: userId, title: 'Habit 1', cue: 'Morning', routine: 'Exercise', reward: 'Coffee', habit_type: 'boolean', goal_quantity: null, goal_unit: null, frequency_period: 'day', goal_frequency: 1, recurrence_rule: 'RRULE:FREQ=DAILY', recurrence_end_date: null, archived_at: null, streak: 5, best_streak: 10, created_at: new Date().toISOString(), updated_at: new Date().toISOString() },
      ];
      const dbError = { message: 'DB error fetching entries', code: '500' };

      // Mock successful habit fetch
      const habitsFilterMock = jest.fn<() => Promise<{ data: Habit[] | null; error: any }>>();
      habitsFilterMock.mockResolvedValue({ data: mockHabits, error: null });
      const isNullHabitsMock = jest.fn().mockReturnValue({ filter: habitsFilterMock });
      const eqHabitsMock = jest.fn().mockReturnValue({ isNull: isNullHabitsMock });
      const selectHabitsMock = jest.fn().mockReturnValue({ eq: eqHabitsMock });

      // Mock failing entry fetch
      const entriesFilterMock = jest.fn<() => Promise<{ data: any[] | null; error: any }>>();
      entriesFilterMock.mockResolvedValue({ data: null, error: dbError });
      const eqDateEntriesMock = jest.fn().mockReturnValue({ filter: entriesFilterMock });
      const eqUserEntriesMock = jest.fn().mockReturnValue({ eq: eqDateEntriesMock });
      const selectEntriesMock = jest.fn().mockReturnValue({ eq: eqUserEntriesMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectHabitsMock,
      } as any).mockReturnValueOnce({ // Mock for 'habit_entries'
        select: selectEntriesMock,
      } as any);
      
      // --- Act & Assert ---
      const caller = createTestCaller(userId);
      await expect(caller.habit.getHabits()).rejects.toThrowError(
        new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message })
      );
      expect(habitsFilterMock).toHaveBeenCalledTimes(1);
      expect(entriesFilterMock).toHaveBeenCalledTimes(1); // Ensure entry fetch was attempted
    });
  });

  describe('getHabitById', () => {
    it('should fetch a specific habit by ID', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-abc';
      const mockHabit: Habit = { id: habitId, user_id: userId, title: 'Test Habit', cue: null, routine: null, reward: null, habit_type: 'boolean', goal_quantity: null, goal_unit: null, frequency_period: 'day', goal_frequency: 1, recurrence_rule: null, recurrence_end_date: null, archived_at: null, streak: 0, best_streak: 0, created_at: new Date().toISOString(), updated_at: new Date().toISOString() };

      // Corrected mock structure for chained eq calls
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: mockHabit, error: null });
      const userEqMock = jest.fn().mockReturnValue({ single: singleMock });
      const idEqMock = jest.fn().mockReturnValue({ eq: userEqMock });
      const selectMock = jest.fn().mockReturnValue({ eq: idEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectMock
      } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      const result = await caller.habit.getHabitById({ id: habitId });
      expect(result).toEqual(mockHabit);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(selectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at'); // Check select fields
      expect(idEqMock).toHaveBeenCalledWith('id', habitId);
      expect(userEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(singleMock).toHaveBeenCalled();
    });

    it('should throw NOT_FOUND error if habit doesnt exist or belongs to another user', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-abc';
      // Router now throws specific error, not just Supabase error
      const expectedError = new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied' });

      // Corrected mock structure for failing call
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: null, error: { message: 'Row not found', code: 'PGRST116' } });
      const userEqMock = jest.fn().mockReturnValue({ single: singleMock });
      const idEqMock = jest.fn().mockReturnValue({ eq: userEqMock });
      const selectMock = jest.fn().mockReturnValue({ eq: idEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectMock
      } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.getHabitById({ id: habitId })).rejects.toThrowError(
        expectedError
      );
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(selectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(idEqMock).toHaveBeenCalledWith('id', habitId);
      expect(userEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(singleMock).toHaveBeenCalled();
    });

     it('should throw INTERNAL_SERVER_ERROR on other database errors', async () => {
       // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-db-error';
      const dbError = { message: 'Generic DB Error', code: '500' };
      const expectedError = new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message });

      // Corrected mock structure for generic error
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: null, error: dbError });
      const userEqMock = jest.fn().mockReturnValue({ single: singleMock });
      const idEqMock = jest.fn().mockReturnValue({ eq: userEqMock });
      const selectMock = jest.fn().mockReturnValue({ eq: idEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        select: selectMock
      } as any);

       // Act
      const caller = createTestCaller(userId);
       // Assert
      await expect(caller.habit.getHabitById({ id: habitId })).rejects.toThrowError(
        expectedError
      );
       expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
       expect(selectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
       expect(idEqMock).toHaveBeenCalledWith('id', habitId);
       expect(userEqMock).toHaveBeenCalledWith('user_id', userId);
       expect(singleMock).toHaveBeenCalled();
     });
   });

  describe('createHabit', () => { 
    it('should create a new habit with default streaks', async () => {
      // Arrange
      const userId = 'test-user-id';
      const inputData = { title: 'New Habit', habit_type: 'boolean' as const, frequency_period: 'day' as const, goal_frequency: 1 };
      const expectedOutput: Habit = { id: 'new-id', user_id: userId, ...inputData, streak: 0, best_streak: 0, created_at: new Date().toISOString(), updated_at: new Date().toISOString(), cue: null, routine: null, reward: null, goal_quantity: null, goal_unit: null, recurrence_rule: null, recurrence_end_date: null, archived_at: null };

      // Correct mock structure for insert -> select -> single
      // Explicitly type the mock function to help with type inference
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: expectedOutput, error: null }); 
      const selectMock = jest.fn().mockReturnValue({ single: singleMock });
      const insertMock = jest.fn().mockReturnValue({ select: selectMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
        insert: insertMock
      } as any);

      // Act
      const caller = createTestCaller(userId);
      const result = await caller.habit.createHabit(inputData);

      // Assert
      expect(result).toEqual(expectedOutput);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      // Check insert arguments carefully
      expect(insertMock).toHaveBeenCalledWith(expect.objectContaining({ 
          ...inputData,
          user_id: userId, 
          streak: 0, 
          best_streak: 0 
      }));
      expect(selectMock).toHaveBeenCalled(); // Check select was called after insert
      expect(singleMock).toHaveBeenCalled(); // Check single was called after select
    });

    it('should throw TRPCError on database error', async () => {
      // Arrange
      const userId = 'test-user-id';
      const inputData = { title: 'Fail Habit', habit_type: 'boolean' as const, frequency_period: 'day' as const, goal_frequency: 1 };
      const dbError = { message: 'Insert failed', code: '500' };
      const expectedError = new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message });

      // Correct mock structure for failing insert
      const singleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      singleMock.mockResolvedValue({ data: null, error: dbError });
      const selectMock = jest.fn().mockReturnValue({ single: singleMock });
      const insertMock = jest.fn().mockReturnValue({ select: selectMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ // Mock for 'habits'
         insert: insertMock
      } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.createHabit(inputData)).rejects.toThrowError(
        expectedError
      );
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      // Check insert arguments
       expect(insertMock).toHaveBeenCalledWith(expect.objectContaining({ 
          ...inputData,
          user_id: userId, 
          streak: 0, 
          best_streak: 0 
      }));
      expect(selectMock).toHaveBeenCalled();
      expect(singleMock).toHaveBeenCalled();
    });
  });

  describe('updateHabit', () => { 
    it('should update an existing habit', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-to-update';
      const updateData = { title: 'Updated Title' };
      // Define the full initial and updated habit objects (need all fields for Habit type)
      const baseHabit = { id: habitId, user_id: userId, cue: null, routine: null, reward: null, habit_type: 'boolean' as const, goal_quantity: null, goal_unit: null, frequency_period: 'day' as const, goal_frequency: 1, recurrence_rule: null, recurrence_end_date: null, archived_at: null, streak: 5, best_streak: 10, created_at: new Date(Date.now() - 100000).toISOString(), updated_at: new Date(Date.now() - 50000).toISOString() }; 
      const initialHabit: Habit = { ...baseHabit, title: 'Old Title' };
      const updatedHabit: Habit = { ...initialHabit, ...updateData, updated_at: new Date().toISOString(), id: habitId, user_id: userId, cue: null, routine: null, reward: null, habit_type: 'boolean', goal_quantity: null, goal_unit: null, frequency_period: 'day', goal_frequency: 1, recurrence_rule: null, recurrence_end_date: null, archived_at: null, streak: 0, best_streak: 0, created_at: new Date().toISOString() };

      // Mock 1: Initial fetch for ownership check (getHabitById logic)
      const fetchSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      fetchSingleMock.mockResolvedValue({ data: initialHabit, error: null });
      const fetchUserEqMock = jest.fn().mockReturnValue({ single: fetchSingleMock });
      const fetchIdEqMock = jest.fn().mockReturnValue({ eq: fetchUserEqMock });
      const fetchSelectMock = jest.fn().mockReturnValue({ eq: fetchIdEqMock });

      // Mock 2: Update operation
      const updateSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      updateSingleMock.mockResolvedValue({ data: updatedHabit, error: null });
      const updateSelectMock = jest.fn().mockReturnValue({ single: updateSingleMock });
      const updateUserEqMock = jest.fn().mockReturnValue({ select: updateSelectMock });
      const updateIdEqMock = jest.fn().mockReturnValue({ eq: updateUserEqMock });
      const updateMock = jest.fn().mockReturnValue({ eq: updateIdEqMock });

      // Chain the mocks: from('habits') -> select (for fetch) -> update 
      mockSupabaseAdmin.from.mockReturnValueOnce({ select: fetchSelectMock } as any)
                             .mockReturnValueOnce({ update: updateMock } as any); // Second call to from('habits') is for update

      // Act
      const caller = createTestCaller(userId);
      const result = await caller.habit.updateHabit({ id: habitId, ...updateData });

      // Assert
      expect(result).toEqual(updatedHabit);

      // Assert fetch mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(1, 'habits');
      expect(fetchSelectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(fetchIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(fetchUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(fetchSingleMock).toHaveBeenCalled();

      // Assert update mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(2, 'habits');
      expect(updateMock).toHaveBeenCalledWith(expect.objectContaining(updateData));
      expect(updateIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(updateUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(updateSelectMock).toHaveBeenCalled();
      expect(updateSingleMock).toHaveBeenCalled();
    });

    it('should throw NOT_FOUND error if habit doesnt exist or belongs to another user during initial fetch', async () => { // Renamed for clarity
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'non-existent-habit';
      const updateData = { title: 'Wont Update' };
      const expectedError = new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied' });

      // Mock only the initial fetch, have it return not found
      const fetchSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      fetchSingleMock.mockResolvedValue({ data: null, error: { message: 'Row not found', code: 'PGRST116' } });
      const fetchUserEqMock = jest.fn().mockReturnValue({ single: fetchSingleMock });
      const fetchIdEqMock = jest.fn().mockReturnValue({ eq: fetchUserEqMock });
      const fetchSelectMock = jest.fn().mockReturnValue({ eq: fetchIdEqMock });

      // Only mock 'from' once for the fetch
      mockSupabaseAdmin.from.mockReturnValueOnce({ select: fetchSelectMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.updateHabit({ id: habitId, ...updateData })).rejects.toThrowError(expectedError);
      // Verify fetch mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenCalledTimes(1);
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(fetchSelectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(fetchIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(fetchUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(fetchSingleMock).toHaveBeenCalled();
      // Crucially, ensure no update mock was ever created or called
    });

    it('should throw TRPCError on database error during update operation', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-to-update';
      const updateData = { title: 'Updated Title' };
      // Reuse initial habit definition
      const baseHabit = { id: habitId, user_id: userId, cue: null, routine: null, reward: null, habit_type: 'boolean' as const, goal_quantity: null, goal_unit: null, frequency_period: 'day' as const, goal_frequency: 1, recurrence_rule: null, recurrence_end_date: null, archived_at: null, streak: 5, best_streak: 10, created_at: new Date(Date.now() - 100000).toISOString(), updated_at: new Date(Date.now() - 50000).toISOString() }; 
      const initialHabit: Habit = { ...baseHabit, title: 'Old Title' };
      const dbError = { message: 'Update failed', code: '500' };
      const expectedError = new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message });

      // Mock 1: Initial fetch for ownership check (success)
      const fetchSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      fetchSingleMock.mockResolvedValue({ data: initialHabit, error: null });
      const fetchUserEqMock = jest.fn().mockReturnValue({ single: fetchSingleMock });
      const fetchIdEqMock = jest.fn().mockReturnValue({ eq: fetchUserEqMock });
      const fetchSelectMock = jest.fn().mockReturnValue({ eq: fetchIdEqMock });

      // Mock 2: Update operation (failure)
      const updateSingleMock = jest.fn<() => Promise<{ data: Habit | null; error: any }>>();
      updateSingleMock.mockResolvedValue({ data: null, error: dbError }); // Make the update return the error
      const updateSelectMock = jest.fn().mockReturnValue({ single: updateSingleMock });
      const updateUserEqMock = jest.fn().mockReturnValue({ select: updateSelectMock });
      const updateIdEqMock = jest.fn().mockReturnValue({ eq: updateUserEqMock });
      const updateMock = jest.fn().mockReturnValue({ eq: updateIdEqMock });

       // Chain the mocks: from('habits') -> select (for fetch) -> update (fails)
      mockSupabaseAdmin.from.mockReturnValueOnce({ select: fetchSelectMock } as any)
                             .mockReturnValueOnce({ update: updateMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.updateHabit({ id: habitId, ...updateData })).rejects.toThrowError(expectedError);

      // Assert fetch mock calls (should have succeeded)
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(1, 'habits');
      expect(fetchSelectMock).toHaveBeenCalledWith('*', 'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, streak, best_streak, created_at, updated_at');
      expect(fetchIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(fetchUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(fetchSingleMock).toHaveBeenCalled();

      // Assert update mock calls (should have been called but failed)
      expect(mockSupabaseAdmin.from).toHaveBeenNthCalledWith(2, 'habits');
      expect(updateMock).toHaveBeenCalledWith(expect.objectContaining(updateData));
      expect(updateIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(updateUserEqMock).toHaveBeenCalledWith('user_id', userId);
      expect(updateSelectMock).toHaveBeenCalled();
      expect(updateSingleMock).toHaveBeenCalled();
    });
  });

  describe('deleteHabit', () => { 
    it('should delete an existing habit and return true', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-to-delete';

      // Mock delete -> eq(id) -> eq(user_id) -> resolves successfully
      // Explicitly type the mock function to help with type inference
      const deleteUserEqMock = jest.fn<() => Promise<{ data: null; error: any }>>();
      deleteUserEqMock.mockResolvedValue({ data: null, error: null }); // Success is indicated by no error
      const deleteIdEqMock = jest.fn().mockReturnValue({ eq: deleteUserEqMock });
      const deleteMock = jest.fn().mockReturnValue({ eq: deleteIdEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ delete: deleteMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.deleteHabit({ id: habitId })).resolves.toBe(true);
      // Verify mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(deleteMock).toHaveBeenCalled();
      expect(deleteIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(deleteUserEqMock).toHaveBeenCalledWith('user_id', userId);
    });

    it('should throw NOT_FOUND error if habit to delete doesnt exist or belongs to another user', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'non-existent-habit';
      const expectedError = new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or cannot be deleted' });

      // Mock delete -> eq(id) -> eq(user_id) -> resolves with error (or indicates 0 rows affected)
      // Simulate a 'not found' scenario, Supabase might return an error or just indicate 0 rows affected.
      // Let's mock returning an error that the router interprets as NOT_FOUND.
      const dbError = { message: 'Row not found', code: 'PGRST116' }; // Example error
      const deleteUserEqMock = jest.fn<() => Promise<{ data: null; error: any }>>();
      deleteUserEqMock.mockResolvedValue({ data: null, error: dbError });
      const deleteIdEqMock = jest.fn().mockReturnValue({ eq: deleteUserEqMock });
      const deleteMock = jest.fn().mockReturnValue({ eq: deleteIdEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ delete: deleteMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.deleteHabit({ id: habitId })).rejects.toThrowError(expectedError);
      // Verify mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(deleteMock).toHaveBeenCalled();
      expect(deleteIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(deleteUserEqMock).toHaveBeenCalledWith('user_id', userId);
    });

    it('should throw TRPCError on database error during delete operation', async () => {
      // Arrange
      const userId = 'test-user-id';
      const habitId = 'habit-delete-error';
      const dbError = { message: 'Internal DB Error', code: '500' };
      const expectedError = new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: dbError.message });

      // Mock delete -> eq(id) -> eq(user_id) -> resolves with a generic error
      const deleteUserEqMock = jest.fn<() => Promise<{ data: null; error: any }>>();
      deleteUserEqMock.mockResolvedValue({ data: null, error: dbError });
      const deleteIdEqMock = jest.fn().mockReturnValue({ eq: deleteUserEqMock });
      const deleteMock = jest.fn().mockReturnValue({ eq: deleteIdEqMock });

      mockSupabaseAdmin.from.mockReturnValueOnce({ delete: deleteMock } as any);

      // Act
      const caller = createTestCaller(userId);
      // Assert
      await expect(caller.habit.deleteHabit({ id: habitId })).rejects.toThrowError(expectedError);
      // Verify mock calls
      expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('habits');
      expect(deleteMock).toHaveBeenCalled();
      expect(deleteIdEqMock).toHaveBeenCalledWith('id', habitId);
      expect(deleteUserEqMock).toHaveBeenCalledWith('user_id', userId);
    });
  });

  // TODO: Add describe blocks for archive/unarchive and habit entry procedures
});

  ```

- **__tests__/server/routers/taskRouter.toggleTask.test.ts** (14.0 KB, 344 lines) *(No explicit exports)*

  ```ts
import { describe, it, expect, beforeEach, jest } from '@jest/globals';
import { 
  createInnerTRPCContext, 
  mockSupabaseAdmin, 
  MockableTableOperations, 
  resetSupabaseMocks, 
  MockablePostgrestResponse 
} from '../test-helpers';
import { DeepMockProxy, mockDeep } from 'jest-mock-extended';
import { appRouter } from '../../../server/src/router';
import { TRPCError } from '@trpc/server';

// Type for database table names to avoid 'any' parameter type errors
type TableName = 'tasks' | 'goals' | 'habits' | string;

// Helper function to create test context
function createTestContext(userId: string | null = 'test-user-id') {
  return createInnerTRPCContext({
    userId,
    supabase: mockSupabaseAdmin,
  });
}

// Create test caller with context
function createTestCaller(userId: string | null = 'test-user-id') {
  const ctx = createTestContext(userId);
  return appRouter.createCaller(ctx);
}

describe('taskRouter.toggleTask', () => {
  beforeEach(() => {
    // Reset mocks before each test
    resetSupabaseMocks();
  });

  it('should toggle a task from incomplete to complete', async () => {
    const taskId = 'task-1';
    const userId = 'test-user-id';
    const initialTaskData = {
      id: taskId,
      user_id: userId,
      title: 'Test Task',
      notes: null,
      status: 'in-progress',
      priority: 2,
      due: null,
      goal_id: null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };
    const updatedTaskData = {
      id: taskId,
      user_id: userId,
      title: 'Test Task',
      notes: null,
      status: 'completed', // This is the expected final status
      priority: 2,
      due: null,
      goal_id: null,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(), // Include fields returned by select
    };

    // Mock setup for 'tasks' table operations
    const fetchMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(fetchMock); // Consistently return fetchMock for 'tasks'

    // Configure chainable methods to return the mock itself
    fetchMock.select.mockReturnValue(fetchMock);
    fetchMock.eq.mockReturnValue(fetchMock);
    fetchMock.update.mockReturnValue(fetchMock);

    // Configure .single() to resolve differently for fetch vs update
    fetchMock.single
      .mockResolvedValueOnce({ data: initialTaskData, error: null }) // First call (fetch)
      .mockResolvedValueOnce({ data: updatedTaskData, error: null }); // Second call (update confirmation)

    const caller = createTestCaller(userId);
    const result = await caller.task.toggleTask({
      taskId: taskId,
    });

    // Verify the result
    expect(result.status).toBe('completed');

    // Verify calls
    expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('tasks');
    expect(fetchMock.select).toHaveBeenCalledWith('id, status, goal_id, title');
    expect(fetchMock.update).toHaveBeenCalledWith(expect.objectContaining({ status: 'completed' }));
    expect(fetchMock.eq).toHaveBeenCalledWith('id', taskId);
    expect(fetchMock.eq).toHaveBeenCalledWith('user_id', userId);
    expect(fetchMock.select).toHaveBeenCalledWith('id, title, status, goal_id, updated_at');
    expect(fetchMock.single).toHaveBeenCalledTimes(2); // Called for fetch and update
  });

  it('should toggle a task from complete to incomplete', async () => {
    const taskId = 'task-1';
    const userId = 'test-user-id';
    const initialTaskData = {
      id: taskId,
      title: 'Test Task',
      status: 'completed', // Starting completed
      goal_id: null,
    };
    const updatedTaskData = {
      id: taskId,
      title: 'Test Task',
      status: 'in-progress', // Expected final status
      goal_id: null,
      updated_at: new Date().toISOString(),
    };

    // Mock setup for 'tasks' table operations
    const fetchMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(fetchMock); // Consistently return fetchMock

    // Configure chainable methods
    fetchMock.select.mockReturnValue(fetchMock);
    fetchMock.eq.mockReturnValue(fetchMock);
    fetchMock.update.mockReturnValue(fetchMock);

    // Configure .single() resolutions
    fetchMock.single
      .mockResolvedValueOnce({ data: initialTaskData, error: null }) // First call (fetch)
      .mockResolvedValueOnce({ data: updatedTaskData, error: null }); // Second call (update confirmation)

    const caller = createTestCaller(userId);
    const result = await caller.task.toggleTask({
      taskId: taskId,
    });

    // Verify the result
    expect(result.status).toBe('in-progress');

    // Verify calls
    expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('tasks');
    expect(fetchMock.select).toHaveBeenCalledWith('id, status, goal_id, title');
    expect(fetchMock.update).toHaveBeenCalledWith(expect.objectContaining({ status: 'in-progress' }));
    expect(fetchMock.eq).toHaveBeenCalledWith('id', taskId);
    expect(fetchMock.eq).toHaveBeenCalledWith('user_id', userId);
    expect(fetchMock.select).toHaveBeenCalledWith('id, title, status, goal_id, updated_at');
    expect(fetchMock.single).toHaveBeenCalledTimes(2); // Called for fetch and update
  });

  it('should update goal progress when toggling a task with goal association', async () => {
    const taskId = 'task-1';
    const goalId = 'goal-1';
    const userId = 'test-user-id';

    // --- Task Mocks --- 
    const taskFetchMock = mockDeep<MockableTableOperations>();
    const initialTaskData = { id: taskId, title: 'Goal Task', status: 'in-progress', goal_id: goalId };
    const updatedTaskData = { ...initialTaskData, status: 'completed', updated_at: new Date().toISOString() };
    
    taskFetchMock.select.mockReturnValue(taskFetchMock);
    taskFetchMock.eq.mockReturnValue(taskFetchMock);
    taskFetchMock.update.mockReturnValue(taskFetchMock);
    taskFetchMock.single
      .mockResolvedValueOnce({ data: initialTaskData, error: null }) // Fetch task
      .mockResolvedValueOnce({ data: updatedTaskData, error: null }); // Update task

    // Helper function to create a properly awaitable mock with data
    function createTableMockWithData<T>(data: T) {
      const mock = mockDeep<MockableTableOperations>();
      
      // Configure chainable methods to return this (for method chaining)
      mock.select.mockReturnThis();
      mock.eq.mockReturnThis();
      mock.order.mockReturnThis();
      mock.limit.mockReturnThis();
      mock.in.mockReturnThis();
      mock.update.mockReturnThis();
      mock.is.mockReturnThis();
      mock.neq.mockReturnThis();
      mock.or.mockReturnThis();
      
      // Add proper promise handling for awaitable operations
      const response = { data, error: null, status: 200, count: Array.isArray(data) ? data.length : undefined };
      const mockPromise = Promise.resolve(response);
      
      // Add then/catch/finally methods to make the mock awaitable
      (mock as any).then = mockPromise.then.bind(mockPromise);
      (mock as any).catch = mockPromise.catch.bind(mockPromise);
      (mock as any).finally = mockPromise.finally.bind(mockPromise);
      
      return mock;
    }
    
    // --- Goal Task List Mock --- 
    // Create a properly awaitable mock with the goal tasks data
    const goalTasksData = [
        { id: taskId, status: 'completed' }, // The toggled task
        { id: 'task-2', status: 'in-progress' },
    ];
    const goalTasksListMock = createTableMockWithData(goalTasksData);

    // --- Goal Update Mock --- 
    const updatedGoalData = { id: goalId, name: 'Test Goal', progress: 0.5, /* other fields */ updated_at: new Date().toISOString() }; // Example with 50% progress
    
    // Create an awaitable mock with the goal update data
    const goalUpdateMock = createTableMockWithData(updatedGoalData);
    // Make sure single() returns a properly typed response
    goalUpdateMock.single.mockResolvedValue({ data: updatedGoalData, error: null });


    // --- Configure from() to return the right mock based on table --- 
    mockSupabaseAdmin.from.mockImplementation((table: TableName) => {
      if (table === 'tasks') {
        // First call to 'tasks' is for the initial fetch/update of the specific task
        // Second call is to get all tasks for the goal
        // Need a way to differentiate... maybe check chained methods?
        // For now, let's assume the first call structure uses single(), the second doesn't directly
        // A more robust way might involve mockFn.mock.calls inspection or clearer separation.
        // Let's try returning taskFetchMock first, then goalTasksListMock.
        if (mockSupabaseAdmin.from.mock.calls.filter(c => c[0] === 'tasks').length <= 1) {
            return taskFetchMock;
        } else {
            return goalTasksListMock;
        }
      }
      if (table === 'goals') {
        return goalUpdateMock; // Only call to 'goals' is for the update
      }
      // Fallback for any other table calls in the test setup (if any)
      const defaultMock = mockDeep<MockableTableOperations>();
      defaultMock.select.mockReturnValue(defaultMock);
      defaultMock.eq.mockReturnValue(defaultMock);
      defaultMock.single.mockResolvedValue({ data: null, error: { message: 'Default mock', code: 'MOCK_ERR' } });
      return defaultMock;
    });

    const caller = createTestCaller(userId);
    const result = await caller.task.toggleTask({
      taskId: taskId,
    });

    // Assertions
    expect(result.status).toBe('completed');
    expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('tasks'); // Called multiple times
    expect(mockSupabaseAdmin.from).toHaveBeenCalledWith('goals');
    
    // Verify task update
    expect(taskFetchMock.update).toHaveBeenCalledWith(expect.objectContaining({ status: 'completed' }));
    expect(taskFetchMock.single).toHaveBeenCalledTimes(2); // Fetch + Update task

    // Verify fetching goal tasks
    expect(goalTasksListMock.select).toHaveBeenCalledWith('id, status');
    expect(goalTasksListMock.eq).toHaveBeenCalledWith('goal_id', goalId);

    // Verify goal update
    expect(goalUpdateMock.update).toHaveBeenCalledWith({ progress: 0.5 }); // 1 out of 2 tasks complete
    expect(goalUpdateMock.eq).toHaveBeenCalledWith('id', goalId);
    expect(goalUpdateMock.select).toHaveBeenCalledWith('id, name, progress, updated_at');
    expect(goalUpdateMock.single).toHaveBeenCalledTimes(1);

    // Reset implementation for next tests if needed (though beforeEach should handle it)
    // mockSupabaseAdmin.from.mockRestore(); // Or reset in beforeEach

  });

  it('should not change status if already in the target state', async () => {
    const taskId = 'task-1';
    const userId = 'test-user-id';
    const existingTask = {
      id: taskId,
      title: 'Test Task',
      status: 'completed',
      goal_id: null,
    };

    // --- Configure from() for tasks table --- 
    const tasksTableMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(tasksTableMock);
    tasksTableMock.select.mockReturnValue(tasksTableMock);
    tasksTableMock.eq.mockReturnValue(tasksTableMock);
    tasksTableMock.single.mockResolvedValue({ data: existingTask, error: null });

    // --- Configure from() for goals table (should not be called) ---
    const goalsTableMock = mockDeep<MockableTableOperations>();
    // ... setup mocks for goals table ...
    // This setup is complex, let's simplify if goal logic isn't tested here
    // goalsTableMock.update.mockReturnValue(goalsTableMock);
    // goalsTableMock.eq.mockReturnValue(goalsTableMock);
    // goalsTableMock.select.mockReturnValue(goalsTableMock);
    // goalsTableMock.single.mockResolvedValue({ data: null, error: null });
    // mockSupabaseAdmin.from('goals').mockReturnValue(goalsTableMock);
    const caller = createTestCaller(userId);
    const result = await caller.task.toggleTask({
      taskId: taskId,
    });

    // Verify the result
    expect(result.status).toBe('completed');

    // Verify no update was performed
    expect(mockSupabaseAdmin.from('tasks').update).not.toHaveBeenCalled();
    expect(mockSupabaseAdmin.from('goals').update).not.toHaveBeenCalled(); // Ensure goal not updated
  });

  it('should throw NOT_FOUND error if task does not exist', async () => {
    // Mock the initial fetch to return no data
    const fetchMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(fetchMock);
    fetchMock.select.mockReturnValue(fetchMock);
    fetchMock.eq.mockReturnValue(fetchMock);
    fetchMock.single.mockResolvedValue({ data: null, error: null }); // Simulate task not found

    const caller = createTestCaller();
    await expect(caller.task.toggleTask({ taskId: 'nonexistent-task' }))
      .rejects.toMatchObject({ code: 'NOT_FOUND' });

    // Ensure update was not called
    expect(fetchMock.update).not.toHaveBeenCalled();
  });

  it('should throw an error if the database update fails', async () => {
    const taskId = 'task-1';
    const userId = 'test-user-id';
    const initialTaskData = { id: taskId, status: 'in-progress', goal_id: null, title: 'Test' };
    const dbError = { message: 'Update failed', code: 'DB_ERROR' };

    // Mock the initial fetch
    const fetchMock = mockDeep<MockableTableOperations>();
    mockSupabaseAdmin.from('tasks').mockReturnValue(fetchMock);
    fetchMock.select.mockReturnValue(fetchMock);
    fetchMock.eq.mockReturnValue(fetchMock);
    fetchMock.update.mockReturnValue(fetchMock); // Update returns mock for chaining

    // Mock .single() for initial fetch (success) and update (failure)
    fetchMock.single
      .mockResolvedValueOnce({ data: initialTaskData, error: null }) // Fetch succeeds
      .mockResolvedValueOnce({ data: null, error: dbError });       // Update fails

    const caller = createTestCaller(userId);
    await expect(caller.task.toggleTask({ taskId: taskId }))
      .rejects.toMatchObject({ message: 'Update failed', code: 'DB_ERROR' });

    // Verify update was attempted
    expect(fetchMock.update).toHaveBeenCalledWith(expect.objectContaining({ status: 'completed' }));
    expect(fetchMock.single).toHaveBeenCalledTimes(2); // Fetch + Update attempt
  });

});

  ```

- **__tests__/server/test-helpers.ts** (10.1 KB, 263 lines) Exports: `createInnerTRPCContext`, `createTestContext`, `MockablePostgrestResponse`, `MockableQueryBuilder`, `MockableSupabaseClient`, `MockableTableOperations`, `mockDeep`, `mockSupabaseAdmin`, `resetSupabaseMocks`, `TableName`

  ```ts
import { mockDeep, mockReset, DeepMockProxy } from 'jest-mock-extended';
import { User, AuthError } from '@supabase/supabase-js';
import { type Context } from '@/server/src/context';
import { TRPCError } from '@trpc/server';

// --- Common Response Type --- 
// Represents the core structure of Supabase Postgrest responses
export type MockablePostgrestResponse<T> = Promise<{
  data: T | null;
  error: any;
  count?: number | null; 
  status?: number;
  statusText?: string;
}>;

// --- Interface for CHAINABLE Query Builder methods --- 
// These methods return the builder itself to allow chaining.
export interface MockableQueryBuilder {
  select: (query?: string, options?: { head?: boolean; count?: 'exact' | 'planned' | 'estimated' }) => MockableQueryBuilder;
  eq: (column: string, value: any) => MockableQueryBuilder;
  neq: (column: string, value: any) => MockableQueryBuilder;
  gt: (column: string, value: any) => MockableQueryBuilder;
  gte: (column: string, value: any) => MockableQueryBuilder;
  lt: (column: string, value: any) => MockableQueryBuilder;
  lte: (column: string, value: any) => MockableQueryBuilder;
  like: (column: string, pattern: string) => MockableQueryBuilder;
  ilike: (column: string, pattern: string) => MockableQueryBuilder;
  is: (column: string, value: boolean | null) => MockableQueryBuilder;
  in: (column: string, values: any[]) => MockableQueryBuilder;
  contains: (column: string, value: any) => MockableQueryBuilder;
  containedBy: (column: string, value: any) => MockableQueryBuilder;
  rangeGt: (column: string, range: string) => MockableQueryBuilder;
  rangeGte: (column: string, range: string) => MockableQueryBuilder;
  rangeLt: (column: string, range: string) => MockableQueryBuilder;
  rangeLte: (column: string, range: string) => MockableQueryBuilder;
  rangeAdjacent: (column: string, range: string) => MockableQueryBuilder;
  overlaps: (column: string, value: any) => MockableQueryBuilder;
  textSearch: (column: string, query: string, options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }) => MockableQueryBuilder;
  match: (query: Record<string, unknown>) => MockableQueryBuilder;
  not: (column: string, operator: string, value: any) => MockableQueryBuilder;
  or: (filters: string, options?: { referencedTable?: string }) => MockableQueryBuilder;
  filter: (column: string, operator: string, value: any) => MockableQueryBuilder;
  limit: (count: number, options?: { referencedTable?: string }) => MockableQueryBuilder;
  range: (from: number, to: number, options?: { referencedTable?: string }) => MockableQueryBuilder;
  order: (column: string, options?: { ascending?: boolean; nullsFirst?: boolean; referencedTable?: string }) => MockableQueryBuilder;
}

// --- Interface for Operations on a Table (after .from()) --- 
// Inherits chainable methods AND adds terminal methods returning Promises.
export interface MockableTableOperations extends MockableQueryBuilder {
  // Terminal methods (return Promises)
  single: <T = any>() => MockablePostgrestResponse<T>;
  maybeSingle: <T = any>() => MockablePostgrestResponse<T>;
  // Note: Insert/Update/Upsert often return arrays in Supabase v2, but the *methods* return the builder
  insert: <T = any>(values: any | any[], options?: any) => MockableTableOperations; 
  upsert: <T = any>(values: any | any[], options?: any) => MockableTableOperations; 
  update: <T = any>(values: any, options?: any) => MockableTableOperations; 
  delete: (options?: any) => MockableTableOperations; 
}

// --- Interface for the Supabase Client itself --- 
/**
 * Represents the structure of the Supabase client that we need to mock.
 * `from` returns an object combining chainable and terminal methods.
 */
export interface MockableSupabaseClient {
  // `from` now returns the object with both chainable and terminal methods
  from: (relation: string) => MockableTableOperations;

  // Top-level client methods
  auth: {
    getUser: (
      jwt?: string
    ) => Promise<{ data: { user: User | null }; error: AuthError | null }>;
    // Add other auth methods here if needed by tests (e.g., signUp, signInWithPassword)
  };
  rpc: <T = any>(fn: string, params?: object, options?: { head?: boolean; count?: 'exact' | 'planned' | 'estimated' }) => MockablePostgrestResponse<T>;
  // Add storage interface here if needed by tests
  // storage: { ... };
}

// --- Mock Implementation --- 

// Create a deep mock instance conforming to the refined interface
export const mockSupabaseAdmin = mockDeep<MockableSupabaseClient>();

// Helper to reset mocks
export function resetSupabaseMocks() {
  // Use mockReset for better compatibility with jest-mock-extended
  mockReset(mockSupabaseAdmin);

  // --- Re-apply default implementations after reset --- 

  // Default: Successful authentication
  mockSupabaseAdmin.auth.getUser.mockResolvedValue({
    data: { user: { id: 'test-user-id', /* other user props */ } as User },
    error: null,
  });

  // Default: Successful RPC call returning null data
  mockSupabaseAdmin.rpc.mockResolvedValue({ 
      data: null, 
      error: null, 
      count: 0, 
      status: 200, 
      statusText: 'OK' 
  });

  // Helper type to create Promise-like chain-terminating objects
  type AsyncResult<T> = Promise<{ data: T | null; error: any; count?: number; status?: number; statusText?: string; }>;

  // Helper function to create a proper mock that handles both chaining AND awaiting
  function createMockWithPromiseCapability<T>(defaultData: T | null = null): any {
    const mockObj = mockDeep<MockableTableOperations>();
    
    // Add an implicit then handler that allows awaiting the mock directly
    // This is what Supabase's actual Query Builder does
    const defaultResponse = { 
      data: defaultData, 
      error: null, 
      count: defaultData && Array.isArray(defaultData) ? defaultData.length : 0,
      status: 200, 
      statusText: 'OK' 
    };
    
    // Allow the mock to be awaited directly
    (mockObj as any).then = jest.fn((onFulfill, onReject) => {
      return Promise.resolve(defaultResponse).then(onFulfill, onReject);
    });
    
    return mockObj;
  }

  // Default behavior for 'from': Return a mock that handles chaining and terminal methods
  mockSupabaseAdmin.from.mockImplementation((relation: string) => {
    // This inner mock needs to satisfy MockableTableOperations
    // AND be awaitable like a promise for terminal operations
    const innerMock = createMockWithPromiseCapability<any[]>([]);

    // --- Configure Default CHAINABLE Methods (Return Self) --- 
    innerMock.select.mockReturnValue(innerMock);
    innerMock.eq.mockReturnValue(innerMock);
    innerMock.neq.mockReturnValue(innerMock);
    innerMock.gt.mockReturnValue(innerMock);
    innerMock.gte.mockReturnValue(innerMock);
    innerMock.lt.mockReturnValue(innerMock);
    innerMock.lte.mockReturnValue(innerMock);
    innerMock.like.mockReturnValue(innerMock);
    innerMock.ilike.mockReturnValue(innerMock);
    innerMock.is.mockReturnValue(innerMock);
    innerMock.in.mockReturnValue(innerMock);
    innerMock.contains.mockReturnValue(innerMock);
    innerMock.containedBy.mockReturnValue(innerMock);
    innerMock.rangeGt.mockReturnValue(innerMock);
    innerMock.rangeGte.mockReturnValue(innerMock);
    innerMock.rangeLt.mockReturnValue(innerMock);
    innerMock.rangeLte.mockReturnValue(innerMock);
    innerMock.rangeAdjacent.mockReturnValue(innerMock);
    innerMock.overlaps.mockReturnValue(innerMock);
    innerMock.textSearch.mockReturnValue(innerMock);
    innerMock.match.mockReturnValue(innerMock);
    innerMock.not.mockReturnValue(innerMock);
    innerMock.or.mockReturnValue(innerMock);
    innerMock.filter.mockReturnValue(innerMock);
    innerMock.limit.mockReturnValue(innerMock);
    innerMock.range.mockReturnValue(innerMock);
    innerMock.order.mockReturnValue(innerMock);

    // --- Configure Default TERMINAL Methods --- 
    // For single-returning methods, default to null
    const singleResponse = { 
      data: null, 
      error: null, 
      status: 200, 
      statusText: 'OK' 
    };
    
    innerMock.single.mockResolvedValue(singleResponse);
    innerMock.maybeSingle.mockResolvedValue(singleResponse);
    
    // For insert/update/upsert operations, return the builder that can be chained further or awaited
    innerMock.insert.mockImplementation(() => {
      const insertMock = createMockWithPromiseCapability();
      insertMock.select.mockReturnValue(insertMock);
      return insertMock;
    });
    
    innerMock.upsert.mockImplementation(() => {
      const upsertMock = createMockWithPromiseCapability();
      upsertMock.select.mockReturnValue(upsertMock);
      return upsertMock;
    });
    
    innerMock.update.mockImplementation(() => {
      const updateMock = createMockWithPromiseCapability();
      updateMock.select.mockReturnValue(updateMock);
      return updateMock;
    });
    
    innerMock.delete.mockImplementation(() => {
      const deleteMock = createMockWithPromiseCapability();
      deleteMock.select.mockReturnValue(deleteMock);
      return deleteMock;
    });

    return innerMock;
  });
}

// Initialize mocks on first load
resetSupabaseMocks();

// --- Context Creation --- 

// Expand this type as more tables are tested
export type TableName = 
  | 'users' 
  | 'user_profiles' 
  | 'user_settings'
  | 'values'
  | 'principles'
  | 'goals' 
  | 'tasks'
  | 'habits'
  | 'habit_entries'
  | 'tracked_state_defs' 
  | 'state_entries'     
  | 'reminders'         
  | 'goal_progress_notes'
  | 'rewards'           
  | 'user_badges';       

/**
 * Creates a TRPC context with a mocked Supabase client.
 * Ensures the user is authenticated unless explicitly bypassed.
 */
export function createInnerTRPCContext(opts: {
  userId: string | null;
  supabase?: any; // Keep as any for simplicity
}): Context {
  if (!opts.userId) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
      message: 'User must be authenticated to access this resource',
    });
  }

  return {
    userId: opts.userId,
    supabaseAdmin: opts.supabase || mockSupabaseAdmin,
  };
}

export function createTestContext(userId: string | null = 'test-user-id', supabase?: any) {
  return createInnerTRPCContext({
    userId,
    supabase,
  });
}

// Export mockDeep so it can be used directly in tests if needed
export { mockDeep };

  ```

### .github/workflows

- **.github/workflows/ci.yml** (1.1 KB, 56 lines) *(No explicit exports)*

  ```yml
name: CI

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: TypeScript check
        run: npx tsc --noEmit

      # Add this step once we have tests
      # - name: Run tests
      #   run: npm test
        
      - name: Expo config validation
        run: npx expo-cli prebuild --clean --no-install
        
  server-build:
    runs-on: ubuntu-latest
    
    defaults:
      run:
        working-directory: ./server
        
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: 'npm'
          cache-dependency-path: './server/package.json'
      
      - name: Install server dependencies
        run: npm ci
        
      - name: Build server
        run: npm run build 
  ```

### app

- **app/_layout.tsx** (0.9 KB, 26 lines) Exports: `default`

  ```tsx
import React from 'react';
import { Stack } from 'expo-router';
import { GestureHandlerRootView } from 'react-native-gesture-handler';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { GluestackUIProvider } from '@gluestack-ui/themed';
import { glueTheme } from '@/design-system/theme.glue';
import { TRPCProvider } from '@/providers/TRPCProvider';
import { SupabaseProvider } from '@/providers/SupabaseProvider';
import '@/global.css';

export default function RootLayout() {
  return (
    <GestureHandlerRootView style={{ flex: 1 }}>
      <SafeAreaProvider>
        <GluestackUIProvider config={glueTheme}>
          <SupabaseProvider>
            <TRPCProvider>
              <Stack screenOptions={{ headerShown: false }} />
            </TRPCProvider>
          </SupabaseProvider>
        </GluestackUIProvider>
      </SafeAreaProvider>
    </GestureHandlerRootView>
  );
}

  ```

- **app/compose.tsx** (9.9 KB, 251 lines) Exports: `default`

  ```tsx
// app/compose.tsx
import React from 'react';
import { ScrollView } from 'react-native'; // Using RN ScrollView directly
import { Stack, useRouter, useLocalSearchParams } from 'expo-router';
import { YStack, XStack, Form, Input, Label, TextArea, Button, Switch, Paragraph, Spinner } from 'tamagui';
import { useForm, Controller, ControllerRenderProps, FieldValues } from 'react-hook-form'; // Import ControllerRenderProps
import { zodResolver } from '@hookform/resolvers/zod';
import { useToastController } from '@tamagui/toast'; // Assuming ToastProvider is set up

import { trpc, type RouterInputs } from '@/utils/trpc'; // Assuming inputs are exported like this
import { haptics } from '@/utils/haptics'; // Assuming haptics helper exists

// Assuming your Zod schemas are exported like this. Adjust if necessary.
type CreateValueInput = RouterInputs['value']['createValue'];
type CreateStateInput = RouterInputs['state']['createDefinition'];

// 1️⃣ Define tagged types for discriminated union
type CreateValueInputTagged = CreateValueInput & { __type: 'value' };
type CreateStateInputTagged = CreateStateInput & { __type: 'state' };
type FormValues = CreateValueInputTagged | CreateStateInputTagged;

export default function ComposeModal() {
  const router = useRouter();
  const params = useLocalSearchParams<{ type: string }>();
  const type = params.type === 'value' || params.type === 'state' ? params.type : undefined;
  const toast = useToastController();
  const utils = trpc.useUtils();

  const isValue = type === 'value';

  // 2️⃣ Define stricter default values using tagged types
  const defaultValueValues: CreateValueInputTagged = {
    __type: 'value',
    title: '', // Use 'title' instead of 'name' - Patch #4
    description: ''
  };
  const defaultStateValues: CreateStateInputTagged = {
    __type: 'state',
    name: '',
    scale: '1-5',
    description: '',
    active: true,
    priority: 50
  };

  // --- Separate useMutation hooks ---
  const createValueMutation = trpc.value.createValue.useMutation({
    onSuccess: (data) => handleSuccess(data),
    onError: (error) => handleError(error),
  });
  const createStateDefMutation = trpc.state.createDefinition.useMutation({
    onSuccess: (data) => handleSuccess(data),
    onError: (error) => handleError(error),
  });

  // --- Form setup ---
  const { control, handleSubmit, formState: { errors }, reset } = useForm<FormValues>({
    // Note: ZodResolver might need specific configuration if schemas differ vastly
    // or consider not using it if relying solely on backend validation for this dynamic form.
    // Use the new stricter default value constants
    defaultValues: isValue ? defaultValueValues : defaultStateValues,
  });

  // Reset form if the type changes dynamically
  React.useEffect(() => {
    // Use the new stricter default value constants for reset
    reset(isValue ? defaultValueValues : defaultStateValues);
  }, [isValue, reset]);

  // --- Shared success/error handlers ---
  const handleSuccess = (data: any) => {
      toast.show('Created successfully!', { native: true });
      haptics.success();
      if (isValue) {
        utils.value.getValues.invalidate();
      } else {
        utils.state.getDefinitions.invalidate();
      }
      if (router.canGoBack()) {
        router.dismiss(); // Apply patch #5 - Use dismiss for modals
      } else {
        router.replace('/(tabs)/compass');
      }
  }

  const handleError = (error: any) => {
       toast.show(`Error: ${error.message}`, { type: 'error', native: true });
       haptics.error();
  }

  // --- Corrected onSubmit ---
  const onSubmit = (formData: FormValues) => {
    // 3️⃣ Use discriminant (__type) for type safety, remove casts
    if (formData.__type === 'value') {
      createValueMutation.mutate(formData);
    } else { // formData.__type === 'state'
      createStateDefMutation.mutate(formData);
    }
  };

  // Handle invalid type parameter gracefully
  if (!type) {
    return (
        <YStack flex={1} justifyContent="center" alignItems="center" padding="$4">
            <Paragraph color="$error">Invalid type specified.</Paragraph> {/* Use $error */}
            <Button onPress={() => router.back()} marginTop="$4">Go Back</Button>
        </YStack>
    );
  }

  // Determine current mutation state for button
  const isPending = isValue ? createValueMutation.isPending : createStateDefMutation.isPending;

  return (
    <ScrollView contentContainerStyle={{ flexGrow: 1 }}>
      <Form onSubmit={handleSubmit(onSubmit)} flex={1} padding="$4" space="$4" backgroundColor="$background">
        <Stack.Screen options={{ title: isValue ? 'Add Principle' : 'Define State' }} />

        {/* Conditionally render form fields */}
        {isValue ? (
          <>
            {/* --- Fields for Principle/Value --- */}
            <YStack space="$2">
              <Label htmlFor="title">Title</Label> {/* Patch #4: name -> title */}
              <Controller
                name="title" /* Patch #4: name -> title */
                control={control}
                rules={{ required: 'Title is required' }} /* Patch #4 */
                render={({ field }) => ( /* Use inferred types from FormValues */
                  <Input
                    id="title"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value}
                    placeholder="Principle Title"
                  />
                )}
              />
              {/* Use $error token */}
              {errors.title && <Paragraph color="$error">{errors.title?.message}</Paragraph>}
            </YStack>

            <YStack space="$2">
              <Label htmlFor="description">Description (Optional)</Label>
              <Controller
                name="description"
                control={control}
                render={({ field }) => ( // Use inferred types
                  <TextArea
                    id="description"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value ?? ''}
                    placeholder="Describe the principle..."
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && <Paragraph color="$error">{errors.description?.message}</Paragraph>}
            </YStack>
          </>
        ) : (
          <>
            {/* --- Fields for State Definition --- */}
            <YStack space="$2">
              <Label htmlFor="name">State Name</Label>
              <Controller
                name="name"
                control={control}
                rules={{ required: 'Name is required' }}
                render={({ field }) => ( // Use inferred types // Explicit type
                  <Input
                    id="name"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value}
                    placeholder="e.g., Energy Level, Mood" />
                )}
              />
              {errors.name && <Paragraph color="$error">{errors.name?.message}</Paragraph>}
            </YStack>

             <YStack space="$2">
               <Label htmlFor="scale">Scale</Label>
               <Controller
                 name="scale"
                 control={control}
                 rules={{ required: 'Scale is required' }}
                 render={({ field }) => ( // Use inferred types
                   <>
                    <Paragraph>Scale Selector Placeholder (Selected: {field.value})</Paragraph>
                    <XStack space="$2">
                      {/* Removed invalid theme prop */}
                      <Button size="$2" onPress={() => field.onChange('1-5')} theme={field.value === '1-5' ? 'active' : undefined}>1-5</Button>
                      <Button size="$2" onPress={() => field.onChange('1-10')} theme={field.value === '1-10' ? 'active' : undefined}>1-10</Button>
                    </XStack>
                   </>
                 )}
               />
                {errors.scale && <Paragraph color="$error">{errors.scale?.message}</Paragraph>}
             </YStack>

             <YStack space="$2">
              <Label htmlFor="description">Description (Optional)</Label>
              <Controller
                name="description"
                control={control}
                render={({ field }) => ( // Use inferred types
                  <TextArea
                    id="description"
                    onBlur={field.onBlur}
                    onChangeText={field.onChange} // Use onChangeText
                    value={field.value ?? ''}
                    placeholder="Describe when/how to track this state..."
                    numberOfLines={3}
                  />
                )}
              />
              {errors.description && <Paragraph color="$error">{errors.description?.message}</Paragraph>}
            </YStack>

            <XStack space="$4" alignItems="center">
               <Label htmlFor="active" flex={1}>Active</Label>
               <Controller
                 name="active"
                 control={control}
                 render={({ field }: { field: ControllerRenderProps<FieldValues, 'active'> }) => ( // Explicit type
                    <Switch
                      id="active"
                      checked={!!field.value} // Use checked
                      onCheckedChange={field.onChange} // Use onCheckedChange
                      size="$3"
                    >
                        <Switch.Thumb animation="quick" />
                    </Switch>
                 )}
               />
            </XStack>
          </>
        )}

        {/* Removed invalid theme prop */}
        <Form.Trigger asChild disabled={isPending}>
          <Button icon={isPending ? <Spinner /> : undefined}>
            {isPending ? 'Saving...' : 'Save'}
          </Button>
        </Form.Trigger>
      </Form>
    </ScrollView>
  );
}
  ```

- **app/index.tsx** (0.4 KB, 10 lines) Exports: `default`

  ```tsx
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/index.tsx
import { Redirect } from 'expo-router';

export default function RootIndex() {
  // Redirect directly to a specific tab without causing infinite redirects
  // Use the path that matches how it's accessed in the proper format
  // TypeScript suggests this is the correct format for Expo Router
  return <Redirect href="/(tabs)/home" />;
}

  ```

### app/(auth)

- **app/(auth)/_layout.tsx** (0.6 KB, 32 lines) Exports: `default`

  ```tsx
// Auth Stack Layout
import React from 'react';
import { Stack } from 'expo-router';

export default function AuthLayout() {
  return (
    <Stack>
      <Stack.Screen 
        name="login" 
        options={{ 
          title: 'Sign In',
          headerShown: false
        }} 
      />
      <Stack.Screen 
        name="register" 
        options={{ 
          title: 'Create Account',
          headerShown: false
        }} 
      />
      <Stack.Screen 
        name="forgot-password" 
        options={{ 
          title: 'Reset Password',
          headerShown: false
        }} 
      />
    </Stack>
  );
}

  ```

- **app/(auth)/forgot-password.tsx** (2.6 KB, 89 lines) Exports: `default`

  ```tsx
// Forgot Password Screen
import React, { useState } from 'react';
import { Link } from 'expo-router';
import { YStack, H1, Input, Button, Text, Spinner, Image } from 'tamagui';
import { supabase } from '@/utils/supabase';
import { useToastController } from '@tamagui/toast';

export default function ForgotPasswordScreen() {
  const [email, setEmail] = useState('');
  const [loading, setLoading] = useState(false);
  const [success, setSuccess] = useState(false);
  const toast = useToastController();

  // Send password reset email via Supabase
  const handleResetPassword = async () => {
    if (!email) {
      toast.show('Please enter your email', { type: 'error' });
      return;
    }

    setLoading(true);

    try {
      const { error } = await supabase.auth.resetPasswordForEmail(email, {
        redirectTo: window?.location?.origin ? `${window.location.origin}/update-password` : undefined,
      });

      if (error) throw error;

      setSuccess(true);
      toast.show('Password reset email sent!', { type: 'success' });
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to send reset email';
      toast.show(errorMessage, { type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <YStack flex={1} padding="$4" justifyContent="center" space="$4" backgroundColor="$background">
      <YStack alignItems="center" marginBottom="$6">
        {/* Replace with your app logo */}
        <Image 
          source={require('@/assets/images/icon.png')} 
          width={100} 
          height={100} 
          marginBottom="$6" 
          resizeMode="contain"
        />
        <H1>Reset Password</H1>
        <Text color="$gray10" textAlign="center">
          {success 
            ? 'Check your email for reset instructions' 
            : 'Enter your email to receive reset instructions'}
        </Text>
      </YStack>

      {!success ? (
        <>
          <Input
            placeholder="Email"
            value={email}
            onChangeText={setEmail}
            autoCapitalize="none"
            keyboardType="email-address"
          />

          <Button
            onPress={handleResetPassword}
            disabled={loading}
            backgroundColor="$blue10"
            color="white"
            size="$5"
          >
            {loading ? <Spinner color="white" /> : 'Send Reset Link'}
          </Button>
        </>
      ) : null}

      <YStack paddingTop="$6" alignItems="center">
        <Link href="/(auth)/login">
          <Text color="$blue10">Back to Sign In</Text>
        </Link>
      </YStack>
    </YStack>
  );
}

  ```

- **app/(auth)/login.tsx** (2.5 KB, 93 lines) Exports: `default`

  ```tsx
// Login Screen
import React, { useState } from 'react';
import { Link, router } from 'expo-router';
import { YStack, H1, Input, Button, Text, XStack, Spinner, Image } from 'tamagui';
import { supabase } from '@/utils/supabase';
import { useToastController } from '@tamagui/toast';

export default function LoginScreen() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const toast = useToastController();

  // Sign in with Supabase authentication
  const handleLogin = async () => {
    if (!email || !password) {
      toast.show('Please enter both email and password', { type: 'error' });
      return;
    }

    setLoading(true);

    try {
      const { error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (error) throw error;

      // Navigate to home screen on successful login
      router.replace('/(tabs)/home');
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Login failed';
      toast.show(errorMessage, { type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <YStack flex={1} padding="$4" justifyContent="center" space="$4" backgroundColor="$background">
      <YStack alignItems="center" marginBottom="$6">
        {/* Replace with your app logo */}
        <Image 
          source={require('@/assets/images/icon.png')} 
          width={100} 
          height={100} 
          marginBottom="$6" 
          resizeMode="contain"
        />
        <H1>Welcome to Aether</H1>
        <Text color="$gray10">Sign in to your account</Text>
      </YStack>

      <Input
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        autoCapitalize="none"
        keyboardType="email-address"
      />

      <Input
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />

      <Button
        onPress={handleLogin}
        disabled={loading}
        backgroundColor="$blue10"
        color="white"
        size="$5"
      >
        {loading ? <Spinner color="white" /> : 'Sign In'}
      </Button>

      <XStack justifyContent="space-between" paddingTop="$2">
        <Link href="/(auth)/forgot-password">
          <Text color="$blue10">Forgot Password?</Text>
        </Link>

        <Link href="/(auth)/register">
          <Text color="$blue10">Create Account</Text>
        </Link>
      </XStack>
    </YStack>
  );
}

  ```

- **app/(auth)/register.tsx** (3.0 KB, 107 lines) Exports: `default`

  ```tsx
// Register Screen
import React, { useState } from 'react';
import { Link, router } from 'expo-router';
import { YStack, H1, Input, Button, Text, XStack, Spinner, Image } from 'tamagui';
import { supabase } from '@/utils/supabase';
import { useToastController } from '@tamagui/toast';

export default function RegisterScreen() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [loading, setLoading] = useState(false);
  const toast = useToastController();

  // Create new account with Supabase authentication
  const handleRegister = async () => {
    if (!email || !password) {
      toast.show('Please enter both email and password', { type: 'error' });
      return;
    }

    if (password !== confirmPassword) {
      toast.show('Passwords do not match', { type: 'error' });
      return;
    }

    setLoading(true);

    try {
      const { error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          emailRedirectTo: window?.location?.origin || undefined,
        }
      });

      if (error) throw error;

      // Navigate to home screen on successful registration
      toast.show('Account created successfully!', { type: 'success' });
      router.replace('/(tabs)/home');
    } catch (error: unknown) {
      const errorMessage = error instanceof Error ? error.message : 'Registration failed';
      toast.show(errorMessage, { type: 'error' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <YStack flex={1} padding="$4" justifyContent="center" space="$4" backgroundColor="$background">
      <YStack alignItems="center" marginBottom="$6">
        {/* Replace with your app logo */}
        <Image 
          source={require('@/assets/images/icon.png')} 
          width={100} 
          height={100} 
          marginBottom="$6" 
          resizeMode="contain"
        />
        <H1>Create Account</H1>
        <Text color="$gray10">Sign up to get started</Text>
      </YStack>

      <Input
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        autoCapitalize="none"
        keyboardType="email-address"
      />

      <Input
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />
      
      <Input
        placeholder="Confirm Password"
        value={confirmPassword}
        onChangeText={setConfirmPassword}
        secureTextEntry
      />

      <Button
        onPress={handleRegister}
        disabled={loading}
        backgroundColor="$blue10"
        color="white"
        size="$5"
      >
        {loading ? <Spinner color="white" /> : 'Create Account'}
      </Button>

      <XStack justifyContent="center" paddingTop="$2">
        <Text color="$gray10">Already have an account? </Text>
        <Link href="/(auth)/login">
          <Text color="$blue10">Sign In</Text>
        </Link>
      </XStack>
    </YStack>
  );
}

  ```

### app/(tabs)

- **app/(tabs)/_layout.tsx** (1.9 KB, 69 lines) Exports: `default`

  ```tsx
import React from 'react';
import { Tabs } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import { useColorModeValue } from '@/design-system/Primitives';

export default function TabsLayout() {
  const active = useColorModeValue('#86A5A9', '#64FFDA');
  const inactive = useColorModeValue('#8e8e93', '#626262');
  const bg = useColorModeValue('#FDFFE0', '#1A2E3A');
  const border = useColorModeValue('#E5E5EA', '#2C2C2E');

  return (
    <Tabs
      screenOptions={{
        headerShown: false,
        tabBarActiveTintColor: active,
        tabBarInactiveTintColor: inactive,
        tabBarStyle: { backgroundColor: bg, borderTopColor: border, height: 60 },
      }}
    >
      <Tabs.Screen
        name="home"
        options={{
          title: 'Home',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="home-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="planner"
        options={{
          title: 'Planner',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="calendar-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="compass"
        options={{
          title: 'Compass',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="stats-chart-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="rewards"
        options={{
          title: 'Rewards',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="sparkles-outline" size={size} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="settings"
        options={{
          title: 'Settings',
          tabBarIcon: ({ color, size }) => (
            <Ionicons name="settings-outline" size={size} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}

  ```

- **app/(tabs)/compass/index.tsx** (4.9 KB, 163 lines) Exports: `default`

  ```tsx
// Compass screen with Principles and States tabs
import React, { useState } from 'react';
import { YStack, XStack, Text, Tabs, Button, ScrollView } from 'tamagui'; 
import { SafeAreaView } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc, type RouterOutputs } from '@/utils/trpc'; 
import { useColorScheme } from '@/hooks/useColorScheme'; 
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { router, type Href } from 'expo-router'; 
import { PrincipleCard } from '@/components/compass/PrincipleCard';
import PrinciplesTab from '@/components/compass/PrinciplesTab';
import { StateDefinitionCard } from '@/components/compass/StateDefinitionCard'; 

interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'principles',
    title: 'Principles',
    icon: <Ionicons name="compass-outline" size={18} color="currentColor" />
  },
  {
    key: 'states',
    title: 'States',
    icon: <Ionicons name="pulse-outline" size={18} color="currentColor" />
  }
];

export default function CompassScreen() {
  const [activeTab, setActiveTab] = useState<string>('principles');
  const colorScheme = useColorScheme();

  const handleAddPress = () => {
    const route = `/compose?type=${activeTab === 'principles' ? 'value' : 'state'}` as Href;
    router.push(route);
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Compass</Text>
          <Button
            size="$3"
            circular
            onPress={handleAddPress} 
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>

        {/* Tabs */}
        <Tabs
          defaultValue="principles"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {React.cloneElement(tab.icon as React.ReactElement, { color: activeTab === tab.key ? '$colorFocus' : '$color' })}
                  <Text color={activeTab === tab.key ? '$colorFocus' : '$color'}>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>

          {/* Tab Content */}
          <Tabs.Content value="principles" flex={1} key="principles-content">
            <ScrollView>
              <PrinciplesTab />
            </ScrollView>
          </Tabs.Content>

          <Tabs.Content value="states" flex={1} key="states-content">
            <ScrollView>
              <StatesTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Define the specific types from RouterOutputs
// Types are now defined in the PrinciplesTab component
type StateDefinition = RouterOutputs['state']['getDefinitions'][number]; 

// Principles Tab Component is now imported from '@/components/compass/PrinciplesTab'

// States Tab Component (manages data fetching and list rendering)
function StatesTab() {
  const { data: states, isLoading, error, refetch } = trpc.state.getDefinitions.useQuery(); 

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }

  if (error) {
    return (
      <EmptyOrSkeleton
        isEmpty={false}
        isError={true}
        onRetry={refetch}
        text="Failed to load tracked state definitions"
      />
    );
  }

  if (!states || states.length === 0) {
    return (
      <EmptyOrSkeleton
        isEmpty={true}
        text="No state definitions found"
        actionText="Define Your First State"
        onAction={() => router.push('/compose?type=state' as Href)}
      />
    );
  }

  return (
    <YStack space="$3"> 
      {states.map((state: StateDefinition) => (
        <StateDefinitionCard
          key={state.id}
          state={state}
          onPress={() => router.push(`/states/${state.id}` as Href)}
        />
      ))}
    </YStack>
  );
}

// 
// Removed inline PrincipleCard definition (extracted to components/compass/PrincipleCard.tsx)
// 

// 
// Removed inline StateDefinitionCard definition (extracted to components/compass/StateDefinitionCard.tsx)
// 

  ```

- **app/(tabs)/home/index.tsx** (2.2 KB, 65 lines) Exports: `default`

  ```tsx
/* app/(tabs)/home/index.tsx */
import React from 'react';
import { RefreshControl } from 'react-native';
import { Stack, Text, ScrollView, Button } from '@/design-system/Primitives';
import { useDashboardQuery } from '@/app/lib/useDashboardQuery';
import { useToggleTaskStatus } from '@/app/lib/useToggleTaskStatus';
import { SwipeableRow } from '@/app/components/SwipeableRow';
import { TaskRow } from '@/app/components/TaskRow';
import { SectionCard } from '@/app/components/SectionCard';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { useColorModeValue } from '@gluestack-ui/themed';

export default function HomeScreen() {
  const router = useRouter();
  const { data, isLoading, isRefetching, refetch } = useDashboardQuery();
  const toggleTask = useToggleTaskStatus();

  const parchment = useColorModeValue('#FDFFE0', '#1A2E3A');

  return (
    <ScrollView
      className="flex-1 px-4"
      style={{ backgroundColor: parchment }}
      refreshControl={<RefreshControl refreshing={isRefetching} onRefresh={refetch} />}
    >
      <Text className="text-2xl font-heading text-darkText mt-6 mb-4">
        Good morning, Link!
      </Text>

      {/* Tasks Section */}
      <SectionCard
        title="Tasks for today"
        action={
          <Button
            className="flex-row items-center"
            onPress={() => router.push('/(tabs)/planner/add-task')}
          >
            <Ionicons name="add" size={18} color="#86A5A9" />
            <Text className="ml-1 text-sheikahCyan">New</Text>
          </Button>
        }
      >
        {isLoading && <Text>Loading…</Text>}
        {!isLoading && (!data?.tasks?.length ? (
          <Text className="text-ios-gray-3">No tasks 🎉</Text>
        ) : (
          data.tasks.map((task) => (
            <SwipeableRow
              key={task.id}
              onComplete={() =>
                toggleTask.mutate({ taskId: task.id, completed: task.status !== 'done' })
              }
            >
              <TaskRow task={task} />
            </SwipeableRow>
          ))
        ))}
      </SectionCard>

      {/* You can add Habits / Goals sections here following the same pattern */}
    </ScrollView>
  );
}

  ```

- **app/(tabs)/planner/_layout.tsx** (0.9 KB, 19 lines) Exports: `default`

  ```tsx
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/planner/_layout.tsx
import { Stack } from 'expo-router';
import React from 'react';

export default function PlannerLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      {/* The index screen is the default for the planner tab */}
      <Stack.Screen name="index" />
      {/* Add screens for the sub-pages */}
      <Stack.Screen name="add-task" options={{ presentation: 'modal', title: 'Add Task' }} />
      <Stack.Screen name="add-habit" options={{ presentation: 'modal', title: 'Add Habit' }} />
      <Stack.Screen name="add-goal" options={{ presentation: 'modal', title: 'Add Goal' }} />
      <Stack.Screen name="goal/[id]" options={{ title: 'Goal Details' }} />
      <Stack.Screen name="habit/[id]" options={{ title: 'Habit Details' }} />
    </Stack>
  );
}

  ```

- **app/(tabs)/planner/add-goal.tsx** (0.7 KB, 20 lines) Exports: `default`

  ```tsx
// Placeholder for Add Goal Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function AddGoalScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Add New Goal</H1>
        <Text>Goal details form will go here.</Text>
        <Button onPress={() => router.back()}>Cancel</Button>
      </YStack>
    </SafeAreaView>
  );
}

  ```

- **app/(tabs)/planner/add-habit.tsx** (0.7 KB, 20 lines) Exports: `default`

  ```tsx
// Placeholder for Add Habit Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function AddHabitScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Add New Habit</H1>
        <Text>Habit details form will go here.</Text>
        <Button onPress={() => router.back()}>Cancel</Button>
      </YStack>
    </SafeAreaView>
  );
}

  ```

- **app/(tabs)/planner/add-task.tsx** (0.7 KB, 20 lines) Exports: `default`

  ```tsx
// Placeholder for Add Task Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function AddTaskScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Add New Task</H1>
        <Text>Task details form will go here.</Text>
        <Button onPress={() => router.back()}>Cancel</Button>
      </YStack>
    </SafeAreaView>
  );
}

  ```

- **app/(tabs)/planner/goal/[id].tsx** (0.8 KB, 23 lines) Exports: `default`

  ```tsx
// Placeholder for Goal Detail Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router, useLocalSearchParams } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function GoalDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const colorScheme = useColorScheme();

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Goal Detail: {id}</H1>
        <Text>Details for goal {id} will be displayed here.</Text>
        {/* Add tRPC query to fetch goal data based on id */}
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}

  ```

- **app/(tabs)/planner/habit/[id].tsx** (0.8 KB, 23 lines) Exports: `default`

  ```tsx
// Placeholder for Habit Detail Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router, useLocalSearchParams } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function HabitDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const colorScheme = useColorScheme();

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Habit Detail: {id}</H1>
        <Text>Details for habit {id} will be displayed here.</Text>
        {/* Add tRPC query to fetch habit data based on id */}
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}

  ```

- **app/(tabs)/planner/index.tsx** (7.6 KB, 266 lines) Exports: `default`

  ```tsx
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/planner/index.tsx
import React, { useState, Suspense } from 'react';
import { YStack, XStack, Text, Tabs, Button, Spinner, Card, ScrollView } from 'tamagui';
import { SafeAreaView, FlatList, RefreshControl } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { RouterOutputs } from '@/utils/api-types';
import { SectionError } from '@/components/ui/ErrorBanner';


interface TabData {
  key: string;
  title: string;
  icon: React.ReactNode;
}

// Tab configurations
const TABS: TabData[] = [
  {
    key: 'goals',
    title: 'Goals',
    icon: <Ionicons name="trophy-outline" size={18} color="currentColor" />
  },
  {
    key: 'habits',
    title: 'Habits',
    icon: <Ionicons name="repeat-outline" size={18} color="currentColor" />
  },
  {
    key: 'calendar',
    title: 'Calendar',
    icon: <Ionicons name="calendar-outline" size={18} color="currentColor" />
  }
];

export default function PlannerScreen() {
  const [activeTab, setActiveTab] = useState<string>('goals');
  const colorScheme = useColorScheme();
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        {/* Header */}
        <XStack justifyContent="space-between" alignItems="center" marginBottom="$4">
          <Text fontSize={24} fontWeight="bold">Planner</Text>
          <Button
            size="$3"
            circular
            onPress={() => {/* Handle new item */}}
            icon={<Ionicons name="add" size={22} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          />
        </XStack>
        
        {/* Tabs */}
        <Tabs
          defaultValue="goals"
          orientation="horizontal"
          flexDirection="column"
          flex={1}
          value={activeTab}
          onValueChange={setActiveTab}
        >
          <Tabs.List 
            backgroundColor="$backgroundStrong"
            paddingHorizontal="$2"
            borderRadius="$4"
            marginBottom="$4"
          >
            {TABS.map((tab) => (
              <Tabs.Tab
                key={tab.key}
                flex={1}
                value={tab.key}
                padding="$3"
                borderRadius="$2"
                backgroundColor={activeTab === tab.key ? '$backgroundFocus' : 'transparent'}
              >
                <XStack space="$2" justifyContent="center" alignItems="center">
                  {tab.icon}
                  <Text>{tab.title}</Text>
                </XStack>
              </Tabs.Tab>
            ))}
          </Tabs.List>
          
          {/* Tab Content */}
          <Tabs.Content value="goals" flex={1}>
            <ScrollView>
              <GoalsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="habits" flex={1}>
            <ScrollView>
              <HabitsTab />
            </ScrollView>
          </Tabs.Content>
          
          <Tabs.Content value="calendar" flex={1}>
            <ScrollView>
              <CalendarTab />
            </ScrollView>
          </Tabs.Content>
        </Tabs>
      </YStack>
    </SafeAreaView>
  );
}

// Goals Tab
function GoalsTab() {
  // Fetch goals using tRPC
  const { data: goals, isLoading, error, refetch } = trpc.goal.getGoals.useQuery();
  
  // Define the inferred type for a single goal
  type PlannerGoal = RouterOutputs['goal']['getGoals'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={true} count={3} type="card" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load goals" 
      />
    );
  }
  
  if (!goals || goals.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No goals yet" 
        actionText="Create a goal" 
        onAction={() => router.push('/planner/add-goal')} 
      />
    );
  }
  
  return (
    <YStack space="$4">
      {goals.map((goal: PlannerGoal) => (
        <Button 
          key={goal.id} 
          height="$12" 
          justifyContent="flex-start" 
          paddingHorizontal="$3"
          onPress={() => router.push({ pathname: '/planner/goal/[id]', params: { id: goal.id } })}
        >
          <YStack>
            <Text fontWeight="bold">{goal.title}</Text>
            <Text fontSize="$2" color="$gray10">
              {goal.dueDate ? new Date(goal.dueDate).toLocaleDateString() : 'No due date'}
            </Text>
          </YStack>
        </Button>
      ))}
    </YStack>
  );
}

// Habits Tab
function HabitsTab() {
  // Fetch habits using tRPC
  const { data: habits, isLoading, error, refetch } = trpc.habit.getHabits.useQuery();
  
  // Define the inferred type for a single habit
  type PlannerHabit = RouterOutputs['habit']['getHabits'][number];

  if (isLoading) {
    return <EmptyOrSkeleton isLoading={isLoading} count={3} type="row" />;
  }
  
  if (error) {
    return (
      <EmptyOrSkeleton 
        isEmpty={false} 
        isError={true} 
        onRetry={refetch} 
        text="Failed to load habits" 
      />
    );
  }
  
  if (!habits || habits.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty={true} 
        text="No habits yet" 
        actionText="Create a habit" 
        onAction={() => router.push('/planner/add-habit')} 
      />
    );
  }
  
  return (
    <YStack space="$3">
      {habits.map((habit: PlannerHabit) => (
        <XStack 
          key={habit.id} 
          justifyContent="space-between" 
          alignItems="center" 
          paddingVertical="$3" 
          paddingHorizontal="$3" 
          borderBottomWidth={1} 
          borderColor="$gray5"
          pressStyle={{ opacity: 0.7 }}
          tag="pressable"
          onPress={() => router.push({ pathname: '/planner/habit/[id]', params: { id: habit.id } })}
        >
          <Text>{habit.title}</Text>
          <Button
            size="$2"
            circular
            backgroundColor={habit.completed ? '$green9' : '$gray9'}
            onPress={() => {
              // Use today's date for the habit entry
              const today = new Date().toISOString().split('T')[0];
              
              // Create a mutation to toggle habit completion
              const toggleHabit = trpc.habit.createHabitEntry.useMutation({
                onSuccess: () => {
                  refetch(); // Refresh data after toggling
                },
                onError: (error) => {
                  // Show error message
                  console.error('Failed to toggle habit:', error.message);
                }
              });
              
              // Toggle the habit completion status
              toggleHabit.mutate({
                habitId: habit.id,
                completed: !habit.completed,
                date: today
              });
            }}
            icon={<Ionicons name="checkmark" size={18} color="white" />}
          />
        </XStack>
      ))}
    </YStack>
  );
}

// Calendar Tab
function CalendarTab() {
  return (
    <YStack alignItems="center" justifyContent="center" padding="$8">
      <Text fontSize="$5" textAlign="center">
        Calendar integration coming soon
      </Text>
      <Text marginTop="$2" color="$gray10" textAlign="center">
        This tab will display task and habit schedules in a calendar view
      </Text>
    </YStack>
  );
}

  ```

- **app/(tabs)/rewards/index.tsx** (9.0 KB, 257 lines) Exports: `default`

  ```tsx
// Rewards screen with grid/list toggle and claim functionality
import React, { useState, useCallback } from 'react';
import { YStack, XStack, Text, Button, ScrollView, Card, Checkbox, useTheme, H1 } from 'tamagui';
import { SafeAreaView, View, FlatList, ImageBackground, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { trpc } from '@/utils/trpc';
import { useColorScheme } from '@/hooks/useColorScheme';
import { RouterOutputs } from '@/utils/trpc'; // Import RouterOutputs
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton'; // Import helper component

// Define inferred type for rewards
type RewardItem = RouterOutputs['rewards']['getAvailableRewards'][number];

enum ViewMode {
  Grid = 'grid',
  List = 'list'
}

export default function RewardsScreen() {
  const [viewMode, setViewMode] = useState<ViewMode>(ViewMode.Grid);
  const colorScheme = useColorScheme();
  const theme = useTheme();

  // Define fallback colors
  const blue2 = theme?.blue2?.val ?? '#eff6ff';
  const blue5 = theme?.blue5?.val ?? '#60a5fa';
  const blue10 = theme?.blue10?.val ?? '#1e40af';
  const blue11 = theme?.blue11?.val ?? '#1e3a8a';
  const green9 = theme?.green9?.val ?? '#16a34a';

  // Fetch available rewards from tRPC
  const { 
    data: rewards, 
    isLoading, 
    error, 
    refetch 
  } = trpc.rewards.getAvailableRewards.useQuery();

  // Mutation for claiming rewards
  const claimMutation = trpc.rewards.earnReward.useMutation({
    onSuccess: (data) => {
      console.log('Reward claimed successfully:', data);
      // Maybe show confetti?
      Alert.alert('Reward Claimed!', `You spent ${data.reward.points_spent} points. Remaining: ${data.remainingPoints}`);
      refetch(); // Refetch the list of available rewards
    },
    onError: (err) => {
      console.error('Failed to claim reward:', err);
      Alert.alert('Claim Failed', err.message || 'Could not claim reward.');
    }
  });
  
  const handleClaimReward = useCallback((rewardId: string) => {
    if (claimMutation.isPending) return; // Prevent double-clicks
    
    Alert.alert(
      'Confirm Claim',
      'Are you sure you want to spend points on this reward?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Claim', 
          onPress: () => {
            claimMutation.mutate({ rewardId });
          },
          style: 'default'
        }
      ]
    );
  }, [claimMutation]);
  
  const renderItem = ({ item }: { item: RewardItem }) => { // Use inferred type
    // Assuming backend field is image_url, map to imagePath
    const imagePath = item.image_url; 
    // All items from getAvailableRewards are considered claimable (not yet claimed)
    const claimed = false; 
    // Map required_points to pointCost
    const pointCost = item.required_points;

    if (viewMode === ViewMode.Grid) {
      return (
        <Card
          size="$4"
          bordered
          width={160}
          height={200}
          margin="$2"
          overflow="hidden"
          elevation="$2"
          opacity={claimed ? 0.7 : 1}
        >
          <ImageBackground
            source={{ uri: imagePath }}
            style={{ width: '100%', height: 100 }}
          >
            <View style={{ 
              position: 'absolute', 
              top: 5, 
              right: 5, 
              backgroundColor: blue5,
              borderRadius: 10,
              padding: 4
            }}>
              <Text color="white" fontSize="$2" fontWeight="bold">
                {pointCost} pts
              </Text>
            </View>
          </ImageBackground>
          
          <YStack padding="$2" flex={1} justifyContent="space-between">
            <Text fontSize="$4" fontWeight="bold" numberOfLines={1}>
              {item.name}
            </Text>
            
            <Button
              size="$2"
              themeInverse={claimed}
              backgroundColor={claimed ? undefined : blue10}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </YStack>
        </Card>
      );
    } else {
      return (
        <Card
          bordered
          margin="$2"
          padding="$3"
          opacity={claimed ? 0.7 : 1}
        >
          <XStack space="$3" alignItems="center">
            {imagePath && (
              <View style={{ 
                width: 60, 
                height: 60, 
                borderRadius: 8, 
                overflow: 'hidden',
                backgroundColor: theme.gray3.val
              }}>
                <ImageBackground
                  source={{ uri: imagePath }}
                  style={{ width: '100%', height: '100%' }}
                />
              </View>
            )}
            
            <YStack flex={1} space="$1">
              <Text fontSize="$5" fontWeight="bold">{item.name}</Text>
              <Text fontSize="$3" color="$gray11" numberOfLines={2}>{item.description}</Text>
              <Text fontSize="$3" color={blue10} fontWeight="500">{pointCost} points</Text>
            </YStack>
            
            <Button
              size="$3"
              backgroundColor={claimed ? undefined : blue10}
              themeInverse={claimed}
              onPress={() => handleClaimReward(item.id)}
              disabled={claimed || claimMutation.isPending} // Disable if claimed or mutation pending
            >
              {claimMutation.isPending && claimMutation.variables?.rewardId === item.id ? 'Claiming...' : (claimed ? 'Claimed' : 'Claim')}
            </Button>
          </XStack>
        </Card>
      );
    }
  };
  
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4">
        <YStack space="$4">
          {/* Header */}
          <XStack justifyContent="space-between" alignItems="center">
            <H1>Rewards</H1>
            
            <XStack space="$2">
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.Grid ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.Grid)}
              >
                <Ionicons 
                  name="grid-outline" 
                  size={22} 
                  color={viewMode === ViewMode.Grid ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
              
              <Button
                chromeless
                circular
                padding="$2"
                backgroundColor={viewMode === ViewMode.List ? blue5 : 'transparent'}
                onPress={() => setViewMode(ViewMode.List)}
              >
                <Ionicons 
                  name="list-outline" 
                  size={22} 
                  color={viewMode === ViewMode.List ? blue10 : (colorScheme === 'dark' ? '#fff' : '#000')} 
                />
              </Button>
            </XStack>
          </XStack>
          
          {/* Stats */}
          <Card padding="$3" backgroundColor={blue2}>
            <XStack justifyContent="space-between" alignItems="center">
              <Text fontSize="$5" fontWeight="bold" color={blue11}>Your Points</Text>
              <Text fontSize="$6" fontWeight="bold" color={blue10}>275</Text>
            </XStack>
          </Card>
        </YStack>
        
        {/* Content Area */} 
        <EmptyOrSkeleton 
          isLoading={isLoading}
          isEmpty={!isLoading && !error && (!rewards || rewards.length === 0)}
          isError={!!error}
          text={error ? error.message : 'No rewards available yet.'} // Use text for error OR empty msg
          onRetry={refetch}
          type={viewMode === ViewMode.Grid ? 'card' : 'row'}
          count={viewMode === ViewMode.Grid ? 6 : 3}
        >
          <FlatList
            key={viewMode} // Change key based on viewMode to force re-render
            data={rewards}
            renderItem={renderItem}
            keyExtractor={(item, index) =>
              `${item?.id ?? `tmp-${index}`}-${viewMode}`   // fall back to index if ID is missing
            }
            
            // Optional: Log corrupt data in development
            onLayout={() => {
              if (__DEV__) {
                const missing = (rewards ?? []).filter(r => !r?.id);
                if (missing.length) console.warn('Rewards missing id:', missing);
              }
            }}
            numColumns={viewMode === ViewMode.Grid ? 2 : 1}
            contentContainerStyle={{ paddingBottom: 50 }} // Add padding at the bottom
            // Optional Optimizations (Patch #6)
            initialNumToRender={8}
            removeClippedSubviews={true} // Note: Can have visual glitches on iOS sometimes
          />
        </EmptyOrSkeleton>

      </YStack>
    </SafeAreaView>
  );
}

  ```

- **app/(tabs)/settings/_layout.tsx** (0.9 KB, 20 lines) Exports: `default`

  ```tsx
// File: /Users/tylerbedford/Documents/Coding Projects/AetherIphone/app/(tabs)/settings/_layout.tsx
import { Stack } from 'expo-router';
import React from 'react';

export default function SettingsLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      {/* The index screen is the default for the settings tab */}
      <Stack.Screen name="index" />
      {/* Add screens for the sub-pages */}
      <Stack.Screen name="profile" options={{ title: 'Edit Profile' }} />
      <Stack.Screen name="security" options={{ title: 'Security' }} />
      <Stack.Screen name="privacy" options={{ title: 'Data & Privacy' }} />
      <Stack.Screen name="notifications" options={{ title: 'Notifications' }} />
      <Stack.Screen name="help" options={{ title: 'Help & Support' }} />
      <Stack.Screen name="about" options={{ title: 'About Aether' }} />
    </Stack>
  );
}

  ```

- **app/(tabs)/settings/about.tsx** (0.7 KB, 20 lines) Exports: `default`

  ```tsx
// Placeholder for About Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function AboutScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>About Aether</H1>
        <Text>App version, terms of service, credits, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}

  ```

- **app/(tabs)/settings/help.tsx** (0.7 KB, 20 lines) Exports: `default`

  ```tsx
// Placeholder for Help Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function HelpScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Help & Support</H1>
        <Text>FAQ, contact support link, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}

  ```

- **app/(tabs)/settings/index.tsx** (9.6 KB, 274 lines) Exports: `default`

  ```tsx
// Settings screen with account, preferences, and app settings
import React, { useState } from 'react';
import { YStack, XStack, Text, Button, Switch, Separator, ScrollView, Card, H1 } from 'tamagui';
import { SafeAreaView, View, Alert } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { router } from 'expo-router';
import { supabase } from '@/utils/supabase';
import { useColorScheme } from 'react-native';
import { useAccent } from '@/app/_layout'; // Import the useAccent hook

interface SettingsSectionProps {
  title: string;
  icon: React.ReactNode;
  children: React.ReactNode;
}

const SettingsSection = ({ title, icon, children }: SettingsSectionProps) => {
  return (
    <YStack marginVertical="$2">
      <XStack alignItems="center" space="$2" marginBottom="$2">
        {icon}
        <Text fontSize="$5" fontWeight="bold">{title}</Text>
      </XStack>
      <Card padding="$3" bordered>
        {children}
      </Card>
    </YStack>
  );
};

interface SettingsRowProps {
  label: string;
  icon?: React.ReactNode;
  rightElement?: React.ReactNode;
  onPress?: () => void;
  showChevron?: boolean;
}

const SettingsRow = ({ label, icon, rightElement, onPress, showChevron = false }: SettingsRowProps) => {
  return (
    <XStack
      paddingVertical="$3"
      justifyContent="space-between"
      alignItems="center"
      onPress={onPress}
      pressStyle={onPress ? { opacity: 0.7 } : undefined}
    >
      <XStack space="$3" alignItems="center" flex={1}>
        {icon}
        <Text fontSize="$4">{label}</Text>
      </XStack>
      <XStack space="$2" alignItems="center">
        {rightElement}
        {showChevron && <Ionicons name="chevron-forward" size={18} color="#A0A0A0" />}
      </XStack>
    </XStack>
  );
};

export default function SettingsScreen() {
  const colorScheme = useColorScheme();
  const [notificationsEnabled, setNotificationsEnabled] = useState(true);
  const [trackingEnabled, setTrackingEnabled] = useState(true);
  const { setAccent } = useAccent(); // Get the function to update accent color
  const [selectedAccent, setSelectedAccent] = useState('blue'); // Placeholder state for selected accent

  const handleLogout = async () => {
    Alert.alert(
      'Log Out',
      'Are you sure you want to log out?',
      [
        { text: 'Cancel', style: 'cancel' },
        { 
          text: 'Log Out', 
          style: 'destructive',
          onPress: async () => {
            await supabase.auth.signOut();
            router.replace('/(auth)/login');
          }
        }
      ]
    );
  };

  const AccentSelector = ({ currentAccent, onSelect }: { currentAccent: string, onSelect: (accent: string) => void }) => {
    const accents = ['blue', 'green', 'orange', 'red']; // Example accents corresponding to theme names
    return (
      <XStack space="$2">
        {accents.map((accent) => (
          <Button 
            key={accent} 
            onPress={() => {
              onSelect(accent);
              setAccent(accent); // Call setAccent with the selected accent
            }} 
            theme={accent as any} // Preview the theme (cast needed for demo)
            backgroundColor={accent === currentAccent ? '$backgroundStrong' : '$background'}
          >
            {accent.charAt(0).toUpperCase() + accent.slice(1)}
          </Button>
        ))}
      </XStack>
    );
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <ScrollView>
        <YStack flex={1} padding="$4">
          <H1 marginBottom="$4">Settings</H1>
          
          {/* Account Section */}
          <SettingsSection
            title="Account"
            icon={<Ionicons name="person-circle-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Edit Profile"
                icon={<Ionicons name="person-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/profile' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Security"
                icon={<Ionicons name="lock-closed-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/security' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Data & Privacy"
                icon={<Ionicons name="shield-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/privacy' as any)}
              />
            </YStack>
          </SettingsSection>
          
          {/* Appearance Section */}
          <SettingsSection
            title="Appearance"
            icon={<Ionicons name="color-palette-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Theme"
                icon={<Ionicons name="moon-outline" size={20} color="#A0A0A0" />}
                rightElement={<Text color="$gray10">{colorScheme === 'dark' ? 'Dark (System)' : 'Light (System)'}</Text>}
              />
              <SettingsRow
                label="Accent Color"
                icon={<Ionicons name="color-palette-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <AccentSelector 
                    currentAccent={selectedAccent} 
                    onSelect={(accent) => setSelectedAccent(accent)} 
                  />
                }
              />
            </YStack>
          </SettingsSection>
          
          {/* Notifications Section */}
          <SettingsSection
            title="Notifications"
            icon={<Ionicons name="notifications-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Push Notifications"
                icon={<Ionicons name="push-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={notificationsEnabled}
                    onCheckedChange={setNotificationsEnabled}
                  />
                }
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Notification Settings"
                icon={<Ionicons name="options-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/notifications' as any)}
              />
            </YStack>
          </SettingsSection>
          
          {/* Privacy Section */}
          <SettingsSection
            title="Privacy & Data"
            icon={<Ionicons name="analytics-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Analytics Tracking"
                icon={<Ionicons name="trending-up-outline" size={20} color="#A0A0A0" />}
                rightElement={
                  <Switch
                    size="$3"
                    checked={trackingEnabled}
                    onCheckedChange={setTrackingEnabled}
                  />
                }
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="Export Data"
                icon={<Ionicons name="download-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => {
                  Alert.alert(
                    'Export Data',
                    'Your data will be prepared for export and sent to your email address.',
                    [
                      { text: 'Cancel', style: 'cancel' },
                      { text: 'Export', onPress: () => {
                        // Would call an API endpoint to initiate export
                        Alert.alert('Export Initiated', 'Check your email for the export file.');
                      }}
                    ]
                  );
                }}
              />
            </YStack>
          </SettingsSection>
          
          {/* Support Section */}
          <SettingsSection
            title="Support & About"
            icon={<Ionicons name="help-circle-outline" size={24} color={colorScheme === 'dark' ? '#fff' : '#000'} />}
          >
            <YStack>
              <SettingsRow
                label="Help Center"
                icon={<Ionicons name="help-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/help' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="About Aether"
                icon={<Ionicons name="information-circle-outline" size={20} color="#A0A0A0" />}
                showChevron
                onPress={() => router.push('/settings/about' as any)}
              />
              <Separator marginVertical="$1" />
              <SettingsRow
                label="App Version"
                icon={<Ionicons name="code-outline" size={20} color="#A0A0A0" />}
                rightElement={<Text color="$gray10">1.0.0</Text>}
              />
            </YStack>
          </SettingsSection>
          
          {/* Logout Button */}
          <Button
            marginTop="$6"
            marginBottom="$8"
            size="$4"
            themeInverse
            onPress={handleLogout}
          >
            Log Out
          </Button>
        </YStack>
      </ScrollView>
    </SafeAreaView>
  );
}

  ```

- **app/(tabs)/settings/notifications.tsx** (0.7 KB, 20 lines) Exports: `default`

  ```tsx
// Placeholder for Notification Settings Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function NotificationSettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Notification Settings</H1>
        <Text>Granular controls for different notification types.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}

  ```

- **app/(tabs)/settings/privacy.tsx** (0.7 KB, 20 lines) Exports: `default`

  ```tsx
// Placeholder for Privacy Settings Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function PrivacySettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Data & Privacy</H1>
        <Text>Data management options, privacy policy link, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}

  ```

- **app/(tabs)/settings/profile.tsx** (0.7 KB, 20 lines) Exports: `default`

  ```tsx
// Placeholder for Profile Settings Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function ProfileSettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Edit Profile</H1>
        <Text>Profile editing form will go here.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}

  ```

- **app/(tabs)/settings/security.tsx** (0.7 KB, 20 lines) Exports: `default`

  ```tsx
// Placeholder for Security Settings Screen
import React from 'react';
import { YStack, H1, Text, Button } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';
import { useColorScheme } from '@/hooks/useColorScheme';

export default function SecuritySettingsScreen() {
  const colorScheme = useColorScheme();
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: colorScheme === 'dark' ? '#000' : '#fff' }}>
      <YStack flex={1} padding="$4" space="$4">
        <H1>Security Settings</H1>
        <Text>Password change, 2FA options, etc.</Text>
        <Button onPress={() => router.back()}>Back</Button>
      </YStack>
    </SafeAreaView>
  );
}

  ```

### app/components

- **app/components/SectionCard.tsx** (0.7 KB, 23 lines) Exports: `SectionCard`

  ```tsx
// app/components/SectionCard.tsx
import React from 'react';
import { Stack, Text } from '@/design-system/Primitives';
import { BlurView } from 'expo-blur';

type SectionCardProps = {
  title: string;
  children: React.ReactNode;
};

export const SectionCard: React.FC<SectionCardProps> = ({ title, children }) => {
  return (
    <Stack className="mb-6 overflow-hidden rounded-2xl">
      <BlurView intensity={30} tint="light" className="overflow-hidden rounded-2xl">
        <Stack className="p-4 bg-parchment/50 dark:bg-sheikahCyan/10">
          <Text className="font-heading text-lg mb-2 text-darkText dark:text-parchment">{title}</Text>
          {children}
        </Stack>
      </BlurView>
    </Stack>
  );
};

  ```

- **app/components/SwipeableRow.tsx** (1.6 KB, 58 lines) Exports: `SwipeableRow`

  ```tsx
// app/components/SwipeableRow.tsx
import React from 'react';
import { View } from 'react-native';
import Swipeable from 'react-native-gesture-handler/Swipeable';
import { Button } from '@/design-system/Primitives';
import { Ionicons } from '@expo/vector-icons';

type SwipeableRowProps = {
  children: React.ReactNode;
  onComplete?: () => void;
  onDelete?: () => void;
};

export const SwipeableRow = ({ children, onComplete, onDelete }: SwipeableRowProps) => {
  // Render left-swipe (complete) action
  const renderLeftActions = () => {
    if (!onComplete) return null;
    return (
      <View className="flex-row">
        <Button 
          className="w-20 h-full justify-center items-center bg-korokGreen" 
          onPress={onComplete}
          aria-label="Complete task"
        >
          <Ionicons name="checkmark-outline" size={20} color="#FDFFE0" /* parchment */ />
        </Button>
      </View>
    );
  };

  // Render right-swipe (delete) action
  const renderRightActions = () => {
    if (!onDelete) return null;
    return (
      <View className="flex-row justify-end">
        <Button 
          className="w-20 h-full justify-center items-center bg-guardianOrange" 
          onPress={onDelete}
          aria-label="Delete task"
        >
          <Ionicons name="trash-outline" size={20} color="#FDFFE0" /* parchment */ />
        </Button>
      </View>
    );
  };

  return (
    <Swipeable
      renderLeftActions={renderLeftActions}
      renderRightActions={renderRightActions}
      overshootFriction={8}
      containerStyle={{ backgroundColor: 'transparent' }}
    >
      {children}
    </Swipeable>
  );
};

  ```

- **app/components/TaskRow.tsx** (1.1 KB, 35 lines) Exports: `TaskRow`

  ```tsx
// app/components/TaskRow.tsx
import React, { memo } from 'react';
import { Text, Stack } from '@/design-system/Primitives';
import { Ionicons } from '@expo/vector-icons';
import { RouterOutputs } from '@/utils/trpc';

// Use the existing task type from your tRPC output
type DashboardData = RouterOutputs['dashboard']['getDashboardData'];
type Task = DashboardData['tasks'][number];

export const TaskRow = memo(({ task }: { task: Task }) => (
  <Stack className="flex-row items-center py-3 px-4 bg-parchment/80 dark:bg-darkTealBg/50">
    {task.status === 'completed' && (
      <Ionicons 
        name="checkmark-circle" 
        size={18} 
        color="#92C582" // korokGreen
        style={{ marginRight: 8 }} 
      />
    )}
    <Text 
      className={`flex-1 ${task.status === 'completed' 
        ? 'text-darkText/50 line-through' 
        : 'text-darkText dark:text-parchment'}`}
    >
      {task.name}
    </Text>
    {task.due_date && (
      <Text className="text-xs text-darkText/70 dark:text-parchment/70">
        {new Date(task.due_date).toLocaleDateString()}
      </Text>
    )}
  </Stack>
));

  ```

### app/lib

- **app/lib/useDashboardQuery.ts** (0.5 KB, 15 lines) Exports: `DashboardData`, `useDashboardQuery`

  ```ts
// app/lib/useDashboardQuery.ts
import { trpc, RouterOutputs } from '@/utils/trpc';

// Export the dashboard data type for reuse
export type DashboardData = RouterOutputs['dashboard']['getDashboardData'];

/**
 * Hook to fetch dashboard data with caching
 */
export const useDashboardQuery = () =>
  trpc.dashboard.getDashboardData.useQuery(undefined, { 
    staleTime: 60_000, // 1 minute stale time
    refetchOnMount: 'always', // Always refetch when component mounts
  });

  ```

- **app/lib/useToggleTaskStatus.ts** (1.8 KB, 56 lines) Exports: `useToggleTaskStatus`

  ```ts
// app/lib/useToggleTaskStatus.ts
import { trpc } from '@/utils/trpc';
// Import Alert from React Native instead of using a toast library for simplicity
import { Alert } from 'react-native';

/**
 * Hook for toggling task completion status with optimistic updates
 */
export const useToggleTaskStatus = () => {
  const utils = trpc.useUtils();
  
  return trpc.task.toggleTask.useMutation({
    // Optimistically update UI before server responds
    onMutate: async ({ taskId, completed }) => {
      // Cancel any outgoing refetches
      await utils.dashboard.getDashboardData.cancel();
      
      // Snapshot current data for potential rollback
      const previous = utils.dashboard.getDashboardData.getData();
      
      // Optimistically update to the new value
      utils.dashboard.getDashboardData.setData(undefined, (oldData) => {
        if (!oldData) return oldData;
        return {
          ...oldData,
          tasks: oldData.tasks.map((task) => 
            task.id === taskId ? { ...task, status: completed ? 'completed' : 'in-progress' } : task
          ),
        };
      });
      
      return { previous };
    },
    
    // On successful mutation, show success message (silent in production)
    onSuccess: () => {
      if (__DEV__) {
        Alert.alert('Success', 'Task status updated');
      }
    },
    
    // If mutation fails, roll back optimistic update
    onError: (error, variables, context) => {
      if (context?.previous) {
        utils.dashboard.getDashboardData.setData(undefined, context.previous);
      }
      Alert.alert('Error', error.message || 'Failed to update task');
    },
    
    // Regardless of outcome, invalidate queries to refetch data
    onSettled: () => {
      utils.dashboard.getDashboardData.invalidate();
    },
  });
};

  ```

### app/planner

- **app/planner/add-habit.tsx** (0.5 KB, 19 lines) Exports: `default`

  ```tsx
import React from 'react';
import { YStack, H1, Text, Button, ScrollView } from 'tamagui';
import { SafeAreaView } from 'react-native';
import { router } from 'expo-router';

export default function AddHabitScreen() {
  return (
    <SafeAreaView style={{ flex: 1 }}>
      <ScrollView>
        <YStack flex={1} padding="$4" space="$4">
          <H1>Add New Habit</H1>
          <Text>Form to add a new habit will go here.</Text>
          <Button onPress={() => router.back()}>Go Back</Button>
        </YStack>
      </ScrollView>
    </SafeAreaView>
  );
}

  ```

- **app/planner/index.tsx** (0.2 KB, 4 lines) Exports: `default`

  ```tsx
// app/planner/index.tsx
import { YStack, H2 } from 'tamagui'
export default () => <YStack f={1} jc="center" ai="center"><H2>Planner coming soon</H2></YStack>

  ```

### app/settings

- **app/settings/index.tsx** (0.2 KB, 4 lines) Exports: `default`

  ```tsx
// app/settings/index.tsx
import { YStack, H2 } from 'tamagui'
export default () => <YStack f={1} jc="center" ai="center"><H2>Settings coming soon</H2></YStack>

  ```

### app/states

- **app/states/[id].tsx** (0.9 KB, 24 lines) (1 TODOs) Exports: `default`

  ```tsx
// app/states/[id].tsx
import React from 'react';
import { YStack, Text, H2, Paragraph, Button } from 'tamagui';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useLocalSearchParams, useRouter } from 'expo-router';

export default function StateDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const router = useRouter();

  // TODO: Fetch state definition details using trpc.state.getDefinitionById.useQuery({ id })

  return (
    <SafeAreaView style={{ flex: 1 }}>
      <YStack flex={1} padding="$4" space="$4">
        <H2>State Definition Detail</H2>
        <Paragraph>Details for State Definition with ID: {id}</Paragraph>
        {/* TODO: Display actual state definition details and add edit functionality */}
        <Button onPress={() => router.back()}>Go Back</Button>
      </YStack>
    </SafeAreaView>
  );
}

  ```

### app/utils

- **app/utils/api-types.ts** (0.6 KB, 22 lines) Exports: `RouterInputs`, `RouterOutputs`

  ```ts
/**
 * This file was auto-generated by the generate-trpc-types script.
 * Do not edit manually! Instead, run the script again.
 */

import type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from '../../server/src/router';

/**
 * Inference helper for inputs.
 *
 * @example type HelloInput = RouterInputs['example']['hello']
 */
export type RouterInputs = inferRouterInputs<AppRouter>;

/**
 * Inference helper for outputs.
 *
 * @example type HelloOutput = RouterOutputs['example']['hello']
 */
export type RouterOutputs = inferRouterOutputs<AppRouter>;

  ```

### app/values

- **app/values/[id].tsx** (0.8 KB, 24 lines) (1 TODOs) Exports: `default`

  ```tsx
// app/values/[id].tsx
import React from 'react';
import { YStack, Text, H2, Paragraph, Button } from 'tamagui';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useLocalSearchParams, useRouter } from 'expo-router';

export default function ValueDetailScreen() {
  const { id } = useLocalSearchParams<{ id: string }>();
  const router = useRouter();

  // TODO: Fetch value details using trpc.value.getValueById.useQuery({ id })

  return (
    <SafeAreaView style={{ flex: 1 }}>
      <YStack flex={1} padding="$4" space="$4">
        <H2>Principle Detail</H2>
        <Paragraph>Details for Principle (Value) with ID: {id}</Paragraph>
        {/* TODO: Display actual value details and add edit functionality */}
        <Button onPress={() => router.back()}>Go Back</Button>
      </YStack>
    </SafeAreaView>
  );
}

  ```

### assets

- **assets/refresh-sheikah.json** (14.8 KB, 1 lines) *(No explicit exports)*

  ```json
{"v":"4.6.8","fr":29.9700012207031,"ip":0,"op":69.0000028104276,"w":256,"h":256,"nm":"Comp 1","ddd":0,"assets":[],"layers":[{"ddd":0,"ind":1,"ty":4,"nm":"Glow ball","ks":{"o":{"a":0,"k":100},"r":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0],"e":[360]},{"t":69.0000028104276}]},"p":{"a":0,"k":[127.984,127.969,0]},"a":{"a":0,"k":[-0.182,32.385,0]},"s":{"a":0,"k":[132,132,100]}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[14.125,14.125]},"p":{"a":0,"k":[0,0]},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse"},{"ty":"fl","c":{"a":0,"k":[0.1635217,0.8509804,0.8105415,1]},"o":{"a":0,"k":100},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill"},{"ty":"tr","p":{"a":0,"k":[-0.063,1.5],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group"}],"ip":0,"op":300.00001221925,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":2,"ty":4,"nm":"Shape Layer 8","ks":{"o":{"a":0,"k":100},"r":{"a":0,"k":315},"p":{"a":0,"k":[127.984,127.969,0]},"a":{"a":0,"k":[-0.182,32.385,0]},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":56,"s":[132,132,100],"e":[145,145,100]},{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":59,"s":[145,145,100],"e":[132,132,100]},{"t":63.0000025660426}]}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[14.125,14.125]},"p":{"a":0,"k":[0,0]},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse"},{"ty":"fl","c":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0.1647059,0.6313726,0.8509804,1],"e":[0.1647059,0.6313726,0.8509804,1]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":56,"s":[0.1647059,0.6313726,0.8509804,1],"e":[0.1647059,0.8509804,0.8117647,1]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":62,"s":[0.1647059,0.8509804,0.8117647,1],"e":[0.1647059,0.6313726,0.8509804,1]},{"t":69.0000028104276}]},"o":{"a":0,"k":100},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill"},{"ty":"tr","p":{"a":0,"k":[-0.063,1.5],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group"}],"ip":0,"op":300.00001221925,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":3,"ty":4,"nm":"Shape Layer 7","ks":{"o":{"a":0,"k":100},"r":{"a":0,"k":270},"p":{"a":0,"k":[127.984,127.969,0]},"a":{"a":0,"k":[-0.182,32.385,0]},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":48,"s":[132,132,100],"e":[145,145,100]},{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":51,"s":[145,145,100],"e":[132,132,100]},{"t":55.0000022401959}]}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[14.125,14.125]},"p":{"a":0,"k":[0,0]},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse"},{"ty":"fl","c":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0.1647059,0.6313726,0.8509804,1],"e":[0.1647059,0.6745098,0.8431373,1]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":47,"s":[0.1647059,0.6745098,0.8431373,1],"e":[0.1647059,0.8509804,0.8117647,1]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":58,"s":[0.1647059,0.8509804,0.8117647,1],"e":[0.1647059,0.6313726,0.8509804,1]},{"t":69.0000028104276}]},"o":{"a":0,"k":100},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill"},{"ty":"tr","p":{"a":0,"k":[-0.063,1.5],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group"}],"ip":0,"op":300.00001221925,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":4,"ty":4,"nm":"Shape Layer 6","ks":{"o":{"a":0,"k":100},"r":{"a":0,"k":225},"p":{"a":0,"k":[127.984,127.969,0]},"a":{"a":0,"k":[-0.182,32.385,0]},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":39,"s":[132,132,100],"e":[145,145,100]},{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":42,"s":[145,145,100],"e":[132,132,100]},{"t":46.0000018736184}]}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[14.125,14.125]},"p":{"a":0,"k":[0,0]},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse"},{"ty":"fl","c":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0.1647059,0.6313726,0.8509804,1],"e":[0.1647059,0.6313726,0.8509804,1]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":37,"s":[0.1647059,0.6313726,0.8509804,1],"e":[0.1647059,0.8509804,0.8117647,1]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":43,"s":[0.1647059,0.8509804,0.8117647,1],"e":[0.1647059,0.6313726,0.8509804,1]},{"t":48.0000019550801}]},"o":{"a":0,"k":100},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill"},{"ty":"tr","p":{"a":0,"k":[-0.063,1.5],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group"}],"ip":0,"op":300.00001221925,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":5,"ty":4,"nm":"Shape Layer 5","ks":{"o":{"a":0,"k":100},"r":{"a":0,"k":180},"p":{"a":0,"k":[127.984,127.969,0]},"a":{"a":0,"k":[-0.182,32.385,0]},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":31,"s":[132,132,100],"e":[145,145,100]},{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":34,"s":[145,145,100],"e":[132,132,100]},{"t":38.0000015477717}]}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[14.125,14.125]},"p":{"a":0,"k":[0,0]},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse"},{"ty":"fl","c":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0.1647059,0.6313726,0.8509804,1],"e":[0.1647059,0.6313726,0.8509804,1]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":26,"s":[0.1647059,0.6313726,0.8509804,1],"e":[0.1647059,0.8509804,0.8117647,1]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":38,"s":[0.1647059,0.8509804,0.8117647,1],"e":[0.1647059,0.6313726,0.8509804,1]},{"t":42.0000017106951}]},"o":{"a":0,"k":100},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill"},{"ty":"tr","p":{"a":0,"k":[-0.063,1.5],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group"}],"ip":0,"op":300.00001221925,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":6,"ty":4,"nm":"Shape Layer 4","ks":{"o":{"a":0,"k":100},"r":{"a":0,"k":135},"p":{"a":0,"k":[127.984,127.969,0]},"a":{"a":0,"k":[-0.182,32.385,0]},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":23,"s":[132,132,100],"e":[145,145,100]},{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":26,"s":[145,145,100],"e":[132,132,100]},{"t":30.0000012219251}]}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[14.125,14.125]},"p":{"a":0,"k":[0,0]},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse"},{"ty":"fl","c":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0.1647059,0.6313726,0.8509804,1],"e":[0.1647059,0.8509804,0.8117647,1]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":30,"s":[0.1647059,0.8509804,0.8117647,1],"e":[0.1647059,0.6313726,0.8509804,1]},{"t":38.0000015477717}]},"o":{"a":0,"k":100},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill"},{"ty":"tr","p":{"a":0,"k":[-0.063,1.5],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group"}],"ip":0,"op":300.00001221925,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":7,"ty":4,"nm":"Shape Layer 3","ks":{"o":{"a":0,"k":100},"r":{"a":0,"k":90},"p":{"a":0,"k":[127.984,127.969,0]},"a":{"a":0,"k":[-0.182,32.385,0]},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":14,"s":[132,132,100],"e":[145,145,100]},{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":17,"s":[145,145,100],"e":[132,132,100]},{"t":21.0000008553475}]}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[14.125,14.125]},"p":{"a":0,"k":[0,0]},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse"},{"ty":"fl","c":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0.1647059,0.6313726,0.8509804,1],"e":[0.1647059,0.8509804,0.8117647,1]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":22,"s":[0.1647059,0.8509804,0.8117647,1],"e":[0.1647059,0.6313726,0.8509804,1]},{"t":28.0000011404634}]},"o":{"a":0,"k":100},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill"},{"ty":"tr","p":{"a":0,"k":[-0.063,1.5],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group"}],"ip":0,"op":300.00001221925,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":8,"ty":4,"nm":"Shape Layer 2","ks":{"o":{"a":0,"k":100},"r":{"a":0,"k":45},"p":{"a":0,"k":[127.984,127.969,0]},"a":{"a":0,"k":[-0.182,32.385,0]},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":7,"s":[132,132,100],"e":[145,145,100]},{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":10,"s":[145,145,100],"e":[132,132,100]},{"t":14.0000005702317}]}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[14.125,14.125]},"p":{"a":0,"k":[0,0]},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse"},{"ty":"fl","c":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0.1647059,0.6313726,0.8509804,1],"e":[0.1647059,0.8509804,0.8117647,1]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":16,"s":[0.1647059,0.8509804,0.8117647,1],"e":[0.1647059,0.6313726,0.8509804,1]},{"t":22.0000008960784}]},"o":{"a":0,"k":100},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill"},{"ty":"tr","p":{"a":0,"k":[-0.063,1.5],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group"}],"ip":0,"op":300.00001221925,"st":0,"bm":0,"sr":1},{"ddd":0,"ind":9,"ty":4,"nm":"Shape Layer 1","ks":{"o":{"a":0,"k":100},"r":{"a":0,"k":0},"p":{"a":0,"k":[127.984,127.969,0]},"a":{"a":0,"k":[-0.182,32.385,0]},"s":{"a":1,"k":[{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":0,"s":[132,132,100],"e":[145,145,100]},{"i":{"x":[0.833,0.833,0.833],"y":[0.833,0.833,0.833]},"o":{"x":[0.167,0.167,0.167],"y":[0.167,0.167,0.167]},"n":["0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167","0p833_0p833_0p167_0p167"],"t":3,"s":[145,145,100],"e":[132,132,100]},{"t":7.00000028511585}]}},"ao":0,"shapes":[{"ty":"gr","it":[{"d":1,"ty":"el","s":{"a":0,"k":[14.125,14.125]},"p":{"a":0,"k":[0,0]},"nm":"Ellipse Path 1","mn":"ADBE Vector Shape - Ellipse"},{"ty":"fl","c":{"a":1,"k":[{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":0,"s":[0.1647059,0.6313726,0.8509804,1],"e":[0.1647059,0.8509804,0.8117647,1]},{"i":{"x":[0.833],"y":[0.833]},"o":{"x":[0.167],"y":[0.167]},"n":["0p833_0p833_0p167_0p167"],"t":5,"s":[0.1647059,0.8509804,0.8117647,1],"e":[0.1647059,0.6313726,0.8509804,1]},{"t":16.0000006516934}]},"o":{"a":0,"k":100},"r":1,"nm":"Fill 1","mn":"ADBE Vector Graphic - Fill"},{"ty":"tr","p":{"a":0,"k":[-0.063,1.5],"ix":2},"a":{"a":0,"k":[0,0],"ix":1},"s":{"a":0,"k":[100,100],"ix":3},"r":{"a":0,"k":0,"ix":6},"o":{"a":0,"k":100,"ix":7},"sk":{"a":0,"k":0,"ix":4},"sa":{"a":0,"k":0,"ix":5},"nm":"Transform"}],"nm":"Ellipse 1","np":3,"cix":2,"ix":1,"mn":"ADBE Vector Group"}],"ip":0,"op":300.00001221925,"st":0,"bm":0,"sr":1}]}
  ```

### components

- **components/EmptyOrSkeleton.tsx** (5.1 KB, 209 lines) Exports: `default`, `EmptyOrSkeletonProps`, `EmptyStateProps`

  ```tsx
import React, { ReactNode } from 'react';
import { StyleSheet, StyleProp, ViewStyle, TextStyle, ImageStyle, ImageSourcePropType, View, Image } from 'react-native';
import Animated from 'react-native-reanimated';
import { Text, YStack, StackProps } from 'tamagui';
import { useSkeleton, SkeletonOptions } from '@/hooks/useSkeleton';

export interface EmptyStateProps {
  /** Title text for the empty state */
  title?: string;
  /** Subtitle/description text for the empty state */
  message?: string;
  /** Optional image/illustration to display */
  image?: ImageSourcePropType;
  /** Optional custom component to render instead of default empty state */
  customEmptyComponent?: ReactNode;
  /** Style for the container */
  containerStyle?: StyleProp<ViewStyle>;
  /** Style for the title */
  titleStyle?: StyleProp<TextStyle>;
  /** Style for the message */
  messageStyle?: StyleProp<TextStyle>;
  /** Style for the image container */
  imageContainerStyle?: StyleProp<ViewStyle>;
  /** Style for the image */
  imageStyle?: StyleProp<ImageStyle>;
}

export interface EmptyOrSkeletonProps extends EmptyStateProps, StackProps {
  /** Whether data is loading */
  isLoading: boolean;
  /** Children to display when not loading and not empty */
  children: ReactNode;
  /** Whether the content is empty (no data) */
  isEmpty?: boolean;
  /** Number of skeleton placeholders to display when loading */
  skeletonCount?: number;
  /** Height of each skeleton item */
  skeletonHeight?: number;
  /** Width of each skeleton item (default: 100%) */
  skeletonWidth?: number | string;
  /** Gap between skeleton items */
  skeletonGap?: number;
  /** Border radius for skeleton items */
  skeletonBorderRadius?: number;
  /** Custom skeleton component */
  customSkeletonComponent?: ReactNode;
  /** Options for the skeleton animation */
  skeletonOptions?: SkeletonOptions;
}

/**
 * Placeholder component for the skeleton loading state
 */
const SkeletonPlaceholder = ({
  height, 
  width = '100%',
  borderRadius = 8,
  options
}: {
  height: number;
  width?: number | string;
  borderRadius?: number;
  options?: SkeletonOptions;
}) => {
  const { shimmerStyle, styles } = useSkeleton(options);
  
  return (
    <Animated.View 
      style={[
        styles.container, 
        { 
          height,
          width: typeof width === 'string' ? width : width,
          borderRadius
        } as ViewStyle
      ]}
    >
      <Animated.View style={[styles.shimmer, shimmerStyle]} />
    </Animated.View>
  );
};

/**
 * Default empty state component
 */
const EmptyState = ({
  title = 'No data found',
  message = 'There is nothing to display at the moment.',
  image,
  containerStyle,
  titleStyle,
  messageStyle,
  imageContainerStyle,
  imageStyle
}: EmptyStateProps) => {
  return (
    <YStack
      alignItems="center"
      justifyContent="center"
      padding="$4"
      space="$3"
      style={containerStyle}
    >
      {image && (
        <View style={[styles.imageContainer, imageContainerStyle]}>
          <Image source={image} style={[styles.image, imageStyle]} />
        </View>
      )}
      <Text 
        fontSize="$6" 
        fontWeight="bold" 
        textAlign="center"
        style={titleStyle}
      >
        {title}
      </Text>
      <Text 
        fontSize="$4" 
        color="$gray10" 
        textAlign="center"
        style={messageStyle}
      >
        {message}
      </Text>
    </YStack>
  );
};

/**
 * A component that conditionally renders skeleton, empty state, or content
 * based on loading and data states.
 */
export default function EmptyOrSkeleton({
  isLoading,
  isEmpty = false,
  children,
  skeletonCount = 3,
  skeletonHeight = 80,
  skeletonWidth = '100%',
  skeletonGap = 12,
  skeletonBorderRadius = 8,
  customSkeletonComponent,
  customEmptyComponent,
  skeletonOptions,
  title,
  message,
  image,
  containerStyle,
  titleStyle,
  messageStyle,
  imageContainerStyle,
  imageStyle,
  ...stackProps
}: EmptyOrSkeletonProps) {
  // If loading, show skeleton
  if (isLoading) {
    if (customSkeletonComponent) {
      return <>{customSkeletonComponent}</>;
    }
    
    return (
      <YStack space={skeletonGap} width="100%" {...stackProps}>
        {Array.from({ length: skeletonCount }).map((_, index) => (
          <SkeletonPlaceholder
            key={`skeleton-${index}`}
            height={skeletonHeight}
            width={skeletonWidth}
            borderRadius={skeletonBorderRadius}
            options={skeletonOptions}
          />
        ))}
      </YStack>
    );
  }
  
  // If empty, show empty state
  if (isEmpty) {
    if (customEmptyComponent) {
      return <>{customEmptyComponent}</>;
    }
    
    return (
      <EmptyState
        title={title}
        message={message}
        image={image}
        containerStyle={containerStyle}
        titleStyle={titleStyle}
        messageStyle={messageStyle}
        imageContainerStyle={imageContainerStyle}
        imageStyle={imageStyle}
      />
    );
  }
  
  // Otherwise, show children
  return <>{children}</>;
}

const styles = StyleSheet.create({
  imageContainer: {
    marginBottom: 20,
  },
  image: {
    width: 150,
    height: 150,
    resizeMode: 'contain',
  },
}); 
  ```

### components/aether

- **components/aether/ProgressRing.tsx** (1.9 KB, 69 lines) Exports: `default`

  ```tsx
import React from 'react';
import { Stack, useTheme, ColorTokens } from 'tamagui';
import Svg, { Circle } from 'react-native-svg';

interface ProgressRingProps {
  progress: number;  // 0 to 1 (or 0 to 100 as percentage)
  size?: number;     // Diameter of the circle
  strokeWidth?: number;
  primaryColor?: string;
  secondaryColor?: string;
  backgroundColor?: ColorTokens | 'transparent' | undefined;
}

/**
 * A circular progress indicator component
 */
export default function ProgressRing({
  progress: rawProgress,
  size = 60,
  strokeWidth = 6,
  primaryColor,
  secondaryColor,
  backgroundColor = 'transparent',
}: ProgressRingProps) {
  const theme = useTheme();
  
  // Normalize progress to 0-1 range
  const progress = rawProgress > 1 ? rawProgress / 100 : rawProgress;
  
  // Calculate radius and other dimensions
  const radius = (size - strokeWidth) / 2;
  const circumference = radius * 2 * Math.PI;
  const strokeDashoffset = circumference - progress * circumference;

  // Use theme colors if not explicitly provided
  const primary = primaryColor || theme.blue10.val;
  const secondary = secondaryColor || theme.gray4.val;

  return (
    <Stack width={size} height={size} backgroundColor={backgroundColor} alignItems="center" justifyContent="center">
      <Svg width={size} height={size}>
        {/* Background circle */}
        <Circle
          stroke={secondary}
          fill="none"
          cx={size / 2}
          cy={size / 2}
          r={radius}
          strokeWidth={strokeWidth}
        />
        
        {/* Progress circle */}
        <Circle
          stroke={primary}
          fill="none"
          cx={size / 2}
          cy={size / 2}
          r={radius}
          strokeWidth={strokeWidth}
          strokeDasharray={circumference}
          strokeDashoffset={strokeDashoffset}
          strokeLinecap="round"
          transform={`rotate(-90, ${size / 2}, ${size / 2})`} // Start from top
        />
      </Svg>
    </Stack>
  );
}

  ```

### components/auth

- **components/auth/FloatingInput.tsx** (5.6 KB, 208 lines) Exports: `default`, `FloatingInputProps`

  ```tsx
import React, { useState, useRef, useEffect } from 'react';
import { StyleSheet, TextInput as RNTextInput, View, TextInputProps as RNTextInputProps } from 'react-native';
import { Text, InputProps, getTokens, useTheme } from 'tamagui';
import Animated, { useSharedValue, withTiming, useAnimatedStyle, Easing } from 'react-native-reanimated';
import { durations } from '@/constants/motion';

export interface FloatingInputProps extends RNTextInputProps {
  /** Label for the input */
  label: string;
  /** Error message to display */
  error?: string;
  /** Container style */
  containerStyle?: object;
  /** Label style */
  labelStyle?: object;
  /** Error style */
  errorStyle?: object;
  /** Tamagui tokens for theming */
  tokens?: ReturnType<typeof getTokens>;
  /** Called when focus changes */
  onFocusChange?: (focused: boolean) => void;
  /** Left icon to display */
  leftIcon?: React.ReactNode;
  /** Right icon to display */
  rightIcon?: React.ReactNode;
  /** Whether to adjust label position */
  adjustLabel?: boolean;
}

/**
 * Input component with animated floating label
 */
export default function FloatingInput({
  label,
  value,
  error,
  containerStyle,
  labelStyle,
  errorStyle,
  onFocusChange,
  leftIcon,
  rightIcon,
  adjustLabel = true,
  style,
  ...props
}: FloatingInputProps) {
  const [isFocused, setIsFocused] = useState(false);
  const inputRef = useRef<RNTextInput | null>(null);
  const animatedLabelValue = useSharedValue(value ? 1 : 0);
  const theme = useTheme();
  
  // Handle label animation when focus or value changes
  useEffect(() => {
    animatedLabelValue.value = withTiming(
      (isFocused || !!value) ? 1 : 0,
      {
        duration: 200, // Match durations.standard
        easing: Easing.bezier(0.4, 0.0, 0.2, 1.0),
      }
    );
  }, [isFocused, value, animatedLabelValue]);
  
  // Get dynamic colors from theme
  const colors = {
    input: {
      background: theme.inputBackground?.get() || theme.backgroundHover?.get() || '#F3F4F6',
      text: theme.color?.get() || '#111827',
      border: theme.borderColor?.get() || '#E5E7EB',
      focusBorder: theme.borderColorFocus?.get() || '#93C5FD',
      placeholderText: theme.colorTransparent?.get() || '#6B7280',
    },
    error: theme.red10?.get() || '#EF4444',
  };
  
  // Determine text color based on disabled state
  const textColor = props.editable === false 
    ? theme.colorTransparent?.get() || '#9CA3AF'
    : colors.input.text;
  
  // Handle focus changes
  const handleFocus = (event: any) => {
    setIsFocused(true);
    if (onFocusChange) onFocusChange(true);
    if (props.onFocus) props.onFocus(event);
  };
  
  const handleBlur = (event: any) => {
    setIsFocused(false);
    if (onFocusChange) onFocusChange(false);
    if (props.onBlur) props.onBlur(event);
  };
  
  // Animated styles
  const animatedLabelStyle = useAnimatedStyle(() => {
    return {
      position: 'absolute',
      left: leftIcon ? 40 : 16,
      top: adjustLabel ? 
        (16 + (-24 * animatedLabelValue.value)) : 
        (12 + (-20 * animatedLabelValue.value)),
      fontSize: 16 - (4 * animatedLabelValue.value),
      color: error ? colors.error : 
        animatedLabelValue.value > 0 ? 
          (isFocused ? colors.input.focusBorder : colors.input.placeholderText) : 
          colors.input.placeholderText,
      backgroundColor: animatedLabelValue.value > 0 ? 
        (theme.background?.get() || '#FFFFFF') : 'transparent',
      paddingHorizontal: 4 * animatedLabelValue.value,
      zIndex: 10,
    };
  });
  
  // Focus the input when the component is tapped
  const handleContainerPress = () => {
    if (inputRef.current) {
      inputRef.current.focus();
    }
  };
  
  // Prepare input styles - flatten the array and provide default
  const inputStyles = StyleSheet.flatten([
    styles.input, 
    { color: textColor },
    leftIcon && { paddingLeft: 40 },
    rightIcon && { paddingRight: 40 },
    style // Style prop from component props
  ]) || {}; // Provide default empty style object
  
  return (
    <View style={[styles.container, containerStyle]}>
      <View 
        style={[
          styles.inputContainer, 
          { backgroundColor: colors.input.background },
          { borderColor: isFocused ? colors.input.focusBorder : colors.input.border },
          error && { borderColor: colors.error },
        ]} 
        onTouchStart={handleContainerPress}
      >
        {leftIcon && <View style={styles.leftIcon}>{leftIcon}</View>}
        
        <RNTextInput
          ref={inputRef}
          style={inputStyles}
          value={value}
          onFocus={handleFocus}
          onBlur={handleBlur}
          placeholderTextColor={colors.input.placeholderText}
          {...props}
        />
        
        {rightIcon && <View style={styles.rightIcon}>{rightIcon}</View>}
        
        <Animated.Text style={[animatedLabelStyle, labelStyle]}>
          {label}
        </Animated.Text>
      </View>
      
      {error && (
        <Text
          style={[styles.errorText, { color: colors.error }, errorStyle]}
          fontSize="$3"
          marginTop="$1"
        >
          {error}
        </Text>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    marginBottom: 16,
    width: '100%',
  },
  inputContainer: {
    borderWidth: 1,
    borderRadius: 8,
    height: 56,
    position: 'relative',
    justifyContent: 'center',
  },
  input: {
    height: 56,
    paddingHorizontal: 16,
    fontSize: 16,
    flex: 1,
  },
  label: {
    zIndex: 10,
  },
  errorText: {
    marginLeft: 4,
  },
  leftIcon: {
    position: 'absolute',
    left: 12,
    top: 16,
    zIndex: 2,
  },
  rightIcon: {
    position: 'absolute',
    right: 12,
    top: 16,
    zIndex: 2,
  },
}); 
  ```

### components/compass

- **components/compass/PrincipleCard.tsx** (1.1 KB, 41 lines) Exports: `PrincipleCard`

  ```tsx
// components/compass/PrincipleCard.tsx
import React from 'react';
import { Card, Text, YStack } from 'tamagui';
import { type RouterOutputs } from '@/utils/trpc';

// Use the correct type based on the query in PrinciplesTab
type Principle = RouterOutputs['value']['getValues'][number];

interface PrincipleCardProps {
  principle: Principle;
  onPress?: () => void; // Make onPress optional if not always needed
}

export function PrincipleCard({ principle, onPress }: PrincipleCardProps) {
  return (
    <Card
      bordered
      padding="$4"
      elevation="$1"
      pressTheme
      hoverTheme
      onPress={onPress}
      animation="bouncy"
      scale={onPress ? 0.98 : 1} // Only apply scale if pressable
      hoverStyle={onPress ? { scale: 0.99 } : {}}
      pressStyle={onPress ? { scale: 0.96 } : {}}
    >
      <YStack>
        <Text fontSize="$5" fontWeight="bold">
          {principle.name}
        </Text>
        {principle.description && (
          <Text color="$colorFocus" marginTop="$2">
            {principle.description}
          </Text>
        )}
      </YStack>
    </Card>
  );
}

  ```

- **components/compass/PrinciplesTab.tsx** (1.2 KB, 47 lines) Exports: `default`

  ```tsx
import React from 'react';
import { YStack } from 'tamagui';
import { router, type Href } from 'expo-router';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { trpc, type RouterOutputs } from '@/utils/trpc';
import { PrincipleCard } from './PrincipleCard';

type Principle = RouterOutputs['value']['getValues'][number];

export default function PrinciplesTab() {
  const { data, isLoading, error, refetch } =
    trpc.value.getValues.useQuery();

  if (isLoading) return <EmptyOrSkeleton isLoading count={3} type="card" />;

  if (error)
    return (
      <EmptyOrSkeleton
        isError
        onRetry={refetch}
        text={error.message ?? 'Failed to load principles'}
      />
    );

  if (!Array.isArray(data) || !data.length)
    return (
      <EmptyOrSkeleton
        isEmpty
        text="No principles yet"
        actionText="Add Principle"
        onAction={() => router.push('/compose?type=value' as Href)}
      />
    );

  return (
    <YStack space="$3">
      {data.map((p: Principle) => (
        <PrincipleCard
          key={p.id}
          principle={p}
          onPress={() => router.push(`/values/${p.id}` as Href)}
        />
      ))}
    </YStack>
  );
}

  ```

- **components/compass/StateDefinitionCard.tsx** (1.3 KB, 47 lines) Exports: `StateDefinitionCard`

  ```tsx
// components/compass/StateDefinitionCard.tsx
import React from 'react';
import { Card, Text, XStack, YStack } from 'tamagui';
import { type RouterOutputs } from '@/utils/trpc';

// Use the correct type based on the query in StatesTab (getDefinitions)
type StateDefinition = RouterOutputs['state']['getDefinitions'][number];

interface StateDefinitionCardProps {
  state: StateDefinition;
  onPress?: () => void; // Make onPress optional
}

export function StateDefinitionCard({ state, onPress }: StateDefinitionCardProps) {
  return (
    <Card
      bordered
      padding="$4"
      elevation="$1"
      pressTheme
      hoverTheme
      onPress={onPress}
      animation="bouncy"
      scale={onPress ? 0.98 : 1} // Only apply scale if pressable
      hoverStyle={onPress ? { scale: 0.99 } : {}}
      pressStyle={onPress ? { scale: 0.96 } : {}}
    >
      <YStack>
        <XStack alignItems="center" space="$3">
          <Text fontSize="$5" fontWeight="bold">
            {state.name}
          </Text>
          {/* Display scale type if available */}
          {state.scale && (
            <Text color="$colorFocus" fontSize="$2">({state.scale})</Text>
          )}
        </XStack>
        {state.description && (
          <Text color="$colorFocus" marginTop="$2">
            {state.description}
          </Text>
        )}
      </YStack>
    </Card>
  );
}

  ```

### components/dashboard

- **components/dashboard/DailyProgressBanner.tsx** (2.3 KB, 66 lines) Exports: `default`

  ```tsx
import React from 'react';
import { XStack, YStack, Text, Progress, useTheme } from 'tamagui';
import { BlurView } from 'expo-blur';
import { CheckSquare, Target } from '@tamagui/lucide-icons'; // Example icons

type DailyProgressBannerProps = {
  tasksCompleted: number;
  totalTasks: number; // Needed for progress calculation
  habitsChecked: number;
  totalHabits: number; // Needed for progress calculation
};

export default function DailyProgressBanner({ 
  tasksCompleted = 3, // Placeholder
  totalTasks = 5, // Placeholder
  habitsChecked = 2, // Placeholder
  totalHabits = 4 // Placeholder
}: DailyProgressBannerProps) {
  const theme = useTheme();
  const taskProgress = totalTasks > 0 ? (tasksCompleted / totalTasks) * 100 : 0;
  const habitProgress = totalHabits > 0 ? (habitsChecked / totalHabits) * 100 : 0;

  return (
    <BlurView intensity={50} tint="default" style={{ borderRadius: 12, overflow: 'hidden', marginBottom: 16 }}>
      <XStack 
        padding="$3"
        space="$4"
        alignItems="center" 
        backgroundColor="$surfaceSubtle" // Use subtle background from theme
      >
        {/* Tasks Progress */}
        <YStack flex={1} space="$1">
          <XStack space="$2" alignItems="center">
            <CheckSquare size={16} color={theme.accent?.get()} />
            <Text fontSize="$3" fontWeight="bold" color="$onSurface">
              Tasks
            </Text>
          </XStack>
          <Progress size="$1" value={taskProgress}>
            <Progress.Indicator animation="bouncy" backgroundColor="$accent" />
          </Progress>
          <Text fontSize="$1" color="$onSurfaceSubtle">
            {tasksCompleted} / {totalTasks} done
          </Text>
        </YStack>

        {/* Habits Progress */}
        <YStack flex={1} space="$1">
          <XStack space="$2" alignItems="center">
            <Target size={16} color={theme.accent?.get()} />
            <Text fontSize="$3" fontWeight="bold" color="$onSurface">
              Habits
            </Text>
          </XStack>
          <Progress size="$1" value={habitProgress}>
            <Progress.Indicator animation="bouncy" backgroundColor="$accent" />
          </Progress>
          <Text fontSize="$1" color="$onSurfaceSubtle">
            {habitsChecked} / {totalHabits} checked
          </Text>
        </YStack>
      </XStack>
    </BlurView>
  );
}

  ```

- **components/dashboard/DashboardSection.tsx** (2.4 KB, 83 lines) Exports: `default`

  ```tsx
import React, { ReactNode } from 'react';
import { Text, YStack, XStack, Button, Anchor, H4 } from 'tamagui';
import { router } from 'expo-router';
import { SkeletonRow } from '@/components/ui/Skeleton';
import { SectionError } from '@/components/ui/ErrorBanner';
import { BlurView } from 'expo-blur'; // Import BlurView

interface DashboardSectionProps<T> {
  title: string;
  data?: T[];
  isLoading?: boolean;
  emptyMessage?: string;
  seeAllRoute?: string;
  renderItem?: (item: T) => ReactNode;
  skeletonCount?: number;
  error?: string;
  onRetry?(): void;
  children?: ReactNode;
  onSeeAll?(): void;
}

export default function DashboardSection<T>({ 
  title, 
  data, 
  isLoading, 
  emptyMessage,
  seeAllRoute,
  renderItem,
  skeletonCount = 2,
  error,
  onRetry,
  children,
  onSeeAll
}: DashboardSectionProps<T>) {
  return (
    <YStack space="$2">
      <XStack justifyContent="space-between" alignItems="center" marginBottom="$2" paddingHorizontal="$2">
        <H4>{title}</H4>
        {((data && data.length > 0 && seeAllRoute) || onSeeAll) && (
          <Button 
            chromeless 
            size="$2" 
            onPress={() => {
              if (onSeeAll) {
                onSeeAll();
              } else if (seeAllRoute) {
                // Navigate to route using type assertions
                // Safe because the route will be a tab/screen name within the app
                router.push(seeAllRoute as any);
              }
            }}
          >
            See All
          </Button>
        )}
      </XStack>
      
      {/* Wrap content in BlurView */}
      <BlurView 
        intensity={50} 
        tint="default" 
        style={{ borderRadius: 12, overflow: 'hidden' }} 
      >
        <YStack padding="$3">
          {/* If children are provided, render them */}
          {children ? (
            children
          ) : isLoading ? (
            <SkeletonRow lines={skeletonCount} />
          ) : error ? (
            <SectionError message={error ? String(error) : 'An error occurred'} onRetry={onRetry} />
          ) : data && data.length === 0 ? (
            <YStack alignItems="center" padding="$4">
              <Text color="$gray10">{emptyMessage ?? 'No items found'}</Text>
            </YStack>
          ) : (
            data && renderItem && data.map(renderItem)
          )}
        </YStack>
      </BlurView>
    </YStack>
  );
} 
  ```

- **components/dashboard/GoalSummaryCard.tsx** (1.5 KB, 58 lines) Exports: `default`

  ```tsx
import React from 'react';
import { Text, XStack, Button } from 'tamagui';
import ProgressRing from '@/components/aether/ProgressRing';
import { RouterOutputs } from '@/utils/trpc';
import { BlurView } from 'expo-blur'; // Import BlurView

// Define a custom type that includes everything we need
type DashboardGoal = {
  id: string;
  title: string;
  status?: string;
  priority?: number;
  progress: number;
  tasks?: {
    total: number;
    completed: number;
  };
};

interface GoalSummaryCardProps {
  goal: DashboardGoal;
  onPress: () => void;
}

export default function GoalSummaryCard({ goal, onPress }: GoalSummaryCardProps) {
  return (
    <BlurView 
      intensity={50} 
      tint="default" 
      style={{ borderRadius: 12, overflow: 'hidden' }}
    >
      <Button 
        chromeless // Remove default button styling
        padding="$3" 
        onPress={onPress}
        width="100%" // Ensure it fills the BlurView
      >
        <XStack alignItems="center" space="$3" flex={1}> 
          <ProgressRing
            progress={goal.progress}
            size={40}
            primaryColor="$primary"
          />
          <XStack flex={1} flexDirection="column">
            <Text fontSize="$4" fontWeight="500" color="$color">
              {goal.title}
            </Text>
            {goal.tasks && (
              <Text color="$gray9" fontSize="$2">
                {goal.tasks.completed}/{goal.tasks.total} tasks completed
              </Text>
            )}
          </XStack>
        </XStack>
      </Button>
    </BlurView>
  );
}
  ```

- **components/dashboard/HabitCheckItem.tsx** (4.4 KB, 154 lines) Exports: `default`

  ```tsx
import React, { useState, useEffect } from 'react';
import { Text, XStack, Button, YStack, useTheme } from 'tamagui';
import * as Haptics from 'expo-haptics';
import { trpc, RouterOutputs } from '@/utils/trpc';

// Custom types that match the backend expectations
type DashboardHabit = {
  id: string;
  name: string;  // Backend returns 'name'
  description?: string;
  habit_type?: string;
  streak?: number;
  completed: boolean; // Backend returns 'completed'
  duration_minutes?: number;
  last_entry_id?: string; // Add last_entry_id property
};

// Types for habit entry mutations
type CreateHabitEntryInput = {
  habit_id: string;
  date: string;
  completed?: boolean;
  quantity_value?: number | null;
  notes?: string | null;
};

type DeleteHabitEntryInput = {
  id: string; // Update property name
};

interface HabitCheckItemProps {
  habit: DashboardHabit;
  onToggle?: (habitId: string, completedToday: boolean) => void; 
}

export default function HabitCheckItem({ habit, onToggle }: HabitCheckItemProps) {
  const [checked, setChecked] = useState(habit.completed);
  const [isUpdating, setIsUpdating] = useState(false);
  const theme = useTheme(); 
  const utils = trpc.useUtils(); 

  // Define specific theme colors with safe access and fallbacks to theme variables
  const green10 = theme?.green10?.val ?? '$green10'; 
  const gray10 = theme?.gray10?.val ?? '$gray10'; 
  const orange10 = theme?.orange10?.val ?? '$orange10'; 


  const createEntryMutation = trpc.habit.createHabitEntry.useMutation({
    onSuccess: (updatedHabit) => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error creating habit entry:', error);
    }
  });

  const deleteEntryMutation = trpc.habit.deleteHabitEntry.useMutation({
    onSuccess: () => {
      setIsUpdating(false);
      utils.habit.getHabits.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    },
    onError: (error) => {
      setChecked(!checked);
      setIsUpdating(false);
      console.error('Error deleting habit entry:', error);
    }
  });

  useEffect(() => {
    setChecked(habit.completed);
  }, [habit.completed]);

  const handleToggle = () => {
    const newValue = !checked;
    setChecked(newValue); 
    setIsUpdating(true);

    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);

    const todayDateString = new Date().toISOString().split('T')[0];

    if (newValue) {
      const createInput: CreateHabitEntryInput = {
        habit_id: habit.id,
        date: todayDateString,
        completed: true, 
        quantity_value: null, 
        notes: null, 
      };
      createEntryMutation.mutate(createInput);
    } else {
      if (habit.last_entry_id) { 
        const deleteInput: DeleteHabitEntryInput = {
          id: habit.last_entry_id, 
        };
        deleteEntryMutation.mutate(deleteInput);
      } else {
        console.warn("Attempted to delete habit entry, but last_entry_id is missing.");
      }
    }

    if (onToggle) {
      onToggle(habit.id, newValue);
    }
  };

  const streakColor = checked ? green10 : gray10; // Use safe theme value
  const habitTypeColor = orange10; // Use safe theme value

  return (
    <XStack 
      backgroundColor="$backgroundStrong" // Use theme variable
      padding="$3"
      borderRadius="$4"
      alignItems="center"
      justifyContent="space-between"
      space="$3"
    >
      <YStack flex={1} gap="$1">
        <Text fontSize="$4" fontWeight="500" color="$color"> // Use theme variable
          {habit.name}
        </Text>
        
        {habit.streak != null && habit.streak > 0 && ( // Add null check
          <Text fontSize="$2" color={streakColor}> 
            Streak: {habit.streak ?? 0}
          </Text>
        )}
        {habit.habit_type && (
          <Text fontSize="$2" color={habitTypeColor}> // Use safe theme value
            ({habit.habit_type})
          </Text>
        )}
      </YStack>
      
      <Button
        size="$3"
        variant={checked ? undefined : 'outlined'} // Let variant handle appearance
        // Remove explicit colors - rely on theme/variant
        theme={checked ? 'green' : undefined} // Apply green theme when checked
        onPress={handleToggle}
        disabled={isUpdating} 
        iconAfter={checked ? <Text>✓</Text> : undefined}
      >
        {checked ? "Done" : "Check-in"}
      </Button>
    </XStack>
  );
}
  ```

- **components/dashboard/StateIndicator.tsx** (1.7 KB, 55 lines) Exports: `default`

  ```tsx
import React from 'react';
// Use Tamagui components
import { Text, XStack, YStack, Card } from 'tamagui'; 
// Import RouterOutputs for inferred types
import { RouterOutputs } from '@/utils/trpc';

// Define prop type using inferred type from router
type DashboardTrackedState = RouterOutputs['dashboard']['getDashboardData']['trackedStates'][number];

interface StateIndicatorProps {
  state: DashboardTrackedState; // Use the inferred type
  onPress: () => void;
  lastEntry: any;
}

export default function StateIndicator({ state, onPress, lastEntry }: StateIndicatorProps) {
  // Format the last updated time
  const formattedTime = state.lastUpdated 
    ? new Date(state.lastUpdated).toLocaleTimeString([], { 
        hour: '2-digit', 
        minute: '2-digit' 
      })
    : 'N/A';
  
  // Use Tamagui Card component
  return (
    <Card 
      onPress={onPress} 
      pressStyle={{ opacity: 0.8 }}
      padding="$3"
      // No explicit background, will use default Card background from theme
    >
      <YStack space="$1"> {/* Main container for text */}
        <XStack flex={1} alignItems="center">
          <Text fontSize="$4" fontWeight="500">{state.name}</Text>
          {lastEntry && (
            <Text fontSize="$2" color="$gray10" marginLeft="$2">
              ({formattedTime})
            </Text>
          )}
        </XStack>
        <XStack alignItems="baseline" space="$2"> {/* Align text by baseline, add space */}
          <Text fontSize="$5" fontWeight="600" color="$color"> {/* Use tokens */}
            {state.currentValue}
          </Text>
        </XStack>
        {!lastEntry && (
          <Text fontSize="$2" color="$gray10" marginTop="$1">
            No data recorded yet.
          </Text>
        )}
      </YStack>
    </Card>
  );
} 
  ```

- **components/dashboard/TaskItem.tsx** (5.9 KB, 181 lines) Exports: `default`

  ```tsx
import React from 'react';
// Use Tamagui components
import { Text, XStack, YStack, Checkbox, Spinner } from 'tamagui'; 
import { trpc, RouterOutputs, RouterInputs } from '@/utils/trpc';
import { Check } from '@tamagui/lucide-icons';

// Custom Task type that matches the actual format returned from the backend
type Task = {
  id: string;
  name: string;  // Backend returns 'name' not 'title'
  status: string;
  priority?: number;
  due_date?: string; // Backend returns 'due_date' not 'due'
  notes?: string;
  goal_id?: string;
  // Include other fields as needed
};

interface TaskItemProps {
  task: Task;
  onPress: () => void;
}

export default function TaskItem({ task, onPress }: TaskItemProps) {
  
  // Setup toggleTask mutation with optimistic updates
  const utils = trpc.useContext();
  // Setup mutation for task toggling
  const toggleTaskMutation = trpc.task.toggleTask.useMutation({
    // Optimistically update the UI
    onMutate: async ({ taskId, completed }: { taskId: string; completed?: boolean }) => {
      // Default to toggling the current state if completed is not provided
      const newCompleted = completed !== undefined ? completed : !isCompleted;
      // Cancel outgoing fetches that might overwrite our optimistic update
      await utils.task.getTasks.cancel();
      await utils.dashboard.getDashboardData.cancel();
      
      // Get previous data for potential rollback
      const prevTasksData = utils.task.getTasks.getData();
      const prevDashboardData = utils.dashboard.getDashboardData.getData();
      
      // Optimistically update tasks data if present
      if (prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return old.map((t: any) => {
            if (t.id === taskId) {
              return {
                ...t,
                status: completed ? 'completed' : 'in-progress'
              };
            }
            return t;
          });
        });
      }
      
      // Optimistically update dashboard data if present
      if (prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, (old: any) => {
          if (!old) return old;
          return {
            ...old,
            tasks: old.tasks.map((t: any) => {
              if (t.id === taskId) {
                return {
                  ...t,
                  status: newCompleted ? 'completed' : 'in-progress'
                };
              }
              return t;
            }),
          };
        });
      }
      
      // Return previous data for rollback
      return { prevTasksData, prevDashboardData };
    },
    
    // If something goes wrong, rollback optimistic updates
    onError: (err: any, variables: any, context: any) => {
      if (context?.prevTasksData) {
        utils.task.getTasks.setData({ goalId: undefined } as any, context.prevTasksData);
      }
      if (context?.prevDashboardData) {
        utils.dashboard.getDashboardData.setData({ goalId: undefined } as any, context.prevDashboardData);
      }
      console.error('Error toggling task:', err);
    },
    
    // Always refetch after error or success
    onSettled: () => {
      utils.task.getTasks.invalidate();
      utils.dashboard.getDashboardData.invalidate();
    }
  });

  // Handle checkbox toggle
  const handleToggle = () => {
    toggleTaskMutation.mutate({
      taskId: task.id, // Using taskId as expected by the backend
      completed: !isCompleted
    });
  };

  // Map priority to color
  const priorityColor = task.priority === 1 ? '$brandRed' : 
                        task.priority === 2 ? '$brandYellow' : 
                        '$brandGreen';
  
  // Format due date
  const formattedDate = task.due_date 
    ? new Date(task.due_date).toLocaleDateString(undefined, { 
        month: 'short', 
        day: 'numeric' 
      })
    : null;
    
  // Determine task completion status
  const isCompleted = task.status === 'completed';
  // No need for text style object since we use Tamagui props directly

  
  // Use YStack as the base component
  return (
    <YStack 
      backgroundColor="$backgroundStrong"
      padding="$3"
      borderRadius="$4"
      space="$1" // Add space between XStack and Date Text
    >
      <XStack alignItems="center" space="$2"> {/* Use XStack for horizontal layout */}
        {/* Checkbox for task completion */}
        <Checkbox
          size="$4"
          checked={isCompleted}
          onCheckedChange={handleToggle}
          disabled={toggleTaskMutation.isPending}
        >
          {toggleTaskMutation.isPending ? (
            <Spinner size="small" color="$brandPrimary" />
          ) : (
            <Checkbox.Indicator>
              <Check size={16} />
            </Checkbox.Indicator>
          )}
        </Checkbox>

        {/* Container for task details (clickable) */}
        <XStack flex={1} tag="pressable" onPress={onPress} pressStyle={{ opacity: 0.7 }}>
          {/* Priority Dot using YStack */}
          <YStack 
            width="$2" // Use size token for width
            height="$2" // Use size token for height
            borderRadius="$10" // Use a large radius token
            backgroundColor={priorityColor} 
            marginRight="$2" // Use space token for margin
          />
          <Text 
            fontSize="$4" // Use font size token
            fontWeight={task.priority === 1 ? '600' : '400'} // Keep fontWeight
            color="$color"
            flex={1} // Allow text to take remaining space
            opacity={isCompleted ? 0.7 : 1}
            textDecorationLine={isCompleted ? 'line-through' : undefined} // Proper Tamagui text decoration
          >
            {task.name}
          </Text>
        </XStack>
      </XStack>
      
      {formattedDate && (
        // Removed explicit margin, rely on outer YStack space
        <Text color="$gray9" fontSize="$2">
          Due: {formattedDate}
        </Text>
      )}
    </YStack>
  );
} 
  ```

### components/lists

- **components/lists/GoalList.tsx** (4.6 KB, 158 lines) Exports: `GoalCard`, `GoalList`

  ```tsx
import React from 'react';
import { FlatList, RefreshControl, ListRenderItem } from 'react-native';
import { YStack, Spinner, XStack, Text } from 'tamagui';
import { router } from 'expo-router';
import { RouterOutputs } from '@/utils/api-types';
import { AetherCard } from '@/components/ui/primitives';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { Ionicons } from '@expo/vector-icons';

type Goal = RouterOutputs['goal']['list'][number];

interface GoalListProps {
  goals?: Goal[];
  isLoading: boolean;
  isError?: boolean;
  refetch: () => void;
  onSelectGoal?: (goal: Goal) => void;
}

/**
 * GoalCard - Individual goal card component
 */
export function GoalCard({ goal, onPress }: { goal: Goal; onPress: () => void }) {
  // Calculate progress percentage for the progress ring
  const progressPercent = goal.progress ? goal.progress : 0;
  
  // Format the target date
  const formattedDate = goal.target_date
    ? new Date(goal.target_date).toLocaleDateString(undefined, {
        month: 'short',
        day: 'numeric',
      })
    : 'No due date';

  return (
    <AetherCard 
      isInteractive 
      variant="default"
      onPress={onPress}
    >
      <YStack space="$2">
        {/* Title */}
        <YStack>
          <XStack space="$2" alignItems="center">
            <Ionicons name="trophy-outline" size={18} color="$primary" />
            <Text fontSize="$5" fontWeight="bold" color="$color">
              {goal.title}
            </Text>
          </XStack>
        </YStack>
        
        {/* Description if available */}
        {goal.description && (
          <Text color="$colorMuted" fontSize="$3" numberOfLines={2}>
            {goal.description}
          </Text>
        )}
        
        {/* Footer with date and progress */}
        <XStack justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center">
            <Ionicons name="calendar-outline" size={16} color="$colorMuted" />
            <Text fontSize="$2" color="$colorMuted">
              {formattedDate}
            </Text>
          </XStack>
          
          {/* Progress display */}
          <XStack backgroundColor="$background" paddingHorizontal="$2" paddingVertical="$1" borderRadius="$2">
            <Text fontSize="$2" fontWeight="bold" color={progressPercent >= 75 ? '$success' : '$primary'}>
              {progressPercent}%
            </Text>
          </XStack>
        </XStack>
      </YStack>
    </AetherCard>
  );
}

/**
 * GoalList - List component for displaying goals
 */
export function GoalList({ goals, isLoading, isError, refetch, onSelectGoal }: GoalListProps) {
  const renderGoalItem: ListRenderItem<Goal> = ({ item }) => (
    <GoalCard 
      goal={item} 
      onPress={() => {
        if (onSelectGoal) {
          onSelectGoal(item);
        } else {
          // Default navigation
          router.push({ 
            pathname: '/planner/goal/[id]', 
            params: { id: item.id } 
          });
        }
      }} 
    />
  );

  if (isLoading) {
    return <EmptyOrSkeleton isLoading count={3} type="card" />;
  }

  if (isError) {
    return (
      <YStack padding="$4" space="$4" alignItems="center" justifyContent="center">
        <Ionicons name="alert-circle-outline" size={48} color="$error" />
        <YStack>
          <YStack alignItems="center">
            <Text fontSize="$5" fontWeight="bold" color="$color" textAlign="center">
              Unable to load goals
            </Text>
            <Text fontSize="$3" color="$colorMuted" textAlign="center" marginTop="$2">
              Please check your connection and try again
            </Text>
          </YStack>
        </YStack>
        <AetherCard onPress={refetch} isInteractive padding="$3" paddingHorizontal="$5">
          <XStack alignItems="center" space="$2">
            <Ionicons name="refresh-outline" size={18} color="$primary" />
            <Text fontSize="$4" fontWeight="500" color="$primary">
              Retry
            </Text>
          </XStack>
        </AetherCard>
      </YStack>
    );
  }

  if (!goals || goals.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty 
        text="No goals yet" 
        actionText="Create a goal" 
        onAction={() => router.push('/planner/add-goal')} 
      />
    );
  }

  return (
    <FlatList
      data={goals}
      keyExtractor={(item) => item.id}
      renderItem={renderGoalItem}
      contentContainerStyle={{ padding: 16, paddingBottom: 32 }}
      ItemSeparatorComponent={() => <YStack height="$4" />}
      refreshControl={
        <RefreshControl 
          refreshing={isLoading} 
          onRefresh={refetch} 
        />
      }
    />
  );
}

  ```

- **components/lists/HabitList.tsx** (5.4 KB, 193 lines) Exports: `HabitCard`, `HabitList`

  ```tsx
import React from 'react';
import { FlatList, RefreshControl, ListRenderItem } from 'react-native';
import { YStack, XStack, Text, Stack } from 'tamagui';
import { router } from 'expo-router';
import { RouterOutputs } from '@/utils/api-types';
import { AetherCard } from '@/components/ui/primitives';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { Ionicons } from '@expo/vector-icons';

type Habit = RouterOutputs['habit']['list'][number];

interface HabitListProps {
  habits?: Habit[];
  isLoading: boolean;
  isError?: boolean;
  refetch: () => void;
  onSelectHabit?: (habit: Habit) => void;
  onToggleHabit?: (habitId: string, completed: boolean) => void;
}

/**
 * HabitCard - Individual habit card component
 */
export function HabitCard({ 
  habit, 
  onPress, 
  onToggle 
}: { 
  habit: Habit; 
  onPress: () => void; 
  onToggle?: (completed: boolean) => void;
}) {
  // Calculate progress streak display
  const streakText = habit.streak === 1 
    ? '1 day'
    : `${habit.streak} days`;

  const bestStreakText = habit.best_streak === 1
    ? '1 day'
    : `${habit.best_streak} days`;

  // Check if the habit has been completed today
  const [isCompleted, setIsCompleted] = React.useState(false); // This would come from habit entries

  const handleToggle = () => {
    const newStatus = !isCompleted;
    setIsCompleted(newStatus);
    if (onToggle) {
      onToggle(newStatus);
    }
  };

  return (
    <AetherCard 
      isInteractive 
      variant="default"
      onPress={onPress}
    >
      <YStack space="$2">
        {/* Title with completion toggle */}
        <XStack space="$3" justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center" flex={1}>
            <Ionicons name="repeat-outline" size={18} color="$primary" />
            <Text fontSize="$5" fontWeight="bold" color="$color" numberOfLines={1} flex={1}>
              {habit.title}
            </Text>
          </XStack>
          
          {/* Toggle button for completing today's habit */}
          <Stack 
            onPress={handleToggle}
            pressStyle={{ opacity: 0.8 }}
          >
            <Ionicons 
              name={isCompleted ? "checkmark-circle" : "checkmark-circle-outline"} 
              size={26} 
              color={isCompleted ? "$success" : "$colorMuted"} 
            />
          </Stack>
        </XStack>
        
        {/* Streak information */}
        <XStack justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center">
            <Ionicons name="flame-outline" size={16} color="$colorMuted" />
            <Text fontSize="$2" color="$colorMuted">
              Current: {streakText}
            </Text>
          </XStack>
          
          <XStack space="$2" alignItems="center">
            <Ionicons name="trophy-outline" size={16} color="$colorMuted" />
            <Text fontSize="$2" color="$colorMuted">
              Best: {bestStreakText}
            </Text>
          </XStack>
        </XStack>
      </YStack>
    </AetherCard>
  );
}

/**
 * HabitList - List component for displaying habits
 */
export function HabitList({ 
  habits, 
  isLoading, 
  isError, 
  refetch, 
  onSelectHabit,
  onToggleHabit 
}: HabitListProps) {
  const renderHabitItem: ListRenderItem<Habit> = ({ item }) => (
    <HabitCard 
      habit={item} 
      onPress={() => {
        if (onSelectHabit) {
          onSelectHabit(item);
        } else {
          // Default navigation
          router.push({ 
            pathname: '/planner/habit/[id]', 
            params: { id: item.id } 
          });
        }
      }}
      onToggle={(completed) => {
        if (onToggleHabit) {
          onToggleHabit(item.id, completed);
        }
      }}
    />
  );

  if (isLoading) {
    return <EmptyOrSkeleton isLoading count={3} type="card" />;
  }

  if (isError) {
    return (
      <YStack padding="$4" space="$4" alignItems="center" justifyContent="center">
        <Ionicons name="alert-circle-outline" size={48} color="$error" />
        <YStack>
          <YStack alignItems="center">
            <Text fontSize="$5" fontWeight="bold" color="$color" textAlign="center">
              Unable to load habits
            </Text>
            <Text fontSize="$3" color="$colorMuted" textAlign="center" marginTop="$2">
              Please check your connection and try again
            </Text>
          </YStack>
        </YStack>
        <AetherCard onPress={refetch} isInteractive padding="$3" paddingHorizontal="$5">
          <XStack alignItems="center" space="$2">
            <Ionicons name="refresh-outline" size={18} color="$primary" />
            <Text fontSize="$4" fontWeight="500" color="$primary">
              Retry
            </Text>
          </XStack>
        </AetherCard>
      </YStack>
    );
  }

  if (!habits || habits.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty 
        text="No habits yet" 
        actionText="Create a habit" 
        onAction={() => router.push('/planner/add-habit')} 
      />
    );
  }

  return (
    <FlatList
      data={habits}
      keyExtractor={(item) => item.id}
      renderItem={renderHabitItem}
      contentContainerStyle={{ padding: 16, paddingBottom: 32 }}
      ItemSeparatorComponent={() => <YStack height="$4" />}
      refreshControl={
        <RefreshControl 
          refreshing={isLoading} 
          onRefresh={refetch} 
        />
      }
    />
  );
}

  ```

- **components/lists/TaskList.tsx** (6.2 KB, 221 lines) Exports: `TaskCard`, `TaskList`

  ```tsx
import React from 'react';
import { FlatList, RefreshControl, ListRenderItem } from 'react-native';
import { YStack, XStack, Text, Stack } from 'tamagui';
import { router } from 'expo-router';
import { RouterOutputs } from '@/utils/api-types';
import { AetherCard } from '@/components/ui/primitives';
import { EmptyOrSkeleton } from '@/components/ui/EmptyOrSkeleton';
import { Ionicons } from '@expo/vector-icons';

type Task = RouterOutputs['task']['list'][number];

interface TaskListProps {
  tasks?: Task[];
  isLoading: boolean;
  isError?: boolean;
  refetch: () => void;
  onSelectTask?: (task: Task) => void;
  onCompleteTask?: (taskId: string, completed: boolean) => void;
}

/**
 * TaskCard - Individual task card component
 */
export function TaskCard({ 
  task, 
  onPress, 
  onComplete 
}: { 
  task: Task; 
  onPress: () => void; 
  onComplete?: (completed: boolean) => void;
}) {
  // Get the completion status of the task
  const [isCompleted, setIsCompleted] = React.useState(Boolean(task.completed));
  
  // Format the due date
  const formattedDate = task.due
    ? new Date(task.due).toLocaleDateString(undefined, {
        month: 'short',
        day: 'numeric',
      })
    : 'No due date';
    
  // Check if task is overdue
  const isOverdue = task.due && new Date(task.due) < new Date() && !isCompleted;

  const handleToggle = () => {
    const newStatus = !isCompleted;
    setIsCompleted(newStatus);
    if (onComplete) {
      onComplete(newStatus);
    }
  };

  return (
    <AetherCard 
      isInteractive 
      variant="default"
      onPress={onPress}
    >
      <YStack space="$2">
        {/* Title with completion toggle */}
        <XStack space="$3" justifyContent="space-between" alignItems="center">
          <XStack space="$2" alignItems="center" flex={1}>
            <Stack 
              onPress={handleToggle}
              pressStyle={{ opacity: 0.8 }}
            >
              <Ionicons 
                name={isCompleted ? "checkmark-circle" : "checkmark-circle-outline"} 
                size={26} 
                color={isCompleted ? "$success" : "$colorMuted"} 
              />
            </Stack>
            <Text 
              fontSize="$5" 
              fontWeight="bold" 
              color={isCompleted ? "$colorMuted" : "$color"} 
              numberOfLines={1} 
              flex={1}
              textDecorationLine={isCompleted ? 'line-through' : 'none'}
            >
              {task.title}
            </Text>
          </XStack>
        </XStack>
        
        {/* Notes if available */}
        {task.notes && !isCompleted && (
          <Text color="$colorMuted" fontSize="$3" numberOfLines={2} paddingLeft="$7">
            {task.notes}
          </Text>
        )}
        
        {/* Footer with due date and goal information */}
        <XStack justifyContent="space-between" alignItems="center" paddingLeft="$7">
          <XStack space="$2" alignItems="center">
            <Ionicons 
              name="calendar-outline" 
              size={16} 
              color={isOverdue ? "$error" : "$colorMuted"} 
            />
            <Text 
              fontSize="$2" 
              color={isOverdue ? "$error" : "$colorMuted"}
              fontWeight={isOverdue ? "bold" : "normal"}
            >
              {isOverdue ? "Overdue: " : ""}{formattedDate}
            </Text>
          </XStack>
          
          {/* If task is linked to a goal, show goal name */}
          {task.goal_id && (
            <XStack 
              backgroundColor="$backgroundStrong" 
              paddingHorizontal="$2" 
              paddingVertical="$1" 
              borderRadius="$2"
            >
              <Text fontSize="$2" color="$primary">
                {task.goal?.title || 'Linked goal'}
              </Text>
            </XStack>
          )}
        </XStack>
      </YStack>
    </AetherCard>
  );
}

/**
 * TaskList - List component for displaying tasks
 */
export function TaskList({ 
  tasks, 
  isLoading, 
  isError, 
  refetch, 
  onSelectTask,
  onCompleteTask 
}: TaskListProps) {
  const renderTaskItem: ListRenderItem<Task> = ({ item }) => (
    <TaskCard 
      task={item} 
      onPress={() => {
        if (onSelectTask) {
          onSelectTask(item);
        } else {
          // Default navigation
          router.push({ 
            pathname: '/planner/task/[id]', 
            params: { id: item.id } 
          });
        }
      }}
      onComplete={(completed) => {
        if (onCompleteTask) {
          onCompleteTask(item.id, completed);
        }
      }}
    />
  );

  if (isLoading) {
    return <EmptyOrSkeleton isLoading count={3} type="card" />;
  }

  if (isError) {
    return (
      <YStack padding="$4" space="$4" alignItems="center" justifyContent="center">
        <Ionicons name="alert-circle-outline" size={48} color="$error" />
        <YStack>
          <YStack alignItems="center">
            <Text fontSize="$5" fontWeight="bold" color="$color" textAlign="center">
              Unable to load tasks
            </Text>
            <Text fontSize="$3" color="$colorMuted" textAlign="center" marginTop="$2">
              Please check your connection and try again
            </Text>
          </YStack>
        </YStack>
        <AetherCard onPress={refetch} isInteractive padding="$3" paddingHorizontal="$5">
          <XStack alignItems="center" space="$2">
            <Ionicons name="refresh-outline" size={18} color="$primary" />
            <Text fontSize="$4" fontWeight="500" color="$primary">
              Retry
            </Text>
          </XStack>
        </AetherCard>
      </YStack>
    );
  }

  if (!tasks || tasks.length === 0) {
    return (
      <EmptyOrSkeleton 
        isEmpty 
        text="No tasks yet" 
        actionText="Create a task" 
        onAction={() => router.push('/planner/add-task')} 
      />
    );
  }

  return (
    <FlatList
      data={tasks}
      keyExtractor={(item) => item.id}
      renderItem={renderTaskItem}
      contentContainerStyle={{ padding: 16, paddingBottom: 32 }}
      ItemSeparatorComponent={() => <YStack height="$4" />}
      refreshControl={
        <RefreshControl 
          refreshing={isLoading} 
          onRefresh={refetch} 
        />
      }
    />
  );
}

  ```

- **components/lists/index.ts** (0.3 KB, 7 lines) Exports: `GoalCard`, `GoalList`, `HabitCard`, `HabitList`, `TaskCard`, `TaskList`

  ```ts
// Export all list components from a single file for easier imports
export { GoalList, GoalCard } from './GoalList';
export { HabitList, HabitCard } from './HabitList';
export { TaskList, TaskCard } from './TaskList';

// Add additional list exports as they are created

  ```

### components/planner

- **components/planner/GoalsList.tsx** (5.3 KB, 198 lines) Exports: `default`, `Goal`, `GoalsListProps`

  ```tsx
import React from 'react';
import { StyleSheet, Pressable, ViewStyle, StyleProp } from 'react-native';
import { FlashList } from '@shopify/flash-list';
import { YStack, XStack, Text, View, Progress, ProgressIndicator } from 'tamagui';
import { useColors } from '@/utils/colors';
import EmptyOrSkeleton from '@/components/EmptyOrSkeleton';

// Goal interface - this should match your API schema
export interface Goal {
  id: string;
  title: string;
  description?: string;
  progress: number; // 0 to 1
  deadline?: string; // ISO date string
  userId: string;
  createdAt: string;
  updatedAt: string;
}

export interface GoalsListProps {
  /** List of goals to display */
  goals?: Goal[];
  /** Whether the data is loading */
  isLoading?: boolean;
  /** Called when a goal is pressed */
  onGoalPress?: (goal: Goal) => void;
  /** Called when the add button is pressed */
  onAddPress?: () => void;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}

/**
 * Component to render a goal card with progress bar
 */
function GoalCard({
  goal,
  onPress,
}: {
  goal: Goal;
  onPress?: (goal: Goal) => void;
}) {
  const colors = useColors();
  
  // Calculate remaining days if deadline is set
  const daysLeft = goal.deadline 
    ? Math.ceil((new Date(goal.deadline).getTime() - Date.now()) / (1000 * 60 * 60 * 24))
    : null;
  
  // Determine progress status color
  const getProgressColor = () => {
    if (goal.progress >= 1) return colors.status.success;
    if (daysLeft !== null && daysLeft < 3) return colors.status.error;
    if (daysLeft !== null && daysLeft < 7) return colors.status.warning;
    return colors.status.info;
  };
  
  const progressColor = getProgressColor();
  
  return (
    <Pressable
      onPress={() => onPress?.(goal)}
      style={({ pressed }) => [
        styles.card,
        {
          backgroundColor: colors.background.card,
          borderColor: colors.border.default,
          transform: [{ scale: pressed ? 0.98 : 1 }],
        },
      ]}
    >
      <YStack space="$2" padding="$4">
        <Text fontSize="$5" fontWeight="$2" color={colors.content.primary}>
          {goal.title}
        </Text>
        
        {goal.description && (
          <Text fontSize="$3" color={colors.content.secondary} numberOfLines={2}>
            {goal.description}
          </Text>
        )}
        
        <YStack space="$1" marginTop="$2">
          <XStack justifyContent="space-between" alignItems="center">
            <Text fontSize="$3" fontWeight="$2" color={colors.content.secondary}>
              Progress
            </Text>
            <Text fontSize="$3" color={colors.content.subtle}>
              {Math.round(goal.progress * 100)}%
            </Text>
          </XStack>
          
          <Progress value={goal.progress * 100} backgroundColor={colors.background.secondary}>
            <ProgressIndicator backgroundColor={progressColor} />
          </Progress>
        </YStack>
        
        {daysLeft !== null && (
          <XStack justifyContent="flex-end" marginTop="$1">
            <Text 
              fontSize="$2" 
              color={daysLeft < 0 ? colors.status.error : colors.content.subtle}
            >
              {daysLeft < 0 
                ? `Overdue by ${Math.abs(daysLeft)} days` 
                : daysLeft === 0 
                  ? "Due today" 
                  : `${daysLeft} days left`}
            </Text>
          </XStack>
        )}
      </YStack>
    </Pressable>
  );
}

/**
 * Component to display a list of goals with progress indicators
 */
export default function GoalsList({
  goals = [],
  isLoading = false,
  onGoalPress,
  onAddPress,
  style,
}: GoalsListProps) {
  const colors = useColors();
  
  return (
    <YStack flex={1} style={style}>
      <EmptyOrSkeleton
        isLoading={isLoading}
        isEmpty={goals.length === 0}
        skeletonCount={3}
        skeletonHeight={160}
        skeletonBorderRadius={12}
        title="No goals yet"
        message="Create a new goal to track your progress"
      >
        <FlashList
          data={goals}
          renderItem={({ item }) => (
            <GoalCard goal={item} onPress={onGoalPress} />
          )}
          estimatedItemSize={180}
          contentContainerStyle={styles.listContent}
          ItemSeparatorComponent={() => <View style={styles.separator} />}
        />
      </EmptyOrSkeleton>
      
      {onAddPress && (
        <Pressable
          onPress={onAddPress}
          style={({ pressed }) => [
            styles.addButton,
            {
              backgroundColor: colors.brand.primary,
              opacity: pressed ? 0.9 : 1,
              transform: [{ scale: pressed ? 0.97 : 1 }],
            }
          ]}
        >
          <Text fontSize="$4" fontWeight="$3" color="white">
            + Add Goal
          </Text>
        </Pressable>
      )}
    </YStack>
  );
}

const styles = StyleSheet.create({
  card: {
    borderRadius: 12,
    borderWidth: 1,
    overflow: 'hidden',
  },
  listContent: {
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  separator: {
    height: 12,
  },
  addButton: {
    position: 'absolute',
    bottom: 24,
    right: 24,
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 30,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 4,
  },
}); 
  ```

- **components/planner/HabitTracker.tsx** (3.4 KB, 135 lines) Exports: `HabitTracker`

  ```tsx
import React, { useState } from "react";
import { View, StyleSheet } from "react-native";
import { XStack, YStack, Text, Button, H4, Separator } from "tamagui";
import StreakCalendar from './StreakCalendar';
import { Plus, Check } from "@tamagui/lucide-icons";
import { format } from "date-fns";

interface Habit {
  id: string;
  name: string;
  description?: string;
  completedDates: string[]; // ISO date strings
}

interface HabitTrackerProps {
  habits: Habit[];
  onAddHabit?: () => void;
  onToggleHabit?: (habitId: string, date: string, completed: boolean) => void;
  onHabitPress?: (habit: Habit) => void;
}

export function HabitTracker({
  habits = [],
  onAddHabit,
  onToggleHabit,
  onHabitPress,
}: HabitTrackerProps) {
  const today = format(new Date(), "yyyy-MM-dd");

  const handleToggleHabit = (habit: Habit) => {
    if (!onToggleHabit) return;
    
    const isCompleted = habit.completedDates.includes(today);
    onToggleHabit(habit.id, today, !isCompleted);
  };

  return (
    <YStack space="$4">
      <XStack justifyContent="space-between" alignItems="center">
        <H4>Habits</H4>
        <Button 
          size="$2" 
          circular 
          icon={<Plus size={16} />} 
          onPress={onAddHabit}
        />
      </XStack>

      {habits.length === 0 ? (
        <YStack 
          p="$4"
          alignItems="center" 
          justifyContent="center" 
          backgroundColor="$gray2" 
          borderRadius="$4"
        >
          <Text color="$gray11" textAlign="center">
            No habits yet. Add your first habit to start tracking.
          </Text>
        </YStack>
      ) : (
        <YStack space="$3">
          {habits.map((habit, index) => (
            <YStack key={habit.id} space="$2">
              {index > 0 && <Separator />}
              <HabitItem 
                habit={habit} 
                onToggle={() => handleToggleHabit(habit)}
                onPress={() => onHabitPress?.(habit)} 
              />
            </YStack>
          ))}
        </YStack>
      )}
    </YStack>
  );
}

interface HabitItemProps {
  habit: Habit;
  onToggle: () => void;
  onPress: () => void;
}

function HabitItem({ habit, onToggle, onPress }: HabitItemProps) {
  const today = format(new Date(), "yyyy-MM-dd");
  const isCompletedToday = habit.completedDates.includes(today);

  return (
    <XStack 
      p="$3"
      borderRadius="$4" 
      backgroundColor="$gray2"
      justifyContent="space-between"
      alignItems="center"
      pressStyle={{ opacity: 0.8 }}
      onPress={onPress}
    >
      <YStack space="$1" flex={1}>
        <Text fontSize="$3" fontWeight="$5">
          {habit.name}
        </Text>
        {habit.description && (
          <Text fontSize="$2" color="$gray11">
            {habit.description}
          </Text>
        )}
        
        <YStack mt="$2">
          <StreakCalendar
            completedDates={habit.completedDates}
          />
        </YStack>
      </YStack>

      <Button
        size="$3"
        circular
        backgroundColor={isCompletedToday ? "$primary9" : "$gray4"}
        onPress={(e) => {
          e.stopPropagation();
          onToggle();
        }}
        pressStyle={{
          backgroundColor: isCompletedToday ? "$primary8" : "$gray5",
        }}
      >
        <Check 
          size={18} 
          color={isCompletedToday ? "$gray1" : "$gray11"} 
        />
      </Button>
    </XStack>
  );
} 
  ```

- **components/planner/HabitsList.tsx** (5.7 KB, 220 lines) Exports: `default`, `Habit`, `HabitsListProps`

  ```tsx
import React, { useState } from 'react';
import { StyleSheet, Pressable, ViewStyle, StyleProp } from 'react-native';
import { YStack, XStack, Text, View, Checkbox } from 'tamagui';
import { useColors } from '@/utils/colors';
import EmptyOrSkeleton from '@/components/EmptyOrSkeleton';
import * as Haptics from 'expo-haptics';

// Habit interface - this should match your API schema
export interface Habit {
  id: string;
  title: string;
  description?: string;
  frequency: 'daily' | 'weekly' | 'monthly';
  completedToday: boolean;
  streak: number;
  userId: string;
  createdAt: string;
  updatedAt: string;
}

export interface HabitsListProps {
  /** List of habits to display */
  habits?: Habit[];
  /** Whether the data is loading */
  isLoading?: boolean;
  /** Called when a habit's completion status is toggled */
  onToggleHabit?: (habitId: string, completed: boolean) => Promise<void>;
  /** Called when a habit item is pressed */
  onHabitPress?: (habit: Habit) => void;
  /** Called when the add button is pressed */
  onAddPress?: () => void;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}

/**
 * Component to render a habit item with checkbox
 */
function HabitItem({
  habit,
  onToggle,
  onPress,
}: {
  habit: Habit;
  onToggle?: (habitId: string, completed: boolean) => Promise<void>;
  onPress?: (habit: Habit) => void;
}) {
  const colors = useColors();
  const [isChecked, setIsChecked] = useState(habit.completedToday);
  const [isUpdating, setIsUpdating] = useState(false);
  
  const handleToggle = async () => {
    if (isUpdating || !onToggle) return;
    
    // Optimistic update
    const newValue = !isChecked;
    setIsChecked(newValue);
    
    // Provide haptic feedback
    if (newValue) {
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    } else {
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
    
    try {
      setIsUpdating(true);
      await onToggle(habit.id, newValue);
    } catch (error) {
      // Revert on error
      setIsChecked(!newValue);
      console.error('Failed to update habit:', error);
    } finally {
      setIsUpdating(false);
    }
  };
  
  // Get frequency text
  const getFrequencyText = () => {
    switch (habit.frequency) {
      case 'daily': return 'Daily';
      case 'weekly': return 'Weekly';
      case 'monthly': return 'Monthly';
      default: return '';
    }
  };
  
  return (
    <Pressable
      onPress={() => onPress?.(habit)}
      style={({ pressed }) => [
        styles.habitItem,
        {
          backgroundColor: colors.background.card,
          borderColor: colors.border.default,
          opacity: isUpdating ? 0.7 : 1,
          transform: [{ scale: pressed ? 0.98 : 1 }],
        },
      ]}
      disabled={isUpdating}
    >
      <XStack space="$3" flex={1} alignItems="center">
        <Checkbox
          checked={isChecked}
          onCheckedChange={handleToggle}
          disabled={isUpdating}
          borderColor="$gray8"
          backgroundColor={isChecked ? "green" : undefined}
          opacity={isUpdating ? 0.5 : 1}
          size="$5"
        />
        
        <YStack flex={1} space="$1">
          <Text 
            fontSize="$4" 
            fontWeight="$2" 
            color="$color"
            textDecorationLine={isChecked ? 'line-through' : 'none'}
            opacity={isChecked ? 0.8 : 1}
          >
            {habit.title}
          </Text>
          
          <XStack space="$3" alignItems="center">
            <Text fontSize="$2" color="$gray10">
              {getFrequencyText()}
            </Text>
            
            {habit.streak > 0 && (
              <XStack space="$1" alignItems="center">
                <Text fontSize="$2" color={colors.status.success} fontWeight="$2">
                  {habit.streak} day streak 🔥
                </Text>
              </XStack>
            )}
          </XStack>
        </YStack>
      </XStack>
    </Pressable>
  );
}

/**
 * Component to display a list of habits with checkboxes
 */
export default function HabitsList({
  habits = [],
  isLoading = false,
  onToggleHabit,
  onHabitPress,
  onAddPress,
  style,
}: HabitsListProps) {
  const colors = useColors();
  
  return (
    <YStack flex={1} style={style}>
      <EmptyOrSkeleton
        isLoading={isLoading}
        isEmpty={habits.length === 0}
        skeletonCount={4}
        skeletonHeight={80}
        skeletonBorderRadius={12}
        title="No habits yet"
        message="Create a habit to track your daily progress"
      >
        <YStack space="$2" padding="$4">
          {habits.map((habit) => (
            <HabitItem
              key={habit.id}
              habit={habit}
              onToggle={onToggleHabit}
              onPress={onHabitPress}
            />
          ))}
        </YStack>
      </EmptyOrSkeleton>
      
      {onAddPress && (
        <Pressable
          onPress={onAddPress}
          style={({ pressed }) => [
            styles.addButton,
            {
              backgroundColor: colors.brand.primary,
              opacity: pressed ? 0.9 : 1,
              transform: [{ scale: pressed ? 0.97 : 1 }],
            }
          ]}
        >
          <Text fontSize="$4" fontWeight="$3" color="white">
            + Add Habit
          </Text>
        </Pressable>
      )}
    </YStack>
  );
}

const styles = StyleSheet.create({
  habitItem: {
    borderRadius: 12,
    borderWidth: 1,
    padding: 16,
    marginBottom: 8,
  },
  addButton: {
    position: 'absolute',
    bottom: 24,
    right: 24,
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 30,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 4,
  },
}); 
  ```

- **components/planner/StreakCalendar.tsx** (5.0 KB, 189 lines) Exports: `default`, `StreakCalendarProps`

  ```tsx
import React, { useMemo } from 'react';
import { StyleSheet, ViewStyle, StyleProp } from 'react-native';
import { View, XStack, YStack, Text, Circle } from 'tamagui';
import { useColors } from '@/utils/colors';
import { format, startOfWeek, addDays, isSameDay, subWeeks, addWeeks } from 'date-fns';

export interface StreakCalendarProps {
  /** Array of dates (ISO strings) when the habit was completed */
  completedDates: string[];
  /** Number of weeks to display (default: 4) */
  weekCount?: number;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}

/**
 * Component that displays a habit completion calendar with dots for each day
 */
export default function StreakCalendar({
  completedDates = [],
  weekCount = 4,
  style,
}: StreakCalendarProps) {
  const today = new Date();

  const completedDatesObjects = useMemo(() => {
    return completedDates.map(dateStr => new Date(dateStr));
  }, [completedDates]);

  // Generate weeks from the current week backwards
  const weeks = useMemo(() => {
    const result = [];
    const day = startOfWeek(today, { weekStartsOn: 0 }); // Sunday as first day

    // Get current week
    const currentWeek = Array(7)
      .fill(null)
      .map((_, i) => {
        const date = addDays(day, i);
        return {
          date,
          completed: completedDatesObjects.some((d) => isSameDay(d, date)),
          isToday: isSameDay(date, today),
          isPast: date < today,
          isFuture: date > today,
        };
      });
    result.push(currentWeek);

    // Get previous weeks
    for (let i = 1; i < weekCount; i++) {
      const startDay = subWeeks(day, i);
      const week = Array(7)
        .fill(null)
        .map((_, j) => {
          const date = addDays(startDay, j);
          return {
            date,
            completed: completedDatesObjects.some((d) => isSameDay(d, date)),
            isToday: false,
            isPast: date < today,
            isFuture: date > today,
          };
        });
      result.push(week);
    }

    // Reverse so most recent week is at the bottom
    return result.reverse();
  }, [completedDatesObjects, weekCount, today]);

  const dayNames = useMemo(() => {
    const firstDayOfWeek = startOfWeek(new Date(), { weekStartsOn: 0 });
    return Array(7)
      .fill(null)
      .map((_, i) => {
        return format(addDays(firstDayOfWeek, i), "EEE").charAt(0);
      });
  }, []);

  return (
    <YStack space="$3" style={style}>
      <Text fontSize="$3" fontWeight="$3" color="$content.primary">
        Activity
      </Text>
      
      <XStack justifyContent="space-between">
        {dayNames.map((day, index) => (
          <Text key={index} color="$gray11" textAlign="center" fontSize="$1">
            {day}
          </Text>
        ))}
      </XStack>
      
      <YStack space="$3">
        {weeks.map((week, weekIndex) => (
          <XStack key={`week-${weekIndex}`} justifyContent="space-between">
            {week.map((day, dayIndex) => (
              <YStack key={`day-${weekIndex}-${dayIndex}`} alignItems="center" space="$1">
                <Text 
                  fontSize="$1" 
                  color={day.isToday ? "$brand.primary" : "$content.subtle"}
                  fontWeight={day.isToday ? '$3' : '$2'}
                >
                  {day.date.getDate()}
                </Text>
                
                {/* Day circle */}
                <DayCircle 
                  completed={day.completed}
                  isToday={day.isToday}
                  isPast={day.isPast}
                  isFuture={day.isFuture}
                />
              </YStack>
            ))}
          </XStack>
        ))}
      </YStack>
      
      {/* Legend */}
      <XStack space="$4" justifyContent="center" marginTop="$2">
        <XStack space="$1" alignItems="center">
          <View
            style={{
              width: 8,
              height: 8,
              borderRadius: 4,
              backgroundColor: "$gray6",
            }}
          />
          <Text fontSize="$2" color="$content.subtle">Not completed</Text>
        </XStack>
        
        <XStack space="$1" alignItems="center">
          <View
            style={{
              width: 8,
              height: 8,
              borderRadius: 4,
              backgroundColor: "$primary9",
            }}
          />
          <Text fontSize="$2" color="$content.subtle">Completed</Text>
        </XStack>
      </XStack>
    </YStack>
  );
}

function DayCircle({ 
  completed, 
  isToday, 
  isPast, 
  isFuture 
}: { 
  completed: boolean; 
  isToday: boolean;
  isPast: boolean;
  isFuture: boolean;
}) {
  let backgroundColor = completed 
    ? "$primary9" 
    : "transparent";
  
  // Future dates should be more faded
  if (isFuture) {
    backgroundColor = "transparent";
  }
  
  return (
    <View style={[
      styles.dayCircle,
      {
        backgroundColor,
        borderWidth: isToday ? 1 : 0,
        borderColor: "$primary9",
      }
    ]} />
  );
}

const styles = StyleSheet.create({
  dayCircle: {
    width: 32,
    height: 32,
    borderRadius: 16,
  },
}); 
  ```

### components/rewards

- **components/rewards/ConfettiBurst.tsx** (5.4 KB, 224 lines) Exports: `default`

  ```tsx
import React, { useEffect } from 'react';
import { StyleSheet, Dimensions } from 'react-native';
import { View } from 'tamagui';
import Animated, {
  useSharedValue,
  withDelay,
  withTiming,
  useAnimatedStyle,
  withSequence,
  runOnJS,
  Easing,
} from 'react-native-reanimated';
import { durations, easings } from '@/constants/motion';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

// Define confetti piece colors
const COLORS = [
  '#FF5252', // Red
  '#FFD740', // Amber
  '#64FFDA', // Teal
  '#448AFF', // Blue
  '#B388FF', // Deep Purple
  '#FF80AB', // Pink
  '#1DE9B6', // Green
  '#F48FB1', // Light Pink
];

// Number of confetti pieces
const CONFETTI_COUNT = 50;

// Confetti piece configuration
interface ConfettiPiece {
  id: number;
  x: number;
  y: number;
  size: number;
  color: string;
  rotation: number;
  delay: number;
  duration: number;
}

interface ConfettiBurstProps {
  /** Whether to show the confetti */
  isVisible: boolean;
  /** Called when animation completes */
  onComplete?: () => void;
  /** Number of confetti pieces to display (default: 50) */
  count?: number;
  /** Custom colors to use for confetti pieces */
  colors?: string[];
  /** Duration of the animation in ms (default: 2000) */
  duration?: number;
}

/**
 * A component that displays a burst of confetti animation
 */
export default function ConfettiBurst({
  isVisible,
  onComplete,
  count = CONFETTI_COUNT,
  colors = COLORS,
  duration = 2000,
}: ConfettiBurstProps) {
  // Create confetti pieces
  const pieces = React.useMemo(() => {
    const result: ConfettiPiece[] = [];
    
    for (let i = 0; i < count; i++) {
      result.push({
        id: i,
        x: Math.random() * SCREEN_WIDTH,
        y: -20, // Start above the screen
        size: Math.random() * 8 + 4, // Size between 4-12
        color: colors[Math.floor(Math.random() * colors.length)],
        rotation: Math.random() * 360,
        delay: Math.random() * 500, // Random delay up to 500ms
        duration: Math.random() * 1000 + 1500, // Duration between 1.5-2.5s
      });
    }
    
    return result;
  }, [count, colors]);
  
  // Trigger animation complete callback
  const animationComplete = () => {
    if (onComplete) {
      onComplete();
    }
  };
  
  return (
    <>
      {isVisible && (
        <View style={styles.container} pointerEvents="none">
          {pieces.map((piece) => (
            <ConfettiPiece
              key={piece.id}
              piece={piece}
              animationDuration={duration}
              onComplete={animationComplete}
            />
          ))}
        </View>
      )}
    </>
  );
}

// Individual confetti piece component
function ConfettiPiece({
  piece,
  animationDuration,
  onComplete,
}: {
  piece: ConfettiPiece;
  animationDuration: number;
  onComplete: () => void;
}) {
  const translateY = useSharedValue(piece.y);
  const translateX = useSharedValue(piece.x);
  const rotate = useSharedValue(piece.rotation);
  const opacity = useSharedValue(1);
  
  // Track if this is the last piece to complete
  const wasLastPiece = React.useRef(false);
  
  useEffect(() => {
    // Last piece will trigger onComplete
    if (piece.id === CONFETTI_COUNT - 1) {
      wasLastPiece.current = true;
    }
    
    // Start Y animation (falling down)
    translateY.value = withDelay(
      piece.delay,
      withTiming(
        SCREEN_HEIGHT + 50, // End below the screen
        {
          duration: piece.duration,
          easing: easings.accelerate,
        },
        () => {
          if (wasLastPiece.current) {
            runOnJS(onComplete)();
          }
        }
      )
    );
    
    // Swaying horizontal movement
    translateX.value = withDelay(
      piece.delay,
      withSequence(
        withTiming(piece.x - 50 + Math.random() * 100, {
          duration: piece.duration * 0.3,
          easing: easings.standard,
        }),
        withTiming(piece.x + 50 + Math.random() * 100, {
          duration: piece.duration * 0.3,
          easing: easings.standard,
        }),
        withTiming(piece.x - 25 + Math.random() * 50, {
          duration: piece.duration * 0.4,
          easing: easings.standard,
        })
      )
    );
    
    // Rotation animation
    rotate.value = withDelay(
      piece.delay,
      withTiming(piece.rotation + Math.random() * 720, {
        duration: piece.duration,
        easing: easings.standard,
      })
    );
    
    // Fade out toward the end
    opacity.value = withDelay(
      piece.delay + (piece.duration * 0.7),
      withTiming(0, {
        duration: piece.duration * 0.3,
        easing: easings.standard,
      })
    );
  }, []);
  
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        { translateX: translateX.value },
        { translateY: translateY.value },
        { rotate: `${rotate.value}deg` },
      ],
      opacity: opacity.value,
    };
  });
  
  return (
    <Animated.View
      style={[
        {
          position: 'absolute',
          width: piece.size,
          height: piece.size * (Math.random() * 0.8 + 0.2), // Varying heights
          backgroundColor: piece.color,
          borderRadius: Math.random() > 0.5 ? piece.size / 2 : 0, // Some round, some square
        },
        animatedStyle,
      ]}
    />
  );
}

const styles = StyleSheet.create({
  container: {
    ...StyleSheet.absoluteFillObject,
    zIndex: 999,
    pointerEvents: 'none',
  },
}); 
  ```

### components/settings

- **components/settings/NotificationRow.tsx** (2.2 KB, 93 lines) Exports: `default`, `NotificationRowProps`

  ```tsx
import React, { ReactNode } from 'react';
import { StyleSheet, ViewStyle, StyleProp } from 'react-native';
import { XStack, Text, Switch, SwitchProps, YStack } from 'tamagui';
import { useColors } from '@/utils/colors';

export interface NotificationRowProps {
  /** Title of the notification setting */
  title: string;
  /** Optional description */
  description?: string;
  /** Whether the notification is turned on */
  enabled: boolean;
  /** Called when the switch is toggled */
  onToggle: (value: boolean) => void;
  /** Icon to display in the row */
  icon?: ReactNode;
  /** Whether the control is in loading state */
  isLoading?: boolean;
  /** Switch props */
  switchProps?: Omit<SwitchProps, 'checked' | 'onCheckedChange'>;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}

/**
 * A component for displaying a notification setting row with toggle switch
 */
export default function NotificationRow({
  title,
  description,
  enabled,
  onToggle,
  icon,
  isLoading,
  switchProps,
  style,
}: NotificationRowProps) {
  const colors = useColors();
  
  const handleToggle = (value: boolean) => {
    if (!isLoading) {
      onToggle(value);
    }
  };
  
  return (
    <XStack
      style={[styles.container, style]}
      alignItems="center"
      justifyContent="space-between"
      padding="$4"
      backgroundColor={colors.background.card}
      borderRadius="$4"
    >
      <XStack alignItems="center" space="$3" flex={1}>
        {icon && <XStack opacity={isLoading ? 0.5 : 1}>{icon}</XStack>}
        
        <YStack space="$1" flex={1} opacity={isLoading ? 0.5 : 1}>
          <Text
            fontSize="$4"
            fontWeight="$2"
            color={colors.content.primary}
          >
            {title}
          </Text>
          
          {description && (
            <Text
              fontSize="$3"
              color={colors.content.secondary}
            >
              {description}
            </Text>
          )}
        </YStack>
      </XStack>
      
      <Switch
        size="$2"
        checked={enabled}
        onCheckedChange={handleToggle}
        disabled={isLoading}
        {...switchProps}
      />
    </XStack>
  );
}

const styles = StyleSheet.create({
  container: {
    marginBottom: 12,
  },
}); 
  ```

- **components/settings/ThemePreview.tsx** (3.6 KB, 140 lines) Exports: `default`, `ThemePreviewProps`

  ```tsx
import React from 'react';
import { StyleSheet, ViewStyle, StyleProp, Pressable } from 'react-native';
import { View, Stack, YStack, Text, XStack, Theme } from 'tamagui';
import { useTheme } from 'tamagui';
import { useColors } from '@/utils/colors';
import { Check } from '@tamagui/lucide-icons';

export interface ThemePreviewProps {
  /** The theme name to display */
  themeName: string;
  /** Whether this theme is currently selected */
  isSelected: boolean;
  /** Called when this theme is selected */
  onSelect: () => void;
  /** Whether to force dark mode for this preview */
  forceDark?: boolean;
  /** Whether to force light mode for this preview */
  forceLight?: boolean;
  /** Container style */
  style?: StyleProp<ViewStyle>;
}

/**
 * A component that displays a preview of a theme with sample UI elements
 */
export default function ThemePreview({
  themeName,
  isSelected,
  onSelect,
  forceDark,
  forceLight,
  style,
}: ThemePreviewProps) {
  const currentTheme = useTheme();
  const previewTheme = forceDark ? 'dark' : forceLight ? 'light' : undefined;
  const colors = useColors();
  
  return (
    <Pressable 
      onPress={onSelect}
      style={({ pressed }) => [
        styles.container,
        {
          transform: [{ scale: pressed ? 0.97 : 1 }],
          borderColor: isSelected ? colors.border.focus : colors.border.default,
          borderWidth: isSelected ? 2 : 1,
        },
        style,
      ]}
    >
      <YStack space="$2">
        <Text
          fontSize="$4"
          fontWeight="$2"
          color={colors.content.primary}
          marginBottom="$1"
        >
          {themeName}
        </Text>
        
        <Theme name={previewTheme}>
          <YStack
            backgroundColor="$cardBackground"
            borderRadius="$3"
            padding="$2"
            space="$2"
          >
            {/* Header Preview */}
            <View 
              style={styles.header}
              backgroundColor="$primary"
            />
            
            {/* Content Preview */}
            <YStack space="$1">
              <View style={styles.textLine} backgroundColor="$color" opacity={0.9} />
              <View style={styles.textLine} backgroundColor="$color" opacity={0.7} width="80%" />
              <View style={styles.textLine} backgroundColor="$color" opacity={0.5} width="60%" />
            </YStack>
            
            {/* Button Preview */}
            <XStack space="$2">
              <View
                style={styles.button}
                backgroundColor="$primary"
              />
              <View
                style={styles.button}
                backgroundColor="$backgroundPress"
              />
            </XStack>
          </YStack>
        </Theme>
        
        {isSelected && (
          <View style={styles.checkContainer}>
            <XStack
              backgroundColor={colors.status.success}
              borderRadius={999}
              alignItems="center"
              justifyContent="center"
              width={24}
              height={24}
            >
              <Check color="white" size={16} />
            </XStack>
          </View>
        )}
      </YStack>
    </Pressable>
  );
}

const styles = StyleSheet.create({
  container: {
    borderRadius: 12,
    padding: 12,
    backgroundColor: 'transparent',
    overflow: 'hidden',
    position: 'relative',
  },
  header: {
    height: 24,
    borderRadius: 4,
  },
  textLine: {
    height: 8,
    borderRadius: 4,
  },
  button: {
    height: 20,
    flex: 1,
    borderRadius: 4,
  },
  checkContainer: {
    position: 'absolute',
    top: 8,
    right: 8,
  },
}); 
  ```

### components/ui

- **components/ui/Container.tsx** (0.7 KB, 30 lines) Exports: `Container`, `default`

  ```tsx
import React, { ReactNode } from 'react';
import { SafeAreaView, SafeAreaViewProps } from 'react-native';
import { styled, useTheme, YStack } from 'tamagui';

interface ContainerProps extends SafeAreaViewProps {
  children: ReactNode;
}

const StyledSafeArea = styled(SafeAreaView, {
  name: 'StyledSafeArea',
  flex: 1,
});

export const Container: React.FC<ContainerProps> = ({ style, children, ...props }) => {
  const theme = useTheme();
  return (
    <StyledSafeArea
      style={[
        { backgroundColor: theme.background.val },
        style as any
      ]}
      {...props}
    >
      <YStack flex={1}>{children}</YStack>
    </StyledSafeArea>
  );
};

export default Container;

  ```

- **components/ui/EmptyOrSkeleton.tsx** (2.0 KB, 96 lines) Exports: `EmptyOrSkeleton`, `EmptyOrSkeletonProps`

  ```tsx
import React from 'react';
import { YStack, Text, Button } from 'tamagui';
import { SkeletonCard, SkeletonRow, SkeletonCircle } from './Skeleton';
import { SectionError } from './ErrorBanner';

export interface EmptyOrSkeletonProps {
  // Loading state
  isLoading?: boolean;
  count?: number;
  type?: 'card' | 'row' | 'circle';
  
  // Empty state
  isEmpty?: boolean;
  text?: string;
  actionText?: string;
  onAction?: () => void;
  
  // Error state
  isError?: boolean;
  onRetry?: () => void;
  
  // Children to render when not in any special state
  children?: React.ReactNode;
}

export const EmptyOrSkeleton = ({
  isLoading = false,
  count = 3,
  type = 'row',
  isEmpty = false,
  text = 'No items found',
  actionText = 'Add New',
  onAction,
  isError = false,
  onRetry,
  children
}: EmptyOrSkeletonProps) => {
  // Generate skeleton based on type
  const renderSkeletons = () => {
    const skeletons = [];
    for (let i = 0; i < count; i++) {
      if (type === 'card') {
        skeletons.push(<SkeletonCard key={i} />);
      } else if (type === 'circle') {
        skeletons.push(<SkeletonCircle key={i} />);
      } else {
        skeletons.push(<SkeletonRow key={i} />);
      }
    }
    return skeletons;
  };

  // Show skeleton if loading
  if (isLoading) {
    return (
      <YStack space="$3">
        {renderSkeletons()}
      </YStack>
    );
  }
  
  // Show error state if there's an error
  if (isError) {
    return (
      <SectionError 
        message={text} 
        onRetry={onRetry} 
      />
    );
  }
  
  // Show empty state if empty
  if (isEmpty) {
    return (
      <YStack
        padding="$4"
        alignItems="center"
        justifyContent="center"
        space="$3"
      >
        <Text textAlign="center" color="$gray11">
          {text}
        </Text>
        {onAction && (
          <Button size="$3" onPress={onAction}>
            {actionText}
          </Button>
        )}
      </YStack>
    );
  }
  
  // Default: return children
  return <>{children}</>;
};

  ```

- **components/ui/ErrorBanner.tsx** (2.7 KB, 101 lines) Exports: `ErrorBanner`, `SectionError`

  ```tsx
import React from 'react';
import { YStack, Text, Button, XStack, H4, useTheme } from 'tamagui';
import { Ionicons } from '@expo/vector-icons';

interface ErrorBannerProps {
  title?: string;
  message: string;
  onRetry?: () => void;
}

export function ErrorBanner({ title, message, onRetry }: ErrorBannerProps) {
  const theme = useTheme();

  const red3 = theme?.red3?.val ?? '#fee2e2';
  const red5 = theme?.red5?.val ?? '#f87171';
  const red6 = theme?.red6?.val ?? '#ef4444';
  const red7 = theme?.red7?.val ?? '#dc2626';
  const red10 = theme?.red10?.val ?? '#991b1b';
  const red11 = theme?.red11?.val ?? '#7f1d1d';

  return (
    <YStack 
      backgroundColor={red3} 
      borderColor={red7} 
      borderWidth={1} 
      borderRadius="$3"
      padding="$3"
      space="$2"
      alignItems="center"
    >
      <XStack width="100%" justifyContent="space-between" alignItems="center">
        <H4 color={red11}>{title || 'Error'}</H4> 
        {/* Optional: Add an icon */} 
        {/* <Ionicons name="alert-circle-outline" size={20} color={red10} /> */} 
      </XStack>
      <Text color={red11}>{message}</Text> 
      {onRetry && (
        <Button 
          // theme="red" 
          icon={<Ionicons name="refresh" size={16} color={red11} />} 
          onPress={onRetry}
          size="$2"
          backgroundColor={red5} 
          borderColor={red7} 
          borderWidth={1}
          pressStyle={{ backgroundColor: red6 }}
        >
          <Text color={red11}>Retry</Text>
        </Button>
      )}
    </YStack>
  );
}

interface SectionErrorProps {
  message: string;
  onRetry?: () => void;
}

export function SectionError({ message, onRetry }: SectionErrorProps) {
  const theme = useTheme();

  const red3 = theme?.red3?.val ?? '#fee2e2';
  const red5 = theme?.red5?.val ?? '#f87171';
  const red6 = theme?.red6?.val ?? '#ef4444';
  const red7 = theme?.red7?.val ?? '#dc2626';
  const red10 = theme?.red10?.val ?? '#991b1b';
  const red11 = theme?.red11?.val ?? '#7f1d1d';

  return (
    <YStack 
      padding="$3" 
      borderRadius="$3" 
      borderWidth={1} 
      borderColor={red7} 
      backgroundColor={red3} 
      alignItems="center" 
      space="$2"
    >
      <Ionicons name="warning-outline" size={24} color={red10} /> 
      <Text color={red11} textAlign="center"> 
        {message || 'Failed to load this section.'}
      </Text>
      {onRetry && (
        <Button 
          size="$2" 
          // theme="red"
          backgroundColor={red5} 
          icon={<Ionicons name="refresh" size={16} color={red11} />} 
          onPress={onRetry}
          pressStyle={{ backgroundColor: red6 }}
          borderColor={red7} 
          borderWidth={1} 
        >
          <Text color={red11}>Retry</Text>
        </Button>
      )}
    </YStack>
  );
}

  ```

- **components/ui/InteractiveCard.tsx** (0.6 KB, 29 lines) Exports: `default`

  ```tsx
import { Card, styled } from 'tamagui';

const InteractiveCard = styled(Card, {
  name: 'InteractiveCard',
  // default props
  elevate: true,
  bordered: true,
  animation: 'bouncy',
  padding: '$4',

  hoverStyle: {
    y: -2,
    shadowColor: '$color.transparent',
    backgroundColor: '$backgroundHover',
  },
  pressStyle: {
    scale: 0.97,
    backgroundColor: '$backgroundPress',
  },
  focusStyle: {
    backgroundColor: '$backgroundFocus',
    outlineColor: '$borderColorFocus',
  },
  shadowOffset: { width: 0, height: 2 },
  shadowOpacity: 0.1,
});

export default InteractiveCard;

  ```

- **components/ui/Section.tsx** (0.5 KB, 24 lines) Exports: `default`

  ```tsx
import React, { ReactNode } from 'react';
import { YStack, Text } from 'tamagui';

interface SectionProps {
  title?: string;
  children: ReactNode;
}

/**
 * Semantic section wrapper with optional title and consistent spacing.
 */
const Section: React.FC<SectionProps> = ({ title, children }) => (
  <YStack marginVertical="$4">
    {title && (
      <Text fontSize="$6" fontWeight="bold" marginBottom="$2">
        {title}
      </Text>
    )}
    {children}
  </YStack>
);

export default Section;

  ```

- **components/ui/Skeleton.tsx** (2.6 KB, 113 lines) Exports: `Skeleton`, `SkeletonAvatar`, `SkeletonCard`, `SkeletonCircle`, `SkeletonProfile`, `SkeletonRow`

  ```tsx
import React from 'react';
import { DimensionValue } from 'react-native';
import { YStack, XStack, styled, Stack } from 'tamagui';
import { useColorScheme } from '@/hooks/useColorScheme';

const SkeletonBase = styled(Stack, {
  name: 'SkeletonBase',
  backgroundColor: '$gray5',
  overflow: 'hidden',
  position: 'relative',
  variants: {
    colorMode: {
      light: { backgroundColor: '$gray5' },
      dark: { backgroundColor: '$gray9' },
    },
  } as const,
});

const SkeletonShimmer = styled(Stack, {
  name: 'SkeletonShimmer',
  position: 'absolute',
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  opacity: 0.5,
});

interface SkeletonProps {
  width?: DimensionValue;
  height?: DimensionValue;
  borderRadius?: number;
}

export function Skeleton({ width = '100%', height = 20, borderRadius = 4 }: SkeletonProps) {
  const colorScheme = useColorScheme();
  
  return (
    <SkeletonBase
      colorMode={colorScheme === 'dark' ? 'dark' : 'light'}
      width={width}
      height={height}
      borderRadius={borderRadius}
    />
  );
}

interface SkeletonRowProps {
  height?: DimensionValue;
  width?: DimensionValue;
  lines?: number;
  spacing?: number;
}

export function SkeletonRow({ height = 20, width = '100%', lines = 3, spacing = 10 }: SkeletonRowProps) {
  return (
    <YStack space={spacing}>
      {Array.from({ length: lines }).map((_, i) => (
        <Skeleton 
          key={i}
          height={height}
          width={i === lines - 1 && typeof width === 'string' ? '70%' : width}
        />
      ))}
    </YStack>
  );
}

interface SkeletonCardProps {
  height?: DimensionValue;
  width?: DimensionValue;
}

export function SkeletonCard({ height = 100, width = '100%' }: SkeletonCardProps) {
  return (
    <YStack space="$2">
      <Skeleton height={height} width={width} borderRadius={8} />
    </YStack>
  );
}

interface SkeletonAvatarProps {
  size?: number;
}

export function SkeletonAvatar({ size = 40 }: SkeletonAvatarProps) {
  return <Skeleton width={size} height={size} borderRadius={size / 2} />;
}

interface SkeletonProfileProps {
  avatarSize?: number;
}

export function SkeletonProfile({ avatarSize = 40 }: SkeletonProfileProps) {
  return (
    <XStack space="$3" alignItems="center">
      <SkeletonAvatar size={avatarSize} />
      <YStack space="$1" flex={1}>
        <Skeleton width="60%" height={16} />
        <Skeleton width="40%" height={12} />
      </YStack>
    </XStack>
  );
}

interface SkeletonCircleProps {
  size?: number;
}

export function SkeletonCircle({ size = 60 }: SkeletonCircleProps) {
  return <Skeleton width={size} height={size} borderRadius={size / 2} />;
}

  ```

- **components/ui/SwipeableRow.tsx** (2.2 KB, 76 lines) Exports: `default`

  ```tsx
import React from 'react';
import { Swipeable } from 'react-native-gesture-handler';
import { XStack, Button, useTheme } from 'tamagui';
import { Trash, Check } from '@tamagui/lucide-icons';
import * as Haptics from 'expo-haptics';

type SwipeableRowProps = {
  children: React.ReactNode;
  onDelete?: () => void;
  onComplete?: () => void;
  // Add any other props needed, like unique key for Swipeable instance management
};

export default function SwipeableRow({ children, onDelete, onComplete }: SwipeableRowProps) {
  const theme = useTheme();

  const renderRightActions = () => {
    if (!onDelete) return null;
    return (
      <XStack flex={1} justifyContent="flex-end">
        <Button
          // size="$3" // Match ListItem size?
          backgroundColor="$destructive"
          borderTopRightRadius="$0" // Flatten edges
          borderBottomRightRadius="$0"
          icon={<Trash color={theme.color?.get()} />} // Use theme color for icon
          onPress={() => {
            Haptics.selectionAsync();
            onDelete();
            // Consider closing the Swipeable here if needed
          }}
          width={80} // Fixed width for the action button
          height="100%" // Fill height
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  const renderLeftActions = () => {
    if (!onComplete) return null;
    return (
      <XStack flex={1} justifyContent="flex-start">
        <Button
          // size="$3"
          backgroundColor="$success"
          borderTopLeftRadius="$0"
          borderBottomLeftRadius="$0"
          icon={<Check color={theme.color?.get()} />}
          onPress={() => {
            Haptics.selectionAsync();
            onComplete();
            // Consider closing the Swipeable here if needed
          }}
          width={80}
          height="100%"
          justifyContent="center"
          alignItems="center"
        />
      </XStack>
    );
  };

  return (
    <Swipeable
      renderRightActions={renderRightActions}
      renderLeftActions={renderLeftActions}
      overshootFriction={8} // Standard friction
      containerStyle={{ backgroundColor: '$background' }} // Ensure background matches item
    >
      {children}
    </Swipeable>
  );
}

  ```

- **components/ui/primitives/AetherCard.tsx** (1.9 KB, 77 lines) Exports: `AetherCard`

  ```tsx
import React from 'react';
import { Card, CardProps, YStack, styled } from 'tamagui';

type AetherCardVariant = 'default' | 'elevated' | 'outlined';

interface AetherCardProps extends CardProps {
  variant?: AetherCardVariant;
  // Additional props specific to AetherCard
  isInteractive?: boolean;
}

// Create a styled Card component that uses our custom Tamagui theme variables
const StyledCard = styled(Card, {
  name: 'AetherCard',
  backgroundColor: '$cardBackground',
  borderRadius: '$4',
  padding: '$4',
  elevate: true,

  variants: {
    variant: {
      default: {
        // Using our theme tokens
        shadowColor: '$shadowColor',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 3,
        elevation: 2,
      },
      elevated: {
        shadowColor: '$shadowColor',
        shadowOffset: { width: 0, height: 4 },
        shadowOpacity: 0.15,
        shadowRadius: 6,
        elevation: 4,
      },
      outlined: {
        backgroundColor: 'transparent',
        borderWidth: 1,
        borderColor: '$borderColor',
        shadowOpacity: 0,
        elevation: 0,
      },
    },
    isInteractive: {
      true: {
        pressStyle: {
          backgroundColor: '$cardBackgroundPress',
          opacity: 0.9,
        },
        hoverStyle: {
          backgroundColor: '$cardBackgroundHover',
        },
      },
    },
  } as const,

  defaultVariants: {
    variant: 'default',
    isInteractive: false,
  },
});

/**
 * AetherCard - A stylized card component following Aether design system
 *
 * @param variant - The visual style variant: 'default', 'elevated', or 'outlined'
 * @param isInteractive - Whether the card responds to press/hover states
 */
export function AetherCard({ children, variant, isInteractive, ...props }: AetherCardProps) {
  return (
    <StyledCard variant={variant} isInteractive={isInteractive} {...props}>
      {children}
    </StyledCard>
  );
}

  ```

- **components/ui/primitives/AetherListItem.tsx** (3.3 KB, 124 lines) Exports: `AetherListItem`, `AetherListItemProps`

  ```tsx
import React from 'react';
import { XStack, YStack, Text, styled, GetProps, Stack } from 'tamagui';
import { Ionicons } from '@expo/vector-icons';

// Base ListItem container
const ListItemContainer = styled(XStack, {
  name: 'ListItemContainer',
  backgroundColor: '$cardBackground',
  paddingVertical: '$3',
  paddingHorizontal: '$4',
  borderRadius: '$3',
  alignItems: 'center',
  justifyContent: 'space-between',
  borderBottomWidth: 1,
  borderBottomColor: '$borderColor',
  minHeight: 60,
  
  variants: {
    isLast: {
      true: {
        borderBottomWidth: 0,
      },
    },
    interactive: {
      true: {
        pressStyle: {
          backgroundColor: '$backgroundPress',
          opacity: 0.9,
        },
        hoverStyle: {
          backgroundColor: '$backgroundHover',
        },
      },
    },
    variant: {
      default: {},
      header: {
        backgroundColor: '$backgroundStrong',
        borderBottomColor: '$borderColor',
        paddingVertical: '$2',
      },
    },
  } as const,
  
  defaultVariants: {
    isLast: false,
    interactive: true,
    variant: 'default',
  },
});

type ListItemContainerProps = GetProps<typeof ListItemContainer>;

export interface AetherListItemProps extends ListItemContainerProps {
  title: string;
  subtitle?: string;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
  showChevron?: boolean;
  badge?: string | number;
}

/**
 * AetherListItem - A consistent list item component for use in lists, menus, and settings
 *
 * @param title - The primary text
 * @param subtitle - Optional secondary text shown below the title
 * @param leftIcon - Optional icon component to show on the left side
 * @param rightIcon - Optional icon component to show on the right side
 * @param showChevron - Whether to show a right chevron (useful for navigation items)
 * @param badge - Optional badge text/number to display
 * @param isLast - Whether this is the last item in a list (removes bottom border)
 * @param interactive - Whether the item should visually respond to touch
 */
export function AetherListItem({
  title,
  subtitle,
  leftIcon,
  rightIcon,
  showChevron = false,
  badge,
  isLast,
  interactive,
  ...props
}: AetherListItemProps) {
  return (
    <ListItemContainer isLast={isLast} interactive={interactive} {...props}>
      {/* Left section with icon and text */}
      <XStack space="$3" flex={1} alignItems="center">
        {leftIcon && (
          <Stack marginRight="$2">{leftIcon}</Stack>
        )}
        
        <YStack>
          <Text fontWeight="500" fontSize="$4">{title}</Text>
          {subtitle && (
            <Text fontSize="$2" color="$gray10">{subtitle}</Text>
          )}
        </YStack>
      </XStack>
      
      {/* Right section with badge, custom icon or chevron */}
      <XStack space="$2" alignItems="center">
        {badge && (
          <XStack 
            backgroundColor="$primary"
            paddingHorizontal="$2"
            paddingVertical="$1"
            borderRadius="$2"
          >
            <Text color="white" fontSize="$1" fontWeight="bold">{badge}</Text>
          </XStack>
        )}
        
        {rightIcon && rightIcon}
        
        {showChevron && (
          <Ionicons name="chevron-forward" size={16} color="$gray10" />
        )}
      </XStack>
    </ListItemContainer>
  );
}

  ```

- **components/ui/primitives/SectionHeader.tsx** (1.4 KB, 62 lines) Exports: `SectionHeader`, `SectionHeaderProps`

  ```tsx
import React from 'react';
import { XStack, Text, styled, GetProps, Button } from 'tamagui';

const SectionContainer = styled(XStack, {
  name: 'SectionContainer',
  paddingVertical: '$2',
  paddingHorizontal: '$4',
  marginTop: '$4',
  marginBottom: '$2',
  justifyContent: 'space-between',
  alignItems: 'center',
});

type SectionContainerProps = GetProps<typeof SectionContainer>;

export interface SectionHeaderProps extends SectionContainerProps {
  title: string;
  actionLabel?: string;
  onAction?: () => void;
}

/**
 * SectionHeader - A consistent section header with optional action button
 * 
 * Used to separate content sections in screens like Home, Settings, etc.
 *
 * @param title - The section title
 * @param actionLabel - Optional label for the action button
 * @param onAction - Optional callback when action button is pressed
 */
export function SectionHeader({ 
  title, 
  actionLabel, 
  onAction, 
  ...props 
}: SectionHeaderProps) {
  return (
    <SectionContainer {...props}>
      <Text 
        fontSize="$5" 
        fontWeight="600" 
        color="$color"
      >
        {title}
      </Text>
      
      {actionLabel && onAction && (
        <Button
          onPress={onAction}
          fontSize="$2"
          backgroundColor="transparent"
          color="$primary"
          paddingHorizontal="$2"
          height="$5"
        >
          {actionLabel}
        </Button>
      )}
    </SectionContainer>
  );
}

  ```

- **components/ui/primitives/index.ts** (0.3 KB, 7 lines) Exports: `AetherCard`, `AetherListItem`, `AetherListItemProps`, `SectionHeader`, `SectionHeaderProps`

  ```ts
// Export all primitive components from a single file for easier imports
export { AetherCard } from './AetherCard';
export { AetherListItem, type AetherListItemProps } from './AetherListItem';
export { SectionHeader, type SectionHeaderProps } from './SectionHeader';

// Add additional primitive exports as they are created

  ```

### constants

- **constants/Colors.ts** (0.7 KB, 27 lines) Exports: `Colors`

  ```ts
/**
 * Below are the colors that are used in the app. The colors are defined in the light and dark mode.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */

const tintColorLight = '#0a7ea4';
const tintColorDark = '#fff';

export const Colors = {
  light: {
    text: '#11181C',
    background: '#fff',
    tint: tintColorLight,
    icon: '#687076',
    tabIconDefault: '#687076',
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: '#ECEDEE',
    background: '#151718',
    tint: tintColorDark,
    icon: '#9BA1A6',
    tabIconDefault: '#9BA1A6',
    tabIconSelected: tintColorDark,
  },
};

  ```

- **constants/motion.ts** (3.1 KB, 139 lines) Exports: `componentAnimations`, `durations`, `easings`, `presets`

  ```ts
import { Easing } from 'react-native-reanimated';

/**
 * Standard animation durations (in milliseconds)
 */
export const durations = {
  /** Ultra-fast for micro-interactions */
  micro: 80,
  /** Tap/press feedback */
  tap: 120,
  /** Default animation speed for most UI transitions */
  standard: 200,
  /** For more noticeable animations */
  medium: 250,
  /** Modal entrances/exits, complex transitions */
  modal: 300,
  /** Full screen transitions */
  screen: 350,
  /** Extended animations for emphasis */
  long: 450,
};

/**
 * Standard easing curves
 */
export const easings = {
  /** Quick acceleration, gradual deceleration - for elements entering the screen */
  enter: Easing.bezier(0.25, 0.1, 0.25, 1.0),
  /** Gradual acceleration, quick deceleration - for elements exiting the screen */
  exit: Easing.bezier(0.25, 0.0, 0.2, 1.0),
  /** For transitions between UI states */
  standard: Easing.bezier(0.4, 0.0, 0.2, 1.0),
  /** Quick in, quick out - for emphasis */
  energetic: Easing.bezier(0.55, 0.0, 0.1, 1.0),
  /** Linear - consistent motion with no acceleration/deceleration */
  linear: Easing.linear,
  /** Slow start, fast finish */
  accelerate: Easing.in(Easing.quad),
  /** Fast start, slow finish */
  decelerate: Easing.out(Easing.quad),
  /** Fast start and end, slower in the middle */
  emphasize: Easing.inOut(Easing.quad),
};

/**
 * Animation presets for common UI patterns
 */
export const presets = {
  fadeIn: {
    duration: durations.standard,
    easing: easings.enter,
  },
  fadeOut: {
    duration: durations.standard,
    easing: easings.exit,
  },
  slideIn: {
    duration: durations.modal,
    easing: easings.enter,
  },
  slideOut: {
    duration: durations.modal,
    easing: easings.exit,
  },
  scaleIn: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  scaleOut: {
    duration: durations.standard,
    easing: easings.emphasize,
  },
  tapFeedback: {
    duration: durations.tap,
    easing: easings.emphasize,
  },
  skeleton: {
    duration: durations.long * 2,
    easing: easings.linear,
  },
};

/**
 * Animation values for specific components
 */
export const componentAnimations = {
  toast: {
    show: {
      duration: durations.modal,
      easing: easings.enter,
    },
    hide: {
      duration: durations.standard,
      easing: easings.exit,
    },
  },
  modal: {
    overlay: {
      show: {
        duration: durations.modal,
        easing: easings.standard,
      },
      hide: {
        duration: durations.modal,
        easing: easings.standard,
      },
    },
    content: {
      show: {
        duration: durations.modal,
        easing: easings.enter,
      },
      hide: {
        duration: durations.standard,
        easing: easings.exit,
      },
    },
  },
  button: {
    press: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
    release: {
      duration: durations.tap,
      easing: easings.emphasize,
    },
  },
  navigation: {
    screen: {
      duration: durations.screen,
      easing: easings.standard,
    },
    tab: {
      duration: durations.standard,
      easing: easings.standard,
    },
  },
}; 
  ```

### debug

- **debug/toast-test.tsx** (1.7 KB, 76 lines) Exports: `default`

  ```tsx
import React from 'react';
import { Button, YStack, XStack, Text, Theme } from 'tamagui';
import { useToast } from '@/providers/ToastProvider';
import { StatusBar } from 'expo-status-bar';
import { View } from 'react-native';

export default function ToastTestScreen() {
  const { showToast } = useToast();

  const testSuccessToast = () => {
    showToast({
      type: 'success',
      title: 'Success',
      message: 'This is a success toast message',
      duration: 3000,
    });
  };

  const testErrorToast = () => {
    showToast({
      type: 'error',
      title: 'Error',
      message: 'This is an error toast message',
      duration: 3000,
    });
  };

  const testInfoToast = () => {
    showToast({
      type: 'info',
      message: 'This is an info toast without a title',
      duration: 3000,
    });
  };

  return (
    <View style={{ flex: 1 }}>
      <StatusBar style="auto" />
      <YStack
        flex={1}
        padding={20}
        space={16}
        justifyContent="center"
        alignItems="center"
      >
        <Text fontSize={24} fontWeight="bold" marginBottom={20}>
          Toast Test Screen
        </Text>
        
        <Button 
          onPress={testSuccessToast} 
          backgroundColor="$green6" 
          size="$4"
        >
          Show Success Toast
        </Button>
        
        <Button 
          onPress={testErrorToast} 
          backgroundColor="$red6" 
          size="$4"
        >
          Show Error Toast
        </Button>
        
        <Button 
          onPress={testInfoToast} 
          backgroundColor="$blue6" 
          size="$4"
        >
          Show Info Toast
        </Button>
      </YStack>
    </View>
  );
} 
  ```

### design-system

- **design-system/Animations.ts** (1.2 KB, 41 lines) Exports: `fadeInUp`, `korokReveal`, `sheikahGlow`, `slideOutLeft`, `taskComplete`

  ```ts
// design-system/Animations.ts
// Moti animation presets for consistent effects across the app

// Fade in from bottom
export const fadeInUp = {
  from: { opacity: 0, translateY: 16 },
  animate: { opacity: 1, translateY: 0 },
  exit: { opacity: 0, translateY: 16 },
  transition: { type: 'timing', duration: 350 },
};

// Slide out to left (for swipe to complete)
export const slideOutLeft = {
  from: { translateX: 0 },
  animate: { translateX: -100 },
  exit: { translateX: -100 },
  transition: { type: 'spring', dampingRatio: 0.7 },
};

// Zelda-themed glowing effect
export const sheikahGlow = {
  from: { opacity: 0.4, scale: 0.95 },
  animate: { opacity: 1, scale: 1 },
  exit: { opacity: 0.4, scale: 0.95 },
  transition: { type: 'timing', duration: 800, loop: true },
};

// Task completion animation
export const taskComplete = {
  from: { opacity: 1, translateX: 0 },
  animate: { opacity: 0.6, translateX: -5 },
  transition: { type: 'spring', dampingRatio: 0.8 },
};

// Korok reveal animation (for success states)
export const korokReveal = {
  from: { opacity: 0, scale: 0.7, rotate: '-10deg' },
  animate: { opacity: 1, scale: 1, rotate: '0deg' },
  transition: { type: 'spring', dampingRatio: 0.6 },
};

  ```

- **design-system/Primitives.tsx** (0.9 KB, 30 lines) Exports: `Button`, `Center`, `gs`, `HStack`, `Pressable`, `ScrollView`, `Stack`, `Text`, `useColorMode`, `useColorModeValue`, `useToast`, `VStack`

  ```tsx
// design-system/Primitives.tsx
import React from 'react';
import { styled } from 'nativewind';
import * as gs from '@gluestack-ui/themed';

// Styled components that accept className prop for NativeWind
export const Stack = styled(gs.View);
export const Text = styled(gs.Text);
export const Button = styled(gs.Button);
export const Pressable = styled(gs.Pressable);

// Re-export other Gluestack components that might be needed
export const HStack = styled(gs.HStack);
export const VStack = styled(gs.VStack);
export const Center = styled(gs.Center);
export const ScrollView = styled(gs.ScrollView);

// Forward gluestack hooks
export const useToast = gs.useToast;
export const useColorMode = gs.useColorMode;

export function useColorModeValue<T>(light: T, dark: T) {
  const { colorMode } = useColorMode();
  return colorMode === 'dark' ? dark : light;
}


// Export all other Gluestack components as-is
export { gs };

  ```

- **design-system/theme.glue.ts** (0.2 KB, 11 lines) Exports: `glueTheme`

  ```ts
import { config as base } from '@gluestack-ui/config';
import tokens from './tokens';

export const glueTheme = {
  ...base,
  tokens: {
    ...base.tokens,
    ...tokens,          // merge Zelda palette
  },
} as const;            // ← strongly-typed

  ```

- **design-system/tokens.ts** (1.3 KB, 69 lines) Exports: `colors`, `default`, `fonts`, `radii`, `sizes`, `space`

  ```ts
// design-system/tokens.ts
// Shared tokens used by both NativeWind and Gluestack UI

export const colors = {
  // Zelda theme colors from memories
  'parchment': '#FDFFE0',
  'sheikahCyan': '#86A5A9',
  'korokGreen': '#92C582',
  'darkText': '#536F50',
  'guardianOrange': '#FF9F0A',
  'darkTealBg': '#1A2E3A',
  'cyanGlow': '#64FFDA',
  
  // Semantic aliases
  'surface': '#FDFFE0', // parchment in light mode
  'onSurface': '#536F50', // darkText in light mode
  'outline': '#86A5A9', // sheikahCyan in both modes
  
  // Shadow colors with opacities
  'shadowSm': 'rgba(83, 111, 80, 0.10)', // Light theme
  'shadowMd': 'rgba(83, 111, 80, 0.15)',
  'shadowLg': 'rgba(83, 111, 80, 0.20)',
  'shadowDarkSm': 'rgba(0, 0, 0, 0.20)', // Dark theme
  'shadowDarkMd': 'rgba(0, 0, 0, 0.30)',
  'shadowDarkLg': 'rgba(0, 0, 0, 0.40)',
};

export const radii = {
  'sm': 4,
  'md': 8,
  'lg': 16,
  'xl': 24,
  'full': 9999,
};

export const space = {
  '0': 0,
  '0.5': 2,
  '1': 4,
  '2': 8,
  '3': 12,
  '4': 16,
  '5': 20,
  '6': 24,
  '8': 32,
  '10': 40,
  '12': 48,
  '16': 64,
};

export const sizes = {
  ...space,
};

export const fonts = {
  'heading': 'HyliaSerif',
  'body': 'CalamitySans',
  'mono': 'SpaceMono',
};

// Default export with all tokens
export default {
  colors,
  radii,
  space,
  sizes,
  fonts,
};

  ```

### hooks

- **hooks/useColorScheme.ts** (0.0 KB, 2 lines) Exports: `useColorScheme`

  ```ts
export { useColorScheme } from 'react-native';

  ```

- **hooks/useColorScheme.web.ts** (0.5 KB, 22 lines) Exports: `useColorScheme`

  ```ts
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}

  ```

- **hooks/useOfflineSync.ts** (6.1 KB, 172 lines) Exports: `useOfflineSync`

  ```ts
import { useEffect, useCallback } from 'react';
import NetInfo from '@react-native-community/netinfo';
import { onlineManager } from '@tanstack/react-query';
import { saveOfflineMutation, syncOfflineMutations, getPendingItems, PendingItem, setupBackgroundSync } from '@/utils/offline-sync';
import { useState } from 'react';

/**
 * Hook to provide offline sync functionality
 */
export function useOfflineSync<T extends { id: string }>(entityType: string) {
  const [isOnline, setIsOnline] = useState(true);
  const [pendingItems, setPendingItems] = useState<PendingItem[]>([]);
  const [isSyncing, setIsSyncing] = useState(false);

  // Load pending items on mount
  useEffect(() => {
    loadPendingItems();
    
    // Set up network status listener
    const unsubscribe = NetInfo.addEventListener(state => {
      const online = state.isConnected !== false && state.isInternetReachable !== false;
      setIsOnline(online);
      
      // If going from offline to online, try to sync
      if (online) {
        syncItems();
      }
    });
    
    // Also set up background sync (network status changes outside this component)
    const unsubscribeBackground = setupBackgroundSync();
    
    return () => {
      unsubscribe();
      unsubscribeBackground();
    };
  }, [entityType]);

  // Load pending items from storage
  const loadPendingItems = useCallback(async () => {
    const items = await getPendingItems(entityType);
    setPendingItems(items);
  }, [entityType]);

  // Create an item (works offline)
  const createItem = useCallback(async (data: Omit<T, 'id'>): Promise<{ id: string, isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, create directly
        // In a real app, you'd use your API client (like supabase) here
        // const { data: newItem, error } = await supabase.from(entityType).insert(data).select();
        // if (error) throw error;
        // return { id: newItem.id, isOffline: false };
        
        // For demo purposes, simulate success
        return { id: `server-${Date.now()}`, isOffline: false };
      } else {
        // If offline, save to be synced later
        const tempId = await saveOfflineMutation('create', entityType, data);
        await loadPendingItems(); // Reload pending items
        return { id: tempId, isOffline: true };
      }
    } catch (error) {
      console.error('Error creating item:', error);
      // If API call fails, save offline
      const tempId = await saveOfflineMutation('create', entityType, data);
      await loadPendingItems(); // Reload pending items
      return { id: tempId, isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Update an item (works offline)
  const updateItem = useCallback(async (item: T): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, update directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).update(item).eq('id', item.id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('update', entityType, item);
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error updating item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('update', entityType, item);
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Delete an item (works offline)
  const deleteItem = useCallback(async (id: string): Promise<{ isOffline: boolean }> => {
    try {
      // Check if we're online
      const networkState = await NetInfo.fetch();
      const online = networkState.isConnected && networkState.isInternetReachable !== false;
      
      if (online) {
        // If online, delete directly
        // In a real app, you'd use your API client (like supabase) here
        // const { error } = await supabase.from(entityType).delete().eq('id', id);
        // if (error) throw error;
        // return { isOffline: false };
        
        // For demo purposes, simulate success
        return { isOffline: false };
      } else {
        // If offline, save to be synced later
        await saveOfflineMutation('delete', entityType, { id });
        await loadPendingItems(); // Reload pending items
        return { isOffline: true };
      }
    } catch (error) {
      console.error('Error deleting item:', error);
      // If API call fails, save offline
      await saveOfflineMutation('delete', entityType, { id });
      await loadPendingItems(); // Reload pending items
      return { isOffline: true };
    }
  }, [entityType, loadPendingItems]);

  // Manually trigger sync
  const syncItems = useCallback(async (): Promise<boolean> => {
    if (isSyncing) return false;
    
    setIsSyncing(true);
    try {
      const success = await syncOfflineMutations();
      if (success) {
        await loadPendingItems(); // Reload pending items after successful sync
      }
      return success;
    } catch (error) {
      console.error('Error syncing items:', error);
      return false;
    } finally {
      setIsSyncing(false);
    }
  }, [isSyncing, loadPendingItems]);

  // Check if an item is pending sync
  const isItemPending = useCallback((id: string): boolean => {
    return pendingItems.some(item => item.id === id);
  }, [pendingItems]);

  return {
    isOnline,
    isSyncing,
    pendingItems,
    createItem,
    updateItem,
    deleteItem,
    syncItems,
    isItemPending,
  };
} 
  ```

- **hooks/useSkeleton.ts** (3.6 KB, 164 lines) Exports: `SkeletonOptions`, `useSkeleton`

  ```ts
import { useEffect } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withTiming,
  withSequence,
  withDelay,
  Easing,
} from 'react-native-reanimated';
import { durations, easings } from '@/constants/motion';

export interface SkeletonOptions {
  /**
   * Width of the gradient shimmer (as % of the component width)
   * @default 0.7
   */
  shimmerWidth?: number;
  /**
   * Base color of the skeleton component
   * @default '#E1E9EE'
   */
  baseColor?: string;
  /**
   * Highlight color for the shimmer effect
   * @default '#F2F8FC'
   */
  highlightColor?: string;
  /**
   * Duration for a complete shimmer cycle in ms
   * @default 2000
   */
  duration?: number;
  /**
   * Delay before starting animation in ms
   * @default 0
   */
  delay?: number;
  /**
   * Whether animation should start automatically
   * @default true
   */
  autoStart?: boolean;
  /**
   * Loading state to determine if skeletons should be shown
   * @default false
   */
  isLoading?: boolean;
  /**
   * Number of skeleton items to generate
   * @default 1
   */
  count?: number;
  /**
   * Type of skeleton to generate
   * @default 'card'
   */
  type?: 'card' | 'row' | 'circle';
}

/**
 * Hook to create skeleton loading animations with shimmer effect
 */
export function useSkeleton(options: SkeletonOptions = {}) {
  const {
    shimmerWidth = 0.7,
    baseColor = '#E1E9EE',
    highlightColor = '#F2F8FC',
    duration = durations.long * 2,
    delay = 0,
    autoStart = true,
  } = options;
  
  // Animation value to track shimmer position
  const translateX = useSharedValue(-1);
  
  // Start the animation
  useEffect(() => {
    if (autoStart) {
      translateX.value = withDelay(
        delay,
        withRepeat(
          withSequence(
            withTiming(-1, { duration: 0 }),
            withTiming(1, { 
              duration, 
              easing: easings.linear 
            }),
          ),
          -1, // Infinite repeat
        ),
      );
    }
  }, [translateX, duration, delay, autoStart]);
  
  // Generate the animated styles for the shimmer effect
  const shimmerStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateX: translateX.value * (1 + shimmerWidth) }],
    };
  });
  
  // Create styles for both container and shimmer
  const styles = StyleSheet.create({
    container: {
      backgroundColor: baseColor,
      overflow: 'hidden',
    },
    shimmer: {
      width: `${shimmerWidth * 100}%`,
      height: '100%',
      backgroundColor: highlightColor,
      position: 'absolute',
      top: 0,
      bottom: 0,
      opacity: 0.7,
    },
  });
  
  // Utility function to manually start the animation
  const startAnimation = () => {
    translateX.value = withDelay(
      delay,
      withRepeat(
        withSequence(
          withTiming(-1, { duration: 0 }),
          withTiming(1, { 
            duration, 
            easing: easings.linear 
          }),
        ),
        -1, // Infinite repeat
      ),
    );
  };
  
  // Utility function to stop the animation
  const stopAnimation = () => {
    translateX.value = withTiming(-1, { duration: 200 });
  };
  
  // Generate array of skeletons based on count and type
  const generateSkeletons = () => {
    if (!options.isLoading) return [];
    
    const count = options.count || 1;
    const type = options.type || 'card';
    
    return Array.from({ length: count }).map((_, index) => ({
      key: `skeleton-${index}`,
      type,
    }));
  };
  
  return {
    baseColor,
    shimmerStyle,
    styles,
    startAnimation,
    stopAnimation,
    skeletons: generateSkeletons(),
  };
} 
  ```

- **hooks/useThemeColor.ts** (0.5 KB, 22 lines) Exports: `useThemeColor`

  ```ts
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}

  ```

### modals

- **modals/compose.tsx** (3.1 KB, 101 lines) Exports: `default`

  ```tsx
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { Stack, useRouter } from 'expo-router';
import { Button } from '@/components/ui/iOS/Button';
import Animated, { 
  SlideInDown, 
  // SlideOutDown, // Not using exit animation with gesture
  useSharedValue, 
  useAnimatedStyle, 
  withTiming, 
  runOnJS 
} from 'react-native-reanimated';
import { Gesture, GestureDetector } from 'react-native-gesture-handler';

const { height: SCREEN_HEIGHT } = Dimensions.get('window');
const DISMISS_THRESHOLD = SCREEN_HEIGHT * 0.25; // Swipe 25% down to dismiss

export default function ComposeModal() {
  const router = useRouter();

  // Reanimated shared value for tracking vertical translation
  const translateY = useSharedValue(0);
  const context = useSharedValue({ y: 0 });

  // Gesture handler for swipe down
  const gesture = Gesture.Pan()
    .onStart(() => {
      context.value = { y: translateY.value };
    })
    .onUpdate((event) => {
      translateY.value = Math.max(0, context.value.y + event.translationY); // Only allow downward swipe
    })
    .onEnd(() => {
      if (translateY.value > DISMISS_THRESHOLD) {
        // Animate out and navigate back
        translateY.value = withTiming(SCREEN_HEIGHT, { duration: 200 }, () => {
          runOnJS(router.back)();
        });
      } else {
        // Snap back to original position
        translateY.value = withTiming(0, { duration: 150 });
      }
    });

  // Animated style for the view
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ translateY: translateY.value }],
    };
  });

  return (
    // Wrap with GestureDetector
    <GestureDetector gesture={gesture}>
      {/* Apply animated style and entrance animation */}
      <Animated.View 
        style={[styles.container, animatedStyle]}
        entering={SlideInDown.duration(300)} 
      >
        {/* Optional: Add a small drag handle indicator */}
        <View style={styles.handleIndicator} />

        {/* Use Stack.Screen to configure the modal title */}
        <Stack.Screen 
          options={{
            title: 'Compose New',
            // Ensure header interaction doesn't conflict with gesture
            // headerLeft: () => <Button title="Close" onPress={() => router.back()} />
          }} 
        />
        <Text style={{ fontSize: 20, marginBottom: 20 }}>Swipe Down to Dismiss</Text>
        <Button onPress={() => router.back()}>Close Modal</Button>
      </Animated.View>
    </GestureDetector>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1, 
    alignItems: 'center', 
    justifyContent: 'center',
    backgroundColor: 'white', // Modals usually have solid background
    borderTopLeftRadius: 10, // Apply radius only to top corners for modal sheet look
    borderTopRightRadius: 10,
    // Add shadow for depth if desired
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -3 },
    shadowOpacity: 0.1,
    shadowRadius: 5,
    elevation: 5, // For Android shadow
  },
  handleIndicator: {
    width: 40,
    height: 5,
    backgroundColor: '#ccc',
    borderRadius: 2.5,
    position: 'absolute',
    top: 10,
    alignSelf: 'center',
  }
}); 
  ```

### providers

- **providers/AppProvider.tsx** (2.7 KB, 93 lines) Exports: `AppProvider`

  ```tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { httpBatchLink } from '@trpc/client';
import { useEffect, useState, type ReactNode } from 'react';
import { Platform } from 'react-native';
import { TamaguiProvider } from 'tamagui';

import { NativeWindProvider } from '@/components/ui/nativewind-setup';
import config from '../tamagui.config';
import { trpc } from '@/utils/trpc';
import { useUiStore } from '@/stores/uiStore'; // Import store to get theme

/**
 * Complete app provider that integrates:
 * - tRPC
 * - React Query
 * - Tamagui
 * - NativeWind
 * - Additional providers can be added here
 */
export function AppProvider({ children }: { children: ReactNode }) {
  // Create Query Client
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 1000, // 5 seconds
        retry: Platform.OS === 'web' ? 3 : 1, // Less retries on mobile to save battery
      },
    },
  }));
  
  // Create tRPC client
  const [trpcClient] = useState(() => 
    trpc.createClient({
      links: [
        httpBatchLink({
          url: 'http://localhost:3000/api/trpc',
          fetch: (input, init) => {
            return fetch(input, {
              ...init,
              credentials: 'include',
            });
          },
        }),
      ],
    })
  );
  
  // Get theme state from Zustand
  const { isDarkMode } = useUiStore();
  const currentTheme = isDarkMode ? 'dark' : 'light';
  
  // You could add NATS initialization here
  useEffect(() => {
    // Example: Initialize NATS for real-time updates
    // Note: This is commented out since we don't have a real NATS server to connect to
    /*
    try {
      const url = 'ws://localhost:4222';
      initNatsClient(url, queryClient)
        .then(conn => {
          console.log('NATS client initialized successfully');
          // Set up subscriptions to relevant topics
          subscribeWithCache('users.updates', ['users']);
          subscribeWithCache('messages.updates', ['messages']);
        })
        .catch(err => {
          console.error('Failed to initialize NATS client:', err);
        });
    } catch (error) {
      console.error('Error in NATS setup:', error);
    }
    
    // Cleanup on unmount
    return () => {
      closeNatsConnection().catch(err => {
        console.error('Error closing NATS connection:', err);
      });
    };
    */
  }, [queryClient]);
  
  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        <NativeWindProvider theme={currentTheme}>
          <TamaguiProvider config={config}>
            {children}
          </TamaguiProvider>
        </NativeWindProvider>
      </QueryClientProvider>
    </trpc.Provider>
  );
} 
  ```

- **providers/ConfettiProvider.tsx** (4.9 KB, 181 lines) Exports: `ConfettiProvider`, `useConfetti`

  ```tsx
import { ReactNode, createContext, useCallback, useContext, useRef, useState } from 'react';
import { StyleSheet, Dimensions } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSequence,
  withDelay,
  runOnJS,
} from 'react-native-reanimated';
import { View } from 'tamagui';
import * as Haptics from 'expo-haptics';

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');
const CONFETTI_COUNT = 50; // Number of confetti pieces
const COLORS = ['#ff4747', '#ffae47', '#fff347', '#47ff70', '#47d0ff', '#9147ff', '#ff47f3'];

interface ConfettiContextValue {
  showConfetti: () => void;
}

const ConfettiContext = createContext<ConfettiContextValue>({
  showConfetti: () => {},
});

export const useConfetti = () => useContext(ConfettiContext);

// Create a single confetti piece component
function ConfettiPiece({ 
  size, 
  color, 
  initialX, 
  initialY, 
  duration, 
  delay 
}: { 
  size: number, 
  color: string, 
  initialX: number, 
  initialY: number, 
  duration: number, 
  delay: number 
}) {
  const translateX = useSharedValue(initialX);
  const translateY = useSharedValue(initialY);
  const rotate = useSharedValue(0);
  const opacity = useSharedValue(1);

  // Create animation when component mounts
  useState(() => {
    // Random horizontal movement
    const targetX = initialX + (Math.random() * 2 - 1) * SCREEN_WIDTH * 0.5;
    
    // Fall down animation
    translateY.value = withDelay(
      delay,
      withTiming(SCREEN_HEIGHT + 100, { duration })
    );
    
    // Horizontal movement with some randomness
    translateX.value = withDelay(
      delay,
      withSequence(
        withTiming(targetX, { duration: duration * 0.4 }),
        withTiming(targetX + (Math.random() * 2 - 1) * 100, { duration: duration * 0.6 })
      )
    );
    
    // Rotation animation
    rotate.value = withDelay(
      delay,
      withTiming(Math.random() * 1080, { duration })
    );
    
    // Fade out toward the end
    opacity.value = withDelay(
      delay + duration * 0.7,
      withTiming(0, { duration: duration * 0.3 })
    );
  });

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { rotate: `${rotate.value}deg` },
    ],
    opacity: opacity.value,
  }));

  return (
    <Animated.View
      style={[
        {
          position: 'absolute',
          width: size,
          height: size * (Math.random() * 0.8 + 0.2), // Varying heights
          backgroundColor: color,
          borderRadius: Math.random() > 0.5 ? size / 2 : 0, // Some round, some square
        },
        animatedStyle,
      ]}
    />
  );
}

export function ConfettiProvider({ children }: { children: ReactNode }) {
  const [isVisible, setIsVisible] = useState(false);
  const animationTimeout = useRef<NodeJS.Timeout | null>(null);
  
  // Generate confetti pieces data
  const generateConfettiData = useCallback(() => {
    const pieces = [];
    for (let i = 0; i < CONFETTI_COUNT; i++) {
      pieces.push({
        id: i,
        size: Math.random() * 8 + 4, // Size between 4-12
        color: COLORS[Math.floor(Math.random() * COLORS.length)],
        initialX: Math.random() * SCREEN_WIDTH,
        initialY: -20, // Start just above the screen
        duration: Math.random() * 1000 + 2000, // Duration between 2-3 seconds
        delay: Math.random() * 500, // Random delay up to 500ms
      });
    }
    return pieces;
  }, []);

  const [confettiPieces, setConfettiPieces] = useState(generateConfettiData());

  const showConfetti = useCallback(() => {
    // Trigger haptic feedback
    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    
    // Clear any existing timeout
    if (animationTimeout.current) {
      clearTimeout(animationTimeout.current);
    }
    
    // Generate new confetti data and show
    setConfettiPieces(generateConfettiData());
    setIsVisible(true);
    
    // Hide confetti after animation completes
    animationTimeout.current = setTimeout(() => {
      setIsVisible(false);
    }, 3500); // Slightly longer than the max animation time to ensure all pieces are gone
  }, [generateConfettiData]);

  return (
    <ConfettiContext.Provider value={{ showConfetti }}>
      {children}
      {isVisible && (
        <View style={styles.confettiContainer} pointerEvents="none">
          {confettiPieces.map((piece) => (
            <ConfettiPiece
              key={piece.id}
              size={piece.size}
              color={piece.color}
              initialX={piece.initialX}
              initialY={piece.initialY}
              duration={piece.duration}
              delay={piece.delay}
            />
          ))}
        </View>
      )}
    </ConfettiContext.Provider>
  );
}

const styles = StyleSheet.create({
  confettiContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 9999,
    pointerEvents: 'none',
  },
}); 
  ```

- **providers/SupabaseProvider.tsx** (0.4 KB, 14 lines) Exports: `SupabaseContext`, `SupabaseProvider`, `useSupabase`

  ```tsx
import React, { createContext, PropsWithChildren } from 'react';
import { supabase } from '@/utils/supabase';

export const SupabaseContext = createContext(supabase);
export const useSupabase = () => React.useContext(SupabaseContext);

export function SupabaseProvider({ children }: PropsWithChildren) {
  return (
    <SupabaseContext.Provider value={supabase}>
      {children}
    </SupabaseContext.Provider>
  );
}

  ```

- **providers/TRPCProvider.tsx** (1.1 KB, 39 lines) Exports: `trpc`, `TRPCProvider`

  ```tsx
import React, { PropsWithChildren } from 'react';
import { createTRPCReact } from '@trpc/react-query';
import type { AppRouter } from 'server/src/router';
import { httpBatchLink } from '@trpc/client';
import { QueryClientProvider } from '@tanstack/react-query';
import { queryClient } from '@/utils/query-client';

// 👉 one singleton instance – re-use across the app
export const trpc = createTRPCReact<AppRouter>();

export function TRPCProvider({ children }: PropsWithChildren) {
  const url =
    process.env.EXPO_PUBLIC_API_URL ??
    `${process.env.EXPO_PUBLIC_SUPABASE_URL}/functions/trpc`;

  const client = React.useMemo(
    () =>
      trpc.createClient({
        links: [
          httpBatchLink({
            url,
            headers() {
              return {
                // you can inject the supabase JWT here later:
              };
            },
          }),
        ],
      }),
    [url]
  );

  return (
    <trpc.Provider client={client} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </trpc.Provider>
  );
}

  ```

- **providers/index.ts** (0.1 KB, 4 lines) *(No explicit exports)*

  ```ts
// providers/index.ts
export * from './SupabaseProvider';
export * from './TRPCProvider';

  ```

### scripts

- **scripts/code_atlas.cjs** (16.7 KB, 213 lines) *(No explicit exports)*

  ```cjs
#!/usr/bin/env node
/**
 * scripts/code-atlas.cjs
 *
 * Generates a comprehensive “code atlas” into the `logs/` directory:
 * • Definitions Table (file ↔ exports + type)
 * • Route Definitions (app/ routes)
 * • Database Schema Summary (from types/database.types.ts)
 * • Dependency Graph (Mermaid, local files)
 * • External Dependencies List
 * • TODO/FIXME List
 * • Excluded Files List
 * • Type Check Results (tsc) << NEW - Requires tsc/tsconfig
 * • Linting Results (eslint) << NEW - Requires eslint/config
 * • Buckets (grouped files with size, LOC, test file link, and FULL FILE CONTENT)
 *
 * WARNING: This version includes the FULL content of all non-excluded files
 * AND runs tsc/eslint, making it potentially slow and the output file very large.
 * Ensure typescript, eslint, and their configs are set up correctly.
 *
 * Usage via Yarn:
 * yarn add -D globby micromatch @babel/parser @babel/traverse typescript eslint
 * // add to package.json scripts: "code-atlas": "node scripts/code-atlas.cjs"
 * yarn code-atlas
 */

// Added execSync for running external commands
const { execSync } = require('child_process');
const { statSync, readFileSync, writeFileSync, existsSync, mkdirSync } = require('fs');
const { dirname, extname, relative, basename, join, sep } = require('path');
const globby = require('globby');
const micromatch = require('micromatch');
const parser = require('@babel/parser');
const traverse = require('@babel/traverse').default;

// ─── CLI & CONFIG ────────────────────────────────────────────────────────────
const argv = process.argv.slice(2);
const QUICK = argv.includes('-q');
const timestamp = new Date().toISOString().replace(/[:T]/g,'-').split('.')[0];
const OUTPUT_DIR = 'logs';
const OUT = join(OUTPUT_DIR, `code-atlas_${timestamp}.md`);

const EXCLUDE = [ /* Previous exclusions remain the same */
  'node_modules/**', '**/.git/**', 'dist/**', 'build/**', 'coverage/**',
  '**/.expo/**', '**/.tamagui/**',
  '**/*.d.ts', '**/*.lock', '**/*.snap',
  '**/*.{png,jpg,jpeg,gif,ttf,otf,pdf,woff,woff2,ico,svg,eot}',
  '**/output/**', 'app-example/**', 'public/**',
  '*.log', 'patches/**', 'yarn.lock', 'package-lock.json',
  'babel.config.js', 'metro.config.js', 'postcss.config.js',
  'jest.config.*.js', 'jest.setup.js', 'jest.server.setup.js',
  '**/why.txt',
  'logs/**',
  'types/database.types.ts',
];
const CODE_EXT = new Set(['.ts','.tsx','.js','.jsx']); // Files to parse & lint
const TEST_SUFFIXES = ['.test', '.spec'];
const DB_TYPES_PATH = 'types/database.types.ts';
const APP_DIR_PREFIX = 'app' + sep;

// --- Helper functions (guessExportType, findTestFile, getBucketPath) ---
// (These helpers remain the same)
function guessExportType(name, node) { if (!node) return 'unknown'; if (node.declaration) { const d=node.declaration.type; if (d==='FunctionDeclaration') return 'function'; if (d==='ClassDeclaration') return 'class'; if (d==='VariableDeclaration') { if (/^use[A-Z]/.test(name)) return 'hook'; if (/^[A-Z]/.test(name)) return 'component'; return 'variable'; } if (d==='TSEnumDeclaration') return 'enum'; if (d==='TSInterfaceDeclaration') return 'interface'; if (d==='TSTypeAliasDeclaration') return 'type'; } if (node.type==='ExportDefaultDeclaration' && node.declaration) { const d=node.declaration.type; if (d==='FunctionDeclaration') return 'function'; if (d==='ClassDeclaration') return 'class'; if (d==='Identifier'||d==='CallExpression'){ if (/^use[A-Z]/.test(name)) return 'hook'; if (/^[A-Z]/.test(name)) return 'component'; }} if (/^use[A-Z]/.test(name)) return 'hook'; if (/^[A-Z]/.test(name)) return 'component'; return 'unknown'; }
function findTestFile(filePath) { const d=dirname(filePath); const e=extname(filePath); const b=basename(filePath,e); for (const s of TEST_SUFFIXES) { const p=join(d,`${b}${s}${e}`); if(existsSync(p)) return p; const sp=join(d,'__tests__',`${b}${s}${e}`); if(existsSync(sp)) return sp; } return null; }
function getBucketPath(filePath) { const p=dirname(filePath).split(sep); if(p.length===1&&p[0]==='.') return '.'; if(p.length<=2) return p.join(sep); return p.slice(0,2).join(sep); }

// ─── COLLECT FILES ───────────────────────────────────────────────────────────
let allFoundFiles = [];
const inGit = (() => { try { execSync('git rev-parse --is-inside-work-tree',{stdio:'ignore'}); return true; } catch { return false; } })();
// (File collection logic remains the same)
if (inGit) { if (QUICK) { const b = execSync('git merge-base HEAD origin/main',{encoding:'utf8'}).trim(); allFoundFiles = execSync(`git diff --name-only ${b}..HEAD`,{encoding:'utf8'}).split('\n').filter(Boolean); } else { allFoundFiles = execSync('git ls-files',{encoding:'utf8'}).split('\n').filter(Boolean); } if (!QUICK) { allFoundFiles.push(...execSync('git ls-files --others --exclude-standard',{encoding:'utf8'}).split('\n').filter(Boolean)); } } else { allFoundFiles = globby.sync(['**/*'], { gitignore: true }); }

const initialFileCount = allFoundFiles.length;
const excludedFiles = [];
const includedFiles = []; // Files for analysis and potential linting/type-checking

allFoundFiles.forEach(f => { if (EXCLUDE.some((pat) => micromatch.isMatch(f, pat))) { excludedFiles.push(f); } else { includedFiles.push(f); } });
includedFiles.sort(); excludedFiles.sort();
console.log(`Found ${initialFileCount} files. Including ${includedFiles.length}, Excluding ${excludedFiles.length}.`);


// ─── PARSE & ANALYZE (Only included files) ──────────────────────────────────
console.log(`Analyzing ${includedFiles.length} files...`);
const routes = [];
const codeFilesForLinting = []; // Collect code file paths for eslint
const atlas = includedFiles.map((file) => {
  const bucket = getBucketPath(file);
  const entry = { file, bucket, size: 0, loc: 0, exports: [], imports: { local: new Set(), external: new Set() }, todos: [], testFile: findTestFile(file), fullContent: null };
  try { entry.size = statSync(file).size; } catch {}
  let isRoute = file.startsWith(APP_DIR_PREFIX) && /\.(tsx|jsx)$/.test(file) && !basename(file).startsWith('_');
  let routeType = 'screen';
  const isCodeFile = CODE_EXT.has(extname(file)); // Check if it's a code file we care about parsing/linting
  let src = ''; try { src = readFileSync(file, 'utf8'); entry.loc = src.split('\n').length; entry.fullContent = src; } catch (e) { console.warn(`Warning: Could not read file ${file}: ${e.message}`); return entry; }

  if (!isCodeFile) return entry; // Skip AST parsing and linting for non-code files

  codeFilesForLinting.push(file); // Add to list for eslint

  const lines = src.split('\n'); lines.forEach((line, index) => { const m = line.match(/.*\/\/\s*(TODO|FIXME):?\s*(.*)/i); if (m) entry.todos.push({ line: index + 1, text: m[2].trim() }); });
  let ast; try { ast = parser.parse(src, { sourceType: 'module', plugins: ['typescript','jsx','decorators-legacy', 'classProperties', 'objectRestSpread'], errorRecovery: true, attachComment: true }); } catch (e) { console.warn(`Warning: Could not parse file ${file}: ${e.message}. Exports/Imports may be incomplete.`); return entry; } // Log parse error but continue
  try { let hLE=false, hSE=false; traverse(ast, { ImportDeclaration(p) { const s=p.node.source?.value; if(s){ if(s.startsWith('.'))entry.imports.local.add(s); else entry.imports.external.add(s);}}, ExportNamedDeclaration(p) { const{node}=p; if(node.declaration){ if(node.declaration.id){ const n=node.declaration.id.name; entry.exports.push({name:n, type:guessExportType(n,node)}); }else if(node.declaration.declarations){ node.declaration.declarations.forEach((d)=>{ if(d.id.type==='Identifier'){ const n=d.id.name; entry.exports.push({name:n, type:guessExportType(n,node.declaration)}); }}); }} (node.specifiers||[]).forEach((s)=>{ if(s.exported.type==='Identifier'){ const n=s.exported.name; entry.exports.push({name: n, type:'re-export'}); }}); }, ExportDefaultDeclaration(p) { entry.exports.push({name:'default', type:guessExportType('default',p.node)}); if(basename(file)==='_layout.tsx') hLE=true; }, JSXOpeningElement(p) { if(p.node.name.type==='JSXMemberExpression'&&p.node.name.object.type==='JSXIdentifier'){ const o=p.node.name.object.name; const pr=p.node.name.property.name; if((o==='Stack'||o==='Tabs')&&pr==='Screen') hSE=true; }} }); if(isRoute){ if(hLE) routeType='layout'; else if(hSE) routeType='layout (implicit)'; routes.push({path:file, type:routeType}); } } catch (e) { console.warn(`Warning: Error traversing AST for ${file}: ${e.message}`); }
  entry.exports.sort((a, b) => a.name.localeCompare(b.name)); return entry;
});

// --- Normalize import paths ---
// (Normalization logic remains the same)
const fileMap = new Map(includedFiles.map(f => [f, true])); const normalizedAtlas = atlas.map(entry => ({ ...entry, imports: { ...entry.imports, local: new Set([...entry.imports.local].map(imp => { try { const t=relative('.',join(dirname(entry.file),imp)); const exts=['','.ts','.tsx','.js','.jsx','/index.ts','/index.tsx','/index.js','/index.jsx']; let f=null; for(const e of exts){ const p=t+e; if(fileMap.has(p)){f=p;break;}} return f; } catch { return null; }}).filter(Boolean)) } }));

// --- Parse Database Types ---
// (DB Type parsing logic remains the same)
let dbSchema = { tables: {}, enums: {} }; try { const c=readFileSync(DB_TYPES_PATH,'utf8'); const tr = /([\w_]+):\s*{\s*Row:\s*({[\s\S]*?})/g; let tm; while((tm=tr.exec(c))!==null){ const tN=tm[1]; const rC=tm[2]; const cols=[]; const cr = /([\w_]+):\s*([\w\[\] \|\?&:;'"{}]+)/g; let cm; while((cm=cr.exec(rC))!==null){ cols.push({ name: cm[1], type: cm[2].trim() }); } dbSchema.tables[tN] = cols; } const eb = c.match(/Enums:\s*{([\s\S]*?)}/); if(eb){ const er = /([\w_]+):\s*([\s\S]*?)"/g; let em; while((em=er.exec(eb[1]))!==null){ const eN=em[1]; const vals=[...em[2].matchAll(/"([^"]+)"/g)].map(m=>m[1]); dbSchema.enums[eN]=vals; } } } catch (e) { console.warn(`Warning: Could not read or parse ${DB_TYPES_PATH}: ${e.message}`); }

// --- Run External Checks ---
console.log("Running type checks (tsc)...");
let tscOutput = '';
try {
    // Use --pretty false for potentially cleaner output, capture stderr too
    tscOutput = execSync('npx tsc --noEmit --pretty false', { encoding: 'utf8', stdio: 'pipe' });
    console.log("Type check completed successfully.");
} catch (e) {
    console.warn("Type check failed or returned errors.");
    // e.stdout and e.stderr contain the output even on error for execSync
    tscOutput = `Error running tsc: ${e.message}\n\nSTDOUT:\n${e.stdout}\n\nSTDERR:\n${e.stderr}`;
}

console.log("Running linter (eslint)...");
let eslintOutput = '';
if (codeFilesForLinting.length > 0) {
    try {
        // Pass specific files to eslint; escape spaces/special chars if necessary (simple case here)
        const filesArg = codeFilesForLinting.join(' ');
        eslintOutput = execSync(`npx eslint ${filesArg}`, { encoding: 'utf8', stdio: 'pipe' });
        console.log("Linting completed successfully.");
    } catch (e) {
        console.warn("Linting failed or returned errors.");
        eslintOutput = `Error running eslint: ${e.message}\n\nSTDOUT:\n${e.stdout}\n\nSTDERR:\n${e.stderr}`;
    }
} else {
     eslintOutput = "No code files found to lint.";
}


// ─── EMIT MARKDOWN ────────────────────────────────────────────────────────────
console.log(`Generating Markdown output to ${OUT}...`);
try { mkdirSync(OUTPUT_DIR, { recursive: true }); } catch (e) { console.error(`Error creating output directory ${OUTPUT_DIR}:`, e); process.exit(1); }

let md = `# Aether Code Atlas  \n_generated ${timestamp}_\n\n`;
md += '## Contents\n';
// Added sections to TOC
['Definitions Table', 'Route Definitions', 'Database Schema Summary', 'Dependency Graph', 'External Dependencies', 'TODOs / FIXMEs', 'Excluded Files', 'Type Check Results (tsc)', 'Linting Results (eslint)', 'Buckets'].forEach((t) => { md += `- [${t}](#${t.toLowerCase().replace(/\s+/g,'-')})\n`; });

// Definitions Table
md += '\n## Definitions Table\n| File | Export Name | Type |\n|---|---|---|\n';
normalizedAtlas.forEach(({ file, exports: ex }) => { if (ex.length > 0) ex.forEach(exp => { md += `| ${file} | \`${exp.name}\` | ${exp.type} |\n`; }); });

// Route Definitions
md += '\n## Route Definitions\n| Route File | Type |\n|---|---|\n'; routes.sort((a,b)=>a.path.localeCompare(b.path)).forEach(r => { md += `| ${r.path} | ${r.type} |\n`; }); if (routes.length === 0) md += '| *(No routes found)* | |\n';

// Database Schema Summary
md += '\n## Database Schema Summary\n'; md += `\n_Extracted from: ${DB_TYPES_PATH}_\n`; const tableNames = Object.keys(dbSchema.tables).sort(); const enumNames = Object.keys(dbSchema.enums).sort(); if (tableNames.length > 0) { md += '\n### Tables\n'; tableNames.forEach(tN => { md += `\n**\`${tN}\`**\n\n| Column | Type |\n|---|---|\n`; dbSchema.tables[tN].forEach(col => { md += `| \`${col.name}\` | \`${col.type.replace(/\|/g,'\\|')}\` |\n`; }); }); } else { md += '\n_No tables extracted._\n'; } if (enumNames.length > 0) { md += '\n### Enums\n'; enumNames.forEach(eN => { md += `\n**\`${eN}\`**: ${dbSchema.enums[eN].length > 0 ? `\`${dbSchema.enums[eN].join('` \\| `')}\`` : '*(No values extracted)*'}\n`; }); } else { md += '\n_No enums extracted._\n'; }

// Dependency Graph
md += '\n## Dependency Graph\n*Note: This graph shows dependencies between local files only.*\n```mermaid\ngraph TD;\n'; let dependencyCount = 0; normalizedAtlas.forEach(({ file, imports }) => { const idA = file.replace(/[^a-zA-Z0-9_]/g,'_'); imports.local.forEach((imp) => { const idB = imp.replace(/[^a-zA-Z0-9_]/g,'_'); md += `  ${idA}["${file}"] --> ${idB}["${imp}"];\n`; dependencyCount++; }); }); md += '```\n';

// External Dependencies
md += '\n## External Dependencies\n'; const externalDeps = new Set(); normalizedAtlas.forEach(({ imports }) => { imports.external.forEach(dep => externalDeps.add(dep)); }); if (externalDeps.size > 0) { [...externalDeps].sort().forEach(dep => md += `- \`${dep}\`\n`); } else { md += '_None detected._\n'; }

// TODOs / FIXMEs
md += '\n## TODOs / FIXMEs\n'; let todoCount = 0; normalizedAtlas.forEach(({ file, todos }) => { if (todos.length > 0) { md += `\n**${file}**\n`; todos.forEach(todo => { md += `- (L${todo.line}) ${todo.text}\n`; todoCount++; }); } }); if (todoCount === 0) { md += '_None found._\n'; }

// Excluded Files
md += '\n## Excluded Files\n'; if (excludedFiles.length > 0) { md += `\n_${excludedFiles.length} files were excluded based on the patterns in the script._\n\n`; excludedFiles.forEach(file => { md += `- ${file}\n`; }); } else { md += '_No files were excluded by the exclusion patterns._\n'; }

// Type Check Results << NEW SECTION >>
md += '\n## Type Check Results (tsc)\n';
md += '\n```log\n';
md += tscOutput.trim() || 'tsc produced no output.';
md += '\n```\n';

// Linting Results << NEW SECTION >>
md += '\n## Linting Results (eslint)\n';
md += '\n```log\n';
md += eslintOutput.trim() || 'eslint produced no output or was not run.';
md += '\n```\n';

// Buckets (With Full File Content)
md += '\n## Buckets\n';
const byBucket = normalizedAtlas.reduce((acc, cur) => { (acc[cur.bucket] ||= []).push(cur); return acc; }, {});
const sortedBuckets = Object.keys(byBucket).sort((a, b) => { if (a === '.') return -1; if (b === '.') return 1; return a.localeCompare(b); });

sortedBuckets.forEach((bucket) => { const arr = byBucket[bucket]; md += `\n### ${bucket}\n`;
    arr.forEach(({ file, exports: ex, size, loc, testFile, todos, fullContent }) => {
        const sizeKB = (size / 1024).toFixed(1);
        const testFileRelative = testFile ? relative(OUTPUT_DIR, testFile) : null;
        const testFileLink = testFileRelative ? ` [[Test](${testFileRelative})]` : '';
        const todoMarker = todos.length > 0 ? ` (${todos.length} TODOs)`: '';
        const exportSummary = ex.length > 0 ? ` Exports: ${ex.map(e => `\`${e.name}\``).join(', ')}` : ' *(No explicit exports)*';
        md += `\n- **${file}** (${sizeKB} KB, ${loc} lines)${testFileLink}${todoMarker}${exportSummary}\n`;

        if (fullContent !== null) {
            const ext = extname(file).substring(1) || 'text';
            md += `\n  \`\`\`${ext}\n`;
            md += `${fullContent}\n`;
            md += `  \`\`\`\n`;
        } else {
             md += `  *(Content not read or file is binary/excluded)*\n`;
        }
    });
});

writeFileSync(OUT, md);
console.log(`✅ ${OUT} generated (${includedFiles.length} files analyzed, ${excludedFiles.length} excluded, ${dependencyCount} local dependencies mapped, ${todoCount} TODOs found).`);
console.warn("️⚠️ WARNING: Output file includes full file content AND tsc/eslint results, and may be very large.");
  ```

- **scripts/generate-all.js** (1.1 KB, 32 lines) *(No explicit exports)*

  ```js
const { execSync } = require('child_process');
const path = require('path');

/**
 * This script runs all code generation scripts in the correct order.
 * It ensures that:
 * 1. TRPC types are generated first (shared zod schemas)
 * 2. React Query hooks are generated from the TRPC router
 */
console.log('🚀 Running all code generators...');

try {
  console.log('\n📝 Generating TRPC shared types...');
  execSync('node ./scripts/generate-trpc-types.js', { stdio: 'inherit' });
  
  console.log('\n📝 Generating TRPC client hooks...');
  execSync('node ./scripts/generate-trpc-client.js', { stdio: 'inherit' });

  console.log('\n✅ All code generation complete!');
  console.log('\n🔍 Checking for TypeScript errors...');
  
  try {
    execSync('npx tsc --noEmit', { stdio: 'inherit' });
    console.log('✅ TypeScript validation successful!');
  } catch (error) {
    console.log('⚠️ TypeScript validation found some errors. Please fix them before continuing.');
  }

} catch (error) {
  console.error('\n❌ Generation failed:', error.message);
  process.exit(1);
} 
  ```

- **scripts/generate-trpc-client.js** (2.1 KB, 77 lines) *(No explicit exports)*

  ```js
const fs = require('fs');
const path = require('path');

/**
 * This script generates a TRPC client file with typed hooks for each procedure
 * in the AppRouter. This provides full type safety for the client code.
 */

// Configuration
const outputPath = path.join(__dirname, '../utils/generated-hooks.ts');
const routerPath = path.resolve(__dirname, '../server/src/router.ts');

const generateTRPCClient = () => {
  // First, let's read the router file to understand its structure
  const routerContent = fs.readFileSync(routerPath, 'utf-8');
  
  // Extract all the router imports
  const routerImportRegex = /import\s+{\s*(.*?)Router\s*}\s*from\s*['"](.+?)['"];/g;
  const routerImports = [];
  let match;
  
  while ((match = routerImportRegex.exec(routerContent)) !== null) {
    routerImports.push({
      name: match[1],
      path: match[2]
    });
  }
  
  // Extract the router registrations from appRouter
  const routerRegistrationRegex = /(\w+)\s*:\s*(\w+)Router,/g;
  const routerRegistrations = [];
  
  while ((match = routerRegistrationRegex.exec(routerContent)) !== null) {
    routerRegistrations.push({
      key: match[1],
      name: match[2]
    });
  }
  
  // Generate the type-safe hooks file
  const hookFileContent = `/**
 * GENERATED FILE - DO NOT EDIT
 * This file is automatically generated by the generate-trpc-client script.
 * To update this file, run: npm run generate-hooks
 */

import { trpc } from './trpc';
import { RouterInputs, RouterOutputs } from '../server/src/types/trpc-types';

/**
 * Type-safe hooks for TRPC procedures
 */

${routerRegistrations.map(router => {
  return `// ${router.key} hooks
export const use${capitalizeFirstLetter(router.key)} = {
  // Add strongly typed hooks here
};
`;
}).join('\n')}

// Example type usage
type GreetingOutput = RouterOutputs['greeting']['hello'];
`;

  // Write the generated file
  fs.writeFileSync(outputPath, hookFileContent);
  console.log(`✅ Generated TRPC client hooks at ${outputPath}`);
};

// Helper function to capitalize the first letter
function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

// Run the generator
generateTRPCClient(); 
  ```

- **scripts/generate-trpc-types.js** (1.1 KB, 43 lines) *(No explicit exports)*

  ```js
const fs = require('fs');
const path = require('path');

// Path to the generated types output file
const outputPath = path.join(__dirname, '../app/utils/api-types.ts');

const generateTypes = () => {
  // Define the content of the types file
  const typesContent = `/**
 * This file was auto-generated by the generate-trpc-types script.
 * Do not edit manually! Instead, run the script again.
 */

import type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from '../../server/src/router';

/**
 * Inference helper for inputs.
 *
 * @example type HelloInput = RouterInputs['example']['hello']
 */
export type RouterInputs = inferRouterInputs<AppRouter>;

/**
 * Inference helper for outputs.
 *
 * @example type HelloOutput = RouterOutputs['example']['hello']
 */
export type RouterOutputs = inferRouterOutputs<AppRouter>;
`;

  // Ensure directory exists
  const dir = path.dirname(outputPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  // Write the file
  fs.writeFileSync(outputPath, typesContent);
  console.log(`✅ Types generated at ${outputPath}`);
};

generateTypes(); 
  ```

- **scripts/generate_app_code_overview.sh** (2.3 KB, 80 lines) *(No explicit exports)*

  ```sh
#!/bin/bash

# Create output directory if it doesn't exist
mkdir -p output

OUTPUT_FILE="output/app_code_overview.txt"

# Clear output file if it exists
echo "# Aether App Code Overview" > $OUTPUT_FILE
echo "Generated on $(date)" >> $OUTPUT_FILE
echo "" >> $OUTPUT_FILE

# Function to add file content to the output file
add_file() {
  local file=$1
  echo "## File: $file" >> $OUTPUT_FILE
  echo '```' >> $OUTPUT_FILE
  cat "$file" >> $OUTPUT_FILE
  echo '```' >> $OUTPUT_FILE
  echo "" >> $OUTPUT_FILE
}

# Find all relevant files
# Exclude:
# - node_modules
# - .git
# - .expo
# - .tamagui (generated code)
# - Large files like package-lock.json
# - Binary files
# Include important code files with extensions:
# - .tsx, .ts, .js, .jsx
# - .json (except package-lock.json)
# - .md for documentation

echo "Finding and processing relevant files..."

find . -type f \
  -not -path "*/node_modules/*" \
  -not -path "*/.git/*" \
  -not -path "*/.expo/*" \
  -not -path "*/.tamagui/*" \
  -not -name "package-lock.json" \
  -not -path "*/output/*" \
  \( -name "*.tsx" -o -name "*.ts" -o -name "*.js" -o -name "*.jsx" -o -name "*.md" \) | sort | while read -r file; do
  
  # Check if file size is less than 500KB (to avoid very large files)
  file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
  if [ "$file_size" -lt 500000 ]; then
    echo "Processing: $file"
    add_file "$file"
  else
    echo "Skipping large file: $file"
    echo "## File: $file (skipped - too large, size: $file_size bytes)" >> $OUTPUT_FILE
    echo "" >> $OUTPUT_FILE
  fi
done

# Add select JSON files (excluding package-lock.json which is already excluded above)
find . -type f -name "*.json" \
  -not -path "*/node_modules/*" \
  -not -path "*/.git/*" \
  -not -path "*/.expo/*" \
  -not -path "*/.tamagui/*" \
  -not -name "package-lock.json" \
  -not -path "*/output/*" | sort | while read -r file; do
  
  file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
  if [ "$file_size" -lt 100000 ]; then
    echo "Processing: $file"
    add_file "$file"
  else
    echo "Skipping large file: $file"
    echo "## File: $file (skipped - too large, size: $file_size bytes)" >> $OUTPUT_FILE
    echo "" >> $OUTPUT_FILE
  fi
done

echo "Code overview generated at $OUTPUT_FILE"
echo "Total size: $(stat -f%z "$OUTPUT_FILE" 2>/dev/null || stat -c%s "$OUTPUT_FILE" 2>/dev/null) bytes" 
  ```

- **scripts/reset-project.js** (3.5 KB, 113 lines) *(No explicit exports)*

  ```js
#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It deletes or moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example based on user input and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require("fs");
const path = require("path");
const readline = require("readline");

const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const exampleDir = "app-example";
const newAppDir = "app";
const exampleDirPath = path.join(root, exampleDir);

const indexContent = `import { Text, View } from "react-native";

export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}
`;

const layoutContent = `import { Stack } from "expo-router";

export default function RootLayout() {
  return <Stack />;
}
`;

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const moveDirectories = async (userInput) => {
  try {
    if (userInput === "y") {
      // Create the app-example directory
      await fs.promises.mkdir(exampleDirPath, { recursive: true });
      console.log(`📁 /${exampleDir} directory created.`);
    }

    // Move old directories to new app-example directory or delete them
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      if (fs.existsSync(oldDirPath)) {
        if (userInput === "y") {
          const newDirPath = path.join(root, exampleDir, dir);
          await fs.promises.rename(oldDirPath, newDirPath);
          console.log(`➡️ /${dir} moved to /${exampleDir}/${dir}.`);
        } else {
          await fs.promises.rm(oldDirPath, { recursive: true, force: true });
          console.log(`❌ /${dir} deleted.`);
        }
      } else {
        console.log(`➡️ /${dir} does not exist, skipping.`);
      }
    }

    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log("\n📁 New /app directory created.");

    // Create index.tsx
    const indexPath = path.join(newAppDirPath, "index.tsx");
    await fs.promises.writeFile(indexPath, indexContent);
    console.log("📄 app/index.tsx created.");

    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, "_layout.tsx");
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log("📄 app/_layout.tsx created.");

    console.log("\n✅ Project reset complete. Next steps:");
    console.log(
      `1. Run \`npx expo start\` to start a development server.\n2. Edit app/index.tsx to edit the main screen.${
        userInput === "y"
          ? `\n3. Delete the /${exampleDir} directory when you're done referencing it.`
          : ""
      }`
    );
  } catch (error) {
    console.error(`❌ Error during script execution: ${error.message}`);
  }
};

rl.question(
  "Do you want to move existing files to /app-example instead of deleting them? (Y/n): ",
  (answer) => {
    const userInput = answer.trim().toLowerCase() || "y";
    if (userInput === "y" || userInput === "n") {
      moveDirectories(userInput).finally(() => rl.close());
    } else {
      console.log("❌ Invalid input. Please enter 'Y' or 'N'.");
      rl.close();
    }
  }
);

  ```

### server

- **server/.env** (0.4 KB, 4 lines) *(No explicit exports)*

  ```text
EXPO_PUBLIC_SUPABASE_URL=https://fjzzeprbdjwpxnhnltqm.supabase.co
EXPO_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZqenplcHJiZGp3cHhuaG5sdHFtIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQ5NjU1ODEsImV4cCI6MjA2MDU0MTU4MX0.iXWsMcw72PV6dtzDnna9LuPFF1MPYvlmFcasx0Qlo34
SUPABASE_URL=https://fjzzeprbdjwpxnhnltqm.supabase.co
SUPABASE_SERVICE_ROLE_KEY=<your-service-role-key-from-supabase-settings>
  ```

- **server/package.json** (0.7 KB, 28 lines) *(No explicit exports)*

  ```json
{
  "name": "aether-server",
  "version": "1.0.0",
  "description": "Backend server for Aether app",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "dependencies": {
    "@supabase/supabase-js": "^2.49.4",
    "cors": "^2.8.5",
    "date-fns": "^4.1.0",
    "express": "^4.18.2",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/node": "^20.11.20",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.3.3"
  }
}

  ```

- **server/tsconfig.json** (0.5 KB, 19 lines) *(No explicit exports)*

  ```json
{
  "compilerOptions": {
    "target": "es2019",
    "module": "commonjs",
    "lib": ["es2019", "esnext.asynciterable"],
    "outDir": "./dist",
    "rootDir": "../",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "sourceMap": true,
    "declaration": true
  },
  "include": ["src/**/*", "types/**/*"],
  "exclude": ["node_modules", "dist"]
}
  ```

### server/src

- **server/src/context.ts** (1.8 KB, 61 lines) Exports: `Context`, `createContext`, `supabaseAdmin`

  ```ts
import { createClient } from '@supabase/supabase-js';
import { TRPCError } from '@trpc/server';
import dotenv from 'dotenv';

// Load environment variables from ./server/.env
dotenv.config();

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

// Add checks to ensure variables are loaded
if (!supabaseUrl) {
    console.log('Attempting Supabase init. URL found: No'); // Keep log here
    throw new Error('Missing environment variable: SUPABASE_URL in server/.env');
}
if (!supabaseServiceKey) {
    throw new Error('Missing environment variable: SUPABASE_SERVICE_ROLE_KEY in server/.env');
}

console.log('Attempting Supabase init. URL found: Yes'); // Log success

// Initialize Supabase Admin client
export const supabaseAdmin = createClient(
  supabaseUrl,
  supabaseServiceKey,
  {
    auth: {
        autoRefreshToken: false,
        persistSession: false
    }
  }
);

// Context passed to all tRPC resolvers
export interface Context {
  supabaseAdmin: typeof supabaseAdmin;
  userId: string;
}

// Build context from incoming request
export async function createContext({ req }: { req: any }): Promise<Context> {
  const authHeader = req.headers.authorization;
  if (!authHeader) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: 'Missing Authorization header' });
  }
  const token = authHeader.split(' ')[1];
  if (!token) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: 'Invalid Authorization header' });
  }

  // Validate JWT and get user
  const { data, error } = await supabaseAdmin.auth.getUser(token);
  if (error || !data.user) {
    throw new TRPCError({ code: 'UNAUTHORIZED', message: error?.message || 'Invalid token' });
  }

  return {
    supabaseAdmin,
    userId: data.user.id,
  };
} 
  ```

- **server/src/index.ts** (0.9 KB, 31 lines) *(No explicit exports)*

  ```ts
import express, { Request, Response } from 'express';
import cors from 'cors';
import { createExpressMiddleware } from '@trpc/server/adapters/express';
import { appRouter } from './router';
import { createContext } from './context';

const app = express();
const port = process.env.PORT || 3000;

// Enable CORS for client app
app.use(cors({
  origin: ['http://localhost:8081', 'http://localhost:19000', 'http://localhost:19006', 'exp://localhost:19000'],
  credentials: true,
}));

// Health check endpoint
app.get('/health', (_: Request, res: Response) => {
  res.status(200).json({ status: 'ok', timestamp: new Date().toISOString() });
});

// Create tRPC middleware
app.use('/api/trpc', createExpressMiddleware({
  router: appRouter,
  createContext,
}));

// Start server
app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
  console.log(`tRPC API available at http://localhost:${port}/api/trpc`);
}); 
  ```

- **server/src/router.ts** (2.0 KB, 61 lines) Exports: `appRouter`, `AppRouter`, `protectedProcedure`, `publicProcedure`, `router`

  ```ts
import { initTRPC } from '@trpc/server';
import { z } from 'zod';
import { TRPCError } from '@trpc/server';
import { supabaseAdmin, Context } from './context';

// Initialize tRPC with Supabase context
const t = initTRPC.context<Context>().create();

// Public procedure (no auth required)
export const router = t.router;
export const publicProcedure = t.procedure;

// Protected procedures ensure user is authenticated
export const protectedProcedure = t.procedure.use(({ ctx, next }) => {
  if (!ctx.userId) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }
  return next({ ctx: { supabaseAdmin: ctx.supabaseAdmin, userId: ctx.userId } });
});

// Import individual routers
import { dashboardRouter } from './routers/dashboardRouter';
import { valueRouter } from './routers/valueRouter';
import { principleRouter } from './routers/principleRouter';
import { goalRouter } from './routers/goalRouter';
import { taskRouter } from './routers/taskRouter';
import { habitRouter } from './routers/habitRouter';
import { trackedStateRouter } from './routers/trackedStateRouter';
import { userRouter } from './routers/userRouter';
import { rewardsRouter } from './routers/rewardsRouter';
import { reminderRouter } from './routers/reminderRouter';
import { goalProgressNoteRouter } from './routers/goalProgressNoteRouter';

// Create the router with Supabase-backed procedures
export const appRouter = router({
  greeting: {
    hello: publicProcedure
      .input(z.object({ name: z.string().optional() }))
      .query(async ({ input }) => {
        return { greeting: `Hello ${input.name ?? 'world'}` };
      }),
    goodbye: publicProcedure
      .query(() => {
        return { greeting: 'Goodbye!' };
      }),
  },
  user: userRouter,
  dashboard: dashboardRouter,
  value: valueRouter,
  principle: principleRouter,
  goal: goalRouter,
  task: taskRouter,
  habit: habitRouter,
  state: trackedStateRouter,
  rewards: rewardsRouter,
  reminder: reminderRouter,
  goalProgressNote: goalProgressNoteRouter,
});

// Export type router type
export type AppRouter = typeof appRouter; 
  ```

- **server/src/routers/dashboardRouter.ts** (20.9 KB, 492 lines) (1 TODOs) Exports: `dashboardRouter`

  ```ts
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';

// Define fields for consistent selection - align with Zod schemas & table structure
const HABIT_FIELDS = 'id, user_id, name, description, habit_type, goal_quantity, goal_units, frequency_type, frequency_details, reminder_id, streak, best_streak, sort_order, created_at, updated_at'; // Added reminder_id
const GOAL_FIELDS = 'id, user_id, name, description, priority, status, target_date, sort_order, created_at, updated_at'; // Use target_date
const TASK_FIELDS = 'id, user_id, name, notes, status, priority, due_date, reminder_id, goal_id, sort_order, created_at, updated_at'; // Use due_date, reminder_id
const HABIT_ENTRY_FIELDS = 'id, habit_id, user_id, date, quantity_value, notes, created_at';
const TRACKED_STATE_DEF_FIELDS = 'id, user_id, name, description, data_type, unit, sort_order, active, notes, created_at, updated_at'; // Adjusted based on potential schema changes

export const dashboardRouter = router({
  getDashboardData: protectedProcedure
    .input(
      z.object({
        habitLimit: z.number().min(1).default(5),
        goalLimit: z.number().min(1).default(5),
        taskLimit: z.number().min(1).default(10)
      }).optional()
    )
    .query(async ({ ctx, input }) => {
      try {
        // Get limits from input or use defaults
        const habitLimit = input?.habitLimit || 5;
        const goalLimit = input?.goalLimit || 5;
        const taskLimit = input?.taskLimit || 10;

        // --- Fetch Habits ---
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
          .limit(habitLimit);
        if (habitsError) throw habitsError;

        // --- Fetch Goals ---
        const { data: goals, error: goalsError } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .order('sort_order', { ascending: true, nullsFirst: false }) // Correct: nullsFirst: false for nulls last
          .limit(goalLimit);
        if (goalsError) throw goalsError;

        // --- Fetch Upcoming Tasks (focus on upcoming tasks and prioritize those due soon) ---
        const today = new Date();
        const twoWeeksFromNow = new Date();
        twoWeeksFromNow.setDate(today.getDate() + 14);
        
        // We want to fetch tasks that are:
        // 1. Not completed
        // 2. Due within the next two weeks, or overdue
        // 3. Either unassigned or associated with the dashboard goals
        const { data: tasks, error: tasksError } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .is('archived_at', null) // Filter out archived
          .neq('status', 'completed') // Use correct enum value
          .or(`due_date.lte.${twoWeeksFromNow.toISOString()},due_date.is.null`)
          .order('due_date', { ascending: true, nullsFirst: false }) // Use 'due_date'
          .limit(taskLimit);
        if (tasksError) throw tasksError;

        // --- Fetch Active Tracked State Definitions ---
        const { data: trackedStateDefinitions, error: statesError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS) // Use constant
          .eq('user_id', ctx.userId)
          .eq('active', true)
          .order('sort_order', { ascending: true, nullsFirst: false }); // Correct: nullsFirst: false for nulls last
        if (statesError) throw statesError;
        
        // --- Fetch Latest State Entries for Active Definitions ---
        let latestEntriesMap: Record<string, { value: any; created_at: string }> = {};
        const stateDefIds = (trackedStateDefinitions || []).map(s => s.id);

        if (stateDefIds.length > 0) {
          // Use a CTE and ROW_NUMBER() to get the latest entry per state_id
          const { data: latestEntries, error: entriesError } = await ctx.supabaseAdmin.rpc(
            'get_latest_state_entries_for_user', 
            { p_user_id: ctx.userId, p_state_ids: stateDefIds }
          );

          if (entriesError) {
            console.error('Error fetching latest state entries:', entriesError);
            // Decide how to handle this - throw, or continue with empty/default values?
            // For now, log and continue, states will show default value
          } else {
            // Define expected type for entries from RPC
            type LatestEntry = { state_id: string; value: any; created_at: string };
            
            latestEntriesMap = (latestEntries as LatestEntry[] || []).reduce(
              (acc: Record<string, { value: any; created_at: string }>, entry: LatestEntry) => {
              acc[entry.state_id] = { value: entry.value, created_at: entry.created_at };
              return acc;
            }, {} as typeof latestEntriesMap);
          }
        }

        // --- Process Habits for 'completed' flag ---
        const todayStr = new Date().toISOString().split('T')[0];
        const habitIds = (habits || []).map(h => h.id);
        const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id') // Only need habit_id to check existence
          .eq('user_id', ctx.userId)
          .eq('date', todayStr) // Filter by date
          .in('habit_id', habitIds);
        if (todayEntriesError) throw todayEntriesError;

        const completedHabitIds = new Set((habitEntriesToday || []).map(e => e.habit_id));

        const formattedHabits = (habits || []).map(h => ({
          id: h.id,
          name: h.name, // Use name
          description: h.description, // Pass other potentially useful fields
          habit_type: h.habit_type,
          streak: h.streak,
          // Consider a habit completed if *any* entry exists for today
          completed: completedHabitIds.has(h.id)
        }));

        // --- Process Goals for 'progress' ---
        const goalIds = (goals || []).map(g => g.id);
        let tasksMap: Record<string, { total: number; completed: number }> = {};
        if (goalIds.length > 0) {
          const { data: allTasksForGoals, error: tasksError2 } = await ctx.supabaseAdmin
            .from('tasks')
            .select('goal_id, status')
            .eq('user_id', ctx.userId)
            .in('goal_id', goalIds);
          if (tasksError2) throw tasksError2;

          tasksMap = (allTasksForGoals || []).reduce<Record<string, { total: number; completed: number }>>((acc, task) => {
            if (task.goal_id) { // Ensure goal_id is not null
              const gid = task.goal_id;
              if (!acc[gid]) acc[gid] = { total: 0, completed: 0 };
              acc[gid].total++;
              if (task.status === 'completed') acc[gid].completed++;
            }
            return acc;
          }, {});
        }

        const formattedGoals = (goals || []).map((g) => {
          const { total = 0, completed: comp = 0 } = tasksMap[g.id] || {};
          // Calculate progress based on tasks, ignore goal.progress field for now
          const progress = total > 0 ? comp / total : 0;
          return {
            id: g.id,
            title: g.name, // Changed name to title to match frontend expectations
            status: g.status, // Pass status directly
            priority: g.priority, // Pass priority
            progress: Math.round(progress * 100) / 100, // Keep calculated progress
            tasks: { // Add tasks information expected by GoalSummaryCard
              total: total,
              completed: comp
            }
          };
        });

        // --- Format Tasks (Minimal formatting needed if TASK_FIELDS is correct) ---
        const formattedTasks = (tasks || []).map((t) => ({
          id: t.id,
          name: t.name,
          status: t.status,
          priority: t.priority,
          due_date: t.due_date, // Use due_date
          // Add other fields as needed by the dashboard UI
        }));

        // --- Format Tracked States with Latest Values ---
        const formattedTrackedStates = (trackedStateDefinitions || []).map((def) => {
          const latestEntry = latestEntriesMap[def.id];
          return {
            id: def.id,
            name: def.name,
            unit: def.unit, // Use 'unit' field
            currentValue: latestEntry ? latestEntry.value : null, // Default to null
            lastUpdated: latestEntry ? latestEntry.created_at : null,
          };
        });

        // Return formatted data including trackedStates
        return {
          habits: formattedHabits,
          goals: formattedGoals,
          tasks: tasks || [], // Ensure tasks is always an array
          trackedStates: formattedTrackedStates, // Use the newly formatted array
        };
      } catch (error: any) {
        console.error('Dashboard data fetch error:', error);
        
        // Handle specific error types with appropriate error codes
        if (error.code === '42P01') { // Table doesn't exist
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Database schema error',
          });
        }
        
        if (error.code === '23505') { // Unique violation
          throw new TRPCError({
            code: 'CONFLICT',
            message: 'Resource already exists',
          });
        }
        
        // Default error handling
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch dashboard data',
        });
      }
    }),
  
  getWeeklyProgress: protectedProcedure
    .input(z.object({
      daysToInclude: z.number().min(1).optional().default(7),
      includeRawData: z.boolean().optional().default(false),
    }).optional())
    .query(async ({ ctx, input }) => {
      try {
        // Calculate date range based on input or default to past week
        const daysToInclude = input?.daysToInclude || 7;
        const includeRawData = input?.includeRawData || false;
        
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(endDate.getDate() - (daysToInclude - 1));
        
        const todayStr = endDate.toISOString().split('T')[0];
        const startDateStr = startDate.toISOString().split('T')[0];
        
        // Generate array of all dates in the range for daily aggregation
        const dateRange: string[] = [];
        const tempDate = new Date(startDate);
        while (tempDate <= endDate) {
          dateRange.push(tempDate.toISOString().split('T')[0]);
          tempDate.setDate(tempDate.getDate() + 1);
        }
        
        // Fetch habits relevant to the date range (active during any part of the range)
        // Need to consider habits created *before* the end date and not archived *before* the start date
        const HABIT_FIELDS_FOR_PROGRESS = 'id, name, habit_type, frequency_type, frequency_details, created_at, streak, best_streak'; // Add streak fields
        const { data: relevantHabits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS_FOR_PROGRESS)
          .eq('user_id', ctx.userId)
          // Add logic here if needed to filter habits active within the date range
          // e.g., .lt('created_at', endDate.toISOString())
          //       .or(`archived_at.gte.${startDate.toISOString()},archived_at.is.null`)
          ;
        if (habitsError) throw habitsError;

        const relevantHabitIds = (relevantHabits || []).map(h => h.id);

        // Fetch habit entries within the date range for relevant habits
        const { data: habitEntries, error: entriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('id, habit_id, date, completed, quantity_value, notes')
          .eq('user_id', ctx.userId)
          .in('habit_id', relevantHabitIds.length > 0 ? relevantHabitIds : ['dummy-uuid']) // Filter by relevant habits
          .gte('date', startDate.toISOString().split('T')[0])
          .lte('date', endDate.toISOString().split('T')[0])
          .order('date', { ascending: true });
 
        if (entriesError) throw entriesError;

        // Get all tasks completed or due within the date range
        const { data: relevantTasks, error: tasksError } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .or(`due_date.gte.${startDateStr}.and.due_date.lte.${todayStr},status.eq.completed.and.updated_at.gte.${startDateStr}.and.updated_at.lte.${todayStr}`);

        if (tasksError) throw tasksError;
        
        // Get total tasks count for completion rate
        const { count: totalTasks, error: countError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('*', { count: 'exact', head: true })
          .eq('user_id', ctx.userId);
          
        if (countError) throw countError;
        
        // Get goal progress snapshots for the period
        const { data: goalSnapshots, error: goalSnapshotsError } = await ctx.supabaseAdmin
          .from('goal_progress_snapshots') // Assuming we have this table
          .select('goal_id, progress, created_at')
          .eq('user_id', ctx.userId)
          .gte('created_at', startDate.toISOString())
          .lte('created_at', endDate.toISOString())
          .order('created_at', { ascending: true });
          
        if (goalSnapshotsError) throw goalSnapshotsError;

        // -- AGGREGATE DATA BY DAY --
        
        // Create daily habit completion structure
        const habitsByDay: Record<string, { completed: number; total: number; entries: any[]; expected: number }> = {};
        dateRange.forEach(date => {
          habitsByDay[date] = { completed: 0, total: 0, entries: [], expected: 0 };
        });
        
        // Populate completed habits from entries (count existence, not completed flag)
        habitEntries?.forEach((entry: any) => {
          const dateStr = (entry.date as string).split('T')[0];
          if (habitsByDay[dateStr]) {
            // Only count one completion per habit per day
            if (!habitsByDay[dateStr].entries.some((e: any) => e.habit_id === entry.habit_id)) {
              habitsByDay[dateStr].completed++;
            }
            habitsByDay[dateStr].entries.push(entry);
          }
        });
        
        // Create daily task completion structure
        const tasksByDay: Record<string, { completed: number; entries: any[] }> = {};
        dateRange.forEach(date => {
          tasksByDay[date] = { completed: 0, entries: [] };
        });
        
        // Process completed tasks into daily stats
        relevantTasks?.forEach(task => {
          const completedDate = (task.updated_at as string).split('T')[0];
          if (tasksByDay[completedDate]) {
            tasksByDay[completedDate].completed++;
            tasksByDay[completedDate].entries.push(task);
          }
        });
        
        // Calculate expected habits per day based on frequency
        const isHabitExpected = (habit: any, date: string): boolean => {
          const dateObj = new Date(date + 'T00:00:00Z'); // Ensure UTC
          const dayOfWeek = dateObj.getUTCDay(); // 0 = Sunday, 6 = Saturday
          const dayOfMonth = dateObj.getUTCDate();
          const month = dateObj.getUTCMonth(); // 0 = January, 11 = December

          const habitCreatedDate = new Date(habit.created_at);
          if (dateObj < habitCreatedDate) {
            return false; // Cannot be expected before it was created
          }

          switch (habit.frequency_type) {
            case 'daily':
              return true;
            case 'specific_days':
              return Array.isArray(habit.frequency_details?.days) && habit.frequency_details.days.includes(dayOfWeek);
            // TODO: Add logic for 'weekly', 'monthly' etc. as needed
            default:
              return false;
          }
        };
        relevantHabits?.forEach(habit => {
          dateRange.forEach(date => {
            if (isHabitExpected(habit, date)) {
              habitsByDay[date].expected++;
            }
          });
        });
        
        // Format into daily progress reports
        const dailyProgress = dateRange.map(date => {
          const habitStats = habitsByDay[date];
          const taskStats = tasksByDay[date];
          
          const habitCompletionRate = habitStats.expected > 0 
            ? habitStats.completed / habitStats.expected 
            : 0;
            
          return {
            date,
            habits: {
              total: habitStats.total,
              completed: habitStats.completed,
              completionRate: habitCompletionRate,
              expected: habitStats.expected
            },
            tasks: {
              completed: taskStats.completed
            },
            // Optionally include raw entries if requested
            ...(includeRawData ? {
              habitEntries: habitStats.entries,
              completedTasks: taskStats.entries
            } : {})
          };
        });
        
        // Calculate overall metrics
        const totalHabitEntries = Object.values(habitsByDay).reduce(
          (sum, day) => sum + day.total, 0);
        const completedHabitEntries = Object.values(habitsByDay).reduce(
          (sum, day) => sum + day.completed, 0);
        const totalCompletedTasks = Object.values(tasksByDay).reduce(
          (sum, day) => sum + day.completed, 0);
          
        const taskCompletionRate = totalTasks ? totalCompletedTasks / totalTasks : 0;
        const habitConsistency = totalHabitEntries > 0 
          ? completedHabitEntries / totalHabitEntries 
          : 0;
          
        // Calculate habit streaks (could be moved to a separate helper function)
        const habitStreaks = (relevantHabits || []).map(habit => ({
          id: habit.id,
          name: habit.name,
          currentStreak: habit.streak || 0,
          bestStreak: habit.best_streak || 0
        }));
        
        // Prepare goal progress data
        const goalProgress: Record<string, { snapshots: any[]; startProgress?: number; endProgress?: number }> = {};
        
        (goalSnapshots || []).forEach(snapshot => {
          if (!goalProgress[snapshot.goal_id]) {
            goalProgress[snapshot.goal_id] = { snapshots: [] };
          }
          goalProgress[snapshot.goal_id].snapshots.push({
            progress: snapshot.progress,
            date: (snapshot.created_at as string).split('T')[0]
          });
        });
        
        // Calculate start and end progress for each goal
        Object.keys(goalProgress).forEach(goalId => {
          const snapshots = goalProgress[goalId].snapshots;
          if (snapshots.length > 0) {
            // Sort by date
            snapshots.sort((a, b) => a.date.localeCompare(b.date));
            goalProgress[goalId].startProgress = snapshots[0].progress;
            goalProgress[goalId].endProgress = snapshots[snapshots.length - 1].progress;
          }
        });
        
        return {
          dailyProgress,
          overallMetrics: {
            totalHabitEntries,
            completedHabitEntries,
            habitCompletionRate: habitConsistency,
            completedTasksCount: totalCompletedTasks,
            taskCompletionRate,
            // Trend indicators (compared to previous period)
            trends: {
              habitsImproving: true, // Placeholder - would compare to previous period
              tasksImproving: false // Placeholder - would compare to previous period
            }
          },
          habitStreaks,
          goalProgress: Object.entries(goalProgress).map(([goalId, data]) => ({
            goalId,
            progressChange: (data.endProgress || 0) - (data.startProgress || 0),
            currentProgress: data.endProgress || 0
          })),
          dateRange: {
            start: startDateStr,
            end: todayStr,
            days: dateRange
          }
        };
      } catch (error: any) {
        console.error('Weekly progress fetch error:', error);
        
        // Handle specific error types with appropriate error codes
        if (error.code === '42P01') { // Table doesn't exist
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Database schema error',
          });
        }
        
        if (error.code === '22P02') { // Invalid text representation
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Invalid input format',
          });
        }
        
        // Default error handling
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch weekly progress',
        });
      }
    }),
}); 
  ```

- **server/src/routers/goalProgressNoteRouter.ts** (5.2 KB, 168 lines) Exports: `goalProgressNoteRouter`

  ```ts
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createGoalProgressNoteInput,
  updateGoalProgressNoteInput,
  GetGoalProgressNotesInput,
  DeleteGoalProgressNoteInput,
} from '../types/trpc-types';

// Define fields for consistent selection
const GOAL_PROGRESS_NOTE_FIELDS = 'id, goal_id, user_id, note, created_at';

export const goalProgressNoteRouter = router({
  // Get all notes for a specific goal
  getNotesForGoal: protectedProcedure
    .input(GetGoalProgressNotesInput)
    .query(async ({ ctx, input }) => {
      try {
        // First, ensure the goal exists and belongs to the user
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        // Fetch the notes for that goal
        const { data, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .eq('user_id', ctx.userId) // Redundant check, but good practice
          .eq('goal_id', input.goal_id)
          .order('created_at', { ascending: false }); // Newest first

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal progress notes',
        });
      }
    }),

  createNote: protectedProcedure
    .input(createGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Ensure the goal exists and belongs to the user before adding a note
        const { error: goalError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.goal_id)
          .eq('user_id', ctx.userId)
          .single();

        if (goalError) {
          throw new TRPCError({
            code: goalError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Goal not found or access denied.',
          });
        }

        const { data: note, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return note;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal progress note',
        });
      }
    }),

  updateNote: protectedProcedure
    .input(updateGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership of the note
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { data: updatedNote, error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_PROGRESS_NOTE_FIELDS)
          .single();

        if (error) throw error;
        return updatedNote;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal progress note',
        });
      }
    }),

  deleteNote: protectedProcedure
    .input(DeleteGoalProgressNoteInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Note not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goal_progress_notes')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal progress note',
        });
      }
    }),
});

  ```

- **server/src/routers/goalRouter.ts** (7.6 KB, 265 lines) Exports: `goalRouter`

  ```ts
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createGoalInput, updateGoalInput } from '../types/trpc-types';

const GOAL_FIELDS = 'id, user_id, title, description, progress, target_date, archived_at, sort_order, created_at, updated_at';

export const goalRouter = router({
  getGoals: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;

        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals',
        });
      }
    }),

  getGoalById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!goal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found',
          });
        }

        return goal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goal',
        });
      }
    }),

  createGoal: protectedProcedure
    .input(createGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: goal, error } = await ctx.supabaseAdmin
          .from('goals')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return goal;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create goal',
        });
      }
    }),

  updateGoal: protectedProcedure
    .input(updateGoalInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to update it',
          });
        }

        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) throw error;
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update goal',
        });
      }
    }),

  deleteGoal: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: existingGoal, error: fetchError } = await ctx.supabaseAdmin
          .from('goals')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingGoal) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Goal not found or you do not have permission to delete it',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('goals')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete goal',
        });
      }
    }),

  listActive: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch goals (in listActive stub)',
        });
      }
    }),

  listArchived: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: goals, error } = await ctx.supabaseAdmin
          .from('goals')
          .select(GOAL_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        return goals || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived goals',
        });
      }
    }),

  archiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') { 
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive goal',
        });
      }
    }),

  unarchiveGoal: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedGoal, error } = await ctx.supabaseAdmin
          .from('goals')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(GOAL_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Goal not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        return updatedGoal;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive goal',
        });
      }
    }),
});
  ```

- **server/src/routers/habitRouter.ts** (21.7 KB, 578 lines) (2 TODOs) Exports: `habitRouter`

  ```ts
import { z } from "zod";
import { router, protectedProcedure } from "../router";
import { TRPCError } from "@trpc/server";
import {
  createHabitInput,
  updateHabitInput,
  createHabitEntryInput,
  updateHabitEntryInput,
} from '../types/trpc-types';
import {
  differenceInCalendarDays,
  parseISO,
  format
} from 'date-fns'; // Need date-fns

const HABIT_FIELDS =
  'id, user_id, title, cue, routine, reward, habit_type, goal_quantity, goal_unit, frequency_period, goal_frequency, recurrence_rule, recurrence_end_date, archived_at, sort_order, streak, best_streak, created_at, updated_at';

const HABIT_ENTRY_FIELDS =
  'id, user_id, habit_id, date, completed, quantity_value, notes, created_at';

async function calculateAndUpdateStreak(habitId: string, userId: string, supabase: any): Promise<{ currentStreak: number, bestStreak: number }> {
  try {
    // Fetch all entries for the habit, ordered by date descending
    const { data: entries, error: entriesError } = await supabase
      .from('habit_entries')
      .select('date, completed') // Only need date and completed status
      .eq('habit_id', habitId)
      .eq('user_id', userId)
      .order('date', { ascending: false });

    if (entriesError) {
      console.error(`Streak Calc Error: Failed to fetch entries for habit ${habitId}:`, entriesError);
      return { currentStreak: 0, bestStreak: 0 }; // Return 0 if entries can't be fetched
    }

    if (!entries || entries.length === 0) {
      // No entries, reset streak
      const { error: updateErr } = await supabase
        .from('habits')
        .update({ streak: 0 })
        .eq('id', habitId);
      if (updateErr) console.error(`Streak Calc Error: Failed to reset streak for habit ${habitId}`, updateErr);
      // Fetch best streak to return it accurately even if current is 0
      const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
      return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 };
    }

    let currentStreak = 0;
    const today = new Date();
    let expectedDate = today; // Start checking from today
    const todayStr = format(today, 'yyyy-MM-dd');
    const todayEntry = entries.find((e: any) => e.date === todayStr);

    // Determine starting point for streak check
    if (todayEntry?.completed) {
      currentStreak = 1;
      expectedDate = new Date(today.setDate(today.getDate() - 1)); // Start checking from yesterday
    } else {
      const yesterday = new Date(); // Need a fresh date object
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayStr = format(yesterday, 'yyyy-MM-dd');
      const yesterdayEntry = entries.find((e: any) => e.date === yesterdayStr);
      if (yesterdayEntry?.completed) {
        currentStreak = 1;
        expectedDate = new Date(yesterday.setDate(yesterday.getDate() - 1)); // Start checking from day before yesterday
      } else {
        currentStreak = 0;
        // No need to loop if streak is already 0 based on today/yesterday
      }
    }

    // Only loop if there's a potential streak > 0
    if (currentStreak > 0) {
      // Find index of the entry *before* the expectedDate (since we check backwards)
      let startIndex = entries.findIndex((e: any) => e.date === format(expectedDate, 'yyyy-MM-dd'));
      // If expected date wasn't found (e.g., yesterday was the start), adjust index
      if (startIndex === -1) {
        // Start from the entry after the one that established the initial streak (today or yesterday)
        const initialStreakDateStr = todayEntry?.completed ? todayStr : (format(new Date(new Date().setDate(new Date().getDate() - 1)), 'yyyy-MM-dd'));
        const initialEntryIndex = entries.findIndex((e: any) => e.date === initialStreakDateStr);
        startIndex = initialEntryIndex !== -1 ? initialEntryIndex + 1 : 0;
      }

      for (let i = startIndex; i < entries.length; i++) {
        const entry = entries[i];
        const entryDate = parseISO(entry.date);
        const expectedDateStr = format(expectedDate, 'yyyy-MM-dd');

        if (entry.date === expectedDateStr) {
          if (entry.completed) {
            currentStreak++;
            expectedDate.setDate(expectedDate.getDate() - 1); // Move to check previous day
          } else {
            break; // Streak broken by uncompleted entry
          }
        } else {
          // Check if the date difference breaks the streak (allowing for gaps)
          const previousDate = i > 0 ? parseISO(entries[i - 1].date) : parseISO(entries[0].date);
          const dateDiff = differenceInCalendarDays(previousDate, entryDate);

          if (dateDiff > 1) {
            break; // Gap too large, streak broken
          }

          // If gap is 1 day, but this entry wasn't completed, streak is broken
          if (!entry.completed) {
            break;
          }

          // If gap is 1 day and completed, it doesn't continue the *current* consecutive sequence
          // but doesn't necessarily break it either (e.g., completed Mon, Wed - streak is 1 from Wed).
          // For simplicity, we break the loop here, assuming the *consecutive* streak from today/yesterday is what matters.
          // A more complex implementation could find the *longest* streak ending recently.
          break;
        }
      }
    }

    // Fetch current best_streak
    const { data: habitData, error: habitFetchError } = await supabase
      .from('habits')
      .select('best_streak')
      .eq('id', habitId)
      .single();

    if (habitFetchError) {
      console.error(`Streak Calc Error: Failed to fetch habit ${habitId} for best_streak:`, habitFetchError);
      // Fallback best streak if fetch fails
      const bestStreakFallback = Math.max(currentStreak, 0); 
      const { error: updateError } = await supabase
        .from('habits')
        .update({ streak: currentStreak, best_streak: bestStreakFallback })
        .eq('id', habitId);
      if (updateError) console.error(`Streak Calc Error: Failed to update streak (fallback) for habit ${habitId}:`, updateError);
      console.log(`Streak Updated (Fallback Best) for habit ${habitId}: Current=${currentStreak}, Best=${bestStreakFallback}`);
      return { currentStreak, bestStreak: bestStreakFallback };
    }

    const bestStreak = Math.max(currentStreak, habitData?.best_streak || 0);

    // Update the habit record
    const { error: updateError } = await supabase
      .from('habits')
      .update({ streak: currentStreak, best_streak: bestStreak })
      .eq('id', habitId);

    if (updateError) {
      console.error(`Streak Calc Error: Failed to update streak for habit ${habitId}:`, updateError);
    }

    console.log(`Streak Updated for habit ${habitId}: Current=${currentStreak}, Best=${bestStreak}`);
    return { currentStreak, bestStreak };

  } catch (error) {
    console.error(`Unexpected error calculating streak for habit ${habitId}:`, error);
    // Attempt to fetch best streak even on error
    const { data: habitData } = await supabase.from('habits').select('best_streak').eq('id', habitId).single();
    return { currentStreak: 0, bestStreak: habitData?.best_streak || 0 }; // Return 0 current streak on error
  }
}

export const habitRouter = router({
  getHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error: habitsError } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (habitsError) throw habitsError;
        if (!habits) return [];

        const todayStr = new Date().toISOString().split('T')[0];

        const { data: habitEntriesToday, error: todayEntriesError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id')
          .eq('user_id', ctx.userId)
          .eq('date', todayStr)
          .in('habit_id', habits.map(h => h.id));

        if (todayEntriesError) throw todayEntriesError;

        const completedMap = (habitEntriesToday || []).reduce<Record<string, boolean>>((acc, entry) => {
          acc[entry.habit_id] = true;
          return acc;
        }, {});

        const formattedHabits = habits.map(h => ({
          ...h,
          completedToday: !!completedMap[h.id]
        }));

        return formattedHabits;
      } catch (error: any) {
        throw new TRPCError({ 
          code: 'INTERNAL_SERVER_ERROR', 
          message: error.message || 'Failed to fetch habits'
        });
      }
    }),

  getHabitById: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .select(HABIT_FIELDS)
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (error) throw new TRPCError({ 
        code: error.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: error.message 
      });
      return data;
    }),

  createHabit: protectedProcedure
    .input(createHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .insert({
          ...input,
          user_id: ctx.userId,
          streak: 0,
          best_streak: 0
        })
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  updateHabit: protectedProcedure
    .input(updateHabitInput)
    .mutation(async ({ ctx, input }) => {
      const { id, ...updateData } = input;

      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { data, error } = await ctx.supabaseAdmin
        .from("habits")
        .update(updateData)
        .eq("id", id)
        .eq('user_id', ctx.userId)
        .select(HABIT_FIELDS)
        .single();

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return data;
    }),

  deleteHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      const { data: habit, error: fetchError } = await ctx.supabaseAdmin
        .from("habits")
        .select("id")
        .eq("id", input.id)
        .eq("user_id", ctx.userId)
        .single();

      if (fetchError) throw new TRPCError({ 
        code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
        message: "Habit not found or access denied" 
      });

      const { error } = await ctx.supabaseAdmin
        .from("habits")
        .delete()
        .eq("id", input.id);

      if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });
      return { id: input.id };
    }),

  listArchivedHabits: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: habits, error } = await ctx.supabaseAdmin
          .from('habits')
          .select(HABIT_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null)
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        return habits || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived habits',
        });
      }
    }),

  archiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to archive habit' });
      }
    }),

  unarchiveHabit: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: updatedHabit, error } = await ctx.supabaseAdmin
          .from('habits')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(HABIT_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return updatedHabit;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to unarchive habit' });
      }
    }),

  getHabitEntries: protectedProcedure
    .input(z.object({
      habitId: z.string().uuid(),
      startDate: z.string().optional(), 
      endDate: z.string().optional(),   
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { error: habitError } = await ctx.supabaseAdmin
          .from("habits")
          .select("id")
          .eq("id", input.habitId)
          .eq("user_id", ctx.userId)
          .single();

        if (habitError) {
          if (habitError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Habit not found or access denied.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: habitError.message });
        }

        let query = ctx.supabaseAdmin
          .from('habit_entries')
          .select(HABIT_ENTRY_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('habit_id', input.habitId);

        if (input.startDate) query = query.gte('date', input.startDate);
        if (input.endDate) query = query.lte('date', input.endDate);

        const { data, error: entriesError } = await query.order('date', { ascending: false });

        if (entriesError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: entriesError.message });
        return data || [];
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Failed to fetch habit entries' });
      }
    }),

  getHabitEntriesForHabit: protectedProcedure
    .input(z.object({ habitId: z.string().uuid() }))
    .query(async ({ ctx, input }) => {
      // TODO: Implement logic to fetch habit entries for a specific habit
      console.log(`Fetching entries for habit: ${input.habitId}, user: ${ctx.userId}`);
      // Example fetch:
      // const { data, error } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select(HABIT_ENTRY_FIELDS)
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .order('date', { ascending: false });
      // if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      // return data || [];
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),

  createHabitEntry: protectedProcedure
    .input(createHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .insert({ ...input, user_id: ctx.userId })
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: error.message });

        // Update streak after successful insert
        if (data) {
          await calculateAndUpdateStreak(input.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create habit entry',
        });
      }
    }),

  updateHabitEntry: protectedProcedure
    .input(updateHabitEntryInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        const { data: habitEntry, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) throw new TRPCError({ 
          code: fetchError.code === "PGRST116" ? "NOT_FOUND" : "INTERNAL_SERVER_ERROR",
          message: "Habit entry not found or access denied" 
        });

        const { data, error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId) // Ensure ownership
          .select(HABIT_ENTRY_FIELDS)
          .single();

        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });

        // Update streak after successful update
        if (data) {
          await calculateAndUpdateStreak(data.habit_id, ctx.userId, ctx.supabaseAdmin);
        }

        return data;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update habit entry',
        });
      }
    }),

  deleteHabitEntry: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Fetch habitId *before* deleting the entry
        const { data: entryToDelete, error: fetchError } = await ctx.supabaseAdmin
          .from('habit_entries')
          .select('habit_id') // Fetch habit_id
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !entryToDelete) {
          throw new TRPCError({ 
            code: fetchError?.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Habit entry not found or access denied.' 
          });
        }

        const { habit_id: habitIdForStreak } = entryToDelete; // Store before delete

        // Perform delete
        const { error } = await ctx.supabaseAdmin
          .from('habit_entries')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId); // Ensure user owns the entry being deleted

        if (error) throw error; // Throw if delete fails

        // Update streak *after* successful delete
        if (habitIdForStreak) { // Check if we got the habitId
          await calculateAndUpdateStreak(habitIdForStreak, ctx.userId, ctx.supabaseAdmin);
        }

        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete habit entry',
        });
      }
    }),

  toggleHabitEntry: protectedProcedure
    .input(z.object({ habitId: z.string().uuid(), date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/) }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Implement logic to find if entry exists for habitId/date/userId.
      // If exists, delete it.
      // If not exists, create it (need default values for boolean/quantity type).
      // Call calculateAndUpdateStreak after create/delete.
      console.log(`Toggling habit entry for habit: ${input.habitId}, date: ${input.date}`);
      // Example logic:
      // const { data: existingEntry, error: findError } = await ctx.supabaseAdmin
      //   .from('habit_entries')
      //   .select('id')
      //   .eq('habit_id', input.habitId)
      //   .eq('user_id', ctx.userId)
      //   .eq('date', input.date)
      //   .maybeSingle();
      // if (findError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: findError.message });

      // if (existingEntry) {
      //   // Delete existing
      //   const { error: deleteError } = await ctx.supabaseAdmin.from('habit_entries').delete().eq('id', existingEntry.id);
      //   if (deleteError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: deleteError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'deleted', habitId: input.habitId, date: input.date };
      // } else {
      //   // Create new
      //   // Need to know habit type to set default 'completed' or 'quantity_value'
      //   const { data: newEntry, error: createError } = await ctx.supabaseAdmin
      //     .from('habit_entries')
      //     .insert({ habit_id: input.habitId, user_id: ctx.userId, date: input.date, completed: true /* or quantity_value: default */ })
      //     .select(HABIT_ENTRY_FIELDS)
      //     .single();
      //   if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
      //   await calculateAndUpdateStreak(input.habitId, ctx.userId, input.date, ctx.supabaseAdmin);
      //   return { status: 'created', entry: newEntry };
      // }
      throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: 'Not implemented yet' });
    }),
});
  ```

- **server/src/routers/principleRouter.ts** (5.7 KB, 171 lines) (4 TODOs) Exports: `principleRouter`

  ```ts
// server/src/routers/principleRouter.ts
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createPrincipleInput, updatePrincipleInput } from '../types/trpc-types'; // These now expect 'title' and 'body'

// Define fields for consistent selection, using 'title' and 'body'
const PRINCIPLE_FIELDS = 'id, user_id, title, body, sort_order, created_at, updated_at';

export const principleRouter = router({
  getPrinciples: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: principles, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principles || []; // Return empty array if null
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principles',
        });
      }
    }),

  getPrincipleById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .select(PRINCIPLE_FIELDS) // Use the constant with 'title' and 'body'
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) {
           if (error.code === 'PGRST116') { // Handle not found specifically
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found' });
           }
           throw error; // Rethrow other errors
        }
        // No need for !principle check if .single() is used and error isn't PGRST116

        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch principle',
        });
      }
    }),

  createPrinciple: protectedProcedure
    .input(createPrincipleInput) // This Zod schema now expects 'title' and 'body'
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: principle, error } = await ctx.supabaseAdmin
          .from('principles')
          .insert({
            ...input, // Spread validated input, already contains 'title' and 'body'
            user_id: ctx.userId,
          })
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return principle;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create principle',
        });
      }
    }),

  updatePrinciple: protectedProcedure
    .input(updatePrincipleInput) // This Zod schema now expects 'title' and 'body' (optional)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
           if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to update it' });
           }
           throw fetchError;
        }

        // Update
        const { data: updatedPrinciple, error } = await ctx.supabaseAdmin
          .from('principles')
          .update(updateData) // updateData contains validated 'title'/'body' if provided
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(PRINCIPLE_FIELDS) // Use the constant
          .single();

        if (error) throw error;
        // TODO: Parse with Principle schema from trpc-types?
        return updatedPrinciple;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update principle',
        });
      }
    }),

  deletePrinciple: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existing, error: fetchError } = await ctx.supabaseAdmin
          .from('principles')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
            if (fetchError.code === 'PGRST116') {
             throw new TRPCError({ code: 'NOT_FOUND', message: 'Principle not found or you do not have permission to delete it' });
           }
           throw fetchError;
        }

        // Delete
        const { error } = await ctx.supabaseAdmin
          .from('principles')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete principle',
        });
      }
    }),
});
  ```

- **server/src/routers/reminderRouter.ts** (4.9 KB, 161 lines) (1 TODOs) Exports: `reminderRouter`

  ```ts
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createReminderInput,
  updateReminderInput,
  GetRemindersForEntityInput,
  DeleteReminderInput,
} from '../types/trpc-types';

// Define fields for consistent selection
const REMINDER_FIELDS = 'id, user_id, related_entity_type, related_entity_id, reminder_time, message, is_active, created_at, updated_at';

export const reminderRouter = router({
  // Get all active reminders for the user (might need refinement later)
  getActiveReminders: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('is_active', true)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch active reminders',
        });
      }
    }),

  // Get reminders linked to a specific entity
  getRemindersForEntity: protectedProcedure
    .input(GetRemindersForEntityInput)
    .query(async ({ ctx, input }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('reminders')
          .select(REMINDER_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('related_entity_type', input.related_entity_type)
          .eq('related_entity_id', input.related_entity_id)
          .order('reminder_time', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch reminders for entity',
        });
      }
    }),

  createReminder: protectedProcedure
    .input(createReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // TODO: Potentially validate that related_entity_id exists and belongs to user?
        // This requires knowing the related_entity_type and querying the correct table.
        // For now, assume valid input.
        const { data: reminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return reminder;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create reminder',
        });
      }
    }),

  updateReminder: protectedProcedure
    .input(updateReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { data: updatedReminder, error } = await ctx.supabaseAdmin
          .from('reminders')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(REMINDER_FIELDS)
          .single();

        if (error) throw error;
        return updatedReminder;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update reminder',
        });
      }
    }),

  deleteReminder: protectedProcedure
    .input(DeleteReminderInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Check existence and ownership
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('reminders')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Reminder not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('reminders')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete reminder',
        });
      }
    }),
});

  ```

- **server/src/routers/rewardsRouter.ts** (10.4 KB, 336 lines) Exports: `rewardsRouter`

  ```ts
import { TRPCError } from '@trpc/server';
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { supabaseAdmin } from '../context';

// Corrected relative path
import { claimLootInput, awardBadgeInput } from '../types/trpc-types';

export const rewardsRouter = router({
  // Get all rewards for current user
  getUserRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Select specific fields aligned with our Zod types
        const { data: rewards, error } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('id, user_id, reward_id, earned_at, rewards(id, name, description, emoji, image_url, required_points, type)')
          .eq('user_id', ctx.userId)
          .order('earned_at', { ascending: false });

        if (error) throw error;
        return rewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user rewards',
        });
      }
    }),

  // Get available rewards that can be earned
  getAvailableRewards: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        // Get all rewards with specific fields
        const { data: allRewards, error: rewardsError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('id, name, description, emoji, image_url, required_points, type, can_earn_multiple')
          .order('required_points', { ascending: true });

        if (rewardsError) throw rewardsError;

        // Get already earned rewards
        const { data: earnedRewards, error: earnedError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .select('reward_id')
          .eq('user_id', ctx.userId);

        if (earnedError) throw earnedError;

        // Filter out already earned one-time rewards
        const earnedIds = new Set((earnedRewards || []).map(er => er.reward_id));
        const availableRewards = allRewards?.filter(reward => 
          !earnedIds.has(reward.id) || reward.can_earn_multiple);

        return availableRewards || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch available rewards',
        });
      }
    }),

  // Get user points
  getUserPoints: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: userProfile, error } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (error) throw error;
        return {
          points: userProfile?.points || 0,
          lifetimePoints: userProfile?.lifetime_points || 0,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch user points',
        });
      }
    }),

  // Earn a reward if eligible
  earnReward: protectedProcedure
    .input(claimLootInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get the reward details
        const { data: reward, error: rewardError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.rewardId)
          .single();

        if (rewardError || !reward) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Reward not found',
          });
        }

        // Check if user has enough points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        if (userProfile.points < reward.required_points) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'Not enough points to earn this reward',
          });
        }

        // If the reward is one-time, check if already earned
        if (!reward.can_earn_multiple) {
          const { data: existingReward, error: existingError } = await ctx.supabaseAdmin
            .from('user_rewards')
            .select('id')
            .eq('user_id', ctx.userId)
            .eq('reward_id', input.rewardId)
            .single();

          if (existingReward) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'You have already earned this one-time reward',
            });
          }
        }

        // Begin transaction
        // 1. Deduct points from user
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: userProfile.points - reward.required_points,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // 2. Add reward to user's earned rewards
        const { data: userReward, error: insertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.rewardId,
            earned_at: new Date().toISOString(),
            points_spent: reward.required_points,
          })
          .select()
          .single();

        if (insertError) {
          // Rollback points if adding reward failed
          await ctx.supabaseAdmin
            .from('profiles')
            .update({
              points: userProfile.points,
            })
            .eq('id', ctx.userId);

          throw insertError;
        }

        return {
          success: true,
          reward: userReward,
          remainingPoints: userProfile.points - reward.required_points,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to earn reward',
        });
      }
    }),

  // Award points to user (e.g., for completing habits, tasks)
  awardPoints: protectedProcedure
    .input(awardBadgeInput)
    .mutation(async ({ ctx, input }) => {
      try {
        // Get current user points
        const { data: userProfile, error: profileError } = await ctx.supabaseAdmin
          .from('profiles')
          .select('points, lifetime_points')
          .eq('id', ctx.userId)
          .single();

        if (profileError || !userProfile) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: 'Failed to fetch user profile',
          });
        }

        // Get badge details
        const { data: badge, error: badgeError } = await ctx.supabaseAdmin
          .from('rewards')
          .select('*')
          .eq('id', input.badgeId)
          .eq('type', 'badge')
          .single();

        if (badgeError || !badge) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Badge not found',
          });
        }

        // Default points to award
        const pointsToAward = 10;
        const currentPoints = userProfile.points || 0;
        const lifetimePoints = userProfile.lifetime_points || 0;
        const newPoints = currentPoints + pointsToAward;
        const newLifetimePoints = lifetimePoints + pointsToAward;

        // Update user points
        const { error: updateError } = await ctx.supabaseAdmin
          .from('profiles')
          .update({
            points: newPoints,
            lifetime_points: newLifetimePoints,
          })
          .eq('id', ctx.userId);

        if (updateError) throw updateError;

        // Record the point transaction
        const { data: pointTransaction, error: transactionError } = await ctx.supabaseAdmin
          .from('point_transactions')
          .insert({
            user_id: ctx.userId,
            points: pointsToAward,
            reason: `Earned badge: ${badge.name}`,
            source_type: 'badge',
            source_id: input.badgeId,
          })
          .select()
          .single();

        if (transactionError) throw transactionError;

        // Add badge to user's earned rewards
        const { data: userBadge, error: badgeInsertError } = await ctx.supabaseAdmin
          .from('user_rewards')
          .insert({
            user_id: ctx.userId,
            reward_id: input.badgeId,
            reward_type: 'badge',
            earned_at: new Date().toISOString(),
            points_spent: 0, // Badges don't cost points
          })
          .select()
          .single();

        if (badgeInsertError) throw badgeInsertError;

        return {
          success: true,
          previousPoints: currentPoints,
          newPoints,
          pointsAdded: pointsToAward,
          transaction: pointTransaction,
          badge: userBadge,
        };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to award badge',
        });
      }
    }),

  // Get point transaction history
  getPointHistory: protectedProcedure
    .input(z.object({
      limit: z.number().optional().default(20),
      cursor: z.string().optional(), // for pagination
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('point_transactions')
          .select('*')
          .eq('user_id', ctx.userId)
          .order('created_at', { ascending: false })
          .limit(input.limit);
          
        // Handle cursor-based pagination
        if (input.cursor) {
          query = query.lt('created_at', input.cursor);
        }
        
        const { data: transactions, error } = await query;

        if (error) throw error;
        
        // Determine if there are more results
        const lastItem = transactions && transactions.length > 0 
          ? transactions[transactions.length - 1] 
          : null;
          
        return {
          items: transactions || [],
          nextCursor: lastItem?.created_at,
          hasMore: (transactions?.length || 0) === input.limit,
        };
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch point history',
        });
      }
    }),
}); 
  ```

- **server/src/routers/taskRouter.ts** (21.0 KB, 616 lines) (16 TODOs) Exports: `taskRouter`

  ```ts
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  createTaskInput,
  updateTaskInput,
  updateTaskStatusInput,
  TaskStatusEnum, // Import the enum
  TaskPriorityEnum,
} from '../types/trpc-types';

// Define fields for selection consistency
const TASK_FIELDS =
  'id, user_id, title, notes, status, priority, due_date, goal_id, parent_task_id, recurrence_rule, recurrence_end_date, archived_at, sort_order, created_at, updated_at'; // Corrected: 'priority' instead of 'priority_enum' if that's the actual column name after migration
const GOAL_FIELDS = 'id, user_id, title, description, progress, target_date, archived_at, sort_order, created_at, updated_at';


// --- Helper function to update goal progress ---
async function updateGoalProgress(goalId: string, userId: string, supabase: any) {
  try {
    // 1. Fetch all non-archived tasks for the goal
    const { data: tasks, error: tasksError } = await supabase
      .from('tasks')
      .select('id, status') // Only need id and status
      .eq('goal_id', goalId)
      .eq('user_id', userId)
      .is('archived_at', null); // Exclude archived tasks

    if (tasksError) {
      console.error(`Error fetching tasks for goal ${goalId} during progress update:`, tasksError);
      // Decide how to handle this - maybe just log and skip update?
      return; // Exit if tasks can't be fetched
    }

    const totalTasks = tasks?.length || 0;
    const completedTasks = tasks?.filter((t: { status: string }) => t.status === TaskStatusEnum.enum.done).length || 0;

    // 2. Calculate progress (avoid division by zero)
    const newProgress = totalTasks > 0 ? completedTasks / totalTasks : 0;
    // Ensure progress is between 0 and 1, rounded to avoid floating point issues
    const clampedProgress = Math.round(Math.min(1, Math.max(0, newProgress)) * 100) / 100;

    // 3. Update the goal record
    const { error: updateError } = await supabase
      .from('goals')
      .update({ progress: clampedProgress })
      .eq('id', goalId)
      .eq('user_id', userId); // Ensure user owns the goal

    if (updateError) {
      console.error(`Error updating progress for goal ${goalId}:`, updateError);
      // Log error but don't necessarily throw, task toggle was successful
    } else {
        console.log(`Updated progress for goal ${goalId} to ${clampedProgress}`);
    }

  } catch (err) {
    console.error(`Unexpected error during goal progress update for goal ${goalId}:`, err);
    // Log unexpected errors
  }
}

export const taskRouter = router({
  getTasks: protectedProcedure // Gets non-archived tasks
    .input(z.object({
      goalId: z.string().uuid().optional(),
      // TODO: Add filters for status, priority, dates etc.?
    }))
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null); // Filter out archived

        if (input.goalId) {
          query = query.eq('goal_id', input.goalId);
        }

        // TODO: Add complex priority enum sorting? (e.g. high > medium > low)
        const { data: tasks, error } = await query
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('due_date', { ascending: true, nullsFirst: false }) // Order by due date (nulls last)
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tasks',
        });
      }
    }),

  getTaskById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(), // Use uuid validation
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!task) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found',
          });
        }

        // TODO: Parse with Task schema?
        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch task',
        });
      }
    }),

  createTask: protectedProcedure
    .input(createTaskInput) // Use imported input type
    .mutation(async ({ ctx, input }) => {
      try {
        // Verify goal_id if provided
        if (input.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', input.goal_id)
            .eq('user_id', ctx.userId) // Ensure goal belongs to user
            .is('archived_at', null) // Ensure goal is not archived
            .single();

          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived goal ID',
            });
          }
        }

        // Verify parent_task_id if provided
        if (input.parent_task_id) {
          const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
            .from('tasks')
            .select('id')
            .eq('id', input.parent_task_id)
            .eq('user_id', ctx.userId) // Ensure parent belongs to user
            .is('archived_at', null) // Ensure parent is not archived
            .single();

          if (parentError || !parentTask) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived parent task ID',
            });
          }
        }

        const { data: task, error } = await ctx.supabaseAdmin
          .from('tasks')
          .insert({
            ...input, // Spread validated input (includes new fields like parent_task_id, recurrence etc)
            user_id: ctx.userId,
            // Ensure due_date is used if present in input
            due_date: input.due_date ?? null, // Use correct field name
          })
          .select(TASK_FIELDS)
          .single();

        if (error) {
           // Handle specific errors like FK violations?
           console.error("Create task error:", error);
           throw error;
        }
        // TODO: Parse with Task schema?
        return task;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create task',
        });
      }
    }),

  updateTask: protectedProcedure
    .input(updateTaskInput) // Use imported input type
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input; // Separate id from update payload

        // Check ownership
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id, parent_task_id') // Select parent_task_id for cycle check
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to update it',
          });
        }

        // Verify goal_id if being updated
        if (updateData.goal_id) {
          const { data: goal, error: goalError } = await ctx.supabaseAdmin
            .from('goals')
            .select('id')
            .eq('id', updateData.goal_id)
            .eq('user_id', ctx.userId)
            .is('archived_at', null)
            .single();

          if (goalError || !goal) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived goal ID',
            });
          }
        }
        // Handle setting goal_id to null
        if (updateData.goal_id === null) {
          updateData.goal_id = null;
        }

        // Verify parent_task_id if being updated
        if (updateData.parent_task_id) {
           // Basic cycle check
           if (updateData.parent_task_id === id) {
             throw new TRPCError({
               code: 'BAD_REQUEST',
               message: 'Task cannot be its own parent',
             });
           }
          const { data: parentTask, error: parentError } = await ctx.supabaseAdmin
            .from('tasks')
            .select('id')
            .eq('id', updateData.parent_task_id)
            .eq('user_id', ctx.userId)
            .is('archived_at', null)
            .single();

          if (parentError || !parentTask) {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'Invalid or archived parent task ID',
            });
          }
          // TODO: Add deeper cycle detection if needed (check if new parent is a descendant)
        }
         // Handle setting parent_task_id to null
        if (updateData.parent_task_id === null) {
          updateData.parent_task_id = null;
        }

        // Ensure correct field name for due date if provided
        const payload: Record<string, any> = { ...updateData };
        if ('due_date' in payload) {
          payload.due_date = payload.due_date ?? null;
        }

        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update(payload) // Pass validated update data
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
             // Handle specific errors like FK violations?
           console.error("Update task error:", error);
           throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update task',
        });
      }
    }),

  deleteTask: protectedProcedure
    .input(z.object({
      id: z.string().uuid(), // Use uuid validation
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check ownership
        const { data: existingTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingTask) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Task not found or you do not have permission to delete it',
          });
        }

        // Delete the task (consider implications for subtasks - maybe archive instead?)
        // For now, direct delete.
        const { error } = await ctx.supabaseAdmin
          .from('tasks')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete task',
        });
      }
    }),

  // ---- Archive/Unarchive ----
  listArchivedTasks: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: tasks, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .not('archived_at', 'is', null) // Filter for archived tasks
          .order('archived_at', { ascending: false })
          .order('created_at', { ascending: false });
        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch archived tasks',
        });
      }
    }),

  archiveTask: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
      // TODO: Consider archiving subtasks recursively?
      try {
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ archived_at: new Date().toISOString() })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Task not found or you do not have permission to archive it.',
            });
          }
          throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to archive task',
        });
      }
    }),

  unarchiveTask: protectedProcedure
    .input(z.object({ id: z.string().uuid() }))
    .mutation(async ({ ctx, input }) => {
       // TODO: Consider check if parent is archived?
      try {
        const { data: updatedTask, error } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ archived_at: null })
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .select(TASK_FIELDS)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({
              code: 'NOT_FOUND',
              message: 'Task not found or you do not have permission to unarchive it.',
            });
          }
          throw error;
        }
        // TODO: Parse with Task schema?
        return updatedTask;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to unarchive task',
        });
      }
    }),

  // ---- Status Update ----
  updateTaskStatus: protectedProcedure
    .input(updateTaskStatusInput) // Uses { id: string().uuid(), status: TaskStatusEnum }
    .mutation(async ({ ctx, input }) => {
       try {
         // Check ownership first
         const { data: existing, error: fetchErr } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

         if (fetchErr || !existing) {
           throw new TRPCError({ code: 'NOT_FOUND', message: 'Task not found or permission denied.' });
         }

         // Perform update
         const { data: updatedTask, error: updateErr } = await ctx.supabaseAdmin
           .from('tasks')
           .update({ status: input.status })
           .eq('id', input.id)
           .select(TASK_FIELDS)
           .single();

         if (updateErr) throw updateErr;
         // TODO: Parse with Task schema?
         return updatedTask;
       } catch (error: any) {
         if (error instanceof TRPCError) throw error;
         throw new TRPCError({
           code: 'INTERNAL_SERVER_ERROR',
           message: error.message || 'Failed to update task status',
         });
       }
    }),

  // ---- Refactored Stubs ----
  listToday: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const todayStart = new Date();
        todayStart.setHours(0, 0, 0, 0);
        const todayEnd = new Date();
        todayEnd.setHours(23, 59, 59, 999);

        const { data: tasks, error } = await ctx.supabaseAdmin
          .from('tasks')
          .select(TASK_FIELDS)
          .eq('user_id', ctx.userId)
          .is('archived_at', null)
          .gte('due_date', todayStart.toISOString())
          .lte('due_date', todayEnd.toISOString())
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('due_date', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Task schema?
        return tasks || [];
      } catch (error: any) {
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list tasks for today' });
      }
    }),

  listUpcoming: protectedProcedure
    .query(async ({ ctx }) => {
       try {
         const tomorrowStart = new Date();
         tomorrowStart.setDate(tomorrowStart.getDate() + 1);
         tomorrowStart.setHours(0, 0, 0, 0);

         const { data: tasks, error } = await ctx.supabaseAdmin
           .from('tasks')
           .select(TASK_FIELDS)
           .eq('user_id', ctx.userId)
           .is('archived_at', null)
           .gte('due_date', tomorrowStart.toISOString()) // Due date is tomorrow or later
           .order('due_date', { ascending: true, nullsFirst: false })
           .order('sort_order', { ascending: true, nullsFirst: false })
           .order('created_at', { ascending: false });

         if (error) throw error;
         // TODO: Parse with Task schema?
         return tasks || [];
       } catch (error: any) {
         throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list upcoming tasks' });
       }
    }),

 listOverdue: protectedProcedure
    .query(async ({ ctx }) => {
       try {
         const todayStart = new Date();
         todayStart.setHours(0, 0, 0, 0);

         const { data: tasks, error } = await ctx.supabaseAdmin
           .from('tasks')
           .select(TASK_FIELDS)
           .eq('user_id', ctx.userId)
           .is('archived_at', null)
           .lt('due_date', todayStart.toISOString()) // Due date is before today
           .not('status', 'in', `('${TaskStatusEnum.enum.done}')`) // Exclude completed tasks
           .order('due_date', { ascending: true, nullsFirst: false })
           .order('sort_order', { ascending: true, nullsFirst: false })
           .order('created_at', { ascending: false });

         if (error) throw error;
         // TODO: Parse with Task schema?
         return tasks || [];
       } catch (error: any) {
         throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message || 'Failed to list overdue tasks' });
       }
    }),

  toggleTask: protectedProcedure // Toggles between 'todo' and 'done'
    .input(z.object({
      taskId: z.string().uuid(),
      completed: z.boolean().optional() // Optional for backward compatibility
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // 1. Fetch the current task, including goal_id
        const { data: currentTask, error: fetchError } = await ctx.supabaseAdmin
          .from('tasks')
          .select('id, status, goal_id, title') // <-- Include goal_id and title
          .eq('id', input.taskId)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !currentTask) {
          throw new TRPCError({ code: 'NOT_FOUND', message: 'Task not found or permission denied.' });
        }

        // 2. Determine the new status
        let newStatus;
        if (input.completed !== undefined) {
          // If completed was explicitly provided, use it
          newStatus = input.completed ? TaskStatusEnum.enum.done : TaskStatusEnum.enum.todo;
        } else {
          // Otherwise toggle the current status
          newStatus = currentTask.status === TaskStatusEnum.enum.done
            ? TaskStatusEnum.enum.todo
            : TaskStatusEnum.enum.done;
        }

        // 3. Update the task status
        const { data: updatedTask, error: updateError } = await ctx.supabaseAdmin
          .from('tasks')
          .update({ status: newStatus })
          .eq('id', input.taskId)
          .select(TASK_FIELDS) // Return the full updated task
          .single();

        if (updateError) throw updateError;

        // 4. *** NEW: Update goal progress if applicable ***
        if (currentTask.goal_id) {
           // Call the helper function asynchronously - no need to await here
           // unless the UI needs the updated goal immediately (unlikely for a toggle)
          updateGoalProgress(currentTask.goal_id, ctx.userId, ctx.supabaseAdmin);
        }

        // 5. Return the updated task
        return updatedTask;

      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        console.error("Error in toggleTask:", error); // Log unexpected errors
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to toggle task status',
        });
      }
    }),

  // --- Obsolete Stubs (keep or remove based on client usage) ---
  /*
  getTasksByGoal: protectedProcedure ... // Covered by getTasks with goalId filter
  getTodaysTasks: protectedProcedure ... // Replaced by listToday
  getUpcomingTasks: protectedProcedure ... // Replaced by listUpcoming
  updateTaskStatus_OLD: protectedProcedure ... // Replaced by updateTaskStatus and toggleTask
  */

});
  ```

- **server/src/routers/trackedStateRouter.ts** (11.2 KB, 325 lines) Exports: `trackedStateRouter`

  ```ts
// File: server/src/routers/trackedStateRouter.ts

import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import {
  // Ensure all necessary input types from trpc-types are imported
  createTrackedStateDefInput,
  updateTrackedStateDefInput,
  GetTrackedStateDefByIdInput,
  DeleteTrackedStateDefInput,
  CreateStateEntryInput,      // <--- Import for createEntry
  updateStateEntryInput,      // <--- Import for updateEntry
  GetStateEntriesInput,       // <--- Import for getEntries
  DeleteStateEntryInput       // <--- Import for deleteEntry
} from '../types/trpc-types';

// Use correct field names from database.types.ts & trpc-types.ts
const TRACKED_STATE_DEF_FIELDS = 'id, user_id, name, description, scale, custom_labels, unit, icon, target_min_value, target_max_value, created_at, updated_at, active, priority';
const STATE_ENTRY_FIELDS = 'id, user_id, definition_id, value_numeric, value_text, entry_timestamp, notes';

export const trackedStateRouter = router({
  getDefinitions: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('active', true)
          .order('priority', { ascending: true, nullsFirst: false }) // Corrected: nullsFirst
          .order('created_at', { ascending: true });

        if (error) throw error;
        return data ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tracked state definitions',
        });
      }
    }),

  getDefinitionById: protectedProcedure
    .input(GetTrackedStateDefByIdInput) // Use correct Zod schema
    .query(async ({ ctx, input }) => {
       try {
        const { data: definition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select(TRACKED_STATE_DEF_FIELDS)
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId)
          .single();

        if (error) {
          if (error.code === 'PGRST116') {
            throw new TRPCError({ code: 'NOT_FOUND', message: 'Tracked state definition not found.' });
          }
          throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        }
        return definition;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch tracked state definition',
        });
      }
    }),

  createDefinition: protectedProcedure
    .input(createTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { data: definition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .insert({
            ...input, // input is now correctly typed
            user_id: ctx.userId,
          })
          .select(TRACKED_STATE_DEF_FIELDS)
          .single();

        if (error) throw error;
        return definition;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create tracked state definition',
        });
      }
    }),

  updateDefinition: protectedProcedure
    .input(updateTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { id, ...updateData } = input; // input is now correctly typed

        const { error: fetchError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Definition not found or access denied.',
          });
        }

        const { data: updatedDefinition, error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select(TRACKED_STATE_DEF_FIELDS)
          .single();

        if (error) throw error;
        return updatedDefinition;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update tracked state definition',
        });
      }
    }),

  deleteDefinition: protectedProcedure
    .input(DeleteTrackedStateDefInput) // Use correct Zod schema
    .mutation(async ({ ctx, input }) => {
       try {
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Definition not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .delete()
          .eq('id', input.id) // input.id is now correctly typed
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id }; // input.id is now correctly typed
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete tracked state definition',
        });
      }
    }),

  // --- State Entry Procedures ---

  getEntries: protectedProcedure
    .input(GetStateEntriesInput) // <<<--- ADDED .input() BINDING
    .query(async ({ ctx, input }) => {
      try {
        let query = ctx.supabaseAdmin
          .from('state_entries')
          .select(STATE_ENTRY_FIELDS)
          .eq('user_id', ctx.userId)
          .eq('definition_id', input.tracked_state_def_id); // input is now typed

        if (input.startDate) { // input is now typed
          query = query.gte('entry_timestamp', input.startDate);
        }
        if (input.endDate) { // input is now typed
          query = query.lte('entry_timestamp', input.endDate);
        }

        query = query.order('entry_timestamp', { ascending: false });

        if (input.limit) { // input is now typed
          query = query.limit(input.limit);
        }

        const { data: entries, error } = await query;

        if (error) throw error;
        return entries ?? [];
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch state entries',
        });
      }
    }),

  createEntry: protectedProcedure
    .input(CreateStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
      try {
        // Check definition ownership (already implemented correctly)
        const { error: defError } = await ctx.supabaseAdmin
          .from('tracked_state_defs')
          .select('id')
          .eq('id', input.tracked_state_def_id) // input is now typed
          .eq('user_id', ctx.userId)
          .single();

        if (defError) {
          throw new TRPCError({
            code: defError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Tracked state definition not found or invalid.',
          });
        }

        // Insert typed data
        const { data: entry, error } = await ctx.supabaseAdmin
          .from('state_entries')
          .insert({
            user_id: ctx.userId,
            definition_id: input.tracked_state_def_id, // input is now typed
            value_numeric: input.value_numeric,     // input is now typed
            value_text: input.value_text,         // input is now typed
            entry_timestamp: input.entry_timestamp || new Date().toISOString(), // input is now typed
            notes: input.notes,                 // input is now typed
          })
          .select(STATE_ENTRY_FIELDS)
          .single();

        if (error) throw error;
        return entry;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create state entry',
        });
      }
    }),

  updateEntry: protectedProcedure
    .input(updateStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input; // input is now typed

        // Check ownership (already implemented correctly)
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('state_entries')
          .select('id')
          .eq('id', id) // Use id from destructured input
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Entry not found or access denied.',
          });
        }

        // updateData is now correctly typed from the input schema
        const { data: updatedEntry, error } = await ctx.supabaseAdmin
          .from('state_entries')
          .update(updateData)
          .eq('id', id) // Use id from destructured input
          .eq('user_id', ctx.userId)
          .select(STATE_ENTRY_FIELDS)
          .single();

        if (error) throw error;
        return updatedEntry;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update state entry',
        });
      }
    }),

  deleteEntry: protectedProcedure
    .input(DeleteStateEntryInput) // <<<--- ADDED .input() BINDING
    .mutation(async ({ ctx, input }) => {
       try {
        // Check ownership (already implemented correctly)
        const { error: fetchError } = await ctx.supabaseAdmin
          .from('state_entries')
          .select('id')
          .eq('id', input.id) // input is now typed
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError) {
          throw new TRPCError({
            code: fetchError.code === 'PGRST116' ? 'NOT_FOUND' : 'INTERNAL_SERVER_ERROR',
            message: 'Entry not found or access denied.',
          });
        }

        const { error } = await ctx.supabaseAdmin
          .from('state_entries')
          .delete()
          .eq('id', input.id) // input is now typed
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id }; // input is now typed
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete state entry',
        });
      }
    }),
});
  ```

- **server/src/routers/userRouter.ts** (5.6 KB, 171 lines) Exports: `userRouter`

  ```ts
import { z } from 'zod';
import { router, protectedProcedure, publicProcedure } from '../router';
import { TRPCError } from '@trpc/server';

export const userRouter = router({
  getProfile: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('id, username, avatar_url, full_name, bio, time_zone, onboarding_completed, created_at, updated_at')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  updateProfile: protectedProcedure
    .input(z.object({
      full_name: z.string().optional(),
      avatar_url: z.string().optional(),
      theme: z.string().optional(),
      time_zone: z.string().optional(),
      display_name: z.string().optional(),
      bio: z.string().optional(),
    }))
    .mutation(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update(input)
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getUserSettings: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('id, user_id, notification_preferences, ui_preferences')
        .eq('user_id', ctx.userId)
        .single();
        
      if (error) {
        // If settings don't exist, create default settings
        if (error.code === 'PGRST116') {
          const { data: newSettings, error: createError } = await ctx.supabaseAdmin
            .from('user_settings')
            .insert({
              user_id: ctx.userId,
              notification_preferences: {
                email: true,
                push: true,
                task_reminders: true,
                goal_updates: true,
                habit_reminders: true
              },
              ui_preferences: {
                theme: 'system',
                compact_view: false,
                show_completed_tasks: true
              }
            })
            .select()
            .single();
            
          if (createError) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: createError.message });
          return newSettings;
        }
        
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      }
      
      return data;
    }),
    
  updateUserSettings: protectedProcedure
    .input(z.object({
      notification_preferences: z.object({
        email: z.boolean().optional(),
        push: z.boolean().optional(),
        task_reminders: z.boolean().optional(),
        goal_updates: z.boolean().optional(),
        habit_reminders: z.boolean().optional()
      }).optional(),
      ui_preferences: z.object({
        theme: z.string().optional(),
        compact_view: z.boolean().optional(),
        show_completed_tasks: z.boolean().optional()
      }).optional()
    }))
    .mutation(async ({ ctx, input }) => {
      // First check if settings exist
      const { data: existingSettings, error: fetchError } = await ctx.supabaseAdmin
        .from('user_settings')
        .select('id')
        .eq('user_id', ctx.userId)
        .single();
        
      if (fetchError && fetchError.code === 'PGRST116') {
        // Create settings if they don't exist
        const defaultSettings = {
          user_id: ctx.userId,
          notification_preferences: {
            email: true,
            push: true,
            task_reminders: true,
            goal_updates: true,
            habit_reminders: true,
            ...input.notification_preferences
          },
          ui_preferences: {
            theme: 'system',
            compact_view: false,
            show_completed_tasks: true,
            ...input.ui_preferences
          }
        };
        
        const { data, error } = await ctx.supabaseAdmin
          .from('user_settings')
          .insert(defaultSettings)
          .select()
          .single();
          
        if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
        return data;
      } else if (fetchError) {
        throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: fetchError.message });
      }
      
      // Update existing settings
      const { data, error } = await ctx.supabaseAdmin
        .from('user_settings')
        .update(input)
        .eq('user_id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return data;
    }),
    
  getOnboardingStatus: protectedProcedure
    .query(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .select('id, onboarding_completed')
        .eq('id', ctx.userId)
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { onboardingCompleted: data?.onboarding_completed || false };
    }),
    
  completeOnboarding: protectedProcedure
    .mutation(async ({ ctx }) => {
      const { data, error } = await ctx.supabaseAdmin
        .from('profiles')
        .update({ onboarding_completed: true })
        .eq('id', ctx.userId)
        .select()
        .single();
        
      if (error) throw new TRPCError({ code: 'INTERNAL_SERVER_ERROR', message: error.message });
      return { success: true };
    }),
}); 
  ```

- **server/src/routers/valueRouter.ts** (5.0 KB, 167 lines) (4 TODOs) Exports: `valueRouter`

  ```ts
import { z } from 'zod';
import { router, protectedProcedure } from '../router';
import { TRPCError } from '@trpc/server';
import { createValueInput, updateValueInput } from '../types/trpc-types';

export const valueRouter = router({
  getValues: protectedProcedure
    .query(async ({ ctx }) => {
      try {
        const { data: values, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('user_id', ctx.userId)
          .order('sort_order', { ascending: true, nullsFirst: false })
          .order('created_at', { ascending: false });

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return values;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch values',
        });
      }
    }),

  getValueById: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .query(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (error) throw error;
        if (!value) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found',
          });
        }

        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to fetch value',
        });
      }
    }),

  createValue: protectedProcedure
    .input(createValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { data: value, error } = await ctx.supabaseAdmin
          .from('values')
          .insert({
            ...input,
            user_id: ctx.userId,
          })
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return value;
      } catch (error: any) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to create value',
        });
      }
    }),

  updateValue: protectedProcedure
    .input(updateValueInput)
    .mutation(async ({ ctx, input }) => {
      try {
        const { id, ...updateData } = input;

        // First check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to update it',
          });
        }

        // Update the value
        const { data: updatedValue, error } = await ctx.supabaseAdmin
          .from('values')
          .update(updateData)
          .eq('id', id)
          .eq('user_id', ctx.userId)
          .select('id, user_id, name, description, color, icon, sort_order, created_at, updated_at')
          .single();

        if (error) throw error;
        // TODO: Parse with Value schema from trpc-types?
        return updatedValue;
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to update value',
        });
      }
    }),

  deleteValue: protectedProcedure
    .input(z.object({
      id: z.string().uuid(),
    }))
    .mutation(async ({ ctx, input }) => {
      try {
        // Check if the value exists and belongs to user
        const { data: existingValue, error: fetchError } = await ctx.supabaseAdmin
          .from('values')
          .select('id')
          .eq('id', input.id)
          .eq('user_id', ctx.userId)
          .single();

        if (fetchError || !existingValue) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Value not found or you do not have permission to delete it',
          });
        }

        // Delete the value
        const { error } = await ctx.supabaseAdmin
          .from('values')
          .delete()
          .eq('id', input.id)
          .eq('user_id', ctx.userId);

        if (error) throw error;
        return { success: true, id: input.id };
      } catch (error: any) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message || 'Failed to delete value',
        });
      }
    }),
});
  ```

- **server/src/types/index.ts** (1.5 KB, 75 lines) Exports: `Badge`, `BadgeId`, `Goal`, `GoalId`, `Habit`, `HabitId`, `KeyResult`, `Principle`, `Task`, `TaskId`, `TrackedStateDef`, `Value`, `ValueId`

  ```ts
export type ValueId = string;
export type GoalId = string;
export type TaskId = string;
export type HabitId = string;
export type BadgeId = string;

export interface Value {
  id: ValueId;
  name: string;
  description?: string;
  color: string; // tailwind color token (e.g. 'indigo-500')
  domainId?: string; // optional grouping
}

export interface Goal {
  id: GoalId;
  title: string;
  description?: string;
  valueIds: ValueId[];
  progress: number; // 0‒1
  keyResults: KeyResult[];
  targetDate?: string; // ISO
}

export interface KeyResult {
  id: string;
  title: string;
  progress: number; // 0‒1
}

export interface Task {
  id: TaskId;
  title: string;
  notes?: string;
  status: 'todo' | 'doing' | 'done' | 'blocked';
  due?: string; // ISO date
  priority?: 1 | 2 | 3;
  goalId?: GoalId;
  valueIds?: ValueId[];
}

export interface Habit {
  id: HabitId;
  title: string;
  cue?: string;
  routine?: string;
  reward?: string;
  valueIds: ValueId[];
  streak: number; // current consecutive days
  bestStreak: number;
  history: Record<string, boolean>; // ISO day → done?
}

export interface Principle {
  id: string;
  title: string;
  body: string;
  valueIds: ValueId[];
}

export interface TrackedStateDef {
  id: string;
  name: string;
  scale: '1-5' | 'low-high' | 'custom';
  customLabels?: string[];
  valueIds: ValueId[];
}

export interface Badge {
  id: BadgeId;
  title: string;
  icon: string; // Hero‑icons name or emoji
  earnedAt?: string; // ISO
  progress?: number; // 0‒1 for not‑yet
} 
  ```

- **server/src/types/trpc-types.ts** (14.2 KB, 360 lines) Exports: `awardBadgeInput`, `BadgeDefinition`, `BadgeDefinition`, `claimLootInput`, `createGoalInput`, `createGoalProgressNoteInput`, `createHabitEntryInput`, `createHabitInput`, `createPrincipleInput`, `createReminderInput`, `CreateStateEntryInput`, `createTaskInput`, `createTrackedStateDefInput`, `createValueInput`, `DeleteGoalProgressNoteInput`, `DeleteReminderInput`, `DeleteStateEntryInput`, `DeleteTrackedStateDefInput`, `GetGoalProgressNotesInput`, `GetRemindersForEntityInput`, `GetStateEntriesInput`, `GetTrackedStateDefByIdInput`, `Goal`, `Goal`, `GoalProgressNote`, `GoalProgressNote`, `greetingInput`, `greetingOutput`, `Habit`, `Habit`, `HabitEntry`, `HabitEntry`, `HabitFrequencyPeriodEnum`, `HabitTypeEnum`, `NotificationPrefs`, `PointTransaction`, `PointTransaction`, `Principle`, `Principle`, `Reminder`, `Reminder`, `Reward`, `Reward`, `RewardTypeEnum`, `RouterInputs`, `RouterOutputs`, `StateEntry`, `StateEntry`, `Task`, `Task`, `TaskPriorityEnum`, `TaskStatusEnum`, `TrackedStateDef`, `TrackedStateDef`, `UiPrefs`, `updateGoalInput`, `updateGoalProgressNoteInput`, `updateHabitEntryInput`, `updateHabitInput`, `updatePrincipleInput`, `updateProfileInput`, `updateReminderInput`, `updateSettingsInput`, `updateStateEntryInput`, `updateTaskInput`, `updateTaskStatusInput`, `updateTrackedStateDefInput`, `updateValueInput`, `UserBadge`, `UserBadge`, `UserProfile`, `UserProfile`, `UserReward`, `UserReward`, `UserSettings`, `UserSettings`, `Value`, `Value`

  ```ts
// server/src/types/trpc-types.ts
/*
  Aether – Shared tRPC Types
  ------------------------------------------------------------------
  Every Zod schema that powers a router lives here so both the server
  (routers) and the client (React Query hooks) reference a **single**
  source‑of‑truth.  Import these types everywhere else – **never** hand‑roll
  shapes again.
*/

import { z } from 'zod';
import { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from '../router';

/* ------------------------------------------------------------------
 * Enums (keep in sync with DB enums)
 * ----------------------------------------------------------------*/
export const TaskStatusEnum = z.enum(['todo', 'doing', 'done', 'blocked', 'pending']);
export const TaskPriorityEnum = z.enum(['low', 'medium', 'high']);
export const RewardTypeEnum = z.enum(['badge', 'achievement', 'item', 'discount']);
export const HabitTypeEnum = z.enum(['boolean', 'quantity']);
export const HabitFrequencyPeriodEnum = z.enum(['day', 'week', 'month']);

/* ------------------------------------------------------------------
 * Domain Models (DB row shapes) – keep in sync with Supabase tables
 * ----------------------------------------------------------------*/
export const UserProfile = z.object({
  id: z.string().uuid(),
  username: z.string().nullish(),
  avatar_url: z.string().url().nullish(),
  full_name: z.string().nullish(),
  bio: z.string().nullish(),
  points: z.number().int().nonnegative().default(0),
  time_zone: z.string().nullish(),
  onboarding_completed: z.boolean().default(false),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type UserProfile = z.infer<typeof UserProfile>;

export const NotificationPrefs = z.object({
  email: z.boolean().default(true),
  push: z.boolean().default(true),
  task_reminders: z.boolean().default(true),
  goal_updates: z.boolean().default(true),
  habit_reminders: z.boolean().default(true),
});

export const UiPrefs = z.object({
  theme: z.enum(['system', 'light', 'dark']).default('system'),
  compact_view: z.boolean().default(false),
  show_completed_tasks: z.boolean().default(true),
  first_day_of_week: z.number().int().min(0).max(6).default(0),
});

export const UserSettings = z.object({
  id: z.string().uuid().optional(),
  user_id: z.string().uuid(),
  notification_preferences: NotificationPrefs,
  ui_preferences: UiPrefs,
});
export type UserSettings = z.infer<typeof UserSettings>;

export const Value = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), 
  description: z.string().nullish(),
  color: z.string().nullish(),
  icon: z.string().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type Value = z.infer<typeof Value>;

export const Principle = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(), // <<< Changed from 'name' to 'title'
  body: z.string(), // <<< Renamed from description for clarity, matching migration
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type Principle = z.infer<typeof Principle>;

export const Goal = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  description: z.string().nullish(),
  progress: z.number().nullish(),
  target_date: z.string().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime().nullish(),
  updated_at: z.string().datetime().nullish(),
});
export type Goal = z.infer<typeof Goal>;

export const Task = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  notes: z.string().nullish(),
  status: TaskStatusEnum.default('todo'),
  priority_enum: TaskPriorityEnum.nullish(), // <<< Renamed from priority
  due_date: z.string().datetime().nullish(),
  goal_id: z.string().uuid().nullish(),
  parent_task_id: z.string().uuid().nullish(),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Task = z.infer<typeof Task>;

export const Habit = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  title: z.string(),
  cue: z.string().nullish(),
  routine: z.string().nullish(),
  reward: z.string().nullish(),
  streak: z.number().nonnegative().default(0),
  best_streak: z.number().nonnegative().default(0),
  habit_type: HabitTypeEnum.default('boolean'),
  goal_quantity: z.number().int().nullish(),
  goal_unit: z.string().nullish(),
  frequency_period: HabitFrequencyPeriodEnum.default('day'),
  goal_frequency: z.number().int().positive().default(1),
  recurrence_rule: z.string().nullish(),
  recurrence_end_date: z.string().datetime().nullish(),
  archived_at: z.string().datetime().nullish(),
  sort_order: z.number().int().nullish(), // <<< Added sort_order
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Habit = z.infer<typeof Habit>;

export const HabitEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  habit_id: z.string().uuid(),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be in YYYY-MM-DD format"),
  completed: z.boolean().default(false),
  quantity_value: z.number().int().nullish(),
  notes: z.string().nullish(),
  created_at: z.string().datetime(),
});
export type HabitEntry = z.infer<typeof HabitEntry>;

export const TrackedStateDef = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  name: z.string(),
  // category: z.string(), // Category seems removed/replaced in DB schema by scale/custom_labels
  scale: z.enum(['1-5', 'low-high', 'custom']), // <<< Added scale
  custom_labels: z.array(z.string()).nullish(), // <<< Added custom_labels
  unit: z.string().nullish(), // Keep unit if still used alongside scale
  icon: z.string().nullish(), // Keep icon if still used
  target_min_value: z.number().nullish(), // <<< Added
  target_max_value: z.number().nullish(), // <<< Added
  active: z.boolean().default(true), // <<< Added active
  priority: z.number().int().default(1), // <<< Added priority
  created_at: z.string().datetime(),
  updated_at: z.string().datetime().nullish(),
});
export type TrackedStateDef = z.infer<typeof TrackedStateDef>;

export const StateEntry = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  definition_id: z.string().uuid(), // <<< Renamed from tracked_state_def_id for consistency? check DB
  value_numeric: z.number().optional().nullable(),
  value_text: z.string().optional().nullable(),
  entry_timestamp: z.string().datetime({ message: "Invalid datetime string. Must be UTC ISO 8601" }).optional(),
  notes: z.string().optional().nullable(), // <<< Added notes
});
export type StateEntry = z.infer<typeof StateEntry>;

export const Reward = z.object({
  id: z.string().uuid(),
  name: z.string(),
  description: z.string().nullish(),
  type: RewardTypeEnum,
  required_points: z.number().int().nonnegative().default(0),
  can_earn_multiple: z.boolean().default(false),
  image_url: z.string().url().nullish(),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Reward = z.infer<typeof Reward>;

export const UserReward = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  reward_id: z.string().uuid(),
  reward_type: z.string().nullish(), // From DB schema
  earned_at: z.string().datetime(),
  points_spent: z.number().int().nonnegative().default(0),
  metadata: z.record(z.any()).nullish(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type UserReward = z.infer<typeof UserReward>;

export const PointTransaction = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  points: z.number().int(),
  reason: z.string(),
  source_type: z.string(),
  source_id: z.string().uuid().nullish(),
  created_at: z.string().datetime(),
});
export type PointTransaction = z.infer<typeof PointTransaction>;

export const BadgeDefinition = z.object({
  id: z.string(), // From DB: text primary key
  title: z.string(),
  description: z.string().nullish(),
  icon: z.string(),
});
export type BadgeDefinition = z.infer<typeof BadgeDefinition>;

export const UserBadge = z.object({
  // Note: user_badges might be merged into user_rewards with type='badge'
  user_id: z.string().uuid(),
  badge_id: z.string(), // Matches badge_definitions.id (text)
  earned_at: z.string().datetime(),
  progress: z.number().nullish(), // From DB schema
});
export type UserBadge = z.infer<typeof UserBadge>;

export const Reminder = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
  reminder_time: z.string().datetime(),
  is_active: z.boolean().default(true),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Reminder = z.infer<typeof Reminder>;

export const GoalProgressNote = z.object({
  id: z.string().uuid(),
  goal_id: z.string().uuid(),
  user_id: z.string().uuid(),
  note: z.string(),
  created_at: z.string().datetime(),
});
export type GoalProgressNote = z.infer<typeof GoalProgressNote>;

/* ------------------------------------------------------------------
 * Router‑level Schemas – inputs & outputs for every procedure
 * ----------------------------------------------------------------*/
export const greetingInput = z.object({ name: z.string().optional() });
export const greetingOutput = z.object({ greeting: z.string() });

// User
export const updateProfileInput = UserProfile.partial().omit({ id: true, created_at: true, updated_at: true });
export const updateSettingsInput = z.object({
  notification_preferences: NotificationPrefs.partial().optional(),
  ui_preferences: UiPrefs.partial().optional(),
});

// Values
export const createValueInput = Value.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateValueInput = createValueInput.partial().extend({ id: z.string().uuid() });

// Principles
// Uses 'title' and 'body' from the updated Principle schema
export const createPrincipleInput = Principle.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updatePrincipleInput = createPrincipleInput.partial().extend({ id: z.string().uuid() });

// Goals
export const createGoalInput = Goal.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateGoalInput = createGoalInput.partial().extend({ id: z.string().uuid() });

// Tasks
export const createTaskInput = Task.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateTaskInput = createTaskInput.partial().extend({ id: z.string().uuid() });
export const updateTaskStatusInput = z.object({ id: z.string().uuid(), status: TaskStatusEnum });

// Habits
export const createHabitInput = Habit.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateHabitInput = createHabitInput.partial().extend({ id: z.string().uuid() });

// Habit Entries
export const createHabitEntryInput = HabitEntry.omit({ id: true, user_id: true, created_at: true });
export const updateHabitEntryInput = createHabitEntryInput.partial().extend({ id: z.string().uuid() });

// Tracked State Definitions
export const createTrackedStateDefInput = TrackedStateDef.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateTrackedStateDefInput = createTrackedStateDefInput.partial().extend({ id: z.string().uuid() });
export const GetTrackedStateDefByIdInput = z.object({ id: z.string().uuid() });
export const DeleteTrackedStateDefInput = z.object({ id: z.string().uuid() });

// State Entries
export const CreateStateEntryInput = StateEntry.omit({ id: true, user_id: true })
.extend({
  tracked_state_def_id: z.string().uuid(), // Ensure this is required
  // Values are optional in base schema
});
export const updateStateEntryInput = CreateStateEntryInput.partial().extend({ id: z.string().uuid() });
export const GetStateEntriesInput = z.object({
  tracked_state_def_id: z.string().uuid(), // Renamed from definition_id to match DB? Check usage.
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
  limit: z.number().int().positive().optional(),
});
export const DeleteStateEntryInput = z.object({ id: z.string().uuid() });

// Rewards (Assuming rewards definitions are managed elsewhere)
// No create/update for Reward definitions needed via API?
export const claimLootInput = z.object({
  rewardId: z.string().uuid(), // Use rewardId to match router
});

// Badges
export const awardBadgeInput = z.object({
  badgeId: z.string(), // Matches text ID in badge_definitions
  description: z.string().optional(), // Example custom field if needed
});

// Reminders
export const createReminderInput = Reminder.omit({ id: true, user_id: true, created_at: true, updated_at: true });
export const updateReminderInput = createReminderInput.partial().extend({ id: z.string().uuid() });
export const GetRemindersForEntityInput = z.object({
  related_entity_type: z.string(),
  related_entity_id: z.string().uuid(),
});
export const DeleteReminderInput = z.object({ id: z.string().uuid() });

// Goal Progress Notes
export const createGoalProgressNoteInput = GoalProgressNote.omit({ id: true, user_id: true, created_at: true });
export const updateGoalProgressNoteInput = createGoalProgressNoteInput.partial().extend({ id: z.string().uuid() });
export const GetGoalProgressNotesInput = z.object({ goal_id: z.string().uuid() });
export const DeleteGoalProgressNoteInput = z.object({ id: z.string().uuid() });

/* ------------------------------------------------------------------
 * Aggregate Router Types – automatically inferred
 * ----------------------------------------------------------------*/
export type RouterInputs = inferRouterInputs<AppRouter>;
export type RouterOutputs = inferRouterOutputs<AppRouter>;

/*
  Usage (client‑side):

  const utils = trpc.useUtils();
  type TasksOutput = RouterOutputs['task']['getTasks'];
  type CreateTaskInput = RouterInputs['task']['createTask'];
*/
  ```

### stores

- **stores/uiStore.ts** (0.3 KB, 12 lines) Exports: `useUiStore`

  ```ts
import { create } from 'zustand';

interface UiState {
  isDarkMode: boolean;
  toggleTheme: () => void;
}

// Simple Zustand store for UI state (e.g., theme)
export const useUiStore = create<UiState>((set) => ({
  isDarkMode: false, // Default to light mode
  toggleTheme: () => set((state) => ({ isDarkMode: !state.isDarkMode })),
})); 
  ```

### supabase

- **supabase/.gitignore** (0.1 KB, 9 lines) *(No explicit exports)*

  ```text
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local

  ```

- **supabase/config.toml** (10.9 KB, 309 lines) *(No explicit exports)*

  ```toml
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "AetherIphone"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 1

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"

  ```

### supabase/migrations

- **supabase/migrations/20250424033333_initial_schema.sql** (16.9 KB, 329 lines) *(No explicit exports)*

  ```sql
-- Enable UUID generation
create extension if not exists "uuid-ossp" with schema extensions;

-- === Profiles Table (From SUPABASE_INTEGRATION.md) ===
create table public.profiles (
  id uuid not null references auth.users on delete cascade primary key, -- Link directly to auth.users
  username text unique,
  avatar_url text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.profiles is 'Profile data for each user.';

-- Enable RLS
alter table public.profiles enable row level security;

-- Policies for profiles
create policy "Profiles are viewable by everyone." on public.profiles
  for select using (true);

create policy "Users can insert their own profile." on public.profiles
  for insert with check (auth.uid() = id);

create policy "Users can update their own profile." on public.profiles
  for update using (auth.uid() = id) with check (auth.uid() = id);

-- Function & Trigger to create profile on new user signup (From SUPABASE_INTEGRATION.md)
create or replace function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, username)
  values (new.id, new.raw_user_meta_data ->> 'username');
  return new;
end;
$$ language plpgsql security definer set search_path = public; -- Added search_path

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- === Values Table ===
create table public.values (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  name text not null,
  description text,
  color text, -- Stores color token like 'indigo-500'
  domain_id text, -- Optional grouping identifier
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.values is 'User-defined core values.';
alter table public.values enable row level security;

create policy "Users can view their own values" on public.values for select using (auth.uid() = user_id);
create policy "Users can insert their own values" on public.values for insert with check (auth.uid() = user_id);
create policy "Users can update their own values" on public.values for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own values" on public.values for delete using (auth.uid() = user_id);


-- === Goals Table ===
create table public.goals (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  title text not null,
  description text,
  progress numeric default 0 check (progress >= 0 and progress <= 1),
  target_date date, -- Changed from timestamp to date to match UI potentially
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.goals is 'User goals and objectives.';
alter table public.goals enable row level security;

create policy "Users can view their own goals" on public.goals for select using (auth.uid() = user_id);
create policy "Users can insert their own goals" on public.goals for insert with check (auth.uid() = user_id);
create policy "Users can update their own goals" on public.goals for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own goals" on public.goals for delete using (auth.uid() = user_id);


-- === Key Results Table ===
create table public.key_results (
  id uuid primary key default uuid_generate_v4(),
  goal_id uuid not null references public.goals(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade, -- Denormalized for RLS
  title text not null,
  progress numeric default 0 check (progress >= 0 and progress <= 1),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.key_results is 'Measurable results for achieving goals.';
alter table public.key_results enable row level security;

create policy "Users can view their own key results" on public.key_results for select using (auth.uid() = user_id);
create policy "Users can insert their own key results" on public.key_results for insert with check (auth.uid() = user_id);
create policy "Users can update their own key results" on public.key_results for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own key results" on public.key_results for delete using (auth.uid() = user_id);


-- === Tasks Table ===
-- Define enum for status first
create type public.task_status as enum ('todo', 'doing', 'done', 'blocked');

create table public.tasks (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  title text not null,
  notes text,
  status public.task_status default 'todo' not null,
  due date,
  priority int check (priority in (1, 2, 3)), -- Allow NULL or 1, 2, 3
  goal_id uuid references public.goals(id) on delete set null, -- Keep task if goal deleted
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.tasks is 'Individual tasks or to-do items.';
alter table public.tasks enable row level security;

create policy "Users can view their own tasks" on public.tasks for select using (auth.uid() = user_id);
create policy "Users can insert their own tasks" on public.tasks for insert with check (auth.uid() = user_id);
create policy "Users can update their own tasks" on public.tasks for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own tasks" on public.tasks for delete using (auth.uid() = user_id);


-- === Habits Table ===
create table public.habits (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  title text not null,
  cue text,
  routine text,
  reward text,
  -- value_ids text[], -- Will use join table instead
  streak int default 0 not null,
  best_streak int default 0 not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.habits is 'User habits to track.';
alter table public.habits enable row level security;

create policy "Users can view their own habits" on public.habits for select using (auth.uid() = user_id);
create policy "Users can insert their own habits" on public.habits for insert with check (auth.uid() = user_id);
create policy "Users can update their own habits" on public.habits for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own habits" on public.habits for delete using (auth.uid() = user_id);


-- === Habit Entries Table ===
create table public.habit_entries (
  id uuid primary key default uuid_generate_v4(),
  habit_id uuid not null references public.habits(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade, -- Denormalized for RLS
  date date not null,
  completed boolean default false not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(habit_id, date) -- Ensure only one entry per habit per day
);

comment on table public.habit_entries is 'Daily check-in records for habits.';
alter table public.habit_entries enable row level security;

create policy "Users can view their own habit entries" on public.habit_entries for select using (auth.uid() = user_id);
create policy "Users can insert their own habit entries" on public.habit_entries for insert with check (auth.uid() = user_id);
create policy "Users can update their own habit entries" on public.habit_entries for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own habit entries" on public.habit_entries for delete using (auth.uid() = user_id);


-- === Principles Table ===
create table public.principles (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  title text not null,
  body text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.principles is 'User-defined guiding principles.';
alter table public.principles enable row level security;

create policy "Users can view their own principles" on public.principles for select using (auth.uid() = user_id);
create policy "Users can insert their own principles" on public.principles for insert with check (auth.uid() = user_id);
create policy "Users can update their own principles" on public.principles for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own principles" on public.principles for delete using (auth.uid() = user_id);


-- === Tracked State Definitions Table ===
create type public.tracked_state_scale as enum ('1-5', 'low-high', 'custom');

create table public.tracked_state_defs (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  name text not null,
  scale public.tracked_state_scale not null,
  custom_labels text[], -- Only relevant if scale = 'custom'
  active boolean default true not null,
  priority int default 1 not null, -- For ordering
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.tracked_state_defs is 'Definitions of states users want to track (e.g., energy, focus).';
alter table public.tracked_state_defs enable row level security;

create policy "Users can view their own state definitions" on public.tracked_state_defs for select using (auth.uid() = user_id);
create policy "Users can insert their own state definitions" on public.tracked_state_defs for insert with check (auth.uid() = user_id);
create policy "Users can update their own state definitions" on public.tracked_state_defs for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own state definitions" on public.tracked_state_defs for delete using (auth.uid() = user_id);


-- === State Entries Table ===
create table public.state_entries (
  id uuid primary key default uuid_generate_v4(),
  definition_id uuid not null references public.tracked_state_defs(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade, -- Denormalized for RLS
  value_numeric smallint, -- Use for '1-5' scale
  value_text text, -- Use for 'low-high' or 'custom' scales
  entry_timestamp timestamp with time zone default timezone('utc'::text, now()) not null
);

comment on table public.state_entries is 'Recorded entries for tracked states.';
alter table public.state_entries enable row level security;

create policy "Users can view their own state entries" on public.state_entries for select using (auth.uid() = user_id);
create policy "Users can insert their own state entries" on public.state_entries for insert with check (auth.uid() = user_id);
create policy "Users can update their own state entries" on public.state_entries for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own state entries" on public.state_entries for delete using (auth.uid() = user_id);


-- === Badge Definitions Table ===
create table public.badge_definitions (
  id text primary key, -- e.g., '10_day_streak', 'first_goal'
  title text not null,
  description text,
  icon text not null -- e.g., emoji or icon library name
);

comment on table public.badge_definitions is 'Definitions of all achievable badges.';
-- Enable RLS but allow all authenticated users read access. Inserts/Updates/Deletes likely managed via admin/seed script.
alter table public.badge_definitions enable row level security;

create policy "Badge definitions are viewable by authenticated users"
  on public.badge_definitions for select
  using (auth.role() = 'authenticated');


-- === User Badges Table ===
create table public.user_badges (
  user_id uuid not null references public.profiles(id) on delete cascade,
  badge_id text not null references public.badge_definitions(id) on delete cascade,
  earned_at timestamp with time zone default timezone('utc'::text, now()) not null,
  progress numeric check (progress >= 0 and progress <= 1), -- For badges with progress
  primary key (user_id, badge_id)
);

comment on table public.user_badges is 'Tracks badges earned by users.';
alter table public.user_badges enable row level security;

create policy "Users can view their own earned badges" on public.user_badges for select using (auth.uid() = user_id);
-- Typically, inserting/updating badge progress/earned status is handled by backend logic (e.g., triggers, functions)
-- For simplicity here, allowing user modification, but review this for production security.
create policy "Users can insert their own earned badges" on public.user_badges for insert with check (auth.uid() = user_id);
create policy "Users can update their own badge progress" on public.user_badges for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own earned badges" on public.user_badges for delete using (auth.uid() = user_id);


-- === Join Tables for Values ===

-- goal_values
create table public.goal_values (
  goal_id uuid not null references public.goals(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade, -- For RLS
  primary key (goal_id, value_id)
);
comment on table public.goal_values is 'Links goals to values.';
alter table public.goal_values enable row level security;
create policy "Users can manage goal_values for their own goals/values" on public.goal_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- task_values
create table public.task_values (
  task_id uuid not null references public.tasks(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade, -- For RLS
  primary key (task_id, value_id)
);
comment on table public.task_values is 'Links tasks to values.';
alter table public.task_values enable row level security;
create policy "Users can manage task_values for their own tasks/values" on public.task_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- habit_values
create table public.habit_values (
  habit_id uuid not null references public.habits(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade, -- For RLS
  primary key (habit_id, value_id)
);
comment on table public.habit_values is 'Links habits to values.';
alter table public.habit_values enable row level security;
create policy "Users can manage habit_values for their own habits/values" on public.habit_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- principle_values
create table public.principle_values (
  principle_id uuid not null references public.principles(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade, -- For RLS
  primary key (principle_id, value_id)
);
comment on table public.principle_values is 'Links principles to values.';
alter table public.principle_values enable row level security;
create policy "Users can manage principle_values for their own principles/values" on public.principle_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- tracked_state_values
create table public.tracked_state_values (
  state_id uuid not null references public.tracked_state_defs(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade, -- For RLS
  primary key (state_id, value_id)
);
comment on table public.tracked_state_values is 'Links tracked state definitions to values.';
alter table public.tracked_state_values enable row level security;
create policy "Users can manage tracked_state_values for their own states/values" on public.tracked_state_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
  ```

- **supabase/migrations/20250424035232_add_missing_tables.sql** (0.0 KB, 1 lines) *(No explicit exports)*

  ```sql

  ```

- **supabase/migrations/20250424035717_add_missing_tables.sql** (11.7 KB, 210 lines) *(No explicit exports)*

  ```sql
-- Add missing tables, types, and RLS policies

-- === Values Table ===
create table public.values (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  name text not null,
  description text,
  color text,
  domain_id text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
comment on table public.values is 'User-defined core values.';
alter table public.values enable row level security;
create policy "Users can view their own values" on public.values for select using (auth.uid() = user_id);
create policy "Users can insert their own values" on public.values for insert with check (auth.uid() = user_id);
create policy "Users can update their own values" on public.values for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own values" on public.values for delete using (auth.uid() = user_id);

-- === Key Results Table ===
create table public.key_results (
  id uuid primary key default gen_random_uuid(),
  goal_id uuid not null references public.goals(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  title text not null,
  progress numeric default 0 check (progress >= 0 and progress <= 1),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
comment on table public.key_results is 'Measurable results for achieving goals.';
alter table public.key_results enable row level security;
create policy "Users can view their own key results" on public.key_results for select using (auth.uid() = user_id);
create policy "Users can insert their own key results" on public.key_results for insert with check (auth.uid() = user_id);
create policy "Users can update their own key results" on public.key_results for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own key results" on public.key_results for delete using (auth.uid() = user_id);

-- === Habits Table ===
create table public.habits (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  title text not null,
  cue text,
  routine text,
  reward text,
  streak int not null default 0,
  best_streak int not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
comment on table public.habits is 'User habits to track.';
alter table public.habits enable row level security;
create policy "Users can view their own habits" on public.habits for select using (auth.uid() = user_id);
create policy "Users can insert their own habits" on public.habits for insert with check (auth.uid() = user_id);
create policy "Users can update their own habits" on public.habits for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own habits" on public.habits for delete using (auth.uid() = user_id);

-- === Habit Entries Table ===
create table public.habit_entries (
  id uuid primary key default gen_random_uuid(),
  habit_id uuid not null references public.habits(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  date date not null,
  completed boolean not null default false,
  created_at timestamptz not null default now(),
  unique (habit_id, date)
);
comment on table public.habit_entries is 'Daily check-in records for habits.';
alter table public.habit_entries enable row level security;
create policy "Users can view their own habit entries" on public.habit_entries for select using (auth.uid() = user_id);
create policy "Users can insert their own habit entries" on public.habit_entries for insert with check (auth.uid() = user_id);
create policy "Users can update their own habit entries" on public.habit_entries for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own habit entries" on public.habit_entries for delete using (auth.uid() = user_id);

-- === Principles Table ===
create table public.principles (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  title text not null,
  body text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
comment on table public.principles is 'User-defined guiding principles.';
alter table public.principles enable row level security;
create policy "Users can view their own principles" on public.principles for select using (auth.uid() = user_id);
create policy "Users can insert their own principles" on public.principles for insert with check (auth.uid() = user_id);
create policy "Users can update their own principles" on public.principles for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own principles" on public.principles for delete using (auth.uid() = user_id);

-- === Tracked State Scale Enum ===
create type public.tracked_state_scale as enum ('1-5', 'low-high', 'custom');

-- === Tracked State Definitions Table ===
create table public.tracked_state_defs (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references public.profiles(id) on delete cascade,
  name text not null,
  scale public.tracked_state_scale not null,
  custom_labels text[],
  active boolean not null default true,
  priority int not null default 1,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
comment on table public.tracked_state_defs is 'Definitions of tracked states.';
alter table public.tracked_state_defs enable row level security;
create policy "Users can view their own state definitions" on public.tracked_state_defs for select using (auth.uid() = user_id);
create policy "Users can insert their own state definitions" on public.tracked_state_defs for insert with check (auth.uid() = user_id);
create policy "Users can update their own state definitions" on public.tracked_state_defs for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own state definitions" on public.tracked_state_defs for delete using (auth.uid() = user_id);

-- === State Entries Table ===
create table public.state_entries (
  id uuid primary key default gen_random_uuid(),
  definition_id uuid not null references public.tracked_state_defs(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  value_numeric smallint,
  value_text text,
  entry_timestamp timestamptz not null default now()
);
comment on table public.state_entries is 'Recorded entries for tracked states.';
alter table public.state_entries enable row level security;
create policy "Users can view their own state entries" on public.state_entries for select using (auth.uid() = user_id);
create policy "Users can insert their own state entries" on public.state_entries for insert with check (auth.uid() = user_id);
create policy "Users can update their own state entries" on public.state_entries for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own state entries" on public.state_entries for delete using (auth.uid() = user_id);

-- === Badge Definitions Table ===
create table public.badge_definitions (
  id text primary key,
  title text not null,
  description text,
  icon text not null
);
comment on table public.badge_definitions is 'Definitions of all achievable badges.';
alter table public.badge_definitions enable row level security;
create policy "Badge definitions are viewable by authenticated users" on public.badge_definitions for select using (auth.role() = 'authenticated');

-- === User Badges Table ===
create table public.user_badges (
  user_id uuid not null references public.profiles(id) on delete cascade,
  badge_id text not null references public.badge_definitions(id) on delete cascade,
  earned_at timestamptz not null default now(),
  progress numeric check (progress >= 0 and progress <= 1),
  primary key (user_id, badge_id)
);
comment on table public.user_badges is 'Tracks badges earned by users.';
alter table public.user_badges enable row level security;
create policy "Users can view their own earned badges" on public.user_badges for select using (auth.uid() = user_id);
create policy "Users can insert their own earned badges" on public.user_badges for insert with check (auth.uid() = user_id);
create policy "Users can update their own badge progress" on public.user_badges for update using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users can delete their own earned badges" on public.user_badges for delete using (auth.uid() = user_id);

-- === Join Tables for Values ===
-- goal_values
create table public.goal_values (
  goal_id uuid not null references public.goals(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  primary key (goal_id, value_id)
);
comment on table public.goal_values is 'Links goals to values.';
alter table public.goal_values enable row level security;
create policy "Users can manage goal_values" on public.goal_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- task_values
create table public.task_values (
  task_id uuid not null references public.tasks(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  primary key (task_id, value_id)
);
comment on table public.task_values is 'Links tasks to values.';
alter table public.task_values enable row level security;
create policy "Users can manage task_values" on public.task_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- habit_values
create table public.habit_values (
  habit_id uuid not null references public.habits(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  primary key (habit_id, value_id)
);
comment on table public.habit_values is 'Links habits to values.';
alter table public.habit_values enable row level security;
create policy "Users can manage habit_values" on public.habit_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- principle_values
create table public.principle_values (
  principle_id uuid not null references public.principles(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  primary key (principle_id, value_id)
);
comment on table public.principle_values is 'Links principles to values.';
alter table public.principle_values enable row level security;
create policy "Users can manage principle_values" on public.principle_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- tracked_state_values
create table public.tracked_state_values (
  state_id uuid not null references public.tracked_state_defs(id) on delete cascade,
  value_id uuid not null references public.values(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  primary key (state_id, value_id)
);
comment on table public.tracked_state_values is 'Links tracked states to values.';
alter table public.tracked_state_values enable row level security;
create policy "Users can manage tracked_state_values" on public.tracked_state_values for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

  ```

- **supabase/migrations/20250425000000_create_user_settings_table.sql** (1.8 KB, 55 lines) *(No explicit exports)*

  ```sql
-- Add user_settings table and policies

-- Create user_settings table
CREATE TABLE public.user_settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  notification_preferences JSONB NOT NULL DEFAULT '{"email": true, "push": true, "task_reminders": true, "goal_updates": true, "habit_reminders": true}'::jsonb,
  ui_preferences JSONB NOT NULL DEFAULT '{"theme": "system", "compact_view": false, "show_completed_tasks": true}'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Add comment for the table
COMMENT ON TABLE public.user_settings IS 'Stores user preferences and settings';

-- Enable row level security
ALTER TABLE public.user_settings ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view their own settings" 
  ON public.user_settings 
  FOR SELECT 
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own settings" 
  ON public.user_settings 
  FOR INSERT 
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own settings" 
  ON public.user_settings 
  FOR UPDATE 
  USING (auth.uid() = user_id) 
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own settings" 
  ON public.user_settings 
  FOR DELETE 
  USING (auth.uid() = user_id);

-- Add function to create default settings on user creation
CREATE OR REPLACE FUNCTION public.create_default_user_settings()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.user_settings (user_id)
  VALUES (NEW.id);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add trigger to create default settings when a new profile is created
CREATE TRIGGER on_profile_created
  AFTER INSERT ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.create_default_user_settings(); 
  ```

- **supabase/migrations/20250426000000_create_rewards_tables.sql** (5.6 KB, 149 lines) *(No explicit exports)*

  ```sql
-- Create rewards tables and related schemas

-- Rewards table for different types of rewards (badges, achievements, etc.)
CREATE TABLE public.rewards (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  type TEXT NOT NULL CHECK (type IN ('badge', 'achievement', 'item', 'discount')),
  required_points INTEGER NOT NULL DEFAULT 0,
  can_earn_multiple BOOLEAN NOT NULL DEFAULT FALSE,
  image_url TEXT,
  metadata JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON TABLE public.rewards IS 'Available rewards that users can earn';

-- Junction table for user-earned rewards
CREATE TABLE public.user_rewards (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reward_id UUID NOT NULL REFERENCES public.rewards(id) ON DELETE CASCADE,
  reward_type TEXT, -- Denormalized for easier querying
  earned_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  points_spent INTEGER NOT NULL DEFAULT 0,
  metadata JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (user_id, reward_id) -- Only when can_earn_multiple is false
);

COMMENT ON TABLE public.user_rewards IS 'Rewards earned by users';

-- Point transactions table to track point history
CREATE TABLE public.point_transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  points INTEGER NOT NULL,
  reason TEXT NOT NULL,
  source_type TEXT NOT NULL,
  source_id UUID,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON TABLE public.point_transactions IS 'History of point transactions';

-- Add points columns to profiles if they don't exist
ALTER TABLE public.profiles 
ADD COLUMN IF NOT EXISTS points INTEGER NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS lifetime_points INTEGER NOT NULL DEFAULT 0;

-- Enable RLS
ALTER TABLE public.rewards ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_rewards ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.point_transactions ENABLE ROW LEVEL SECURITY;

-- RLS Policies

-- Rewards policies (public read, admin write)
CREATE POLICY "Anyone can view rewards" 
  ON public.rewards 
  FOR SELECT 
  USING (true);

-- User rewards policies (user can see their own)
CREATE POLICY "Users can view their rewards" 
  ON public.user_rewards 
  FOR SELECT 
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their rewards" 
  ON public.user_rewards 
  FOR INSERT 
  WITH CHECK (auth.uid() = user_id);

-- Point transactions policies (user can see their own)
CREATE POLICY "Users can view their point transactions" 
  ON public.point_transactions 
  FOR SELECT 
  USING (auth.uid() = user_id);

-- Insert some sample rewards
INSERT INTO public.rewards (name, description, type, required_points, can_earn_multiple, image_url)
VALUES
  ('Early Bird', 'Complete 5 tasks before 9 AM', 'badge', 0, false, 'https://api.dicebear.com/7.x/icons/svg?icon=coffee'),
  ('Task Master', 'Complete 100 tasks', 'achievement', 0, false, 'https://api.dicebear.com/7.x/icons/svg?icon=checkSquare'),
  ('Habit Hero', 'Maintain a streak for 30 days', 'achievement', 0, false, 'https://api.dicebear.com/7.x/icons/svg?icon=award'),
  ('Goal Getter', 'Complete 10 goals', 'achievement', 0, false, 'https://api.dicebear.com/7.x/icons/svg?icon=target'),
  ('Theme Customization', 'Unlock custom themes', 'item', 500, false, 'https://api.dicebear.com/7.x/icons/svg?icon=palette'),
  ('Icon Pack', 'Unlock premium icons', 'item', 300, false, 'https://api.dicebear.com/7.x/icons/svg?icon=image'),
  ('Weekly Booster', 'Double points for one week', 'item', 200, true, 'https://api.dicebear.com/7.x/icons/svg?icon=zap'),
  ('Perfectionist', 'Complete all tasks for a week', 'badge', 0, true, 'https://api.dicebear.com/7.x/icons/svg?icon=clipboard');

-- Create function to award points on habit completion
CREATE OR REPLACE FUNCTION public.award_points_for_habit_completion()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.completed = true THEN
    -- Insert a point transaction
    INSERT INTO public.point_transactions (user_id, points, reason, source_type, source_id)
    VALUES (NEW.user_id, 10, 'Completed habit', 'habit', NEW.habit_id);
    
    -- Update user points
    UPDATE public.profiles
    SET 
      points = points + 10,
      lifetime_points = lifetime_points + 10
    WHERE id = NEW.user_id;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger for habit entries to award points
CREATE TRIGGER on_habit_entry_completed
  AFTER INSERT OR UPDATE ON public.habit_entries
  FOR EACH ROW
  WHEN (NEW.completed = true)
  EXECUTE FUNCTION public.award_points_for_habit_completion();

-- Create function to award points on task completion
CREATE OR REPLACE FUNCTION public.award_points_for_task_completion()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN
    -- Insert a point transaction
    INSERT INTO public.point_transactions (user_id, points, reason, source_type, source_id)
    VALUES (NEW.user_id, 5, 'Completed task', 'task', NEW.id);
    
    -- Update user points
    UPDATE public.profiles
    SET 
      points = points + 5,
      lifetime_points = lifetime_points + 5
    WHERE id = NEW.user_id;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger for tasks to award points
CREATE TRIGGER on_task_completed
  AFTER INSERT OR UPDATE ON public.tasks
  FOR EACH ROW
  WHEN (NEW.status = 'completed')
  EXECUTE FUNCTION public.award_points_for_task_completion(); 
  ```

- **supabase/migrations/20250428124230_standardize_field_naming.sql** (1.0 KB, 22 lines) *(No explicit exports)*

  ```sql
-- Migration: Standardize field naming (name → title)
-- Description: Ensure consistency across the database by standardizing on 'title' instead of 'name'

-- This migration doesn't need to modify tables that already use 'title' consistently
-- Based on database inspection, most tables already use 'title' correctly

-- Values table: Rename 'name' to 'title'
ALTER TABLE "public"."values" RENAME COLUMN "name" TO "title";

-- Update triggers and functions if they reference these columns
-- For any downstream foreign key constraints, they should continue to work since we're just renaming columns

-- Update any indexes that might reference the old column names
DROP INDEX IF EXISTS "public"."values_name_idx";
CREATE INDEX IF NOT EXISTS "values_title_idx" ON "public"."values" ("title");

-- Update any views that might reference the old column names
-- (Add appropriate view updates if needed)

-- Note: This migration assumes 'values' is the primary table needing column renaming
-- based on code inspection. If other tables need similar treatment, add them here.

  ```

- **supabase/migrations/20250428130834_enhance_functional_schema.sql** (11.6 KB, 266 lines) *(No explicit exports)*

  ```sql
-- supabase/migrations/20250428130834_enhance_functional_schema.sql
-- Migration: Enhance DB Schema for Aether App Functionality
-- Description: Addresses functional gaps identified in user experience review.

-- === Enums and Types ===

-- Task Status Enum (Reintroduce for better type safety)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'task_status') THEN
        CREATE TYPE public.task_status AS ENUM ('todo', 'doing', 'done', 'blocked', 'pending'); -- Add 'pending' if used
    END IF;
END$$;

-- Task Priority Enum (Change from INT for clarity)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'task_priority') THEN
        CREATE TYPE public.task_priority AS ENUM ('low', 'medium', 'high');
    END IF;
END$$;

-- Reward Type Enum
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'reward_type') THEN
        CREATE TYPE public.reward_type AS ENUM ('badge', 'achievement', 'item', 'discount');
    END IF;
END$$;

-- Habit Type Enum
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'habit_type') THEN
        CREATE TYPE public.habit_type AS ENUM ('boolean', 'quantity');
    END IF;
END$$;

-- Habit Frequency Period Enum (Add if missing or confirm existence)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'habit_frequency_period') THEN
        CREATE TYPE public.habit_frequency_period AS ENUM ('day', 'week', 'month');
    END IF;
END$$;

-- === Table Enhancements ===

-- 1. Tasks Table Enhancements
ALTER TABLE public.tasks
  ADD COLUMN IF NOT EXISTS recurrence_rule TEXT NULL, -- For iCalendar RRULE strings
  ADD COLUMN IF NOT EXISTS recurrence_end_date DATE NULL,
  ADD COLUMN IF NOT EXISTS parent_task_id UUID NULL REFERENCES public.tasks(id) ON DELETE SET NULL,
  ADD COLUMN IF NOT EXISTS archived_at TIMESTAMPTZ NULL,
  ADD COLUMN IF NOT EXISTS sort_order INTEGER NULL;

-- Temporarily drop the trigger that depends on the tasks.status column
DROP TRIGGER IF EXISTS on_task_completed ON public.tasks;

-- Alter task status to use ENUM (Assuming 'pending' might be used based on router)
-- Drop default constraint if it exists
ALTER TABLE public.tasks ALTER COLUMN status DROP DEFAULT;
-- Alter column type
ALTER TABLE public.tasks
  ALTER COLUMN status TYPE public.task_status USING status::public.task_status;
-- Add default back if needed
ALTER TABLE public.tasks ALTER COLUMN status SET DEFAULT 'todo';

-- Recreate the trigger (Ensure the function award_points_for_task_completion still works correctly with the enum type)
-- The function likely still works as it compares with a string literal 'completed', which should match the enum
CREATE TRIGGER on_task_completed
  AFTER INSERT OR UPDATE ON public.tasks
  FOR EACH ROW
  WHEN (NEW.status::text = 'done') -- Explicitly cast NEW.status to text for comparison, or adjust if needed
  EXECUTE FUNCTION public.award_points_for_task_completion();

-- Alter task priority to use ENUM
ALTER TABLE public.tasks
  ADD COLUMN IF NOT EXISTS priority_enum public.task_priority NULL;

-- (Manual step recommended after migration: migrate data from priority (int) to priority_enum, then drop old priority column and rename)
-- Example (Run this manually or in a separate script after checking data):
-- UPDATE public.tasks SET priority_enum = 
--   CASE
--     WHEN priority = 1 THEN 'high'::public.task_priority
--     WHEN priority = 2 THEN 'medium'::public.task_priority
--     WHEN priority = 3 THEN 'low'::public.task_priority -- Assuming 1=High, 3=Low
--     ELSE NULL
--   END;
-- ALTER TABLE public.tasks DROP COLUMN priority;
-- ALTER TABLE public.tasks RENAME COLUMN priority_enum TO priority;

-- Add Indexes
CREATE INDEX IF NOT EXISTS idx_tasks_archived_at ON public.tasks(archived_at);
CREATE INDEX IF NOT EXISTS idx_tasks_sort_order ON public.tasks(sort_order);
CREATE INDEX IF NOT EXISTS idx_tasks_parent_task_id ON public.tasks(parent_task_id);

COMMENT ON COLUMN public.tasks.recurrence_rule IS 'iCalendar RRULE string for recurrence.';
COMMENT ON COLUMN public.tasks.parent_task_id IS 'Link to parent task for sub-tasks.';
COMMENT ON COLUMN public.tasks.archived_at IS 'Timestamp when the task was archived.';
COMMENT ON COLUMN public.tasks.sort_order IS 'Manual sort order within a list.';

-- Task Dependencies (Optional - Use if many-to-many needed)
-- CREATE TABLE public.task_dependencies (
--   task_id UUID NOT NULL REFERENCES public.tasks(id) ON DELETE CASCADE,
--   depends_on_task_id UUID NOT NULL REFERENCES public.tasks(id) ON DELETE CASCADE,
--   user_id uuid not null references public.profiles(id) on delete cascade, -- For RLS
--   PRIMARY KEY (task_id, depends_on_task_id)
-- );
-- COMMENT ON TABLE public.task_dependencies IS 'Tracks dependencies between tasks.';
-- alter table public.task_dependencies enable row level security;
-- create policy "Users can manage task_dependencies for their own tasks" on public.task_dependencies for all using (auth.uid() = user_id) with check (auth.uid() = user_id);


-- 2. Habits Table Enhancements
ALTER TABLE public.habits
  ADD COLUMN IF NOT EXISTS recurrence_rule TEXT NULL, -- For iCalendar RRULE strings
  ADD COLUMN IF NOT EXISTS recurrence_end_date DATE NULL,
  ADD COLUMN IF NOT EXISTS archived_at TIMESTAMPTZ NULL,
  ADD COLUMN IF NOT EXISTS habit_type public.habit_type NOT NULL DEFAULT 'boolean',
  ADD COLUMN IF NOT EXISTS goal_quantity INTEGER NULL,
  ADD COLUMN IF NOT EXISTS goal_unit TEXT NULL,
  ADD COLUMN IF NOT EXISTS frequency_period public.habit_frequency_period NOT NULL DEFAULT 'day', -- Add frequency tracking
  ADD COLUMN IF NOT EXISTS goal_frequency SMALLINT NOT NULL DEFAULT 1; -- Add frequency tracking

-- Add Indexes
CREATE INDEX IF NOT EXISTS idx_habits_archived_at ON public.habits(archived_at);

COMMENT ON COLUMN public.habits.recurrence_rule IS 'iCalendar RRULE string for recurrence.';
COMMENT ON COLUMN public.habits.archived_at IS 'Timestamp when the habit was archived.';
COMMENT ON COLUMN public.habits.habit_type IS 'Type of habit (e.g., boolean check-in or quantity tracking).';
COMMENT ON COLUMN public.habits.goal_quantity IS 'Target quantity for quantity-based habits.';
COMMENT ON COLUMN public.habits.goal_unit IS 'Unit for quantity-based habits (e.g., glasses, km).';
COMMENT ON COLUMN public.habits.frequency_period IS 'Period for habit frequency (day, week, month).';
COMMENT ON COLUMN public.habits.goal_frequency IS 'How many times per period the habit should be done.';


-- 3. Habit Entries Table Enhancements
ALTER TABLE public.habit_entries
  ADD COLUMN IF NOT EXISTS quantity_value INTEGER NULL,
  ADD COLUMN IF NOT EXISTS notes TEXT NULL;

COMMENT ON COLUMN public.habit_entries.quantity_value IS 'Value recorded for quantity-based habits.';
COMMENT ON COLUMN public.habit_entries.notes IS 'User notes for a specific habit entry.';


-- 4. Goals Table Enhancements
ALTER TABLE public.goals
  ADD COLUMN IF NOT EXISTS archived_at TIMESTAMPTZ NULL,
  ADD COLUMN IF NOT EXISTS sort_order INTEGER NULL;

-- Add Indexes
CREATE INDEX IF NOT EXISTS idx_goals_archived_at ON public.goals(archived_at);
CREATE INDEX IF NOT EXISTS idx_goals_sort_order ON public.goals(sort_order);

COMMENT ON COLUMN public.goals.archived_at IS 'Timestamp when the goal was archived.';
COMMENT ON COLUMN public.goals.sort_order IS 'Manual sort order for goals.';


-- 5. Values Table Enhancements
ALTER TABLE public.values
  ADD COLUMN IF NOT EXISTS sort_order INTEGER NULL;

-- Add Indexes
CREATE INDEX IF NOT EXISTS idx_values_sort_order ON public.values(sort_order);

COMMENT ON COLUMN public.values.sort_order IS 'Manual sort order for values.';


-- 6. Principles Table Enhancements
ALTER TABLE public.principles
  ADD COLUMN IF NOT EXISTS sort_order INTEGER NULL;

-- Add Indexes
CREATE INDEX IF NOT EXISTS idx_principles_sort_order ON public.principles(sort_order);

COMMENT ON COLUMN public.principles.sort_order IS 'Manual sort order for principles.';


-- 7. State Entries Table Enhancements
ALTER TABLE public.state_entries
  ADD COLUMN IF NOT EXISTS notes TEXT NULL;

COMMENT ON COLUMN public.state_entries.notes IS 'User notes for a specific state entry.';


-- 8. Tracked State Definitions Enhancements
ALTER TABLE public.tracked_state_defs
  ADD COLUMN IF NOT EXISTS target_min_value NUMERIC NULL,
  ADD COLUMN IF NOT EXISTS target_max_value NUMERIC NULL;

COMMENT ON COLUMN public.tracked_state_defs.target_min_value IS 'Optional minimum target value for the tracked state.';
COMMENT ON COLUMN public.tracked_state_defs.target_max_value IS 'Optional maximum target value for the tracked state.';


-- 9. Rewards Table Enhancements (Use Enum)

-- Drop the existing text-based CHECK constraint first
-- Note: The constraint name might vary. Find the actual name if this fails.
-- You can find it using SQL: SELECT conname FROM pg_constraint WHERE conrelid = 'public.rewards'::regclass AND contype = 'c' AND conname LIKE '%type%';
-- Assuming a default name pattern here:
ALTER TABLE public.rewards DROP CONSTRAINT IF EXISTS rewards_type_check;

-- Alter rewards type to use ENUM
ALTER TABLE public.rewards
  ALTER COLUMN type TYPE public.reward_type USING type::public.reward_type;


-- === New Tables ===

-- 1. Reminders Table
CREATE TABLE IF NOT EXISTS public.reminders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  related_entity_type TEXT NOT NULL, -- e.g., 'task', 'goal', 'habit'
  related_entity_id UUID NOT NULL, -- FK cannot easily reference multiple tables, handled by app logic/RLS
  reminder_time TIMESTAMPTZ NOT NULL,
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON TABLE public.reminders IS 'Stores scheduled reminders for various entities.';
ALTER TABLE public.reminders ENABLE ROW LEVEL SECURITY;
CREATE INDEX IF NOT EXISTS idx_reminders_user_time ON public.reminders(user_id, reminder_time);
CREATE INDEX IF NOT EXISTS idx_reminders_related_entity ON public.reminders(related_entity_type, related_entity_id);

-- RLS Policies for Reminders
CREATE POLICY "Users can manage their own reminders" ON public.reminders
  FOR ALL
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);


-- 2. Goal Progress Notes Table
CREATE TABLE IF NOT EXISTS public.goal_progress_notes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  goal_id UUID NOT NULL REFERENCES public.goals(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE, -- Denormalized for RLS
  note TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON TABLE public.goal_progress_notes IS 'Stores notes related to goal progress updates.';
ALTER TABLE public.goal_progress_notes ENABLE ROW LEVEL SECURITY;
CREATE INDEX IF NOT EXISTS idx_goal_progress_notes_goal_id ON public.goal_progress_notes(goal_id);

-- RLS Policies for Goal Progress Notes
CREATE POLICY "Users can manage notes for their own goals" ON public.goal_progress_notes
  FOR ALL
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- === Function/Trigger Updates (Example - Needs Review) ===

-- Update function/trigger for habit completion points if habit_type is added
-- (This is just illustrative, review existing functions like award_points_for_habit_completion)
-- Example: Maybe points depend on habit_type or goal_quantity?

-- Update function/trigger for task completion points if priority changes type
-- (Review existing functions like award_points_for_task_completion)

-- Note: Ensure existing RLS policies adequately cover new columns or create specific policies if needed.
-- Note: Consider adding foreign key constraints for related_entity_id in reminders if feasible,
--       otherwise enforce relationship integrity at the application level.

  ```

### utils

- **utils/api-types.ts** (0.6 KB, 22 lines) Exports: `RouterInputs`, `RouterOutputs`

  ```ts
/**
 * This file was auto-generated by the generate-trpc-types script.
 * Do not edit manually! Instead, run the script again.
 */

import type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from '../server/src/router';

/**
 * Inference helper for inputs.
 *
 * @example type HelloInput = RouterInputs['example']['hello']
 */
export type RouterInputs = inferRouterInputs<AppRouter>;

/**
 * Inference helper for outputs.
 *
 * @example type HelloOutput = RouterOutputs['example']['hello']
 */
export type RouterOutputs = inferRouterOutputs<AppRouter>;

  ```

- **utils/auth.ts** (1.2 KB, 52 lines) Exports: `getUserProfile`, `logout`

  ```ts
import { supabase } from './supabase';
import { router } from 'expo-router';

/**
 * Logs the user out and redirects to the login screen
 */
export async function logout() {
  try {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
    
    // Navigate to login screen
    router.replace('/auth/login');
  } catch (error) {
    console.error('Error signing out:', error);
    // Force navigation even if there was an error
    router.replace('/auth/login');
  }
}

/**
 * Gets the current user's profile data
 */
export async function getUserProfile() {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) return null;
    
    // If we have a user, get their profile from the profiles table
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', user.id)
      .single();
    
    if (error) {
      // If profile doesn't exist yet, return basic user info
      return {
        id: user.id,
        email: user.email,
        username: user.user_metadata?.username || 'User',
        created_at: user.created_at,
      };
    }
    
    return data;
  } catch (error) {
    console.error('Error getting user profile:', error);
    return null;
  }
} 
  ```

- **utils/colors.ts** (4.9 KB, 213 lines) Exports: `palette`, `semanticTokens`, `useColors`, `withOpacity`

  ```ts
import { useTheme } from 'tamagui';

/**
 * Semantic color tokens that map to theme variables
 */
export const semanticTokens = {
  // Background colors
  background: {
    /** Main app background */
    app: '$background',
    /** Card/surface background */
    card: '$backgroundHover',
    /** Secondary surface background */
    secondary: '$backgroundPress',
    /** Tertiary surface background */
    tertiary: '$backgroundStrong',
    /** Input background */
    input: '$backgroundTransparent',
  },
  
  // Foreground/content colors
  content: {
    /** Primary text */
    primary: '$color',
    /** Secondary/dimmed text */
    secondary: '$colorTransparent',
    /** Subtle text - least emphasis */
    subtle: '$colorTransparent2',
    /** Disabled text */
    disabled: '$colorTransparent3',
  },
  
  // Border colors
  border: {
    /** Default border */
    default: '$borderColor',
    /** Focused border */
    focus: '$borderColorFocus',
    /** Border for hover state */
    hover: '$borderColorHover',
  },
  
  // Status colors
  status: {
    /** Success indicators */
    success: '$green10',
    /** Error indicators */
    error: '$red10',
    /** Warning indicators */
    warning: '$yellow10',
    /** Information indicators */
    info: '$blue10',
  },
  
  // Brand colors (adjust to match your brand)
  brand: {
    /** Primary brand color */
    primary: '$blue10',
    /** Secondary brand color */
    secondary: '$purple10',
    /** Accent brand color */
    accent: '$green10',
  }
};

/**
 * Hook that provides access to theme-aware colors from the semantic tokens
 * @returns An object with semantic color tokens mapped to actual theme colors
 */
export function useColors() {
  const theme = useTheme();
  
  return {
    background: {
      app: theme?.background?.get() || '#FFFFFF',
      card: theme?.backgroundHover?.get() || '#F3F4F6',
      secondary: theme?.backgroundPress?.get() || '#E5E7EB',
      tertiary: theme?.backgroundStrong?.get() || '#D1D5DB',
      input: theme?.backgroundTransparent?.get() || '#FFFFFF',
    },
    content: {
      primary: theme?.color?.get() || '#111827',
      secondary: theme?.colorTransparent?.get() || '#4B5563',
      subtle: theme?.colorTransparent2?.get() || theme?.colorTransparent?.get() || '#6B7280',
      disabled: theme?.colorTransparent3?.get() || theme?.colorTransparent?.get() || '#9CA3AF',
    },
    border: {
      default: theme?.borderColor?.get() || '#E5E7EB',
      focus: theme?.borderColorFocus?.get() || '#93C5FD',
      hover: theme?.borderColorHover?.get() || '#BFDBFE',
    },
    status: {
      success: theme?.green10?.get() || '#10B981',
      error: theme?.red10?.get() || '#EF4444',
      warning: theme?.yellow10?.get() || '#F59E0B',
      info: theme?.blue10?.get() || '#3B82F6',
    },
    brand: {
      primary: theme?.blue10?.get() || '#3B82F6',
      secondary: theme?.purple10?.get() || '#8B5CF6',
      accent: theme?.green10?.get() || '#10B981',
    }
  };
}

/**
 * Helper function to handle opacity for colors
 * @param hex Hex color code
 * @param alpha Opacity (0-1)
 * @returns RGBA color string
 */
export function withOpacity(hex: string, alpha: number): string {
  // Extract RGB components from hex
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

/**
 * Palette with static color values for when theme context is not available
 * These should be used sparingly, prefer the useColors hook when possible
 */
export const palette = {
  // Main UI colors
  black: '#000000',
  white: '#FFFFFF',
  
  // Grays
  gray: {
    50: '#F9FAFB',
    100: '#F3F4F6',
    200: '#E5E7EB',
    300: '#D1D5DB',
    400: '#9CA3AF',
    500: '#6B7280',
    600: '#4B5563',
    700: '#374151',
    800: '#1F2937',
    900: '#111827',
  },
  
  // Blues
  blue: {
    50: '#EFF6FF',
    100: '#DBEAFE',
    200: '#BFDBFE',
    300: '#93C5FD',
    400: '#60A5FA',
    500: '#3B82F6',
    600: '#2563EB',
    700: '#1D4ED8',
    800: '#1E40AF',
    900: '#1E3A8A',
  },
  
  // Greens
  green: {
    50: '#ECFDF5',
    100: '#D1FAE5',
    200: '#A7F3D0',
    300: '#6EE7B7',
    400: '#34D399',
    500: '#10B981',
    600: '#059669',
    700: '#047857',
    800: '#065F46',
    900: '#064E3B',
  },
  
  // Reds
  red: {
    50: '#FEF2F2',
    100: '#FEE2E2',
    200: '#FECACA',
    300: '#FCA5A5',
    400: '#F87171',
    500: '#EF4444',
    600: '#DC2626',
    700: '#B91C1C',
    800: '#991B1B',
    900: '#7F1D1D',
  },
  
  // Yellows
  yellow: {
    50: '#FFFBEB',
    100: '#FEF3C7',
    200: '#FDE68A',
    300: '#FCD34D',
    400: '#FBBF24',
    500: '#F59E0B',
    600: '#D97706',
    700: '#B45309',
    800: '#92400E',
    900: '#78350F',
  },
  
  // Purples
  purple: {
    50: '#F5F3FF',
    100: '#EDE9FE',
    200: '#DDD6FE',
    300: '#C4B5FD',
    400: '#A78BFA',
    500: '#8B5CF6',
    600: '#7C3AED',
    700: '#6D28D9',
    800: '#5B21B6',
    900: '#4C1D95',
  },
}; 
  ```

- **utils/generated-hooks.ts** (1.3 KB, 72 lines) Exports: `useDashboard`, `useGoal`, `useGoalProgressNote`, `useHabit`, `usePrinciple`, `useReminder`, `useRewards`, `useState`, `useTask`, `useUser`, `useValue`

  ```ts
/**
 * GENERATED FILE - DO NOT EDIT
 * This file is automatically generated by the generate-trpc-client script.
 * To update this file, run: npm run generate-hooks
 */

import { trpc } from './trpc';
import { RouterInputs, RouterOutputs } from '../server/src/types/trpc-types';

/**
 * Type-safe hooks for TRPC procedures
 */

// user hooks
export const useUser = {
  // Add strongly typed hooks here
};

// dashboard hooks
export const useDashboard = {
  // Add strongly typed hooks here
};

// value hooks
export const useValue = {
  // Add strongly typed hooks here
};

// principle hooks
export const usePrinciple = {
  // Add strongly typed hooks here
};

// goal hooks
export const useGoal = {
  // Add strongly typed hooks here
};

// task hooks
export const useTask = {
  // Add strongly typed hooks here
};

// habit hooks
export const useHabit = {
  // Add strongly typed hooks here
};

// state hooks
export const useState = {
  // Add strongly typed hooks here
};

// rewards hooks
export const useRewards = {
  // Add strongly typed hooks here
};

// reminder hooks
export const useReminder = {
  // Add strongly typed hooks here
};

// goalProgressNote hooks
export const useGoalProgressNote = {
  // Add strongly typed hooks here
};


// Example type usage
type GreetingOutput = RouterOutputs['greeting']['hello'];

  ```

- **utils/haptics.ts** (1.2 KB, 42 lines) Exports: `haptics`

  ```ts
import * as Haptics from 'expo-haptics';

/**
 * Haptic feedback utilities for iOS-style tactile feedback
 * Maps directly to iOS UIFeedbackGenerator patterns
 */
export const haptics = {
  /**
   * Light impact - subtle tap for small UI elements (buttons, toggles)
   */
  light: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light),
  
  /**
   * Medium impact - standard tap for medium elements (picker selections)
   */
  medium: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium),
  
  /**
   * Heavy impact - stronger bump for significant actions
   */
  heavy: () => Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy),
  
  /**
   * Selection feedback - subtle tap for navigating through options
   */
  selection: () => Haptics.selectionAsync(),
  
  /**
   * Success notification - double-tap vibration for completed actions
   */
  success: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success),
  
  /**
   * Warning notification - attention-grabbing pattern for warnings
   */
  warning: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning),
  
  /**
   * Error notification - strong buzz pattern for errors
   */
  error: () => Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error),
}; 
  ```

- **utils/mock-api.ts** (2.3 KB, 82 lines) Exports: `appRouter`, `AppRouter`

  ```ts
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

// Initialize tRPC for our mock API
const t = initTRPC.create();

// Export a procedure builder
const router = t.router;
const publicProcedure = t.procedure;

// Example router with some procedures
export const appRouter = router({
  greeting: {
    hello: publicProcedure
      .input(z.object({ name: z.string().optional() }))
      .query(({ input }) => {
        return {
          greeting: `Hello ${input.name ?? 'world'}`,
        };
      }),
    goodbye: publicProcedure
      .query(() => {
        return {
          greeting: 'Goodbye!',
        };
      }),
  },
  user: {
    get: publicProcedure
      .input(z.object({ id: z.string() }))
      .query(({ input }) => {
        return {
          id: input.id,
          name: 'Mock User',
        };
      }),
    list: publicProcedure
      .query(() => {
        return [
          { id: '1', name: 'Mock User 1' },
          { id: '2', name: 'Mock User 2' },
        ];
      }),
  },
  auth: {
    refreshToken: publicProcedure
      .input(z.object({ refreshToken: z.string() }))
      .mutation(async ({ input }) => {
        console.log('Mock API: refreshToken called with', input.refreshToken);
        // Simulate checking refresh token and issuing new ones
        await new Promise(resolve => setTimeout(resolve, 300));
        if (input.refreshToken === 'valid-refresh-token') { // Example valid token
          return {
            accessToken: `mock-access-${Date.now()}`,
            refreshToken: `mock-refresh-${Date.now()}`,
          };
        } else {
          // Throw error for invalid refresh token
          throw new Error('Invalid refresh token'); 
        }
      }),
    // Add login/logout mutations here later
  },
  item: {
    add: publicProcedure
      .input(z.object({ name: z.string() }))
      .mutation(async ({ input }) => {
        // Simulate network delay
        await new Promise(resolve => setTimeout(resolve, 500));
        // In a real backend, save to DB
        console.log('Mock API: Adding item', input);
        return {
          id: Math.random().toString(36).substring(7), // Generate random ID
          name: input.name,
          status: 'added'
        };
      }),
  },
});

// Export type router type
export type AppRouter = typeof appRouter; 
  ```

- **utils/nats-client.ts** (4.5 KB, 173 lines) Exports: `addSubjectHandler`, `closeNatsConnection`, `getNatsConnection`, `initNatsClient`, `subscribeWithCache`

  ```ts
import { QueryClient } from '@tanstack/react-query';
import { connect, type ConnectionOptions, type NatsConnection, StringCodec } from 'nats.ws';

// Codec for encoding/decoding NATS messages
const sc = StringCodec();

// Type for cache update handlers
type CacheUpdateHandler = (data: any) => void;

// Global handlers for different subjects
const handlers: Record<string, CacheUpdateHandler[]> = {};

// Connection state
let natsConnection: NatsConnection | null = null;
let queryClient: QueryClient | null = null;
let isConnecting = false;

/**
 * Initialize the NATS client and connect to the server
 */
export async function initNatsClient(
  url: string, 
  qc: QueryClient,
  options: Partial<ConnectionOptions> = {}
): Promise<NatsConnection> {
  if (natsConnection) {
    return natsConnection;
  }
  
  if (isConnecting) {
    throw new Error('NATS connection is already in progress');
  }
  
  isConnecting = true;
  
  try {
    // Set the query client for cache updates
    queryClient = qc;
    
    // Connect to NATS server
    natsConnection = await connect({
      servers: url,
      // Add required polyfills for React Native
      // These would need to be properly implemented in a real app
      ...options,
    });
    
    console.log('Connected to NATS server');
    
    // Setup ping interval to keep connection alive
    const pingInterval = setInterval(() => {
      if (natsConnection && !natsConnection.isClosed) {
        // Note: Using a custom ping mechanism instead of the built-in one
        try {
          const start = Date.now();
          // Simple ping using a request to a dummy subject
          natsConnection.request('_PING_', undefined, { timeout: 1000 })
            .then(() => {
              const latency = Date.now() - start;
              console.log(`NATS server latency: ${latency}ms`);
            })
            .catch((err: Error) => {
              console.error('NATS ping error:', err.message);
            });
        } catch (err) {
          const error = err as Error;
          console.error('NATS ping error:', error.message);
        }
      } else {
        clearInterval(pingInterval);
      }
    }, 30000);
    
    // Handle connection close
    natsConnection.closed().then(() => {
      console.log('NATS connection closed');
      natsConnection = null;
      clearInterval(pingInterval);
      // Could implement reconnection logic here
    });
    
    return natsConnection;
  } catch (error) {
    console.error('Failed to connect to NATS server:', error);
    isConnecting = false;
    throw error;
  }
}

/**
 * Subscribe to a NATS subject and update the React Query cache
 */
export async function subscribeWithCache(
  subject: string,
  queryKey: unknown[],
  updateType: 'invalidate' | 'setData' = 'invalidate'
): Promise<() => void> {
  if (!natsConnection) {
    throw new Error('NATS client not initialized');
  }
  
  if (!queryClient) {
    throw new Error('QueryClient not set');
  }
  
  // Create subscription
  const subscription = natsConnection.subscribe(subject);
  
  // Setup message handler
  (async () => {
    for await (const msg of subscription) {
      try {
        const data = JSON.parse(sc.decode(msg.data));
        
        if (updateType === 'invalidate') {
          // Invalidate the cache for this query key
          queryClient.invalidateQueries({ queryKey });
        } else {
          // Update the cache directly
          queryClient.setQueryData(queryKey, data);
        }
        
        // Call any custom handlers
        if (handlers[subject]) {
          handlers[subject].forEach(handler => handler(data));
        }
      } catch (error) {
        const err = error as Error;
        console.error(`Error handling message for ${subject}:`, err.message);
      }
    }
  })();
  
  // Return unsubscribe function
  return () => {
    subscription.unsubscribe();
  };
}

/**
 * Add a custom handler for a subject
 */
export function addSubjectHandler(subject: string, handler: CacheUpdateHandler): () => void {
  if (!handlers[subject]) {
    handlers[subject] = [];
  }
  
  handlers[subject].push(handler);
  
  // Return a function to remove the handler
  return () => {
    if (handlers[subject]) {
      handlers[subject] = handlers[subject].filter(h => h !== handler);
    }
  };
}

/**
 * Get the NATS connection
 */
export function getNatsConnection(): NatsConnection | null {
  return natsConnection;
}

/**
 * Close the NATS connection
 */
export async function closeNatsConnection(): Promise<void> {
  if (natsConnection) {
    await natsConnection.close();
    natsConnection = null;
  }
} 
  ```

- **utils/offline-mutations.ts** (4.1 KB, 133 lines) Exports: `asyncStoragePersister`, `configureQueryClientForOffline`, `getPendingMutations`, `markItemAsOffline`, `markItemAsSynced`, `reactQueryPersistOptions`, `useResumeNetworkMutations`

  ```ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import {
  QueryClient,
  Mutation,
  MutationCache,
  onlineManager,
} from '@tanstack/react-query';
import {
  persistQueryClient,
  PersistQueryClientOptions,
} from '@tanstack/react-query-persist-client';
import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister';
import { useNetInfo, type NetInfoSubscription } from '@react-native-community/netinfo';
import { useEffect, useRef } from 'react';
import NetInfo from '@react-native-community/netinfo';

// Create a persister for React Query (AsyncStorage-based)
export const asyncStoragePersister = createAsyncStoragePersister({
  storage: AsyncStorage,
});

/**
 * React Query persistence options for offline support
 */
export const reactQueryPersistOptions: Omit<PersistQueryClientOptions, 'queryClient'> = {
  persister: asyncStoragePersister,
  // Add custom serialization/deserialization if needed
  // We want to persist mutations especially for offline support
  buster: 'v1',
  dehydrateOptions: {
    shouldDehydrateMutation: () => true,
  },
};

/**
 * Hook to resume paused mutations when the device comes back online
 */
export function useResumeNetworkMutations(queryClient: QueryClient) {
  const netInfo = useNetInfo();
  const previousNetworkState = useRef(netInfo.isConnected);
  
  // Update React Query's online status manager
  useEffect(() => {
    onlineManager.setOnline(netInfo.isConnected === true);
  }, [netInfo.isConnected]);
  
  useEffect(() => {
    const isConnectedNow = netInfo.isConnected === true;
    const wasConnected = previousNetworkState.current === true;
    
    // If we just reconnected to the network
    if (isConnectedNow && !wasConnected) {
      console.log('Internet connection restored, resuming paused mutations');
      
      // Resume any paused mutations
      queryClient.resumePausedMutations().then(() => {
        // After resuming mutations, invalidate queries to refresh data
        queryClient.invalidateQueries();
      }).catch((error: Error) => {
        console.error('Error resuming mutations:', error.message);
      });
    }
    
    // Update our ref
    previousNetworkState.current = isConnectedNow;
  }, [netInfo.isConnected, queryClient]);
}

/**
 * Add a visual flag to offline-created items for UI feedback
 */
export function markItemAsOffline<T>(item: T): T & { isOffline: boolean } {
  return {
    ...item,
    isOffline: true,
  };
}

/**
 * Remove the offline flag from an item once it's synced
 */
export function markItemAsSynced<T extends { isOffline?: boolean }>(item: T): T {
  const result = { ...item };
  delete result.isOffline;
  return result;
}

/**
 * Get all pending mutations from the mutation cache
 */
export function getPendingMutations(mutationCache: MutationCache): Mutation[] {
  return mutationCache.getAll().filter((mutation: any) => 
    mutation?.state?.status === 'loading' || 
    (mutation?.state?.status === 'error' && mutation?.state?.isPaused)
  );
}

/**
 * Configure the query client for offline support and network state management
 */
export function configureQueryClientForOffline(queryClient: QueryClient): NetInfoSubscription {
  // Listen to network status changes and update onlineManager
  const unsubscribe = NetInfo.addEventListener(state => {
    onlineManager.setOnline(state.isConnected === true);
  });
  
  // When a mutation fails due to network error, pause it instead of failing
  queryClient.getMutationCache().config.onError = (error: unknown, _variables: unknown, _context: unknown, mutation: any) => {
    // Check if the error is a network error
    if (
      error instanceof Error && 
      (
        error.message.includes('network') || 
        error.message.includes('Network Error') ||
        error.message.includes('Failed to fetch')
      )
    ) {
      console.log('Network error detected, pausing mutation for later retry');
      
      // Pause the mutation instead of failing permanently
      mutation.state.isPaused = true;
    }
  };
  
  // Set up persistence
  persistQueryClient({
    queryClient,
    ...reactQueryPersistOptions,
  });

  // Return unsubscribe function for cleanup
  return unsubscribe;
} 
  ```

- **utils/offline-sync.ts** (7.5 KB, 276 lines) Exports: `getPendingItems`, `PendingItem`, `saveOfflineMutation`, `setupBackgroundSync`, `syncOfflineMutations`

  ```ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import NetInfo from '@react-native-community/netinfo';
import { queryClient } from './query-client';
import { supabase } from './supabase';

// Keys for offline data
const OFFLINE_MUTATIONS_KEY = 'aether-offline-mutations';
const PENDING_ITEMS_KEY = 'aether-pending-items';

// Types
export interface PendingItem {
  id: string;
  type: string;
  data: any;
  createdAt: number;
  isNotSynced: boolean;
}

interface OfflineMutation {
  id: string;
  type: 'create' | 'update' | 'delete';
  entity: string;
  data: any;
  timestamp: number;
}

/**
 * Save a mutation to be processed when back online
 */
export async function saveOfflineMutation(
  type: 'create' | 'update' | 'delete',
  entity: string,
  data: any
): Promise<string> {
  try {
    // Generate a temporary ID for new items
    const id = `temp-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
    
    // Create mutation object
    const mutation: OfflineMutation = {
      id,
      type,
      entity,
      data,
      timestamp: Date.now(),
    };
    
    // Get existing mutations
    const existingMutationsStr = await AsyncStorage.getItem(OFFLINE_MUTATIONS_KEY);
    const existingMutations: OfflineMutation[] = existingMutationsStr 
      ? JSON.parse(existingMutationsStr) 
      : [];
    
    // Add new mutation
    existingMutations.push(mutation);
    
    // Save mutations back to storage
    await AsyncStorage.setItem(OFFLINE_MUTATIONS_KEY, JSON.stringify(existingMutations));
    
    // Also add to pending items for UI
    if (type === 'create' || type === 'update') {
      await addToPendingItems(id, entity, data);
    }
    
    return id;
  } catch (error) {
    console.error('Error saving offline mutation:', error);
    throw error;
  }
}

/**
 * Add an item to the pending items list for UI display
 */
async function addToPendingItems(id: string, type: string, data: any): Promise<void> {
  try {
    const existingItemsStr = await AsyncStorage.getItem(PENDING_ITEMS_KEY);
    const existingItems: PendingItem[] = existingItemsStr 
      ? JSON.parse(existingItemsStr)
      : [];
    
    // Create a pending item
    const pendingItem: PendingItem = {
      id,
      type,
      data,
      createdAt: Date.now(),
      isNotSynced: true,
    };
    
    // Add to list
    existingItems.push(pendingItem);
    
    // Save back to storage
    await AsyncStorage.setItem(PENDING_ITEMS_KEY, JSON.stringify(existingItems));
  } catch (error) {
    console.error('Error adding to pending items:', error);
  }
}

/**
 * Get all pending items for a specific type
 */
export async function getPendingItems(type: string): Promise<PendingItem[]> {
  try {
    const itemsStr = await AsyncStorage.getItem(PENDING_ITEMS_KEY);
    if (!itemsStr) return [];
    
    const items: PendingItem[] = JSON.parse(itemsStr);
    return items.filter(item => item.type === type);
  } catch (error) {
    console.error('Error getting pending items:', error);
    return [];
  }
}

/**
 * Synchronize offline mutations with the server
 */
export async function syncOfflineMutations(): Promise<boolean> {
  try {
    // Check if we're online
    const netInfo = await NetInfo.fetch();
    if (!netInfo.isConnected || netInfo.isInternetReachable === false) {
      console.log('Not connected to the internet, skipping sync');
      return false;
    }
    
    // Get all pending mutations
    const mutationsStr = await AsyncStorage.getItem(OFFLINE_MUTATIONS_KEY);
    if (!mutationsStr) return true; // Nothing to sync
    
    const mutations: OfflineMutation[] = JSON.parse(mutationsStr);
    if (!mutations.length) return true; // Nothing to sync
    
    console.log(`Syncing ${mutations.length} offline mutations...`);
    
    // Process each mutation in order
    const results = await Promise.allSettled(
      mutations.map(async (mutation) => {
        try {
          switch (mutation.type) {
            case 'create':
              return await processMutation('create', mutation);
            case 'update':
              return await processMutation('update', mutation);
            case 'delete':
              return await processMutation('delete', mutation);
            default:
              console.error('Unknown mutation type:', mutation.type);
              return false;
          }
        } catch (error) {
          console.error('Error processing mutation:', error);
          return false;
        }
      })
    );
    
    // Check results
    const allSucceeded = results.every(
      result => result.status === 'fulfilled' && result.value === true
    );
    
    if (allSucceeded) {
      // Clear pending mutations if all succeeded
      await AsyncStorage.removeItem(OFFLINE_MUTATIONS_KEY);
      await AsyncStorage.removeItem(PENDING_ITEMS_KEY);
      
      // Invalidate queries to refresh data
      queryClient.invalidateQueries();
      
      return true;
    } else {
      // Some mutations failed, remove the successful ones
      const successfulMutationIndexes = results.map((result, index) => 
        result.status === 'fulfilled' && result.value === true ? index : -1
      ).filter(index => index !== -1);
      
      const remainingMutations = mutations.filter(
        (_, index) => !successfulMutationIndexes.includes(index)
      );
      
      // Save remaining mutations
      await AsyncStorage.setItem(
        OFFLINE_MUTATIONS_KEY, 
        JSON.stringify(remainingMutations)
      );
      
      // Refresh query data
      queryClient.invalidateQueries();
      
      return false;
    }
  } catch (error) {
    console.error('Error syncing offline mutations:', error);
    return false;
  }
}

/**
 * Process a single mutation against the server
 */
async function processMutation(
  type: 'create' | 'update' | 'delete',
  mutation: OfflineMutation
): Promise<boolean> {
  try {
    // Get the entity table name
    const table = mutation.entity;
    
    switch (type) {
      case 'create': {
        // For create, we remove any temp id and insert the record
        const { id, ...data } = mutation.data;
        const { data: responseData, error } = await supabase
          .from(table)
          .insert(data)
          .select();
          
        if (error) throw error;
        return true;
      }
      
      case 'update': {
        // For update, we update the record by ID
        const { id, ...data } = mutation.data;
        const { error } = await supabase
          .from(table)
          .update(data)
          .eq('id', id);
          
        if (error) throw error;
        return true;
      }
      
      case 'delete': {
        // For delete, we delete the record by ID
        const { error } = await supabase
          .from(table)
          .delete()
          .eq('id', mutation.data.id);
          
        if (error) throw error;
        return true;
      }
      
      default:
        return false;
    }
  } catch (error) {
    console.error('Error processing mutation:', error);
    return false;
  }
}

/**
 * Hook up background sync when app comes online
 */
export function setupBackgroundSync(): () => void {
  // Subscribe to network changes
  const unsubscribe = NetInfo.addEventListener(state => {
    // When we go from offline to online, sync mutations
    if (state.isConnected && state.isInternetReachable !== false) {
      syncOfflineMutations()
        .then(success => {
          console.log('Background sync completed:', success ? 'success' : 'with errors');
        })
        .catch(error => {
          console.error('Background sync failed:', error);
        });
    }
  });
  
  return unsubscribe;
} 
  ```

- **utils/query-client.ts** (0.1 KB, 3 lines) Exports: `queryClient`

  ```ts
import { QueryClient } from '@tanstack/react-query';
export const queryClient = new QueryClient();

  ```

- **utils/settings.ts** (1.9 KB, 76 lines) Exports: `APP_SETTINGS_KEY`, `AppSettings`, `getAppVersion`, `getPlatformInfo`, `getSettings`, `saveSettings`, `updateSetting`

  ```ts
import * as SecureStore from 'expo-secure-store';
import { Platform } from 'react-native';

// Settings keys
export const APP_SETTINGS_KEY = 'aether_app_settings';

// Default settings
const DEFAULT_SETTINGS = {
  enableNotifications: true,
  enableDarkMode: null, // null means "use system setting"
  enableOfflineMode: true,
  syncOnCellular: true,
  lastSyncTimestamp: null,
};

// Type for app settings
export type AppSettings = typeof DEFAULT_SETTINGS;

/**
 * Get app settings from secure storage
 */
export async function getSettings(): Promise<AppSettings> {
  try {
    const storedSettings = await SecureStore.getItemAsync(APP_SETTINGS_KEY);
    if (!storedSettings) return DEFAULT_SETTINGS;
    
    return { ...DEFAULT_SETTINGS, ...JSON.parse(storedSettings) };
  } catch (error) {
    console.error('Error getting settings:', error);
    return DEFAULT_SETTINGS;
  }
}

/**
 * Save app settings to secure storage
 */
export async function saveSettings(settings: Partial<AppSettings>): Promise<void> {
  try {
    const currentSettings = await getSettings();
    const newSettings = { ...currentSettings, ...settings };
    
    await SecureStore.setItemAsync(
      APP_SETTINGS_KEY, 
      JSON.stringify(newSettings)
    );
  } catch (error) {
    console.error('Error saving settings:', error);
  }
}

/**
 * Update a single setting
 */
export async function updateSetting<K extends keyof AppSettings>(
  key: K, 
  value: AppSettings[K]
): Promise<void> {
  await saveSettings({ [key]: value } as Partial<AppSettings>);
}

/**
 * Get app version
 */
export function getAppVersion(): string {
  // In a real app, you would use expo-constants to get the app version
  // import Constants from 'expo-constants';
  // return Constants.expoConfig.version;
  return '1.0.0';
}

/**
 * Get platform information
 */
export function getPlatformInfo(): string {
  return `${Platform.OS} ${Platform.Version}`;
} 
  ```

- **utils/supabase.ts** (1.6 KB, 53 lines) Exports: `getCurrentUser`, `isAuthenticated`, `supabase`

  ```ts
import 'react-native-url-polyfill/auto';
import { createClient } from '@supabase/supabase-js';
import * as SecureStore from 'expo-secure-store';

// SecureStore adapter for Supabase auth persistence
const ExpoSecureStoreAdapter = {
  getItem: (key: string) => {
    return SecureStore.getItemAsync(key);
  },
  setItem: (key: string, value: string) => {
    return SecureStore.setItemAsync(key, value);
  },
  removeItem: (key: string) => {
    return SecureStore.deleteItemAsync(key);
  },
};

// Get Supabase URL and anon key from environment variables
// In production, these should be set in app.config.js or via EAS secrets
const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL || '';
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY || '';

if (!supabaseUrl || !supabaseAnonKey) {
  console.warn(
    'Supabase URL or anon key not found. Make sure to set EXPO_PUBLIC_SUPABASE_URL and EXPO_PUBLIC_SUPABASE_ANON_KEY environment variables.'
  );
}

// Create Supabase client
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: ExpoSecureStoreAdapter,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
});

// Helper function to check if user is authenticated
export const isAuthenticated = async () => {
  const { data, error } = await supabase.auth.getSession();
  return !!data.session;
};

// Helper function to get current user
export const getCurrentUser = async () => {
  const { data, error } = await supabase.auth.getUser();
  if (error) {
    console.error('Error getting user:', error.message);
    return null;
  }
  return data.user;
}; 
  ```

- **utils/trpc.ts** (0.7 KB, 21 lines) Exports: `RouterInputs`, `RouterOutputs`, `trpc`

  ```ts
import { createTRPCReact } from '@trpc/react-query';
import { type inferRouterInputs, type inferRouterOutputs } from '@trpc/server';

// Import the real AppRouter type from our server
import { type AppRouter } from '../server/src/router';

// Import types using the updated path
import { RouterInputs as TypedRouterInputs, RouterOutputs as TypedRouterOutputs } from '../server/src/types/trpc-types';

/**
 * tRPC React client
 * The client for consuming your tRPC API from React components
 */
export const trpc = createTRPCReact<AppRouter>();

/**
 * Inference helpers for input/output types
 * Use the pre-defined types from trpc-types.ts
 */
export type RouterInputs = TypedRouterInputs;
export type RouterOutputs = TypedRouterOutputs; 
  ```
